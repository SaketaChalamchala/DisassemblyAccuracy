;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	82B4283B4AA655A709A1DDB74D3820D5
; Input	CRC32 :	C0EA6EE5

; File Name   :	D:\compspace\objfiles\firefox\common\uts46.obj
; Format      :	COFF (X386MAGIC)
; includelib "msvcprtd"
; includelib "MSVCRTD"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		public ?value@?$integral_constant@_N$0A@@tr1@std@@2_NB
; public: static bool const std::tr1::integral_constant<bool, 0>::value
?value@?$integral_constant@_N$0A@@tr1@std@@2_NB	db 0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		;org 4
		public ?value@?$integral_constant@_N$00@tr1@std@@2_NB
; public: static bool const std::tr1::integral_constant<bool, 1>::value
?value@?$integral_constant@_N$00@tr1@std@@2_NB db 1
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8
		public ?value@?$integral_constant@I$0A@@tr1@std@@2IB
; public: static unsigned int const std::tr1::integral_constant<unsigned int, 0>::value
?value@?$integral_constant@I$0A@@tr1@std@@2IB dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0Ch
		public ?_Rank@?$_Arithmetic_traits@_N@std@@2HB
; public: static int const std::_Arithmetic_traits<bool>::_Rank
?_Rank@?$_Arithmetic_traits@_N@std@@2HB	dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 10h
		public ?_Rank@?$_Arithmetic_traits@D@std@@2HB
; public: static int const std::_Arithmetic_traits<char>::_Rank
?_Rank@?$_Arithmetic_traits@D@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 14h
		public ?_Rank@?$_Arithmetic_traits@C@std@@2HB
; public: static int const std::_Arithmetic_traits<signed char>::_Rank
?_Rank@?$_Arithmetic_traits@C@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 18h
		public ?_Rank@?$_Arithmetic_traits@E@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned char>::_Rank
?_Rank@?$_Arithmetic_traits@E@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1Ch
		public ?_Rank@?$_Arithmetic_traits@F@std@@2HB
; public: static int const std::_Arithmetic_traits<short>::_Rank
?_Rank@?$_Arithmetic_traits@F@std@@2HB dd 3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 20h
		public ?_Rank@?$_Arithmetic_traits@G@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned short>::_Rank
?_Rank@?$_Arithmetic_traits@G@std@@2HB dd 3
					; DATA XREF: .rdata:int	const std::_Locbase<int>::messageso
					; .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::showposo ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 24h
		public ?_Rank@?$_Arithmetic_traits@H@std@@2HB
; public: static int const std::_Arithmetic_traits<int>::_Rank
?_Rank@?$_Arithmetic_traits@H@std@@2HB dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 28h
		public ?_Rank@?$_Arithmetic_traits@I@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned int>::_Rank
?_Rank@?$_Arithmetic_traits@I@std@@2HB dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2Ch
		public ?_Rank@?$_Arithmetic_traits@J@std@@2HB
; public: static int const std::_Arithmetic_traits<long>::_Rank
?_Rank@?$_Arithmetic_traits@J@std@@2HB dd 5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 30h
		public ?_Rank@?$_Arithmetic_traits@K@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned long>::_Rank
?_Rank@?$_Arithmetic_traits@K@std@@2HB dd 5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 34h
		public ?_Rank@?$_Arithmetic_traits@_J@std@@2HB
; public: static int const std::_Arithmetic_traits<__int64>::_Rank
?_Rank@?$_Arithmetic_traits@_J@std@@2HB	dd 6
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 38h
		public ?_Rank@?$_Arithmetic_traits@_K@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned __int64>::_Rank
?_Rank@?$_Arithmetic_traits@_K@std@@2HB	dd 6
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3Ch
		public ?_Rank@?$_Arithmetic_traits@M@std@@2HB
; public: static int const std::_Arithmetic_traits<float>::_Rank
?_Rank@?$_Arithmetic_traits@M@std@@2HB dd 7
					; DATA XREF: .rdata:int	const std::_Locbase<int>::allo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 40h
		public ?_Rank@?$_Arithmetic_traits@N@std@@2HB
; public: static int const std::_Arithmetic_traits<double>::_Rank
?_Rank@?$_Arithmetic_traits@N@std@@2HB dd 8
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::lefto
					; .rdata:std::_Iosb<int>::_Openmode const std::_Iosb<int>::_Nocreateo ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 44h
		public ?_Rank@?$_Arithmetic_traits@O@std@@2HB
; public: static int const std::_Arithmetic_traits<long	double>::_Rank
?_Rank@?$_Arithmetic_traits@O@std@@2HB dd 9
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 48h
		public ?collate@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::collate
?collate@?$_Locbase@H@std@@2HB dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4Ch
		public ?ctype@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::ctype
?ctype@?$_Locbase@H@std@@2HB dd	2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 50h
		public ?monetary@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::monetary
?monetary@?$_Locbase@H@std@@2HB	dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 54h
		public ?numeric@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::numeric
?numeric@?$_Locbase@H@std@@2HB dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 58h
		public ?time@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::time
?time@?$_Locbase@H@std@@2HB dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5Ch
		public ?messages@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::messages
?messages@?$_Locbase@H@std@@2HB	dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 60h
		public ?all@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::all
?all@?$_Locbase@H@std@@2HB dd offset ?_Rank@?$_Arithmetic_traits@M@std@@2HB+3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 64h
		public ?none@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::none
?none@?$_Locbase@H@std@@2HB dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 68h
		public ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::skipws
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6Ch
		public ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::unitbuf
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 70h
		public ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::uppercase
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 74h
		public ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showbase
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 78h
		public ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showpoint
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 7Ch
		public ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showpos
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 80h
		public ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::left
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::righto
					; .rdata:std::_Iosb<int>::_Openmode const std::_Iosb<int>::_Noreplaceo
_rdata		ends			; int const std::_Arithmetic_traits<double>::_Rank

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 84h
		public ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::right
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B	dd offset ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B ; std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::left
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 88h
		public ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::internal
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset dword_100
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8Ch
		public ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::dec
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_1FE+2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 90h
		public ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::oct
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_3FC+4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 94h
		public ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::hex
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_7FF+1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 98h
		public ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::scientific
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd	offset loc_1000
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 9Ch
		public ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::fixed
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B	dd offset loc_1FFE+2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A0h
		public ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::hexfloat
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_2FFC+4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A4h
		public ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::boolalpha
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_3FFF+1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A8h
		public ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::_Stdio
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_7FFE+2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0ACh
		public ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::adjustfield
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_1BB+5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B0h
		public ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::basefield
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_E00
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B4h
		public ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::floatfield
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd	offset loc_2FFC+4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B8h
		public ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::goodbit
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0BCh
		public ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::eofbit
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B	dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C0h
		public ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::failbit
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C4h
		public ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::badbit
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B	dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C8h
		public ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::_Hardfail
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0CCh
		public ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::in
?in@?$_Iosb@H@std@@2W4_Openmode@12@B dd	1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D0h
		public ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::out
?out@?$_Iosb@H@std@@2W4_Openmode@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D4h
		public ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::ate
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D8h
		public ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::app
?app@?$_Iosb@H@std@@2W4_Openmode@12@B dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0DCh
		public ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::trunc
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B	dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E0h
		public ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::_Nocreate
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E4h
		public ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::_Noreplace
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B dd	offset ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B ;	std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::left
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E8h
		public ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::binary
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int	const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0ECh
		public ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::beg
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F0h
		public ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::cur
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F4h
		public ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::end
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 0F8h
_asciiData	db 0FFh			; DATA XREF: icu_56::UTS46::process(icu_56::UnicodeString const	&,signed char,signed char,icu_56::UnicodeString	&,icu_56::IDNAInfo &,UErrorCode	&)+19Br
					; icu_56::UTS46::processUTF8(icu_56::StringPiece const &,signed	char,signed char,icu_56::ByteSink &,icu_56::IDNAInfo &,UErrorCode &)+24Ar ...
		db 3 dup(0FFh)
		dd 0FFFFFFFFh
dword_100	dd 9 dup(0FFFFFFFFh), 0FF0000FFh, 2 dup(0)
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::internalo
		dd 0FFFF0000h, 0FFFFFFFFh, 10101FFh, 5 dup(1010101h), 0FF010101h
		dd 0FFFFFFFFh, 0FFh, 5 dup(0)
		dd 0FF000000h, 0FFFFFFFFh
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 178h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	operator new(unsigned int)
		public ??2@YAPAXI@Z
??2@YAPAXI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??2@YAPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$TMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$TMZ
		;org 1B0h
__RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
_rtc$TMZ	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$IMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$IMZ
		;org 1B4h
__RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
_rtc$IMZ	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1B8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl operator	delete(void *)
		public ??3@YAXPAX@Z
??3@YAXPAX@Z	proc near		; CODE XREF: icu_56::UnicodeMatcher::`scalar deleting destructor'(uint)+37p
					; icu_56::UnicodeMatcher::`vector deleting destructor'(uint)+75p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp

loc_1BB:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::adjustfieldo
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??3@YAXPAX@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1ECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	icu_56::UMemory::operator new(unsigned int, void *)
		public ??2UMemory@icu_56@@SAPAXIPAX@Z
??2UMemory@icu_56@@SAPAXIPAX@Z proc near

var_C0		= byte ptr -0C0h
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]

loc_1FE:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::deco
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??2UMemory@icu_56@@SAPAXIPAX@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 214h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl icu_56::UMemory::operator delete(void *)
		public ??3UMemory@icu_56@@SAXPAX0@Z
??3UMemory@icu_56@@SAXPAX0@Z proc near

var_C0		= byte ptr -0C0h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??3UMemory@icu_56@@SAXPAX0@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 23Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UMemory	& __thiscall icu_56::UMemory::operator=(class icu_56::UMemory const &)
		public ??4UMemory@icu_56@@QAEAAV01@ABV01@@Z
??4UMemory@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4UMemory@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 26Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UObject::UObject(icu_56::UObject *__hidden this)
		public ??0UObject@icu_56@@QAE@XZ
??0UObject@icu_56@@QAE@XZ proc near	; CODE XREF: icu_56::Replaceable::Replaceable(void)+26p
					; icu_56::IDNA::IDNA(void)+26p	...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UObject@icu_56@@6B@	; const	icu_56::UObject::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0UObject@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2A4h
		dd offset ??_R4UObject@icu_56@@6B@ ; const icu_56::UObject::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7UObject@icu_56@@6B@
; const	icu_56::UObject::`vftable'
??_7UObject@icu_56@@6B@	dd offset ??_EUObject@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::UObject::UObject(void)+26o
					; icu_56::UObject::UObject(icu_56::UObject const &)+44o
					; icu_56::UObject::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ ;	icu_56::UObject::getDynamicClassID(void)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 2B0h
		public ??_R4UObject@icu_56@@6B@
; const	icu_56::UObject::`RTTI Complete	Object Locator'
??_R4UObject@icu_56@@6B@ dd 3 dup(0)	; DATA XREF: .rdata:000002A4o
		dd offset ??_R0?AVUObject@icu_56@@@8 ; icu_56::UObject `RTTI Type Descriptor'
		dd offset ??_R3UObject@icu_56@@8 ; icu_56::UObject::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 2C4h
		public ??_R0?AVUObject@icu_56@@@8
; class	icu_56::UObject	`RTTI Type Descriptor'
??_R0?AVUObject@icu_56@@@8 dd offset ??_7type_info@@6B@	; DATA XREF: .rdata$r:000002BCo
					; .rdata$r:icu_56::UObject::`RTTI Base Class Descriptor	at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avuobject@ic	db '.?AVUObject@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 2E4h
		public ??_R3UObject@icu_56@@8
; icu_56::UObject::`RTTI Class Hierarchy Descriptor'
??_R3UObject@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:000002C0o
					; .rdata$r:00000318o
		dd 2
		dd offset ??_R2UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 2F4h
		public ??_R2UObject@icu_56@@8
; icu_56::UObject::`RTTI Base Class Array'
??_R2UObject@icu_56@@8 dd offset ??_R1A@?0A@EA@UObject@icu_56@@8
					; DATA XREF: .rdata$r:000002F0o
					; icu_56::UObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 300h
		public ??_R1A@?0A@EA@UObject@icu_56@@8
; icu_56::UObject::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UObject@icu_56@@8	dd offset ??_R0?AVUObject@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UObject::`RTTI Base Class	Array'o
					; .rdata$r:00000B70o ...
					; icu_56::UObject `RTTI	Type Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UObject@icu_56@@8 ; icu_56::UObject::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 31Ch
		public ??_R13?0A@EA@UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Descriptor at (4, -1, 0, 64)'
??_R13?0A@EA@UMemory@icu_56@@8 dd offset ??_R0?AVUMemory@icu_56@@@8
					; DATA XREF: .rdata$r:000002F8o
					; .rdata$r:00000598o ...
					; icu_56::UMemory `RTTI	Type Descriptor'
		dd 0
		dd 4, 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 338h
		public ??_R0?AVUMemory@icu_56@@@8
; class	icu_56::UMemory	`RTTI Type Descriptor'
??_R0?AVUMemory@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::UMemory::`RTTI Base Class	Descriptor at (4,-1,0,64)'o
					; .rdata$r:icu_56::UMemory::`RTTI Base Class Descriptor	at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 10h
a_?avumemory@ic	db '.?AVUMemory@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 358h
		public ??_R3UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Class Hierarchy Descriptor'
??_R3UMemory@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:00000334o
					; .rdata$r:00000388o
		dd 1
		dd offset ??_R2UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 368h
		public ??_R2UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Array'
??_R2UMemory@icu_56@@8 dd offset ??_R1A@?0A@EA@UMemory@icu_56@@8
					; DATA XREF: .rdata$r:00000364o
					; icu_56::UMemory::`RTTI Base Class Descriptor at (0,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 370h
		public ??_R1A@?0A@EA@UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UMemory@icu_56@@8	dd offset ??_R0?AVUMemory@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UMemory::`RTTI Base Class	Array'o
					; icu_56::UMemory `RTTI	Type Descriptor'
		dd 2 dup(0)
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 38Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UObject::UObject(icu_56::UObject *this, const struct icu_56::UObject *)
		public ??0UObject@icu_56@@QAE@ABV01@@Z
??0UObject@icu_56@@QAE@ABV01@@Z	proc near
					; CODE XREF: icu_56::Replaceable::Replaceable(icu_56::Replaceable const	&)+2Ap
					; icu_56::IDNA::IDNA(icu_56::IDNA const	&)+2Ap	...

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jz	short loc_3C3
		mov	eax, [ebp+arg_0]
		add	eax, 4
		mov	[ebp+var_D0], eax
		jmp	short loc_3CD
; ---------------------------------------------------------------------------

loc_3C3:				; CODE XREF: icu_56::UObject::UObject(icu_56::UObject const &)+27j
		mov	[ebp+var_D0], 0

loc_3CD:				; CODE XREF: icu_56::UObject::UObject(icu_56::UObject const &)+35j
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UObject@icu_56@@6B@	; const	icu_56::UObject::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??0UObject@icu_56@@QAE@ABV01@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3E4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UObject	& __thiscall icu_56::UObject::operator=(class icu_56::UObject const &)
		public ??4UObject@icu_56@@QAEAAV01@ABV01@@Z
??4UObject@icu_56@@QAEAAV01@ABV01@@Z proc near
					; CODE XREF: icu_56::Replaceable::operator=(icu_56::Replaceable	const &)+2Ap
					; icu_56::IDNA::operator=(icu_56::IDNA const &)+2Ap ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'

loc_3FC:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::octo
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4UObject@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 414h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UObject::`scalar deleting destructor'(unsigned int)
		public ??_GUObject@icu_56@@UAEPAXI@Z
??_GUObject@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_453
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_453:				; CODE XREF: icu_56::UObject::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GUObject@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 46Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UObject::`vector deleting destructor'(unsigned int)
		public ??_EUObject@icu_56@@UAEPAXI@Z
??_EUObject@icu_56@@UAEPAXI@Z proc near	; DATA XREF: .rdata:const icu_56::UObject::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_4CD
		push	offset ??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	4
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_4C5
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_4C5:				; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_4EC
; ---------------------------------------------------------------------------

loc_4CD:				; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_4E9
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_4E9:				; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_4EC:				; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EUObject@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 504h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::ByteSink::ByteSink(icu_56::ByteSink	*__hidden this)
		public ??0ByteSink@icu_56@@QAE@XZ
??0ByteSink@icu_56@@QAE@XZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7ByteSink@icu_56@@6B@ ; const icu_56::ByteSink::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0ByteSink@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 53Ch
		dd offset ??_R4ByteSink@icu_56@@6B@ ; const icu_56::ByteSink::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7ByteSink@icu_56@@6B@
; const	icu_56::ByteSink::`vftable'
??_7ByteSink@icu_56@@6B@ dd offset ??_EByteSink@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::ByteSink::ByteSink(void)+26o
					; icu_56::ByteSink::`vector deleting destructor'(uint)
		dd offset __purecall
		dd offset ?GetAppendBuffer@ByteSink@icu_56@@UAEPADHHPADHPAH@Z ;	icu_56::ByteSink::GetAppendBuffer(int,int,char *,int,int *)
		dd offset ?Flush@ByteSink@icu_56@@UAEXXZ ; icu_56::ByteSink::Flush(void)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 550h
		public ??_R4ByteSink@icu_56@@6B@
; const	icu_56::ByteSink::`RTTI	Complete Object	Locator'
??_R4ByteSink@icu_56@@6B@ dd 3 dup(0)	; DATA XREF: .rdata:0000053Co
		dd offset ??_R0?AVByteSink@icu_56@@@8 ;	icu_56::ByteSink `RTTI Type Descriptor'
		dd offset ??_R3ByteSink@icu_56@@8 ; icu_56::ByteSink::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 564h
		public ??_R0?AVByteSink@icu_56@@@8
; class	icu_56::ByteSink `RTTI Type Descriptor'
??_R0?AVByteSink@icu_56@@@8 dd offset ??_7type_info@@6B@ ; DATA	XREF: .rdata$r:0000055Co
					; .rdata$r:icu_56::ByteSink::`RTTI Base	Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avbytesink@i	db '.?AVByteSink@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 584h
		public ??_R3ByteSink@icu_56@@8
; icu_56::ByteSink::`RTTI Class	Hierarchy Descriptor'
??_R3ByteSink@icu_56@@8	dd 2 dup(0)	; DATA XREF: .rdata$r:00000560o
					; .rdata$r:000005B8o
		dd 2
		dd offset ??_R2ByteSink@icu_56@@8 ; icu_56::ByteSink::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 594h
		public ??_R2ByteSink@icu_56@@8
; icu_56::ByteSink::`RTTI Base Class Array'
??_R2ByteSink@icu_56@@8	dd offset ??_R1A@?0A@EA@ByteSink@icu_56@@8
					; DATA XREF: .rdata$r:00000590o
					; icu_56::ByteSink::`RTTI Base Class Descriptor	at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 5A0h
		public ??_R1A@?0A@EA@ByteSink@icu_56@@8
; icu_56::ByteSink::`RTTI Base Class Descriptor	at (0, -1, 0, 64)'
??_R1A@?0A@EA@ByteSink@icu_56@@8 dd offset ??_R0?AVByteSink@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::ByteSink::`RTTI Base Class Array'o
					; icu_56::ByteSink `RTTI Type Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3ByteSink@icu_56@@8 ; icu_56::ByteSink::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5BCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::ByteSink::`scalar deleting destructor'(unsigned int)
		public ??_GByteSink@icu_56@@UAEPAXI@Z
??_GByteSink@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1ByteSink@icu_56@@UAE@XZ ; icu_56::ByteSink::~ByteSink(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_5FB
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_5FB:				; CODE XREF: icu_56::ByteSink::`scalar deleting	destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GByteSink@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 614h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::ByteSink::`vector deleting destructor'(unsigned int)
		public ??_EByteSink@icu_56@@UAEPAXI@Z
??_EByteSink@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::ByteSink::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_675
		push	offset ??1ByteSink@icu_56@@UAE@XZ ; icu_56::ByteSink::~ByteSink(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	4
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_66D
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_66D:				; CODE XREF: icu_56::ByteSink::`vector deleting	destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_694
; ---------------------------------------------------------------------------

loc_675:				; CODE XREF: icu_56::ByteSink::`vector deleting	destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1ByteSink@icu_56@@UAE@XZ ; icu_56::ByteSink::~ByteSink(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_691
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_691:				; CODE XREF: icu_56::ByteSink::`vector deleting	destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_694:				; CODE XREF: icu_56::ByteSink::`vector deleting	destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EByteSink@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6ACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::CheckedArrayByteSink::NumberOfBytesWritten(icu_56::CheckedArrayByteSink *__hidden this)
		public ?NumberOfBytesWritten@CheckedArrayByteSink@icu_56@@QBEHXZ
?NumberOfBytesWritten@CheckedArrayByteSink@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+0Ch]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?NumberOfBytesWritten@CheckedArrayByteSink@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6DCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::CheckedArrayByteSink::Overflowed(icu_56::CheckedArrayByteSink *__hidden this)
		public ?Overflowed@CheckedArrayByteSink@icu_56@@QBECXZ
?Overflowed@CheckedArrayByteSink@icu_56@@QBECXZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	al, [eax+14h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?Overflowed@CheckedArrayByteSink@icu_56@@QBECXZ	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 70Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::CheckedArrayByteSink::NumberOfBytesAppended(icu_56::CheckedArrayByteSink *__hidden this)
		public ?NumberOfBytesAppended@CheckedArrayByteSink@icu_56@@QBEHXZ
?NumberOfBytesAppended@CheckedArrayByteSink@icu_56@@QBEHXZ proc	near
					; CODE XREF: _uidna_labelToASCII_UTF8_56+D7p
					; _uidna_labelToUnicodeUTF8_56+D7p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+10h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?NumberOfBytesAppended@CheckedArrayByteSink@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 73Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::StringPiece::StringPiece(icu_56::StringPiece *__hidden this)
		public ??0StringPiece@icu_56@@QAE@XZ
??0StringPiece@icu_56@@QAE@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0StringPiece@icu_56@@QAE@XZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 77Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::StringPiece::StringPiece(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &)
		public ??0StringPiece@icu_56@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
??0StringPiece@icu_56@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0]
		call	?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::data(void)
		mov	ecx, [ebp+var_8]
		mov	[ecx], eax
		mov	ecx, [ebp+arg_0]
		call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
		mov	ecx, [ebp+var_8]
		mov	[ecx+4], eax
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0StringPiece@icu_56@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7D4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::StringPiece::StringPiece(icu_56::StringPiece *this,	const char *, int)
		public ??0StringPiece@icu_56@@QAE@PBDH@Z
??0StringPiece@icu_56@@QAE@PBDH@Z proc near
					; CODE XREF: icu_56::UTS46::processUTF8(icu_56::StringPiece const &,signed char,signed char,icu_56::ByteSink &,icu_56::IDNAInfo	&,UErrorCode &)+3F9p
					; _uidna_labelToASCII_UTF8_56+7Dp ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx

loc_7FF:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::hexo
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		mov	[eax+4], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	8
??0StringPiece@icu_56@@QAE@PBDH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 814h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	char *__thiscall icu_56::StringPiece::data(icu_56::StringPiece *__hidden this)
		public ?data@StringPiece@icu_56@@QBEPBDXZ
?data@StringPiece@icu_56@@QBEPBDXZ proc	near
					; CODE XREF: icu_56::UTS46::processUTF8(icu_56::StringPiece const &,signed char,signed char,icu_56::ByteSink &,icu_56::IDNAInfo	&,UErrorCode &)+62p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?data@StringPiece@icu_56@@QBEPBDXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 844h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::StringPiece::size(icu_56::StringPiece *__hidden this)
		public ?size@StringPiece@icu_56@@QBEHXZ
?size@StringPiece@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?size@StringPiece@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 874h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::StringPiece::length(icu_56::StringPiece *__hidden this)
		public ?length@StringPiece@icu_56@@QBEHXZ
?length@StringPiece@icu_56@@QBEHXZ proc	near
					; CODE XREF: icu_56::UTS46::processUTF8(icu_56::StringPiece const &,signed char,signed char,icu_56::ByteSink &,icu_56::IDNAInfo	&,UErrorCode &)+6Dp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?length@StringPiece@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8A4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::StringPiece::empty(icu_56::StringPiece *__hidden this)
		public ?empty@StringPiece@icu_56@@QBECXZ
?empty@StringPiece@icu_56@@QBECXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4], 0
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?empty@StringPiece@icu_56@@QBECXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8D8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::StringPiece::clear(icu_56::StringPiece *__hidden this)
		public ?clear@StringPiece@icu_56@@QAEXXZ
?clear@StringPiece@icu_56@@QAEXXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?clear@StringPiece@icu_56@@QAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 918h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::StringPiece::set(icu_56::StringPiece *this, const char *, int)
		public ?set@StringPiece@icu_56@@QAEXPBDH@Z
?set@StringPiece@icu_56@@QAEXPBDH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		mov	[eax+4], ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	8
?set@StringPiece@icu_56@@QAEXPBDH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 958h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::StringPiece::remove_prefix(icu_56::StringPiece *this,	int)
		public ?remove_prefix@StringPiece@icu_56@@QAEXH@Z
?remove_prefix@StringPiece@icu_56@@QAEXH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jl	short loc_9B1
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		cmp	ecx, [eax+4]
		jle	short loc_995
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	[ebp+arg_0], ecx

loc_995:				; CODE XREF: icu_56::StringPiece::remove_prefix(int)+32j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		add	ecx, [ebp+arg_0]
		mov	edx, [ebp+var_8]
		mov	[edx], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		sub	ecx, [ebp+arg_0]
		mov	edx, [ebp+var_8]
		mov	[edx+4], ecx

loc_9B1:				; CODE XREF: icu_56::StringPiece::remove_prefix(int)+27j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?remove_prefix@StringPiece@icu_56@@QAEXH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9BCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::StringPiece::remove_suffix(icu_56::StringPiece *this,	int)
		public ?remove_suffix@StringPiece@icu_56@@QAEXH@Z
?remove_suffix@StringPiece@icu_56@@QAEXH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jl	short loc_A0B
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		cmp	ecx, [eax+4]
		jg	short loc_A01
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		sub	ecx, [ebp+arg_0]
		mov	edx, [ebp+var_8]
		mov	[edx+4], ecx
		jmp	short loc_A0B
; ---------------------------------------------------------------------------

loc_A01:				; CODE XREF: icu_56::StringPiece::remove_suffix(int)+32j
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0

loc_A0B:				; CODE XREF: icu_56::StringPiece::remove_suffix(int)+27j
					; icu_56::StringPiece::remove_suffix(int)+43j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?remove_suffix@StringPiece@icu_56@@QAEXH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A14h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::StringPiece __thiscall icu_56::StringPiece::substr(int,	int)const
		public ?substr@StringPiece@icu_56@@QBE?AV12@HH@Z
?substr@StringPiece@icu_56@@QBE?AV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+var_8]
		push	edx		; struct icu_56::StringPiece *
		mov	ecx, [ebp+arg_0] ; this
		call	??0StringPiece@icu_56@@QAE@ABV01@HH@Z ;	icu_56::StringPiece::StringPiece(icu_56::StringPiece const &,int,int)
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?substr@StringPiece@icu_56@@QBE?AV12@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A64h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::StringPiece & __thiscall icu_56::StringPiece::operator=(class icu_56::StringPiece const	&)
		public ??4StringPiece@icu_56@@QAEAAV01@ABV01@@Z
??4StringPiece@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [eax+4]
		mov	eax, [ebp+var_8]
		mov	[eax], ecx
		mov	[eax+4], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4StringPiece@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0AA4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::Replaceable::Replaceable(icu_56::Replaceable *this,	const struct icu_56::Replaceable *)
		public ??0Replaceable@icu_56@@QAE@ABV01@@Z
??0Replaceable@icu_56@@QAE@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UObject *
		mov	ecx, [ebp+var_8] ; this
		call	??0UObject@icu_56@@QAE@ABV01@@Z	; icu_56::UObject::UObject(icu_56::UObject const &)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7Replaceable@icu_56@@6B@ ; const icu_56::Replaceable::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0Replaceable@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0AF8h
		dd offset ??_R4Replaceable@icu_56@@6B@ ; const icu_56::Replaceable::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7Replaceable@icu_56@@6B@
; const	icu_56::Replaceable::`vftable'
??_7Replaceable@icu_56@@6B@ dd offset ??_EReplaceable@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::Replaceable::Replaceable(icu_56::Replaceable const	&)+32o
					; icu_56::Replaceable::Replaceable(void)+2Eo
					; icu_56::Replaceable::`vector deleting	destructor'(uint)
		dd offset ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ ;	icu_56::UObject::getDynamicClassID(void)
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
		dd offset ?hasMetaData@Replaceable@icu_56@@UBECXZ ; icu_56::Replaceable::hasMetaData(void)
		dd offset ?clone@Replaceable@icu_56@@UBEPAV12@XZ ; icu_56::Replaceable::clone(void)
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0B24h
		public ??_R4Replaceable@icu_56@@6B@
; const	icu_56::Replaceable::`RTTI Complete Object Locator'
??_R4Replaceable@icu_56@@6B@ dd	3 dup(0) ; DATA	XREF: .rdata:00000AF8o
		dd offset ??_R0?AVReplaceable@icu_56@@@8 ; icu_56::Replaceable `RTTI Type Descriptor'
		dd offset ??_R3Replaceable@icu_56@@8 ; icu_56::Replaceable::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 0B38h
		public ??_R0?AVReplaceable@icu_56@@@8
; class	icu_56::Replaceable `RTTI Type Descriptor'
??_R0?AVReplaceable@icu_56@@@8 dd offset ??_7type_info@@6B@ ; DATA XREF: .rdata$r:00000B30o
					; .rdata$r:icu_56::Replaceable::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 10h
a_?avreplaceabl	db '.?AVReplaceable@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0B5Ch
		public ??_R3Replaceable@icu_56@@8
; icu_56::Replaceable::`RTTI Class Hierarchy Descriptor'
??_R3Replaceable@icu_56@@8 dd 2	dup(0)	; DATA XREF: .rdata$r:00000B34o
					; .rdata$r:00000B94o
		dd 3
		dd offset ??_R2Replaceable@icu_56@@8 ; icu_56::Replaceable::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0B6Ch
		public ??_R2Replaceable@icu_56@@8
; icu_56::Replaceable::`RTTI Base Class	Array'
??_R2Replaceable@icu_56@@8 dd offset ??_R1A@?0A@EA@Replaceable@icu_56@@8
					; DATA XREF: .rdata$r:00000B68o
					; icu_56::Replaceable::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0B7Ch
		public ??_R1A@?0A@EA@Replaceable@icu_56@@8
; icu_56::Replaceable::`RTTI Base Class	Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@Replaceable@icu_56@@8 dd offset ??_R0?AVReplaceable@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::Replaceable::`RTTI Base Class Array'o
					; .rdata$r:0000120Co
					; icu_56::Replaceable `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3Replaceable@icu_56@@8 ; icu_56::Replaceable::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B98h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::Replaceable & __thiscall icu_56::Replaceable::operator=(class icu_56::Replaceable const	&)
		public ??4Replaceable@icu_56@@QAEAAV01@ABV01@@Z
??4Replaceable@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??4UObject@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::UObject::operator=(icu_56::UObject const	&)
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4Replaceable@icu_56@@QAEAAV01@ABV01@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0BE0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::Replaceable::`scalar deleting destructor'(unsigned int)
		public ??_GReplaceable@icu_56@@UAEPAXI@Z
??_GReplaceable@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1Replaceable@icu_56@@UAE@XZ ;	icu_56::Replaceable::~Replaceable(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_C1F
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_C1F:				; CODE XREF: icu_56::Replaceable::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GReplaceable@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C38h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::Replaceable::`vector deleting destructor'(unsigned int)
		public ??_EReplaceable@icu_56@@UAEPAXI@Z
??_EReplaceable@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::Replaceable::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_C99
		push	offset ??1Replaceable@icu_56@@UAE@XZ ; icu_56::Replaceable::~Replaceable(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	4
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_C91
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_C91:				; CODE XREF: icu_56::Replaceable::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_CB8
; ---------------------------------------------------------------------------

loc_C99:				; CODE XREF: icu_56::Replaceable::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1Replaceable@icu_56@@UAE@XZ ;	icu_56::Replaceable::~Replaceable(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_CB5
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_CB5:				; CODE XREF: icu_56::Replaceable::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_CB8:				; CODE XREF: icu_56::Replaceable::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EReplaceable@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0CD0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::Replaceable::Replaceable(icu_56::Replaceable *__hidden this)
		public ??0Replaceable@icu_56@@IAE@XZ
??0Replaceable@icu_56@@IAE@XZ proc near	; CODE XREF: icu_56::UnicodeString::UnicodeString(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7Replaceable@icu_56@@6B@ ; const icu_56::Replaceable::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0Replaceable@icu_56@@IAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D1Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::Replaceable::length(icu_56::Replaceable *__hidden this)
		public ?length@Replaceable@icu_56@@QBEHXZ
?length@Replaceable@icu_56@@QBEHXZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+1Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?length@Replaceable@icu_56@@QBEHXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D6Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; wchar_t __thiscall icu_56::Replaceable::charAt(icu_56::Replaceable *this, int)
		public ?charAt@Replaceable@icu_56@@QBE_WH@Z
?charAt@Replaceable@icu_56@@QBE_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+20h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?charAt@Replaceable@icu_56@@QBE_WH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0DC0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::Replaceable::char32At(icu_56::Replaceable *this, int)
		public ?char32At@Replaceable@icu_56@@QBEHH@Z
?char32At@Replaceable@icu_56@@QBEHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+24h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx

loc_E00:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::basefieldo
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?char32At@Replaceable@icu_56@@QBEHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0E14h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator=(struct	icu_56::UnicodeString *)
		public ??4UnicodeString@icu_56@@QAEAAV01@$$QAV01@@Z
??4UnicodeString@icu_56@@QAEAAV01@$$QAV01@@Z proc near
					; CODE XREF: icu_56::UTS46::processUTF8(icu_56::StringPiece const &,signed char,signed char,icu_56::ByteSink &,icu_56::IDNAInfo	&,UErrorCode &)+42Ep

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?moveFrom@UnicodeString@icu_56@@QAEAAV12@AAV12@@Z ; icu_56::UnicodeString::moveFrom(icu_56::UnicodeString &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4UnicodeString@icu_56@@QAEAAV01@$$QAV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0E5Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl icu_56::swap(icu_56 *this, struct icu_56::UnicodeString *, struct icu_56::UnicodeString *)
		public ?swap@icu_56@@YAXAAVUnicodeString@1@0@Z
?swap@icu_56@@YAXAAVUnicodeString@1@0@Z	proc near

var_C0		= byte ptr -0C0h
this		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+this]	; this
		call	?swap@UnicodeString@icu_56@@QAEXAAV12@@Z ; icu_56::UnicodeString::swap(icu_56::UnicodeString &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?swap@icu_56@@YAXAAVUnicodeString@1@0@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0E9Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UnicodeString::`scalar deleting destructor'(unsigned int)
		public ??_GUnicodeString@icu_56@@UAEPAXI@Z
??_GUnicodeString@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_EDB
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_EDB:				; CODE XREF: icu_56::UnicodeString::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GUnicodeString@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0EF4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UnicodeString::`vector deleting destructor'(unsigned int)
		public ??_EUnicodeString@icu_56@@UAEPAXI@Z
??_EUnicodeString@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::UnicodeString::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_F55
		push	offset ??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	40h ; '@'
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_F4D
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_F4D:				; CODE XREF: icu_56::UnicodeString::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_F74
; ---------------------------------------------------------------------------

loc_F55:				; CODE XREF: icu_56::UnicodeString::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_F71
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_F71:				; CODE XREF: icu_56::UnicodeString::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_F74:				; CODE XREF: icu_56::UnicodeString::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EUnicodeString@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0F8Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::pinIndex(icu_56::UnicodeString	*this, int *)
		public ?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z
?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z proc near
					; CODE XREF: icu_56::UnicodeString::indexOf(icu_56::UnicodeString const	&,int)+2Ap
					; icu_56::UnicodeString::indexOf(wchar_t const *,int,int)+2Ap ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax], 0
		jge	short loc_FC2
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 0
		jmp	short loc_FDE
; ---------------------------------------------------------------------------

loc_FC2:				; CODE XREF: icu_56::UnicodeString::pinIndex(int &)+29j
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	ecx, [ebp+arg_0]
		cmp	[ecx], eax
		jle	short loc_FDE
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	ecx, [ebp+arg_0]
		mov	[ecx], eax

loc_FDE:				; CODE XREF: icu_56::UnicodeString::pinIndex(int &)+34j
					; icu_56::UnicodeString::pinIndex(int &)+43j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0FF4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::pinIndices(icu_56::UnicodeString *this, int *,	int *)
		public ?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z
?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z proc near
					; CODE XREF: icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+51p
					; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)+51p ...

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi

loc_1000:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::scientifico
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax], 0
		jge	short loc_1035
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 0
		jmp	short loc_1047
; ---------------------------------------------------------------------------

loc_1035:				; CODE XREF: icu_56::UnicodeString::pinIndices(int &,int &)+34j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		cmp	ecx, [ebp+var_14]
		jle	short loc_1047
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		mov	[eax], ecx

loc_1047:				; CODE XREF: icu_56::UnicodeString::pinIndices(int &,int &)+3Fj
					; icu_56::UnicodeString::pinIndices(int	&,int &)+49j
		mov	eax, [ebp+arg_4]
		cmp	dword ptr [eax], 0
		jge	short loc_105A
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0
		jmp	short loc_1076
; ---------------------------------------------------------------------------

loc_105A:				; CODE XREF: icu_56::UnicodeString::pinIndices(int &,int &)+59j
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		sub	ecx, [eax]
		mov	edx, [ebp+arg_4]
		cmp	[edx], ecx
		jle	short loc_1076
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		sub	ecx, [eax]
		mov	edx, [ebp+arg_4]
		mov	[edx], ecx

loc_1076:				; CODE XREF: icu_56::UnicodeString::pinIndices(int &,int &)+64j
					; icu_56::UnicodeString::pinIndices(int	&,int &)+73j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 108Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; wchar_t *__thiscall icu_56::UnicodeString::getArrayStart(icu_56::UnicodeString *__hidden this)
		public ?getArrayStart@UnicodeString@icu_56@@AAEPA_WXZ
?getArrayStart@UnicodeString@icu_56@@AAEPA_WXZ proc near

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 2
		jz	short loc_10C9
		mov	edx, [ebp+var_8]
		add	edx, 6
		mov	[ebp+var_D0], edx
		jmp	short loc_10D5
; ---------------------------------------------------------------------------

loc_10C9:				; CODE XREF: icu_56::UnicodeString::getArrayStart(void)+2Dj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	[ebp+var_D0], ecx

loc_10D5:				; CODE XREF: icu_56::UnicodeString::getArrayStart(void)+3Bj
		mov	eax, [ebp+var_D0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getArrayStart@UnicodeString@icu_56@@AAEPA_WXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 10E4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	wchar_t	*__thiscall icu_56::UnicodeString::getArrayStart(icu_56::UnicodeString *__hidden this)
		public ?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ
?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ proc near
					; CODE XREF: icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+61p
					; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)+61p ...

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 2
		jz	short loc_1121
		mov	edx, [ebp+var_8]
		add	edx, 6
		mov	[ebp+var_D0], edx
		jmp	short loc_112D
; ---------------------------------------------------------------------------

loc_1121:				; CODE XREF: icu_56::UnicodeString::getArrayStart(void)+2Dj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	[ebp+var_D0], ecx

loc_112D:				; CODE XREF: icu_56::UnicodeString::getArrayStart(void)+3Bj
		mov	eax, [ebp+var_D0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 113Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString *__hidden this)
		public ??0UnicodeString@icu_56@@QAE@XZ
??0UnicodeString@icu_56@@QAE@XZ	proc near
					; CODE XREF: icu_56::Normalizer2::normalize(icu_56::UnicodeString const	&,UErrorCode &)+52p
					; icu_56::IDNA::labelToASCII_UTF8(icu_56::StringPiece const &,icu_56::ByteSink &,icu_56::IDNAInfo &,UErrorCode &)+61p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??0Replaceable@icu_56@@IAE@XZ ;	icu_56::Replaceable::Replaceable(void)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UnicodeString@icu_56@@6B@ ;	const icu_56::UnicodeString::`vftable'
		mov	eax, 2
		mov	ecx, [ebp+var_8]
		mov	[ecx+4], ax
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0UnicodeString@icu_56@@QAE@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1194h
		dd offset ??_R4UnicodeString@icu_56@@6B@ ; const icu_56::UnicodeString::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7UnicodeString@icu_56@@6B@
; const	icu_56::UnicodeString::`vftable'
??_7UnicodeString@icu_56@@6B@ dd offset	??_EUnicodeString@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::UnicodeString::UnicodeString(void)+2Eo
					; icu_56::UnicodeString::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@UnicodeString@icu_56@@UBEPAXXZ ; icu_56::UnicodeString::getDynamicClassID(void)
		dd offset ?extractBetween@UnicodeString@icu_56@@UBEXHHAAV12@@Z ; icu_56::UnicodeString::extractBetween(int,int,icu_56::UnicodeString &)
		dd offset ?handleReplaceBetween@UnicodeString@icu_56@@UAEXHHABV12@@Z ; icu_56::UnicodeString::handleReplaceBetween(int,int,icu_56::UnicodeString const &)
		dd offset ?copy@UnicodeString@icu_56@@UAEXHHH@Z	; icu_56::UnicodeString::copy(int,int,int)
		dd offset ?hasMetaData@UnicodeString@icu_56@@UBECXZ ; icu_56::UnicodeString::hasMetaData(void)
		dd offset ?clone@UnicodeString@icu_56@@UBEPAVReplaceable@2@XZ ;	icu_56::UnicodeString::clone(void)
		dd offset ?getLength@UnicodeString@icu_56@@MBEHXZ ; icu_56::UnicodeString::getLength(void)
		dd offset ?getCharAt@UnicodeString@icu_56@@MBE_WH@Z ; icu_56::UnicodeString::getCharAt(int)
		dd offset ?getChar32At@UnicodeString@icu_56@@MBEHH@Z ; icu_56::UnicodeString::getChar32At(int)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 11C0h
		public ??_R4UnicodeString@icu_56@@6B@
; const	icu_56::UnicodeString::`RTTI Complete Object Locator'
??_R4UnicodeString@icu_56@@6B@ dd 3 dup(0) ; DATA XREF:	.rdata:00001194o
		dd offset ??_R0?AVUnicodeString@icu_56@@@8 ; icu_56::UnicodeString `RTTI Type Descriptor'
		dd offset ??_R3UnicodeString@icu_56@@8 ; icu_56::UnicodeString::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 11D4h
		public ??_R0?AVUnicodeString@icu_56@@@8
; class	icu_56::UnicodeString `RTTI Type Descriptor'
??_R0?AVUnicodeString@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:000011CCo
					; .rdata$r:icu_56::UnicodeString::`RTTI	Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avunicodestr	db '.?AVUnicodeString@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 11F8h
		public ??_R3UnicodeString@icu_56@@8
; icu_56::UnicodeString::`RTTI Class Hierarchy Descriptor'
??_R3UnicodeString@icu_56@@8 dd	2 dup(0) ; DATA	XREF: .rdata$r:000011D0o
					; .rdata$r:00001234o
		dd 4
		dd offset ??_R2UnicodeString@icu_56@@8 ; icu_56::UnicodeString::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1208h
		public ??_R2UnicodeString@icu_56@@8
; icu_56::UnicodeString::`RTTI Base Class Array'
??_R2UnicodeString@icu_56@@8 dd	offset ??_R1A@?0A@EA@UnicodeString@icu_56@@8
					; DATA XREF: .rdata$r:00001204o
					; icu_56::UnicodeString::`RTTI Base Class Descriptor at	(0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@Replaceable@icu_56@@8 ;	icu_56::Replaceable::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 121Ch
		public ??_R1A@?0A@EA@UnicodeString@icu_56@@8
; icu_56::UnicodeString::`RTTI Base Class Descriptor at	(0, -1,	0, 64)'
??_R1A@?0A@EA@UnicodeString@icu_56@@8 dd offset	??_R0?AVUnicodeString@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UnicodeString::`RTTI Base	Class Array'o
					; icu_56::UnicodeString	`RTTI Type Descriptor'
		dd 3, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UnicodeString@icu_56@@8 ; icu_56::UnicodeString::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1238h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::hasShortLength(icu_56::UnicodeString *__hidden this)
		public ?hasShortLength@UnicodeString@icu_56@@ABECXZ
?hasShortLength@UnicodeString@icu_56@@ABECXZ proc near
					; CODE XREF: icu_56::UnicodeString::length(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		test	ecx, ecx
		setnl	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?hasShortLength@UnicodeString@icu_56@@ABECXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1270h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::getShortLength(icu_56::UnicodeString *__hidden this)
		public ?getShortLength@UnicodeString@icu_56@@ABEHXZ
?getShortLength@UnicodeString@icu_56@@ABEHXZ proc near
					; CODE XREF: icu_56::UnicodeString::length(void)+35p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	eax, word ptr [eax+4]
		sar	eax, 5
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getShortLength@UnicodeString@icu_56@@ABEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 12A4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::length(icu_56::UnicodeString *__hidden this)
		public ?length@UnicodeString@icu_56@@QBEHXZ
?length@UnicodeString@icu_56@@QBEHXZ proc near
					; CODE XREF: icu_56::UnicodeString::pinIndex(int &)+39p
					; icu_56::UnicodeString::pinIndex(int &)+48p ...

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?hasShortLength@UnicodeString@icu_56@@ABECXZ ; icu_56::UnicodeString::hasShortLength(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_12E6
		mov	ecx, [ebp+var_8] ; this
		call	?getShortLength@UnicodeString@icu_56@@ABEHXZ ; icu_56::UnicodeString::getShortLength(void)
		mov	[ebp+var_D0], eax
		jmp	short loc_12F2
; ---------------------------------------------------------------------------

loc_12E6:				; CODE XREF: icu_56::UnicodeString::length(void)+30j
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+8]
		mov	[ebp+var_D0], edx

loc_12F2:				; CODE XREF: icu_56::UnicodeString::length(void)+40j
		mov	eax, [ebp+var_D0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?length@UnicodeString@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 130Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::getCapacity(icu_56::UnicodeString *__hidden this)
		public ?getCapacity@UnicodeString@icu_56@@QBEHXZ
?getCapacity@UnicodeString@icu_56@@QBEHXZ proc near
					; CODE XREF: icu_56::UTS46::mapDevChars(icu_56::UnicodeString &,int,int,UErrorCode &)+C6p
					; icu_56::UTS46::mapDevChars(icu_56::UnicodeString &,int,int,UErrorCode	&)+1B5p ...

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 2
		jz	short loc_1347
		mov	[ebp+var_D0], 1Dh
		jmp	short loc_1353
; ---------------------------------------------------------------------------

loc_1347:				; CODE XREF: icu_56::UnicodeString::getCapacity(void)+2Dj
		mov	edx, [ebp+var_8]
		mov	eax, [edx+0Ch]
		mov	[ebp+var_D0], eax

loc_1353:				; CODE XREF: icu_56::UnicodeString::getCapacity(void)+39j
		mov	eax, [ebp+var_D0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getCapacity@UnicodeString@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1360h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::hashCode(icu_56::UnicodeString *__hidden this)
		public ?hashCode@UnicodeString@icu_56@@QBEHXZ
?hashCode@UnicodeString@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?doHashCode@UnicodeString@icu_56@@ABEHXZ ; icu_56::UnicodeString::doHashCode(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?hashCode@UnicodeString@icu_56@@QBEHXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 13A0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::isBogus(icu_56::UnicodeString	*__hidden this)
		public ?isBogus@UnicodeString@icu_56@@QBECXZ
?isBogus@UnicodeString@icu_56@@QBECXZ proc near
					; CODE XREF: icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+26p
					; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+35p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	eax, word ptr [eax+4]
		and	eax, 1
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isBogus@UnicodeString@icu_56@@QBECXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 13D4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::isWritable(icu_56::UnicodeString *__hidden this)
		public ?isWritable@UnicodeString@icu_56@@ABECXZ
?isWritable@UnicodeString@icu_56@@ABECXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 11h
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isWritable@UnicodeString@icu_56@@ABECXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 140Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::isBufferWritable(icu_56::UnicodeString *__hidden this)
		public ?isBufferWritable@UnicodeString@icu_56@@ABECXZ
?isBufferWritable@UnicodeString@icu_56@@ABECXZ proc near

var_D0		= byte ptr -0D0h
var_CD		= byte ptr -0CDh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 19h
		jnz	short loc_145D
		mov	edx, [ebp+var_8]
		movsx	eax, word ptr [edx+4]
		and	eax, 4
		jz	short loc_1454
		mov	ecx, [ebp+var_8] ; this
		call	?refCount@UnicodeString@icu_56@@ABEHXZ ; icu_56::UnicodeString::refCount(void)
		cmp	eax, 1
		jnz	short loc_145D

loc_1454:				; CODE XREF: icu_56::UnicodeString::isBufferWritable(void)+39j
		mov	[ebp+var_CD], 1
		jmp	short loc_1464
; ---------------------------------------------------------------------------

loc_145D:				; CODE XREF: icu_56::UnicodeString::isBufferWritable(void)+2Dj
					; icu_56::UnicodeString::isBufferWritable(void)+46j
		mov	[ebp+var_CD], 0

loc_1464:				; CODE XREF: icu_56::UnicodeString::isBufferWritable(void)+4Fj
		mov	al, [ebp+var_CD]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?isBufferWritable@UnicodeString@icu_56@@ABECXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1480h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	wchar_t	*__thiscall icu_56::UnicodeString::getBuffer(icu_56::UnicodeString *__hidden this)
		public ?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ
?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ proc	near
					; CODE XREF: icu_56::UnicodeSet::span(icu_56::UnicodeString const &,int,USetSpanCondition)+59p
					; icu_56::UnicodeSet::spanBack(icu_56::UnicodeString const &,int,USetSpanCondition)+56p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 11h
		jz	short loc_14B5
		xor	eax, eax
		jmp	short loc_14D1
; ---------------------------------------------------------------------------
		jmp	short loc_14D1
; ---------------------------------------------------------------------------

loc_14B5:				; CODE XREF: icu_56::UnicodeString::getBuffer(void)+2Dj
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 2
		jz	short loc_14CB
		mov	eax, [ebp+var_8]
		add	eax, 6
		jmp	short loc_14D1
; ---------------------------------------------------------------------------
		jmp	short loc_14D1
; ---------------------------------------------------------------------------

loc_14CB:				; CODE XREF: icu_56::UnicodeString::getBuffer(void)+3Fj
		mov	eax, [ebp+var_8]
		mov	eax, [eax+10h]

loc_14D1:				; CODE XREF: icu_56::UnicodeString::getBuffer(void)+31j
					; icu_56::UnicodeString::getBuffer(void)+33j ...
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 14D8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::doCompare(icu_56::UnicodeString *this, int, int, const struct	icu_56::UnicodeString *, int, int)
		public ?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z
?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z proc near
					; CODE XREF: icu_56::UnicodeString::operator>(icu_56::UnicodeString const &)+40p
					; icu_56::UnicodeString::operator<(icu_56::UnicodeString const &)+40p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_151E
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		setz	al
		jmp	short loc_154F
; ---------------------------------------------------------------------------
		jmp	short loc_154F
; ---------------------------------------------------------------------------

loc_151E:				; CODE XREF: icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+30j
		lea	eax, [ebp+arg_10]
		push	eax		; int *
		lea	ecx, [ebp+arg_C]
		push	ecx		; int *
		mov	ecx, [ebp+arg_8] ; this
		call	?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z ; icu_56::UnicodeString::pinIndices(int &,int &)
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	ecx, [ebp+arg_8] ; this
		call	?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ ; icu_56::UnicodeString::getArrayStart(void)
		push	eax		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)

loc_154F:				; CODE XREF: icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+42j
					; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+44j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1568h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator==(icu_56::UnicodeString	*)
		public ??8UnicodeString@icu_56@@QBECABV01@@Z
??8UnicodeString@icu_56@@QBECABV01@@Z proc near
					; CODE XREF: icu_56::UnicodeString::operator!=(icu_56::UnicodeString const &)+2Ap

var_E8		= byte ptr -0E8h
var_E5		= byte ptr -0E5h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E8]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_15A6
		mov	ecx, [ebp+arg_0] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		jmp	short loc_1600
; ---------------------------------------------------------------------------
		jmp	short loc_1600
; ---------------------------------------------------------------------------

loc_15A6:				; CODE XREF: icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)+30j
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	[ebp+var_14], eax
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	[ebp+var_20], eax
		mov	ecx, [ebp+arg_0] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_15F3
		mov	ecx, [ebp+var_14]
		cmp	ecx, [ebp+var_20]
		jnz	short loc_15F3
		mov	edx, [ebp+var_14]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?doEquals@UnicodeString@icu_56@@ABECABV12@H@Z ;	icu_56::UnicodeString::doEquals(icu_56::UnicodeString const &,int)
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_15F3
		mov	[ebp+var_E5], 1
		jmp	short loc_15FA
; ---------------------------------------------------------------------------

loc_15F3:				; CODE XREF: icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)+61j
					; icu_56::UnicodeString::operator==(icu_56::UnicodeString const	&)+69j	...
		mov	[ebp+var_E5], 0

loc_15FA:				; CODE XREF: icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)+89j
		mov	al, [ebp+var_E5]

loc_1600:				; CODE XREF: icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)+3Aj
					; icu_56::UnicodeString::operator==(icu_56::UnicodeString const	&)+3Cj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??8UnicodeString@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1618h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator!=(icu_56::UnicodeString	*)
		public ??9UnicodeString@icu_56@@QBECABV01@@Z
??9UnicodeString@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; icu_56::UnicodeString	*
		mov	ecx, [ebp+var_8]
		call	??8UnicodeString@icu_56@@QBECABV01@@Z ;	icu_56::UnicodeString::operator==(icu_56::UnicodeString	const &)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9UnicodeString@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1668h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator>(icu_56::UnicodeString *)
		public ??OUnicodeString@icu_56@@QBECABV01@@Z
??OUnicodeString@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		cmp	ecx, 1
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??OUnicodeString@icu_56@@QBECABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 16CCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator<(icu_56::UnicodeString *)
		public ??MUnicodeString@icu_56@@QBECABV01@@Z
??MUnicodeString@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		cmp	ecx, 0FFFFFFFFh
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??MUnicodeString@icu_56@@QBECABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1730h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator>=(icu_56::UnicodeString	*)
		public ??PUnicodeString@icu_56@@QBECABV01@@Z
??PUnicodeString@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		cmp	ecx, 0FFFFFFFFh
		setnz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??PUnicodeString@icu_56@@QBECABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1794h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator<=(icu_56::UnicodeString	*)
		public ??NUnicodeString@icu_56@@QBECABV01@@Z
??NUnicodeString@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		cmp	ecx, 1
		setnz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??NUnicodeString@icu_56@@QBECABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 17F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compare(icu_56::UnicodeString	*this, const struct icu_56::UnicodeString *)
		public ?compare@UnicodeString@icu_56@@QBECABV12@@Z
?compare@UnicodeString@icu_56@@QBECABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?compare@UnicodeString@icu_56@@QBECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1854h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compare(icu_56::UnicodeString	*this, int, int, const struct icu_56::UnicodeString *)
		public ?compare@UnicodeString@icu_56@@QBECHHABV12@@Z
?compare@UnicodeString@icu_56@@QBECHHABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?compare@UnicodeString@icu_56@@QBECHHABV12@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 18ACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compare(icu_56::UnicodeString	*this, const wchar_t *,	int)
		public ?compare@UnicodeString@icu_56@@QBECPB_WH@Z
?compare@UnicodeString@icu_56@@QBECPB_WH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?compare@UnicodeString@icu_56@@QBECPB_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1904h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compare(icu_56::UnicodeString	*this, int, int, const struct icu_56::UnicodeString *, int, int)
		public ?compare@UnicodeString@icu_56@@QBECHHABV12@HH@Z
?compare@UnicodeString@icu_56@@QBECHHABV12@HH@Z	proc near
					; CODE XREF: icu_56::UnicodeString::startsWith(icu_56::UnicodeString const &)+40p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?compare@UnicodeString@icu_56@@QBECHHABV12@HH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 195Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compare(icu_56::UnicodeString	*this, int, int, const wchar_t *)
		public ?compare@UnicodeString@icu_56@@QBECHHPB_W@Z
?compare@UnicodeString@icu_56@@QBECHHPB_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?compare@UnicodeString@icu_56@@QBECHHPB_W@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 19B0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compare(icu_56::UnicodeString	*this, int, int, const wchar_t *, int, int)
		public ?compare@UnicodeString@icu_56@@QBECHHPB_WHH@Z
?compare@UnicodeString@icu_56@@QBECHHPB_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?compare@UnicodeString@icu_56@@QBECHHPB_WHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1A08h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareBetween(icu_56::UnicodeString *this, int, int,	const struct icu_56::UnicodeString *, int, int)
		public ?compareBetween@UnicodeString@icu_56@@QBECHHABV12@HH@Z
?compareBetween@UnicodeString@icu_56@@QBECHHABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		sub	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_4]
		sub	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?compareBetween@UnicodeString@icu_56@@QBECHHABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1A64h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::doCompareCodePointOrder(icu_56::UnicodeString	*this, int, int, const struct icu_56::UnicodeString *, int, int)
		public ?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z
?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z	proc near
					; CODE XREF: icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString	const &)+40p
					; icu_56::UnicodeString::compareCodePointOrder(int,int,icu_56::UnicodeString const &)+3Dp ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_1AAA
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		setz	al
		jmp	short loc_1ADB
; ---------------------------------------------------------------------------
		jmp	short loc_1ADB
; ---------------------------------------------------------------------------

loc_1AAA:				; CODE XREF: icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const	&,int,int)+30j
		lea	eax, [ebp+arg_10]
		push	eax		; int *
		lea	ecx, [ebp+arg_C]
		push	ecx		; int *
		mov	ecx, [ebp+arg_8] ; this
		call	?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z ; icu_56::UnicodeString::pinIndices(int &,int &)
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	ecx, [ebp+arg_8] ; this
		call	?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ ; icu_56::UnicodeString::getArrayStart(void)
		push	eax		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHPB_WHH@Z ;	icu_56::UnicodeString::doCompareCodePointOrder(int,int,wchar_t const *,int,int)

loc_1ADB:				; CODE XREF: icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const	&,int,int)+42j
					; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)+44j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1AF4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*)
		public ?compareCodePointOrder@UnicodeString@icu_56@@QBECABV12@@Z
?compareCodePointOrder@UnicodeString@icu_56@@QBECABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z	; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?compareCodePointOrder@UnicodeString@icu_56@@QBECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1B50h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString *this, int, int, const struct icu_56::UnicodeString *)
		public ?compareCodePointOrder@UnicodeString@icu_56@@QBECHHABV12@@Z
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z	; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHABV12@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1BA8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString *this, const wchar_t *, int)
		public ?compareCodePointOrder@UnicodeString@icu_56@@QBECPB_WH@Z
?compareCodePointOrder@UnicodeString@icu_56@@QBECPB_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHPB_WHH@Z ;	icu_56::UnicodeString::doCompareCodePointOrder(int,int,wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?compareCodePointOrder@UnicodeString@icu_56@@QBECPB_WH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1C00h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString *this, int, int, const struct icu_56::UnicodeString *, int, int)
		public ?compareCodePointOrder@UnicodeString@icu_56@@QBECHHABV12@HH@Z
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z	; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1C58h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString *this, int, int, const wchar_t *)
		public ?compareCodePointOrder@UnicodeString@icu_56@@QBECHHPB_W@Z
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHPB_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHPB_WHH@Z ;	icu_56::UnicodeString::doCompareCodePointOrder(int,int,wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHPB_W@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1CACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString *this, int, int, const wchar_t *,	int, int)
		public ?compareCodePointOrder@UnicodeString@icu_56@@QBECHHPB_WHH@Z
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHPB_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHPB_WHH@Z ;	icu_56::UnicodeString::doCompareCodePointOrder(int,int,wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHPB_WHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1D04h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrderBetween(icu_56::UnicodeString *this, int, int, const struct icu_56::UnicodeString *, int, int)
		public ?compareCodePointOrderBetween@UnicodeString@icu_56@@QBECHHABV12@HH@Z
?compareCodePointOrderBetween@UnicodeString@icu_56@@QBECHHABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		sub	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_4]
		sub	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z	; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?compareCodePointOrderBetween@UnicodeString@icu_56@@QBECHHABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1D60h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::doCaseCompare(icu_56::UnicodeString *this, int, int, const struct icu_56::UnicodeString *, int, int, unsigned	int)
		public ?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z
?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z proc near
					; CODE XREF: icu_56::UnicodeString::caseCompare(icu_56::UnicodeString const &,uint)+44p
					; icu_56::UnicodeString::caseCompare(int,int,icu_56::UnicodeString const &,uint)+41p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_1DA6
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		setz	al
		jmp	short loc_1DDB
; ---------------------------------------------------------------------------
		jmp	short loc_1DDB
; ---------------------------------------------------------------------------

loc_1DA6:				; CODE XREF: icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString	const &,int,int,uint)+30j
		lea	eax, [ebp+arg_10]
		push	eax		; int *
		lea	ecx, [ebp+arg_C]
		push	ecx		; int *
		mov	ecx, [ebp+arg_8] ; this
		call	?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z ; icu_56::UnicodeString::pinIndices(int &,int &)
		mov	eax, [ebp+arg_14]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_10]
		push	ecx		; int
		mov	edx, [ebp+arg_C]
		push	edx		; int
		mov	ecx, [ebp+arg_8] ; this
		call	?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ ; icu_56::UnicodeString::getArrayStart(void)
		push	eax		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHPB_WHHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,wchar_t const *,int,int,uint)

loc_1DDB:				; CODE XREF: icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString	const &,int,int,uint)+42j
					; icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString const &,int,int,uint)+44j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	18h
?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1DF4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompare(icu_56::UnicodeString *this, const struct	icu_56::UnicodeString *, unsigned int)
		public ?caseCompare@UnicodeString@icu_56@@QBECABV12@I@Z
?caseCompare@UnicodeString@icu_56@@QBECABV12@I@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString const &,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?caseCompare@UnicodeString@icu_56@@QBECABV12@I@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1E54h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompare(icu_56::UnicodeString *this, int,	int, const struct icu_56::UnicodeString	*, unsigned int)
		public ?caseCompare@UnicodeString@icu_56@@QBECHHABV12@I@Z
?caseCompare@UnicodeString@icu_56@@QBECHHABV12@I@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct icu_56::UnicodeString *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString const &,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?caseCompare@UnicodeString@icu_56@@QBECHHABV12@I@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1EB0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompare(icu_56::UnicodeString *this, const wchar_t *, int, unsigned int)
		public ?caseCompare@UnicodeString@icu_56@@QBECPB_WHI@Z
?caseCompare@UnicodeString@icu_56@@QBECPB_WHI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHPB_WHHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,wchar_t const *,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?caseCompare@UnicodeString@icu_56@@QBECPB_WHI@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1F0Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompare(icu_56::UnicodeString *this, int,	int, const struct icu_56::UnicodeString	*, int,	int, unsigned int)
		public ?caseCompare@UnicodeString@icu_56@@QBECHHABV12@HHI@Z
?caseCompare@UnicodeString@icu_56@@QBECHHABV12@HHI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_14]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_10]
		push	ecx		; int
		mov	edx, [ebp+arg_C]
		push	edx		; int
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString const &,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	18h
?caseCompare@UnicodeString@icu_56@@QBECHHABV12@HHI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1F68h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompare(icu_56::UnicodeString *this, int,	int, const wchar_t *, unsigned int)
		public ?caseCompare@UnicodeString@icu_56@@QBECHHPB_WI@Z
?caseCompare@UnicodeString@icu_56@@QBECHHPB_WI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		push	0		; int
		mov	edx, [ebp+arg_8]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHPB_WHHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,wchar_t const *,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?caseCompare@UnicodeString@icu_56@@QBECHHPB_WI@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1FC0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompare(icu_56::UnicodeString *this, int,	int, const wchar_t *, int, int,	unsigned int)
		public ?caseCompare@UnicodeString@icu_56@@QBECHHPB_WHHI@Z
?caseCompare@UnicodeString@icu_56@@QBECHHPB_WHHI@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_14]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_10]
		push	ecx		; int
		mov	edx, [ebp+arg_C]
		push	edx		; int
		mov	eax, [ebp+arg_8]
		push	eax		; wchar_t *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this

loc_1FFE:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::fixedo
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHPB_WHHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,wchar_t const *,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	18h
?caseCompare@UnicodeString@icu_56@@QBECHHPB_WHHI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 201Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompareBetween(icu_56::UnicodeString *this, int, int, const struct icu_56::UnicodeString *, int, int, unsigned int)
		public ?caseCompareBetween@UnicodeString@icu_56@@QBECHHABV12@HHI@Z
?caseCompareBetween@UnicodeString@icu_56@@QBECHHABV12@HHI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_14]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_10]
		sub	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_C]
		push	edx		; int
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		sub	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString const &,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	18h
?caseCompareBetween@UnicodeString@icu_56@@QBECHHABV12@HHI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 207Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*, int,	int, int, int)
		public ?indexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z
?indexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z	proc near
					; CODE XREF: icu_56::UnicodeString::indexOf(icu_56::UnicodeString const	&)+40p
					; icu_56::UnicodeString::indexOf(icu_56::UnicodeString const &,int)+51p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_20E7
		lea	eax, [ebp+arg_8]
		push	eax		; int *
		lea	ecx, [ebp+arg_4]
		push	ecx		; int *
		mov	ecx, [ebp+arg_0] ; this
		call	?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z ; icu_56::UnicodeString::pinIndices(int &,int &)
		cmp	[ebp+arg_8], 0
		jle	short loc_20E7
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ ; icu_56::UnicodeString::getArrayStart(void)
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z ;	icu_56::UnicodeString::indexOf(wchar_t const *,int,int,int,int)
		jmp	short loc_20EA
; ---------------------------------------------------------------------------

loc_20E7:				; CODE XREF: icu_56::UnicodeString::indexOf(icu_56::UnicodeString const	&,int,int,int,int)+30j
					; icu_56::UnicodeString::indexOf(icu_56::UnicodeString const &,int,int,int,int)+46j
		or	eax, 0FFFFFFFFh

loc_20EA:				; CODE XREF: icu_56::UnicodeString::indexOf(icu_56::UnicodeString const	&,int,int,int,int)+69j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?indexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2100h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*)
		public ?indexOf@UnicodeString@icu_56@@QBEHABV12@@Z
?indexOf@UnicodeString@icu_56@@QBEHABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z	; icu_56::UnicodeString::indexOf(icu_56::UnicodeString const &,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?indexOf@UnicodeString@icu_56@@QBEHABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 215Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*, int)
		public ?indexOf@UnicodeString@icu_56@@QBEHABV12@H@Z
?indexOf@UnicodeString@icu_56@@QBEHABV12@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z	; icu_56::UnicodeString::indexOf(icu_56::UnicodeString const &,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?indexOf@UnicodeString@icu_56@@QBEHABV12@H@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 21C8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*, int,	int)
		public ?indexOf@UnicodeString@icu_56@@QBEHABV12@HH@Z
?indexOf@UnicodeString@icu_56@@QBEHABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z	; icu_56::UnicodeString::indexOf(icu_56::UnicodeString const &,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?indexOf@UnicodeString@icu_56@@QBEHABV12@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2220h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, const wchar_t *, int, int)
		public ?indexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z
?indexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_8]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_8]
		push	eax		; int
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z ;	icu_56::UnicodeString::indexOf(wchar_t const *,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?indexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2288h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, const wchar_t *, int, int,	int)
		public ?indexOf@UnicodeString@icu_56@@QBEHPB_WHHH@Z
?indexOf@UnicodeString@icu_56@@QBEHPB_WHHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+arg_4]
		push	edx		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z ;	icu_56::UnicodeString::indexOf(wchar_t const *,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?indexOf@UnicodeString@icu_56@@QBEHPB_WHHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 22DCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, wchar_t, int, int)
		public ?indexOf@UnicodeString@icu_56@@QBEH_WHH@Z
?indexOf@UnicodeString@icu_56@@QBEH_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		movzx	edx, [ebp+arg_0]
		push	edx		; wchar_t
		mov	ecx, [ebp+var_8] ; this
		call	?doIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z ; icu_56::UnicodeString::doIndexOf(wchar_t,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?indexOf@UnicodeString@icu_56@@QBEH_WHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 232Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, int, int, int)
		public ?indexOf@UnicodeString@icu_56@@QBEHHHH@Z
?indexOf@UnicodeString@icu_56@@QBEHHHH@Z proc near
					; CODE XREF: icu_56::UnicodeString::indexOf(int)+35p
					; icu_56::UnicodeString::indexOf(int,int)+46p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doIndexOf@UnicodeString@icu_56@@ABEHHHH@Z ; icu_56::UnicodeString::doIndexOf(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?indexOf@UnicodeString@icu_56@@QBEHHHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 237Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, wchar_t)
		public ?indexOf@UnicodeString@icu_56@@QBEH_W@Z
?indexOf@UnicodeString@icu_56@@QBEH_W@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		movzx	eax, [ebp+arg_0]
		push	eax		; wchar_t
		mov	ecx, [ebp+var_8] ; this
		call	?doIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z ; icu_56::UnicodeString::doIndexOf(wchar_t,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?indexOf@UnicodeString@icu_56@@QBEH_W@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 23D0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, int)
		public ?indexOf@UnicodeString@icu_56@@QBEHH@Z
?indexOf@UnicodeString@icu_56@@QBEHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHHHH@Z ; icu_56::UnicodeString::indexOf(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?indexOf@UnicodeString@icu_56@@QBEHH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2420h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, wchar_t, int)
		public ?indexOf@UnicodeString@icu_56@@QBEH_WH@Z
?indexOf@UnicodeString@icu_56@@QBEH_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		movzx	ecx, [ebp+arg_0]
		push	ecx		; wchar_t
		mov	ecx, [ebp+var_8] ; this
		call	?doIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z ; icu_56::UnicodeString::doIndexOf(wchar_t,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?indexOf@UnicodeString@icu_56@@QBEH_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2484h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, int, int)
		public ?indexOf@UnicodeString@icu_56@@QBEHHH@Z
?indexOf@UnicodeString@icu_56@@QBEHHH@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHHHH@Z ; icu_56::UnicodeString::indexOf(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?indexOf@UnicodeString@icu_56@@QBEHHH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 24E8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, const wchar_t *, int, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+arg_4]
		push	edx		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z ; icu_56::UnicodeString::lastIndexOf(wchar_t const *,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 253Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, const wchar_t *, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_8]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_8]
		push	eax		; int
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z ; icu_56::UnicodeString::lastIndexOf(wchar_t const *,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 25A4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *, int, int, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z proc near
					; CODE XREF: icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int)+3Dp
					; icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int)+51p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_260F
		lea	eax, [ebp+arg_8]
		push	eax		; int *
		lea	ecx, [ebp+arg_4]
		push	ecx		; int *
		mov	ecx, [ebp+arg_0] ; this
		call	?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z ; icu_56::UnicodeString::pinIndices(int &,int &)
		cmp	[ebp+arg_8], 0
		jle	short loc_260F
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ ; icu_56::UnicodeString::getArrayStart(void)
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z ; icu_56::UnicodeString::lastIndexOf(wchar_t const *,int,int,int,int)
		jmp	short loc_2612
; ---------------------------------------------------------------------------

loc_260F:				; CODE XREF: icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int,int,int)+30j
					; icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int,int,int)+46j
		or	eax, 0FFFFFFFFh

loc_2612:				; CODE XREF: icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int,int,int)+69j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2628h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z ; icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2680h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@H@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z ; icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@H@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 26ECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z ; icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2748h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, wchar_t, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEH_WHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEH_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		movzx	edx, [ebp+arg_0]
		push	edx		; wchar_t
		mov	ecx, [ebp+var_8] ; this
		call	?doLastIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z	; icu_56::UnicodeString::doLastIndexOf(wchar_t,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?lastIndexOf@UnicodeString@icu_56@@QBEH_WHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2798h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, int, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHHHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHHHH@Z proc near
					; CODE XREF: icu_56::UnicodeString::lastIndexOf(int)+35p
					; icu_56::UnicodeString::lastIndexOf(int,int)+46p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doLastIndexOf@UnicodeString@icu_56@@ABEHHHH@Z ; icu_56::UnicodeString::doLastIndexOf(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?lastIndexOf@UnicodeString@icu_56@@QBEHHHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 27E8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, wchar_t)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEH_W@Z
?lastIndexOf@UnicodeString@icu_56@@QBEH_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		movzx	eax, [ebp+arg_0]
		push	eax		; wchar_t
		mov	ecx, [ebp+var_8] ; this
		call	?doLastIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z	; icu_56::UnicodeString::doLastIndexOf(wchar_t,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?lastIndexOf@UnicodeString@icu_56@@QBEH_W@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 283Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHHHH@Z ; icu_56::UnicodeString::lastIndexOf(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?lastIndexOf@UnicodeString@icu_56@@QBEHH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 288Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, wchar_t, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEH_WH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEH_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		movzx	ecx, [ebp+arg_0]
		push	ecx		; wchar_t
		mov	ecx, [ebp+var_8] ; this
		call	?doLastIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z	; icu_56::UnicodeString::doLastIndexOf(wchar_t,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?lastIndexOf@UnicodeString@icu_56@@QBEH_WH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 28F0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHHHH@Z ; icu_56::UnicodeString::lastIndexOf(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?lastIndexOf@UnicodeString@icu_56@@QBEHHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2954h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::startsWith(icu_56::UnicodeString *this, const	struct icu_56::UnicodeString *)
		public ?startsWith@UnicodeString@icu_56@@QBECABV12@@Z
?startsWith@UnicodeString@icu_56@@QBECABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?compare@UnicodeString@icu_56@@QBECHHABV12@HH@Z	; icu_56::UnicodeString::compare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?startsWith@UnicodeString@icu_56@@QBECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 29B8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::startsWith(icu_56::UnicodeString *this, const	struct icu_56::UnicodeString *,	int, int)
		public ?startsWith@UnicodeString@icu_56@@QBECABV12@HH@Z
?startsWith@UnicodeString@icu_56@@QBECABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_8]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?startsWith@UnicodeString@icu_56@@QBECABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2A14h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::startsWith(icu_56::UnicodeString *this, const	wchar_t	*, int)
		public ?startsWith@UnicodeString@icu_56@@QBECPB_WH@Z
?startsWith@UnicodeString@icu_56@@QBECPB_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_4], 0
		jge	short loc_2A4C
		mov	eax, [ebp+arg_0]
		push	eax
		call	_u_strlen_56
		add	esp, 4
		mov	[ebp+arg_4], eax

loc_2A4C:				; CODE XREF: icu_56::UnicodeString::startsWith(wchar_t const *,int)+27j
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		movsx	eax, al
		test	eax, eax
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?startsWith@UnicodeString@icu_56@@QBECPB_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2A84h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::startsWith(icu_56::UnicodeString *this, const	wchar_t	*, int,	int)
		public ?startsWith@UnicodeString@icu_56@@QBECPB_WHH@Z
?startsWith@UnicodeString@icu_56@@QBECPB_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_8], 0
		jge	short loc_2ABC
		mov	eax, [ebp+arg_0]
		push	eax
		call	_u_strlen_56
		add	esp, 4
		mov	[ebp+arg_8], eax

loc_2ABC:				; CODE XREF: icu_56::UnicodeString::startsWith(wchar_t const *,int,int)+27j
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_8]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?startsWith@UnicodeString@icu_56@@QBECPB_WHH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2AF4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::endsWith(icu_56::UnicodeString *this,	const struct icu_56::UnicodeString *)
		public ?endsWith@UnicodeString@icu_56@@QBECABV12@@Z
?endsWith@UnicodeString@icu_56@@QBECABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	esi, eax
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	esi, eax
		push	esi		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?endsWith@UnicodeString@icu_56@@QBECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2B6Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::endsWith(icu_56::UnicodeString *this,	const struct icu_56::UnicodeString *, int, int)
		public ?endsWith@UnicodeString@icu_56@@QBECABV12@HH@Z
?endsWith@UnicodeString@icu_56@@QBECABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_8]
		push	eax		; int *
		lea	ecx, [ebp+arg_4]
		push	ecx		; int *
		mov	ecx, [ebp+arg_0] ; this
		call	?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z ; icu_56::UnicodeString::pinIndices(int &,int &)
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?endsWith@UnicodeString@icu_56@@QBECABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2BE4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::endsWith(icu_56::UnicodeString *this,	const wchar_t *, int)
		public ?endsWith@UnicodeString@icu_56@@QBECPB_WH@Z
?endsWith@UnicodeString@icu_56@@QBECPB_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_4], 0
		jge	short loc_2C1C
		mov	eax, [ebp+arg_0]
		push	eax
		call	_u_strlen_56
		add	esp, 4
		mov	[ebp+arg_4], eax

loc_2C1C:				; CODE XREF: icu_56::UnicodeString::endsWith(wchar_t const *,int)+27j
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		movsx	eax, al
		test	eax, eax
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?endsWith@UnicodeString@icu_56@@QBECPB_WH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2C5Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::endsWith(icu_56::UnicodeString *this,	const wchar_t *, int, int)
		public ?endsWith@UnicodeString@icu_56@@QBECPB_WHH@Z
?endsWith@UnicodeString@icu_56@@QBECPB_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_8], 0
		jge	short loc_2C9A
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+arg_0]
		lea	edx, [ecx+eax*2]
		push	edx
		call	_u_strlen_56
		add	esp, 4
		mov	[ebp+arg_8], eax

loc_2C9A:				; CODE XREF: icu_56::UnicodeString::endsWith(wchar_t const *,int,int)+27j
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?endsWith@UnicodeString@icu_56@@QBECPB_WHH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2CDCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replace(icu_56::UnicodeString	*this, int, int, const struct icu_56::UnicodeString *)
		public ?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@@Z
?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@@Z proc	near
					; CODE XREF: icu_56::UTS46::mapDevChars(icu_56::UnicodeString &,int,int,UErrorCode &)+31Cp
					; icu_56::replaceLabel(icu_56::UnicodeString &,int,int,icu_56::UnicodeString const &,int,UErrorCode &)+4Ep

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2D34h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replace(icu_56::UnicodeString	*this, int, int, const struct icu_56::UnicodeString *, int, int)
		public ?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z
?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z proc near
					; CODE XREF: icu_56::UnicodeString::doExtract(int,int,icu_56::UnicodeString &)+3Dp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2D8Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replace(icu_56::UnicodeString	*this, int, int, const wchar_t *, int)
		public ?replace@UnicodeString@icu_56@@QAEAAV12@HHPB_WH@Z
?replace@UnicodeString@icu_56@@QAEAAV12@HHPB_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?replace@UnicodeString@icu_56@@QAEAAV12@HHPB_WH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2DE0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replace(icu_56::UnicodeString	*this, int, int, const wchar_t *, int, int)
		public ?replace@UnicodeString@icu_56@@QAEAAV12@HHPB_WHH@Z
?replace@UnicodeString@icu_56@@QAEAAV12@HHPB_WHH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?replace@UnicodeString@icu_56@@QAEAAV12@HHPB_WHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2E38h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replace(icu_56::UnicodeString	*this, int, int, wchar_t)
		public ?replace@UnicodeString@icu_56@@QAEAAV12@HH_W@Z
?replace@UnicodeString@icu_56@@QAEAAV12@HH_W@Z proc near
					; CODE XREF: icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed	char,icu_56::IDNAInfo &,UErrorCode &)+63Dp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= word ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	1		; int
		push	0		; int
		lea	eax, [ebp+arg_8]
		push	eax		; wchar_t *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?replace@UnicodeString@icu_56@@QAEAAV12@HH_W@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2E8Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replaceBetween(icu_56::UnicodeString *this, int, int,	const struct icu_56::UnicodeString *)
		public ?replaceBetween@UnicodeString@icu_56@@QAEAAV12@HHABV12@@Z
?replaceBetween@UnicodeString@icu_56@@QAEAAV12@HHABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		sub	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?replaceBetween@UnicodeString@icu_56@@QAEAAV12@HHABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2EE8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replaceBetween(icu_56::UnicodeString *this, int, int,	const struct icu_56::UnicodeString *, int, int)
		public ?replaceBetween@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z
?replaceBetween@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		sub	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_4]
		sub	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?replaceBetween@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2F44h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::findAndReplace(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *, const struct icu_56::UnicodeString *)
		public ?findAndReplace@UnicodeString@icu_56@@QAEAAV12@ABV12@0@Z
?findAndReplace@UnicodeString@icu_56@@QAEAAV12@ABV12@0@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_4] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_4]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?findAndReplace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH0HH@Z ; icu_56::UnicodeString::findAndReplace(int,int,icu_56::UnicodeString const &,int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?findAndReplace@UnicodeString@icu_56@@QAEAAV12@ABV12@0@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2FB0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::findAndReplace(icu_56::UnicodeString *this, int, int,	const struct icu_56::UnicodeString *, const struct icu_56::UnicodeString *)
		public ?findAndReplace@UnicodeString@icu_56@@QAEAAV12@HHABV12@0@Z
?findAndReplace@UnicodeString@icu_56@@QAEAAV12@HHABV12@0@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_C] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_C]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct icu_56::UnicodeString *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this

loc_2FFC:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::hexfloato
					; .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::floatfieldo
		call	?findAndReplace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH0HH@Z ; icu_56::UnicodeString::findAndReplace(int,int,icu_56::UnicodeString const &,int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?findAndReplace@UnicodeString@icu_56@@QAEAAV12@HHABV12@0@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3018h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::doExtract(icu_56::UnicodeString *this,	int, int, struct icu_56::UnicodeString *)
		public ?doExtract@UnicodeString@icu_56@@ABEXHHAAV12@@Z
?doExtract@UnicodeString@icu_56@@ABEXHHAAV12@@Z	proc near
					; CODE XREF: icu_56::UnicodeString::extract(int,int,icu_56::UnicodeString &)+32p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	edx, [ebp+var_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_8] ; this
		call	?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::replace(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?doExtract@UnicodeString@icu_56@@ABEXHHAAV12@@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3070h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::extract(icu_56::UnicodeString *this, int, int,	wchar_t	*, int)
		public ?extract@UnicodeString@icu_56@@QBEXHHPA_WH@Z
?extract@UnicodeString@icu_56@@QBEXHHPA_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doExtract@UnicodeString@icu_56@@ABEXHHPA_WH@Z ; icu_56::UnicodeString::doExtract(int,int,wchar_t *,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?extract@UnicodeString@icu_56@@QBEXHHPA_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 30C4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::extract(icu_56::UnicodeString *this, int, int,	struct icu_56::UnicodeString *)
		public ?extract@UnicodeString@icu_56@@QBEXHHAAV12@@Z
?extract@UnicodeString@icu_56@@QBEXHHAAV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doExtract@UnicodeString@icu_56@@ABEXHHAAV12@@Z	; icu_56::UnicodeString::doExtract(int,int,icu_56::UnicodeString &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?extract@UnicodeString@icu_56@@QBEXHHAAV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3114h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::extract(icu_56::UnicodeString *this, int, int, char *, const char *)
		public ?extract@UnicodeString@icu_56@@QBEHHHPADPBD@Z
?extract@UnicodeString@icu_56@@QBEHHHPADPBD@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; char *
		mov	ecx, [ebp+arg_8]
		neg	ecx
		sbb	ecx, ecx
		push	ecx		; unsigned int
		mov	edx, [ebp+arg_8]
		push	edx		; char *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?extract@UnicodeString@icu_56@@QBEHHHPADIPBD@Z ; icu_56::UnicodeString::extract(int,int,char *,uint,char const *)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?extract@UnicodeString@icu_56@@QBEHHHPADPBD@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3170h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::extractBetween(icu_56::UnicodeString *this, int, int, wchar_t *, int)
		public ?extractBetween@UnicodeString@icu_56@@QBEXHHPA_WH@Z
?extractBetween@UnicodeString@icu_56@@QBEXHHPA_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_0]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		sub	edx, [ebp+arg_0]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doExtract@UnicodeString@icu_56@@ABEXHHPA_WH@Z ; icu_56::UnicodeString::doExtract(int,int,wchar_t *,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?extractBetween@UnicodeString@icu_56@@QBEXHHPA_WH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 31DCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeString __thiscall icu_56::UnicodeString::tempSubStringBetween(int, int)const
		public ?tempSubStringBetween@UnicodeString@icu_56@@QBE?AV12@HH@Z
?tempSubStringBetween@UnicodeString@icu_56@@QBE?AV12@HH@Z proc near

var_D8		= byte ptr -0D8h
var_D4		= dword	ptr -0D4h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_D4], 0
		mov	eax, [ebp+arg_8]
		sub	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		mov	ecx, [ebp+var_8]
		call	?tempSubString@UnicodeString@icu_56@@QBE?AV12@HH@Z ; icu_56::UnicodeString::tempSubString(int,int)
		mov	eax, [ebp+var_D4]
		or	eax, 1
		mov	[ebp+var_D4], eax
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?tempSubStringBetween@UnicodeString@icu_56@@QBE?AV12@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3248h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; wchar_t __thiscall icu_56::UnicodeString::doCharAt(icu_56::UnicodeString *this, int)
		public ?doCharAt@UnicodeString@icu_56@@ABE_WH@Z
?doCharAt@UnicodeString@icu_56@@ABE_WH@Z proc near
					; CODE XREF: icu_56::UnicodeString::charAt(int)+2Ap
					; icu_56::UnicodeString::operator[](int)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		cmp	[ebp+arg_0], eax
		jnb	short loc_328B
		mov	ecx, [ebp+var_8] ; this
		call	?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ ; icu_56::UnicodeString::getArrayStart(void)
		mov	ecx, [ebp+arg_0]
		mov	ax, [eax+ecx*2]
		jmp	short loc_3290
; ---------------------------------------------------------------------------
		jmp	short loc_3290
; ---------------------------------------------------------------------------

loc_328B:				; CODE XREF: icu_56::UnicodeString::doCharAt(int)+2Ej
		mov	eax, 0FFFFh

loc_3290:				; CODE XREF: icu_56::UnicodeString::doCharAt(int)+3Fj
					; icu_56::UnicodeString::doCharAt(int)+41j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?doCharAt@UnicodeString@icu_56@@ABE_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 32A8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; wchar_t __thiscall icu_56::UnicodeString::charAt(icu_56::UnicodeString *this,	int)
		public ?charAt@UnicodeString@icu_56@@QBE_WH@Z
?charAt@UnicodeString@icu_56@@QBE_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCharAt@UnicodeString@icu_56@@ABE_WH@Z ; icu_56::UnicodeString::doCharAt(int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?charAt@UnicodeString@icu_56@@QBE_WH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 32F0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: wchar_t __thiscall icu_56::UnicodeString::operator[](int)const
		public ??AUnicodeString@icu_56@@QBE_WH@Z
??AUnicodeString@icu_56@@QBE_WH@Z proc near
					; CODE XREF: icu_56::UTS46::nameToASCII(icu_56::UnicodeString const &,icu_56::UnicodeString &,icu_56::IDNAInfo &,UErrorCode &)+82p
					; icu_56::UTS46::processUTF8(icu_56::StringPiece const &,signed	char,signed char,icu_56::ByteSink &,icu_56::IDNAInfo &,UErrorCode &)+5B8p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCharAt@UnicodeString@icu_56@@ABE_WH@Z ; icu_56::UnicodeString::doCharAt(int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??AUnicodeString@icu_56@@QBE_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3338h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::isEmpty(icu_56::UnicodeString	*__hidden this)
		public ?isEmpty@UnicodeString@icu_56@@QBECXZ
?isEmpty@UnicodeString@icu_56@@QBECXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		sar	ecx, 5
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isEmpty@UnicodeString@icu_56@@QBECXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3374h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::setZeroLength(icu_56::UnicodeString *__hidden this)
		public ?setZeroLength@UnicodeString@icu_56@@AAEXXZ
?setZeroLength@UnicodeString@icu_56@@AAEXXZ proc near
					; CODE XREF: icu_56::UnicodeString::remove(void)+3Fp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 1Fh
		mov	edx, [ebp+var_8]
		mov	[edx+4], cx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?setZeroLength@UnicodeString@icu_56@@AAEXXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 33B0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::setShortLength(icu_56::UnicodeString *this, int)
		public ?setShortLength@UnicodeString@icu_56@@AAEXH@Z
?setShortLength@UnicodeString@icu_56@@AAEXH@Z proc near
					; CODE XREF: icu_56::UnicodeString::setLength(int)+33p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 1Fh
		mov	edx, [ebp+arg_0]
		shl	edx, 5
		or	ecx, edx
		mov	eax, [ebp+var_8]
		mov	[eax+4], cx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?setShortLength@UnicodeString@icu_56@@AAEXH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 33F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::setLength(icu_56::UnicodeString *this,	int)
		public ?setLength@UnicodeString@icu_56@@AAEXH@Z
?setLength@UnicodeString@icu_56@@AAEXH@Z proc near
					; CODE XREF: icu_56::UnicodeString::setArray(wchar_t *,int,int)+2Ap
					; icu_56::UnicodeString::truncate(int)+5Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 3FFh
		jg	short loc_3432
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?setShortLength@UnicodeString@icu_56@@AAEXH@Z ;	icu_56::UnicodeString::setShortLength(int)
		jmp	short loc_344F
; ---------------------------------------------------------------------------

loc_3432:				; CODE XREF: icu_56::UnicodeString::setLength(int)+2Aj
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		or	ecx, 0FFE0h
		mov	edx, [ebp+var_8]
		mov	[edx+4], cx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+8], ecx

loc_344F:				; CODE XREF: icu_56::UnicodeString::setLength(int)+38j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setLength@UnicodeString@icu_56@@AAEXH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3468h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::setToEmpty(icu_56::UnicodeString *__hidden this)
		public ?setToEmpty@UnicodeString@icu_56@@AAEXXZ
?setToEmpty@UnicodeString@icu_56@@AAEXXZ proc near
					; CODE XREF: icu_56::UnicodeString::remove(void)+35p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, 2
		mov	ecx, [ebp+var_8]
		mov	[ecx+4], ax
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?setToEmpty@UnicodeString@icu_56@@AAEXXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 34A0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::setArray(icu_56::UnicodeString	*this, wchar_t *, int, int)
		public ?setArray@UnicodeString@icu_56@@AAEXPA_WHH@Z
?setArray@UnicodeString@icu_56@@AAEXPA_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?setLength@UnicodeString@icu_56@@AAEXH@Z ; icu_56::UnicodeString::setLength(int)
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+10h], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_8]
		mov	[eax+0Ch], ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?setArray@UnicodeString@icu_56@@AAEXPA_WHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 34F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator=(wchar_t)
		public ??4UnicodeString@icu_56@@QAEAAV01@_W@Z
??4UnicodeString@icu_56@@QAEAAV01@_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	1		; int
		push	0		; int
		lea	eax, [ebp+arg_0]
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4UnicodeString@icu_56@@QAEAAV01@_W@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 354Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeString &	__thiscall icu_56::UnicodeString::operator=(int)
		public ??4UnicodeString@icu_56@@QAEAAV01@H@Z
??4UnicodeString@icu_56@@QAEAAV01@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?replace@UnicodeString@icu_56@@QAEAAV12@HHH@Z ;	icu_56::UnicodeString::replace(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4UnicodeString@icu_56@@QAEAAV01@H@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 359Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*, int,	int)
		public ?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z
?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?unBogus@UnicodeString@icu_56@@AAEXXZ ;	icu_56::UnicodeString::unBogus(void)
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 35FCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*, int)
		public ?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@H@Z
?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@H@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?unBogus@UnicodeString@icu_56@@AAEXXZ ;	icu_56::UnicodeString::unBogus(void)
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+arg_0] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@H@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3670h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*)
		public ?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z
?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	0		; signed __int8
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?copyFrom@UnicodeString@icu_56@@AAEAAV12@ABV12@C@Z ; icu_56::UnicodeString::copyFrom(icu_56::UnicodeString const &,signed char)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 36B8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *this, const wchar_t *, int)
		public ?setTo@UnicodeString@icu_56@@QAEAAV12@PB_WH@Z
?setTo@UnicodeString@icu_56@@QAEAAV12@PB_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?unBogus@UnicodeString@icu_56@@AAEXXZ ;	icu_56::UnicodeString::unBogus(void)
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?setTo@UnicodeString@icu_56@@QAEAAV12@PB_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3718h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *this, wchar_t)
		public ?setTo@UnicodeString@icu_56@@QAEAAV12@_W@Z
?setTo@UnicodeString@icu_56@@QAEAAV12@_W@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?unBogus@UnicodeString@icu_56@@AAEXXZ ;	icu_56::UnicodeString::unBogus(void)
		push	1		; int
		push	0		; int
		lea	eax, [ebp+arg_0]
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setTo@UnicodeString@icu_56@@QAEAAV12@_W@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3774h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *this, int)
		public ?setTo@UnicodeString@icu_56@@QAEAAV12@H@Z
?setTo@UnicodeString@icu_56@@QAEAAV12@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?unBogus@UnicodeString@icu_56@@AAEXXZ ;	icu_56::UnicodeString::unBogus(void)
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?replace@UnicodeString@icu_56@@QAEAAV12@HHH@Z ;	icu_56::UnicodeString::replace(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setTo@UnicodeString@icu_56@@QAEAAV12@H@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 37CCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *, int, int)
		public ?append@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z
?append@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@ABV12@HH@Z ; icu_56::UnicodeString::doAppend(icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?append@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 381Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *)
		public ?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z
?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@ABV12@HH@Z ; icu_56::UnicodeString::doAppend(icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 386Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *this, const wchar_t *, int, int)
		public ?append@UnicodeString@icu_56@@QAEAAV12@PB_WHH@Z
?append@UnicodeString@icu_56@@QAEAAV12@PB_WHH@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@PB_WHH@Z ; icu_56::UnicodeString::doAppend(wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?append@UnicodeString@icu_56@@QAEAAV12@PB_WHH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 38BCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *this, const wchar_t *, int)
		public ?append@UnicodeString@icu_56@@QAEAAV12@PB_WH@Z
?append@UnicodeString@icu_56@@QAEAAV12@PB_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@PB_WHH@Z ; icu_56::UnicodeString::doAppend(wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?append@UnicodeString@icu_56@@QAEAAV12@PB_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3908h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *this, wchar_t)
		public ?append@UnicodeString@icu_56@@QAEAAV12@_W@Z
?append@UnicodeString@icu_56@@QAEAAV12@_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	1		; int
		push	0		; int
		lea	eax, [ebp+arg_0]
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@PB_WHH@Z ; icu_56::UnicodeString::doAppend(wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?append@UnicodeString@icu_56@@QAEAAV12@_W@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3954h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator+=(wchar_t)
		public ??YUnicodeString@icu_56@@QAEAAV01@_W@Z
??YUnicodeString@icu_56@@QAEAAV01@_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	1		; int
		push	0		; int
		lea	eax, [ebp+arg_0]
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@PB_WHH@Z ; icu_56::UnicodeString::doAppend(wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??YUnicodeString@icu_56@@QAEAAV01@_W@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 39A0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeString &	__thiscall icu_56::UnicodeString::operator+=(int)
		public ??YUnicodeString@icu_56@@QAEAAV01@H@Z
??YUnicodeString@icu_56@@QAEAAV01@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?append@UnicodeString@icu_56@@QAEAAV12@H@Z ; icu_56::UnicodeString::append(int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??YUnicodeString@icu_56@@QAEAAV01@H@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 39E8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator+=(struct icu_56::UnicodeString *)
		public ??YUnicodeString@icu_56@@QAEAAV01@ABV01@@Z
??YUnicodeString@icu_56@@QAEAAV01@ABV01@@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@ABV12@HH@Z ; icu_56::UnicodeString::doAppend(icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??YUnicodeString@icu_56@@QAEAAV01@ABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3A38h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::insert(icu_56::UnicodeString *this, int, const struct	icu_56::UnicodeString *, int, int)
		public ?insert@UnicodeString@icu_56@@QAEAAV12@HABV12@HH@Z
?insert@UnicodeString@icu_56@@QAEAAV12@HABV12@HH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+arg_4]
		push	edx		; struct icu_56::UnicodeString *
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?insert@UnicodeString@icu_56@@QAEAAV12@HABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3A8Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::insert(icu_56::UnicodeString *this, int, const struct	icu_56::UnicodeString *)
		public ?insert@UnicodeString@icu_56@@QAEAAV12@HABV12@@Z
?insert@UnicodeString@icu_56@@QAEAAV12@HABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_4] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_4]
		push	eax		; struct icu_56::UnicodeString *
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?insert@UnicodeString@icu_56@@QAEAAV12@HABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3AE4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::insert(icu_56::UnicodeString *this, int, const wchar_t *, int, int)
		public ?insert@UnicodeString@icu_56@@QAEAAV12@HPB_WHH@Z
?insert@UnicodeString@icu_56@@QAEAAV12@HPB_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+arg_4]
		push	edx		; wchar_t *
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?insert@UnicodeString@icu_56@@QAEAAV12@HPB_WHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3B38h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::insert(icu_56::UnicodeString *this, int, const wchar_t *, int)
		public ?insert@UnicodeString@icu_56@@QAEAAV12@HPB_WH@Z
?insert@UnicodeString@icu_56@@QAEAAV12@HPB_WH@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; wchar_t *
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?insert@UnicodeString@icu_56@@QAEAAV12@HPB_WH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3B8Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::insert(icu_56::UnicodeString *this, int, wchar_t)
		public ?insert@UnicodeString@icu_56@@QAEAAV12@H_W@Z
?insert@UnicodeString@icu_56@@QAEAAV12@H_W@Z proc near
					; CODE XREF: icu_56::UTS46::markBadACELabel(icu_56::UnicodeString &,int,int,signed char,icu_56::IDNAInfo &,UErrorCode &)+123p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= word ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	1		; int
		push	0		; int
		lea	eax, [ebp+arg_4]
		push	eax		; wchar_t *
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?insert@UnicodeString@icu_56@@QAEAAV12@H_W@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3BDCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::insert(icu_56::UnicodeString *this, int, int)
		public ?insert@UnicodeString@icu_56@@QAEAAV12@HH@Z
?insert@UnicodeString@icu_56@@QAEAAV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?replace@UnicodeString@icu_56@@QAEAAV12@HHH@Z ;	icu_56::UnicodeString::replace(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?insert@UnicodeString@icu_56@@QAEAAV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3C28h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::remove(icu_56::UnicodeString *__hidden this)
		public ?remove@UnicodeString@icu_56@@QAEAAV12@XZ
?remove@UnicodeString@icu_56@@QAEAAV12@XZ proc near
					; CODE XREF: icu_56::UnicodeString::remove(int,int)+35p
					; icu_56::UTS46::process(icu_56::UnicodeString const &,signed char,signed char,icu_56::UnicodeString &,icu_56::IDNAInfo	&,UErrorCode &)+7Dp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_3C64
		mov	ecx, [ebp+var_8] ; this
		call	?setToEmpty@UnicodeString@icu_56@@AAEXXZ ; icu_56::UnicodeString::setToEmpty(void)
		jmp	short loc_3C6C
; ---------------------------------------------------------------------------

loc_3C64:				; CODE XREF: icu_56::UnicodeString::remove(void)+30j
		mov	ecx, [ebp+var_8] ; this
		call	?setZeroLength@UnicodeString@icu_56@@AAEXXZ ; icu_56::UnicodeString::setZeroLength(void)

loc_3C6C:				; CODE XREF: icu_56::UnicodeString::remove(void)+3Aj
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?remove@UnicodeString@icu_56@@QAEAAV12@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3C84h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::remove(icu_56::UnicodeString *this, int, int)
		public ?remove@UnicodeString@icu_56@@QAEAAV12@HH@Z
?remove@UnicodeString@icu_56@@QAEAAV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jg	short loc_3CC0
		cmp	[ebp+arg_4], 7FFFFFFFh
		jnz	short loc_3CC0
		mov	ecx, [ebp+var_8] ; this
		call	?remove@UnicodeString@icu_56@@QAEAAV12@XZ ; icu_56::UnicodeString::remove(void)
		jmp	short loc_3CD6
; ---------------------------------------------------------------------------

loc_3CC0:				; CODE XREF: icu_56::UnicodeString::remove(int,int)+27j
					; icu_56::UnicodeString::remove(int,int)+30j
		push	0		; int
		push	0		; int
		push	0		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)

loc_3CD6:				; CODE XREF: icu_56::UnicodeString::remove(int,int)+3Aj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?remove@UnicodeString@icu_56@@QAEAAV12@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3CECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::removeBetween(icu_56::UnicodeString *this, int, int)
		public ?removeBetween@UnicodeString@icu_56@@QAEAAV12@HH@Z
?removeBetween@UnicodeString@icu_56@@QAEAAV12@HH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	0		; int
		push	0		; int
		push	0		; wchar_t *
		mov	eax, [ebp+arg_4]
		sub	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?removeBetween@UnicodeString@icu_56@@QAEAAV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3D40h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::retainBetween(icu_56::UnicodeString *this, int, int)
		public ?retainBetween@UnicodeString@icu_56@@QAEAAV12@HH@Z
?retainBetween@UnicodeString@icu_56@@QAEAAV12@HH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?truncate@UnicodeString@icu_56@@QAECH@Z	; icu_56::UnicodeString::truncate(int)
		push	0		; int
		push	0		; int
		push	0		; wchar_t *
		mov	eax, [ebp+arg_0]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?retainBetween@UnicodeString@icu_56@@QAEAAV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3D9Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::truncate(icu_56::UnicodeString *this,	int)
		public ?truncate@UnicodeString@icu_56@@QAECH@Z
?truncate@UnicodeString@icu_56@@QAECH@Z	proc near
					; CODE XREF: icu_56::UnicodeString::retainBetween(int,int)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_3DE2
		cmp	[ebp+arg_0], 0
		jnz	short loc_3DE2
		mov	ecx, [ebp+var_8] ; this
		call	?unBogus@UnicodeString@icu_56@@AAEXXZ ;	icu_56::UnicodeString::unBogus(void)
		xor	al, al
		jmp	short loc_3E03
; ---------------------------------------------------------------------------
		jmp	short loc_3E03
; ---------------------------------------------------------------------------

loc_3DE2:				; CODE XREF: icu_56::UnicodeString::truncate(int)+30j
					; icu_56::UnicodeString::truncate(int)+36j
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		cmp	[ebp+arg_0], eax
		jnb	short loc_3E01
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?setLength@UnicodeString@icu_56@@AAEXH@Z ; icu_56::UnicodeString::setLength(int)
		mov	al, 1
		jmp	short loc_3E03
; ---------------------------------------------------------------------------
		jmp	short loc_3E03
; ---------------------------------------------------------------------------

loc_3E01:				; CODE XREF: icu_56::UnicodeString::truncate(int)+51j
		xor	al, al

loc_3E03:				; CODE XREF: icu_56::UnicodeString::truncate(int)+42j
					; icu_56::UnicodeString::truncate(int)+44j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?truncate@UnicodeString@icu_56@@QAECH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3E1Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::reverse(icu_56::UnicodeString	*__hidden this)
		public ?reverse@UnicodeString@icu_56@@QAEAAV12@XZ
?reverse@UnicodeString@icu_56@@QAEAAV12@XZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReverse@UnicodeString@icu_56@@AAEAAV12@HH@Z ; icu_56::UnicodeString::doReverse(int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?reverse@UnicodeString@icu_56@@QAEAAV12@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3E68h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::reverse(icu_56::UnicodeString	*this, int, int)
		public ?reverse@UnicodeString@icu_56@@QAEAAV12@HH@Z
?reverse@UnicodeString@icu_56@@QAEAAV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReverse@UnicodeString@icu_56@@AAEAAV12@HH@Z ; icu_56::UnicodeString::doReverse(int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?reverse@UnicodeString@icu_56@@QAEAAV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3EB4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::IDNA::IDNA(icu_56::IDNA *__hidden this)
		public ??0IDNA@icu_56@@QAE@XZ
??0IDNA@icu_56@@QAE@XZ proc near	; CODE XREF: icu_56::UTS46::UTS46(uint,UErrorCode &)+45p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7IDNA@icu_56@@6B@ ; const icu_56::IDNA::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0IDNA@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3F00h
		dd offset ??_R4IDNA@icu_56@@6B@	; const	icu_56::IDNA::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7IDNA@icu_56@@6B@
; const	icu_56::IDNA::`vftable'
??_7IDNA@icu_56@@6B@ dd	offset ??_EIDNA@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::IDNA::IDNA(void)+2Eo
					; icu_56::IDNA::IDNA(icu_56::IDNA const	&)+32o	...
					; icu_56::IDNA::`vector	deleting destructor'(uint)
		dd offset ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ ;	icu_56::UObject::getDynamicClassID(void)
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
		dd offset ?labelToASCII_UTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z ;	icu_56::IDNA::labelToASCII_UTF8(icu_56::StringPiece const &,icu_56::ByteSink &,icu_56::IDNAInfo	&,UErrorCode &)
		dd offset ?labelToUnicodeUTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z ; icu_56::IDNA::labelToUnicodeUTF8(icu_56::StringPiece const &,icu_56::ByteSink &,icu_56::IDNAInfo &,UErrorCode &)
		dd offset ?nameToASCII_UTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z ; icu_56::IDNA::nameToASCII_UTF8(icu_56::StringPiece const	&,icu_56::ByteSink &,icu_56::IDNAInfo &,UErrorCode &)
		dd offset ?nameToUnicodeUTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z ;	icu_56::IDNA::nameToUnicodeUTF8(icu_56::StringPiece const &,icu_56::ByteSink &,icu_56::IDNAInfo	&,UErrorCode &)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 3F2Ch
		public ??_R4IDNA@icu_56@@6B@
; const	icu_56::IDNA::`RTTI Complete Object Locator'
??_R4IDNA@icu_56@@6B@ dd 3 dup(0)	; DATA XREF: .rdata:00003F00o
		dd offset ??_R0?AVIDNA@icu_56@@@8 ; icu_56::IDNA `RTTI Type Descriptor'
		dd offset ??_R3IDNA@icu_56@@8 ;	icu_56::IDNA::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 3F40h
		public ??_R0?AVIDNA@icu_56@@@8
; class	icu_56::IDNA `RTTI Type	Descriptor'
??_R0?AVIDNA@icu_56@@@8	dd offset ??_7type_info@@6B@ ; DATA XREF: .rdata$r:00003F38o
					; .rdata$r:icu_56::IDNA::`RTTI Base Class Descriptor at	(0,-1,0,64)'o
					; const	type_info::`vftable'
		align 8
a_?avidna@icu_5	db '.?AVIDNA@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 3F5Ch
		public ??_R3IDNA@icu_56@@8
; icu_56::IDNA::`RTTI Class Hierarchy Descriptor'
??_R3IDNA@icu_56@@8 dd 2 dup(0)		; DATA XREF: .rdata$r:00003F3Co
					; .rdata$r:00003F94o
		dd 3
		dd offset ??_R2IDNA@icu_56@@8 ;	icu_56::IDNA::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 3F6Ch
		public ??_R2IDNA@icu_56@@8
; icu_56::IDNA::`RTTI Base Class Array'
??_R2IDNA@icu_56@@8 dd offset ??_R1A@?0A@EA@IDNA@icu_56@@8 ; DATA XREF:	.rdata$r:00003F68o
					; icu_56::IDNA::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 3F7Ch
		public ??_R1A@?0A@EA@IDNA@icu_56@@8
; icu_56::IDNA::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@IDNA@icu_56@@8 dd	offset ??_R0?AVIDNA@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::IDNA::`RTTI Base Class Array'o
					; .rdata$r:00005F04o
					; icu_56::IDNA `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3IDNA@icu_56@@8 ;	icu_56::IDNA::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3F98h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::IDNA::IDNA(icu_56::IDNA *this, const struct	icu_56::IDNA *)
		public ??0IDNA@icu_56@@QAE@ABV01@@Z
??0IDNA@icu_56@@QAE@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UObject *
		mov	ecx, [ebp+var_8] ; this
		call	??0UObject@icu_56@@QAE@ABV01@@Z	; icu_56::UObject::UObject(icu_56::UObject const &)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7IDNA@icu_56@@6B@ ; const icu_56::IDNA::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0IDNA@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3FECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::IDNA & __thiscall icu_56::IDNA::operator=(class	icu_56::IDNA const &)
		public ??4IDNA@icu_56@@QAEAAV01@ABV01@@Z
??4IDNA@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]

loc_3FFF:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::boolalphao
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??4UObject@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::UObject::operator=(icu_56::UObject const	&)
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4IDNA@icu_56@@QAEAAV01@ABV01@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4034h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::IDNA::`scalar deleting destructor'(unsigned int)
		public ??_GIDNA@icu_56@@UAEPAXI@Z
??_GIDNA@icu_56@@UAEPAXI@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1IDNA@icu_56@@UAE@XZ ; icu_56::IDNA::~IDNA(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_4073
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_4073:				; CODE XREF: icu_56::IDNA::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GIDNA@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 408Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::IDNA::`vector deleting destructor'(unsigned int)
		public ??_EIDNA@icu_56@@UAEPAXI@Z
??_EIDNA@icu_56@@UAEPAXI@Z proc	near	; DATA XREF: .rdata:const icu_56::IDNA::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_40ED
		push	offset ??1IDNA@icu_56@@UAE@XZ ;	icu_56::IDNA::~IDNA(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	4
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_40E5
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_40E5:				; CODE XREF: icu_56::IDNA::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_410C
; ---------------------------------------------------------------------------

loc_40ED:				; CODE XREF: icu_56::IDNA::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1IDNA@icu_56@@UAE@XZ ; icu_56::IDNA::~IDNA(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_4109
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_4109:				; CODE XREF: icu_56::IDNA::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_410C:				; CODE XREF: icu_56::IDNA::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EIDNA@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4124h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::IDNAInfo::IDNAInfo(icu_56::IDNAInfo	*__hidden this)
		public ??0IDNAInfo@icu_56@@QAE@XZ
??0IDNAInfo@icu_56@@QAE@XZ proc	near	; CODE XREF: _uidna_labelToASCII_56+8Cp
					; _uidna_labelToUnicode_56+8Cp	...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+9], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+0Ah], 1
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0IDNAInfo@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 417Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::IDNAInfo::hasErrors(icu_56::IDNAInfo	*__hidden this)
		public ?hasErrors@IDNAInfo@icu_56@@QBECXZ
?hasErrors@IDNAInfo@icu_56@@QBECXZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax], 0
		setnz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?hasErrors@IDNAInfo@icu_56@@QBECXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 41B0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; unsigned int __thiscall icu_56::IDNAInfo::getErrors(icu_56::IDNAInfo *__hidden this)
		public ?getErrors@IDNAInfo@icu_56@@QBEIXZ
?getErrors@IDNAInfo@icu_56@@QBEIXZ proc	near
					; CODE XREF: idnaInfoToStruct(icu_56::IDNAInfo &,UIDNAInfo *)+2Fp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getErrors@IDNAInfo@icu_56@@QBEIXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 41E0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::IDNAInfo::isTransitionalDifferent(icu_56::IDNAInfo *__hidden	this)
		public ?isTransitionalDifferent@IDNAInfo@icu_56@@QBECXZ
?isTransitionalDifferent@IDNAInfo@icu_56@@QBECXZ proc near
					; CODE XREF: idnaInfoToStruct(icu_56::IDNAInfo &,UIDNAInfo *)+21p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	al, [eax+8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isTransitionalDifferent@IDNAInfo@icu_56@@QBECXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4210h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::IDNAInfo::reset(icu_56::IDNAInfo *__hidden this)
		public ?reset@IDNAInfo@icu_56@@AAEXXZ
?reset@IDNAInfo@icu_56@@AAEXXZ proc near
					; CODE XREF: icu_56::UTS46::process(icu_56::UnicodeString const	&,signed char,signed char,icu_56::UnicodeString	&,icu_56::IDNAInfo &,UErrorCode	&)+85p
					; icu_56::UTS46::processUTF8(icu_56::StringPiece const &,signed	char,signed char,icu_56::ByteSink &,icu_56::IDNAInfo &,UErrorCode &)+92p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0
		mov	ecx, [ebp+var_8]
		mov	dword ptr [ecx], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+9], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+0Ah], 1
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?reset@IDNAInfo@icu_56@@AAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4264h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UnicodeFunctor::UnicodeFunctor(icu_56::UnicodeFunctor *__hidden this)
		public ??0UnicodeFunctor@icu_56@@QAE@XZ
??0UnicodeFunctor@icu_56@@QAE@XZ proc near
					; CODE XREF: icu_56::UnicodeFilter::UnicodeFilter(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UnicodeFunctor@icu_56@@6B@ ; const icu_56::UnicodeFunctor::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0UnicodeFunctor@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 42B0h
		dd offset ??_R4UnicodeFunctor@icu_56@@6B@ ; const icu_56::UnicodeFunctor::`RTTI	Complete Object	Locator'
;
; Exported entry
;
		public ??_7UnicodeFunctor@icu_56@@6B@
; const	icu_56::UnicodeFunctor::`vftable'
??_7UnicodeFunctor@icu_56@@6B@ dd offset ??_EUnicodeFunctor@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::UnicodeFunctor::UnicodeFunctor(void)+2Eo
					; icu_56::UnicodeFunctor::UnicodeFunctor(icu_56::UnicodeFunctor	const &)+32o
					; icu_56::UnicodeFunctor::`vector deleting destructor'(uint)
		dd offset __purecall
		dd offset __purecall
		dd offset ?toMatcher@UnicodeFunctor@icu_56@@UBEPAVUnicodeMatcher@2@XZ ;	icu_56::UnicodeFunctor::toMatcher(void)
		dd offset ?toReplacer@UnicodeFunctor@icu_56@@UBEPAVUnicodeReplacer@2@XZ	; icu_56::UnicodeFunctor::toReplacer(void)
		dd offset __purecall
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 42CCh
		public ??_R4UnicodeFunctor@icu_56@@6B@
; const	icu_56::UnicodeFunctor::`RTTI Complete Object Locator'
??_R4UnicodeFunctor@icu_56@@6B@	dd 3 dup(0) ; DATA XREF: .rdata:000042B0o
		dd offset ??_R0?AVUnicodeFunctor@icu_56@@@8 ; icu_56::UnicodeFunctor `RTTI Type	Descriptor'
		dd offset ??_R3UnicodeFunctor@icu_56@@8	; icu_56::UnicodeFunctor::`RTTI	Class Hierarchy	Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 42E0h
		public ??_R0?AVUnicodeFunctor@icu_56@@@8
; class	icu_56::UnicodeFunctor `RTTI Type Descriptor'
??_R0?AVUnicodeFunctor@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:000042D8o
					; .rdata$r:icu_56::UnicodeFunctor::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 8
a_?avunicodefun	db '.?AVUnicodeFunctor@icu_56@@',0
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 4304h
		public ??_R3UnicodeFunctor@icu_56@@8
; icu_56::UnicodeFunctor::`RTTI	Class Hierarchy	Descriptor'
??_R3UnicodeFunctor@icu_56@@8 dd 2 dup(0) ; DATA XREF: .rdata$r:000042DCo
					; .rdata$r:0000433Co
		dd 3
		dd offset ??_R2UnicodeFunctor@icu_56@@8	; icu_56::UnicodeFunctor::`RTTI	Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 4314h
		public ??_R2UnicodeFunctor@icu_56@@8
; icu_56::UnicodeFunctor::`RTTI	Base Class Array'
??_R2UnicodeFunctor@icu_56@@8 dd offset	??_R1A@?0A@EA@UnicodeFunctor@icu_56@@8
					; DATA XREF: .rdata$r:00004310o
					; icu_56::UnicodeFunctor::`RTTI	Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 4324h
		public ??_R1A@?0A@EA@UnicodeFunctor@icu_56@@8
; icu_56::UnicodeFunctor::`RTTI	Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UnicodeFunctor@icu_56@@8 dd offset ??_R0?AVUnicodeFunctor@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UnicodeFunctor::`RTTI Base Class Array'o
					; .rdata$r:000047F8o
					; icu_56::UnicodeFunctor `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UnicodeFunctor@icu_56@@8	; icu_56::UnicodeFunctor::`RTTI	Class Hierarchy	Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4340h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UnicodeFunctor::UnicodeFunctor(icu_56::UnicodeFunctor *this, const struct icu_56::UnicodeFunctor *)
		public ??0UnicodeFunctor@icu_56@@QAE@ABV01@@Z
??0UnicodeFunctor@icu_56@@QAE@ABV01@@Z proc near
					; CODE XREF: icu_56::UnicodeFilter::UnicodeFilter(icu_56::UnicodeFilter	const &)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UObject *
		mov	ecx, [ebp+var_8] ; this
		call	??0UObject@icu_56@@QAE@ABV01@@Z	; icu_56::UObject::UObject(icu_56::UObject const &)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UnicodeFunctor@icu_56@@6B@ ; const icu_56::UnicodeFunctor::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0UnicodeFunctor@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4394h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeFunctor & __thiscall icu_56::UnicodeFunctor::operator=(class icu_56::UnicodeFunctor const &)
		public ??4UnicodeFunctor@icu_56@@QAEAAV01@ABV01@@Z
??4UnicodeFunctor@icu_56@@QAEAAV01@ABV01@@Z proc near
					; CODE XREF: icu_56::UnicodeFilter::operator=(icu_56::UnicodeFilter const &)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??4UObject@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::UObject::operator=(icu_56::UObject const	&)
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4UnicodeFunctor@icu_56@@QAEAAV01@ABV01@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 43DCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UnicodeFunctor::`scalar deleting destructor'(unsigned int)
		public ??_GUnicodeFunctor@icu_56@@UAEPAXI@Z
??_GUnicodeFunctor@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1UnicodeFunctor@icu_56@@UAE@XZ ; icu_56::UnicodeFunctor::~UnicodeFunctor(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_441B
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_441B:				; CODE XREF: icu_56::UnicodeFunctor::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GUnicodeFunctor@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4434h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UnicodeFunctor::`vector deleting destructor'(unsigned int)
		public ??_EUnicodeFunctor@icu_56@@UAEPAXI@Z
??_EUnicodeFunctor@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::UnicodeFunctor::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_4495
		push	offset ??1UnicodeFunctor@icu_56@@UAE@XZ	; icu_56::UnicodeFunctor::~UnicodeFunctor(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	4
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_448D
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_448D:				; CODE XREF: icu_56::UnicodeFunctor::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_44B4
; ---------------------------------------------------------------------------

loc_4495:				; CODE XREF: icu_56::UnicodeFunctor::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1UnicodeFunctor@icu_56@@UAE@XZ ; icu_56::UnicodeFunctor::~UnicodeFunctor(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_44B1
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_44B1:				; CODE XREF: icu_56::UnicodeFunctor::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_44B4:				; CODE XREF: icu_56::UnicodeFunctor::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EUnicodeFunctor@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 44CCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UnicodeMatcher::UnicodeMatcher(icu_56::UnicodeMatcher *__hidden this)
		public ??0UnicodeMatcher@icu_56@@QAE@XZ
??0UnicodeMatcher@icu_56@@QAE@XZ proc near
					; CODE XREF: icu_56::UnicodeFilter::UnicodeFilter(void)+31p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UnicodeMatcher@icu_56@@6B@ ; const icu_56::UnicodeMatcher::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0UnicodeMatcher@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4504h
		dd offset ??_R4UnicodeMatcher@icu_56@@6B@ ; const icu_56::UnicodeMatcher::`RTTI	Complete Object	Locator'
;
; Exported entry
;
		public ??_7UnicodeMatcher@icu_56@@6B@
; const	icu_56::UnicodeMatcher::`vftable'
??_7UnicodeMatcher@icu_56@@6B@ dd offset ??_EUnicodeMatcher@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::UnicodeMatcher::UnicodeMatcher(void)+26o
					; icu_56::UnicodeMatcher::UnicodeMatcher(icu_56::UnicodeMatcher	const &)+26o
					; icu_56::UnicodeMatcher::`vector deleting destructor'(uint)
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 451Ch
		public ??_R4UnicodeMatcher@icu_56@@6B@
; const	icu_56::UnicodeMatcher::`RTTI Complete Object Locator'
??_R4UnicodeMatcher@icu_56@@6B@	dd 3 dup(0) ; DATA XREF: .rdata:00004504o
		dd offset ??_R0?AVUnicodeMatcher@icu_56@@@8 ; icu_56::UnicodeMatcher `RTTI Type	Descriptor'
		dd offset ??_R3UnicodeMatcher@icu_56@@8	; icu_56::UnicodeMatcher::`RTTI	Class Hierarchy	Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 4530h
		public ??_R0?AVUnicodeMatcher@icu_56@@@8
; class	icu_56::UnicodeMatcher `RTTI Type Descriptor'
??_R0?AVUnicodeMatcher@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:00004528o
					; .rdata$r:icu_56::UnicodeMatcher::`RTTI Base Class Descriptor at (0,-1,0,64)'o ...
					; const	type_info::`vftable'
		align 8
a_?avunicodemat	db '.?AVUnicodeMatcher@icu_56@@',0
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 4554h
		public ??_R3UnicodeMatcher@icu_56@@8
; icu_56::UnicodeMatcher::`RTTI	Class Hierarchy	Descriptor'
??_R3UnicodeMatcher@icu_56@@8 dd 2 dup(0) ; DATA XREF: .rdata$r:0000452Co
					; .rdata$r:00004584o ...
		dd 1
		dd offset ??_R2UnicodeMatcher@icu_56@@8	; icu_56::UnicodeMatcher::`RTTI	Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 4564h
		public ??_R2UnicodeMatcher@icu_56@@8
; icu_56::UnicodeMatcher::`RTTI	Base Class Array'
??_R2UnicodeMatcher@icu_56@@8 dd offset	??_R1A@?0A@EA@UnicodeMatcher@icu_56@@8
					; DATA XREF: .rdata$r:00004560o
					; icu_56::UnicodeMatcher::`RTTI	Base Class Descriptor at (0,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 456Ch
		public ??_R1A@?0A@EA@UnicodeMatcher@icu_56@@8
; icu_56::UnicodeMatcher::`RTTI	Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UnicodeMatcher@icu_56@@8 dd offset ??_R0?AVUnicodeMatcher@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UnicodeMatcher::`RTTI Base Class Array'o
					; icu_56::UnicodeMatcher `RTTI Type Descriptor'
		dd 2 dup(0)
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UnicodeMatcher@icu_56@@8	; icu_56::UnicodeMatcher::`RTTI	Class Hierarchy	Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4588h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UnicodeMatcher::UnicodeMatcher(icu_56::UnicodeMatcher *this, const struct icu_56::UnicodeMatcher *)
		public ??0UnicodeMatcher@icu_56@@QAE@ABV01@@Z
??0UnicodeMatcher@icu_56@@QAE@ABV01@@Z proc near
					; CODE XREF: icu_56::UnicodeFilter::UnicodeFilter(icu_56::UnicodeFilter	const &)+5Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UnicodeMatcher@icu_56@@6B@ ; const icu_56::UnicodeMatcher::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??0UnicodeMatcher@icu_56@@QAE@ABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 45C0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeMatcher & __thiscall icu_56::UnicodeMatcher::operator=(class icu_56::UnicodeMatcher const &)
		public ??4UnicodeMatcher@icu_56@@QAEAAV01@ABV01@@Z
??4UnicodeMatcher@icu_56@@QAEAAV01@ABV01@@Z proc near
					; CODE XREF: icu_56::UnicodeFilter::operator=(icu_56::UnicodeFilter const &)+5Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4UnicodeMatcher@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 45F0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UnicodeMatcher::`scalar deleting destructor'(unsigned int)
		public ??_GUnicodeMatcher@icu_56@@UAEPAXI@Z
??_GUnicodeMatcher@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1UnicodeMatcher@icu_56@@UAE@XZ ; icu_56::UnicodeMatcher::~UnicodeMatcher(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_462F
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_462F:				; CODE XREF: icu_56::UnicodeMatcher::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GUnicodeMatcher@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4648h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UnicodeMatcher::`vector deleting destructor'(unsigned int)
		public ??_EUnicodeMatcher@icu_56@@UAEPAXI@Z
??_EUnicodeMatcher@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::UnicodeMatcher::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_46A9
		push	offset ??1UnicodeMatcher@icu_56@@UAE@XZ	; icu_56::UnicodeMatcher::~UnicodeMatcher(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	4
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_46A1
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_V@YAXPAX@Z	; operator delete[](void *)
		add	esp, 4

loc_46A1:				; CODE XREF: icu_56::UnicodeMatcher::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_46C8
; ---------------------------------------------------------------------------

loc_46A9:				; CODE XREF: icu_56::UnicodeMatcher::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1UnicodeMatcher@icu_56@@UAE@XZ ; icu_56::UnicodeMatcher::~UnicodeMatcher(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_46C5
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_46C5:				; CODE XREF: icu_56::UnicodeMatcher::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_46C8:				; CODE XREF: icu_56::UnicodeMatcher::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EUnicodeMatcher@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 46E0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl operator	delete[](void *)
		public ??_V@YAXPAX@Z
??_V@YAXPAX@Z	proc near		; CODE XREF: icu_56::UnicodeMatcher::`vector deleting destructor'(uint)+51p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??_V@YAXPAX@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4714h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UnicodeFilter::UnicodeFilter(icu_56::UnicodeFilter *__hidden this)
		public ??0UnicodeFilter@icu_56@@QAE@XZ
??0UnicodeFilter@icu_56@@QAE@XZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??0UnicodeFunctor@icu_56@@QAE@XZ ; icu_56::UnicodeFunctor::UnicodeFunctor(void)
		mov	ecx, [ebp+var_8]
		add	ecx, 4		; this
		call	??0UnicodeMatcher@icu_56@@QAE@XZ ; icu_56::UnicodeMatcher::UnicodeMatcher(void)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UnicodeFilter@icu_56@@6BUnicodeFunctor@1@@ ; const icu_56::UnicodeFilter::`vftable'{for `icu_56::UnicodeFunctor'}
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], offset ??_7UnicodeFilter@icu_56@@6BUnicodeMatcher@1@@ ; const icu_56::UnicodeFilter::`vftable'{for `icu_56::UnicodeMatcher'}
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0UnicodeFilter@icu_56@@QAE@XZ	endp

_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4774h
		dd offset ??_R4UnicodeFilter@icu_56@@6BUnicodeMatcher@1@@ ; const icu_56::UnicodeFilter::`RTTI Complete	Object Locator'{for `icu_56::UnicodeMatcher'}
;
; Exported entry
;
		public ??_7UnicodeFilter@icu_56@@6BUnicodeMatcher@1@@
; const	icu_56::UnicodeFilter::`vftable'{for `icu_56::UnicodeMatcher'}
??_7UnicodeFilter@icu_56@@6BUnicodeMatcher@1@@ dd offset ??_EUnicodeFilter@icu_56@@W3AEPAXI@Z
					; DATA XREF: icu_56::UnicodeFilter::UnicodeFilter(void)+42o
					; icu_56::UnicodeFilter::UnicodeFilter(icu_56::UnicodeFilter const &)+6Bo
					; [thunk]:icu_56::UnicodeFilter::`vector deleting destructor'`adjustor{4}' (uint)
		dd offset ?matches@UnicodeFilter@icu_56@@UAE?AW4UMatchDegree@2@ABVReplaceable@2@AAHHC@Z	; icu_56::UnicodeFilter::matches(icu_56::Replaceable const &,int &,int,signed char)
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 478Ch
		dd offset ??_R4UnicodeFilter@icu_56@@6BUnicodeFunctor@1@@ ; const icu_56::UnicodeFilter::`RTTI Complete	Object Locator'{for `icu_56::UnicodeFunctor'}
;
; Exported entry
;
		public ??_7UnicodeFilter@icu_56@@6BUnicodeFunctor@1@@
; const	icu_56::UnicodeFilter::`vftable'{for `icu_56::UnicodeFunctor'}
??_7UnicodeFilter@icu_56@@6BUnicodeFunctor@1@@ dd offset ??_EUnicodeFilter@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::UnicodeFilter::UnicodeFilter(void)+39o
					; icu_56::UnicodeFilter::UnicodeFilter(icu_56::UnicodeFilter const &)+62o
					; icu_56::UnicodeFilter::`vector deleting destructor'(uint)
		dd offset __purecall
		dd offset __purecall
		dd offset ?toMatcher@UnicodeFilter@icu_56@@UBEPAVUnicodeMatcher@2@XZ ; icu_56::UnicodeFilter::toMatcher(void)
		dd offset ?toReplacer@UnicodeFunctor@icu_56@@UBEPAVUnicodeReplacer@2@XZ	; icu_56::UnicodeFunctor::toReplacer(void)
		dd offset ?setData@UnicodeFilter@icu_56@@UAEXPBVTransliterationRuleData@2@@Z ; icu_56::UnicodeFilter::setData(icu_56::TransliterationRuleData const *)
		dd offset __purecall
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 47ACh
		public ??_R4UnicodeFilter@icu_56@@6BUnicodeFunctor@1@@
; const	icu_56::UnicodeFilter::`RTTI Complete Object Locator'{for `icu_56::UnicodeFunctor'}
??_R4UnicodeFilter@icu_56@@6BUnicodeFunctor@1@@	dd 3 dup(0) ; DATA XREF: .rdata:0000478Co
		dd offset ??_R0?AVUnicodeFilter@icu_56@@@8 ; icu_56::UnicodeFilter `RTTI Type Descriptor'
		dd offset ??_R3UnicodeFilter@icu_56@@8 ; icu_56::UnicodeFilter::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 47C0h
		public ??_R0?AVUnicodeFilter@icu_56@@@8
; class	icu_56::UnicodeFilter `RTTI Type Descriptor'
??_R0?AVUnicodeFilter@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:000047B8o
					; .rdata$r:icu_56::UnicodeFilter::`RTTI	Base Class Descriptor at (0,-1,0,64)'o ...
					; const	type_info::`vftable'
		align 8
a_?avunicodefil	db '.?AVUnicodeFilter@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 47E4h
		public ??_R3UnicodeFilter@icu_56@@8
; icu_56::UnicodeFilter::`RTTI Class Hierarchy Descriptor'
??_R3UnicodeFilter@icu_56@@8 dd	0	; DATA XREF: .rdata$r:000047BCo
					; .rdata$r:00004824o ...
		dd 1, 5
		dd offset ??_R2UnicodeFilter@icu_56@@8 ; icu_56::UnicodeFilter::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 47F4h
		public ??_R2UnicodeFilter@icu_56@@8
; icu_56::UnicodeFilter::`RTTI Base Class Array'
??_R2UnicodeFilter@icu_56@@8 dd	offset ??_R1A@?0A@EA@UnicodeFilter@icu_56@@8
					; DATA XREF: .rdata$r:000047F0o
					; icu_56::UnicodeFilter::`RTTI Base Class Descriptor at	(0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UnicodeFunctor@icu_56@@8 ; icu_56::UnicodeFunctor::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		dd offset ??_R13?0A@EA@UnicodeMatcher@icu_56@@8	; icu_56::UnicodeMatcher::`RTTI	Base Class Descriptor at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 480Ch
		public ??_R1A@?0A@EA@UnicodeFilter@icu_56@@8
; icu_56::UnicodeFilter::`RTTI Base Class Descriptor at	(0, -1,	0, 64)'
??_R1A@?0A@EA@UnicodeFilter@icu_56@@8 dd offset	??_R0?AVUnicodeFilter@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UnicodeFilter::`RTTI Base	Class Array'o
					; icu_56::UnicodeFilter	`RTTI Type Descriptor'
		dd 4, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UnicodeFilter@icu_56@@8 ; icu_56::UnicodeFilter::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 4828h
		public ??_R13?0A@EA@UnicodeMatcher@icu_56@@8
; icu_56::UnicodeMatcher::`RTTI	Base Class Descriptor at (4, -1, 0, 64)'
??_R13?0A@EA@UnicodeMatcher@icu_56@@8 dd offset	??_R0?AVUnicodeMatcher@icu_56@@@8
					; DATA XREF: .rdata$r:00004804o
					; icu_56::UnicodeMatcher `RTTI Type Descriptor'
		align 10h
		dd 4, 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UnicodeMatcher@icu_56@@8	; icu_56::UnicodeMatcher::`RTTI	Class Hierarchy	Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 4844h
		public ??_R4UnicodeFilter@icu_56@@6BUnicodeMatcher@1@@
; const	icu_56::UnicodeFilter::`RTTI Complete Object Locator'{for `icu_56::UnicodeMatcher'}
??_R4UnicodeFilter@icu_56@@6BUnicodeMatcher@1@@	dd 0 ; DATA XREF: .rdata:00004774o
		dd 4, 0
		dd offset ??_R0?AVUnicodeFilter@icu_56@@@8 ; icu_56::UnicodeFilter `RTTI Type Descriptor'
		dd offset ??_R3UnicodeFilter@icu_56@@8 ; icu_56::UnicodeFilter::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4858h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UnicodeFilter::UnicodeFilter(icu_56::UnicodeFilter *this, const struct icu_56::UnicodeFilter *)
		public ??0UnicodeFilter@icu_56@@QAE@ABV01@@Z
??0UnicodeFilter@icu_56@@QAE@ABV01@@Z proc near

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeFunctor	*
		mov	ecx, [ebp+var_8] ; this
		call	??0UnicodeFunctor@icu_56@@QAE@ABV01@@Z ; icu_56::UnicodeFunctor::UnicodeFunctor(icu_56::UnicodeFunctor const &)
		cmp	[ebp+arg_0], 0
		jz	short loc_489B
		mov	eax, [ebp+arg_0]
		add	eax, 4
		mov	[ebp+var_D0], eax
		jmp	short loc_48A5
; ---------------------------------------------------------------------------

loc_489B:				; CODE XREF: icu_56::UnicodeFilter::UnicodeFilter(icu_56::UnicodeFilter	const &)+33j
		mov	[ebp+var_D0], 0

loc_48A5:				; CODE XREF: icu_56::UnicodeFilter::UnicodeFilter(icu_56::UnicodeFilter	const &)+41j
		mov	ecx, [ebp+var_D0]
		push	ecx		; struct icu_56::UnicodeMatcher	*
		mov	ecx, [ebp+var_8]
		add	ecx, 4		; this
		call	??0UnicodeMatcher@icu_56@@QAE@ABV01@@Z ; icu_56::UnicodeMatcher::UnicodeMatcher(icu_56::UnicodeMatcher const &)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UnicodeFilter@icu_56@@6BUnicodeFunctor@1@@ ; const icu_56::UnicodeFilter::`vftable'{for `icu_56::UnicodeFunctor'}
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], offset ??_7UnicodeFilter@icu_56@@6BUnicodeMatcher@1@@ ; const icu_56::UnicodeFilter::`vftable'{for `icu_56::UnicodeMatcher'}
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0UnicodeFilter@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 48E4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeFilter &	__thiscall icu_56::UnicodeFilter::operator=(class icu_56::UnicodeFilter	const &)
		public ??4UnicodeFilter@icu_56@@QAEAAV01@ABV01@@Z
??4UnicodeFilter@icu_56@@QAEAAV01@ABV01@@Z proc	near

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??4UnicodeFunctor@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::UnicodeFunctor::operator=(icu_56::UnicodeFunctor const &)
		cmp	[ebp+arg_0], 0
		jz	short loc_4927
		mov	eax, [ebp+arg_0]
		add	eax, 4
		mov	[ebp+var_D0], eax
		jmp	short loc_4931
; ---------------------------------------------------------------------------

loc_4927:				; CODE XREF: icu_56::UnicodeFilter::operator=(icu_56::UnicodeFilter const &)+33j
		mov	[ebp+var_D0], 0

loc_4931:				; CODE XREF: icu_56::UnicodeFilter::operator=(icu_56::UnicodeFilter const &)+41j
		mov	ecx, [ebp+var_D0]
		push	ecx
		mov	ecx, [ebp+var_8]
		add	ecx, 4
		call	??4UnicodeMatcher@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::UnicodeMatcher::operator=(icu_56::UnicodeMatcher const &)
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4UnicodeFilter@icu_56@@QAEAAV01@ABV01@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 495Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UnicodeFilter::`scalar deleting destructor'(unsigned int)
		public ??_GUnicodeFilter@icu_56@@UAEPAXI@Z
??_GUnicodeFilter@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1UnicodeFilter@icu_56@@UAE@XZ	; icu_56::UnicodeFilter::~UnicodeFilter(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_499B
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_499B:				; CODE XREF: icu_56::UnicodeFilter::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GUnicodeFilter@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 49B4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UnicodeFilter::`vector deleting destructor'(unsigned int)
		public ??_EUnicodeFilter@icu_56@@UAEPAXI@Z
??_EUnicodeFilter@icu_56@@UAEPAXI@Z proc near
					; CODE XREF: [thunk]:icu_56::UnicodeFilter::`vector deleting destructor'`adjustor{4}' (uint)+3j
					; DATA XREF: .rdata:const icu_56::UnicodeFilter::`vftable'{for `icu_56::UnicodeFunctor'}o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_4A15
		push	offset ??1UnicodeFilter@icu_56@@UAE@XZ ; icu_56::UnicodeFilter::~UnicodeFilter(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	8
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_4A0D
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_4A0D:				; CODE XREF: icu_56::UnicodeFilter::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_4A34
; ---------------------------------------------------------------------------

loc_4A15:				; CODE XREF: icu_56::UnicodeFilter::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1UnicodeFilter@icu_56@@UAE@XZ	; icu_56::UnicodeFilter::~UnicodeFilter(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_4A31
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_4A31:				; CODE XREF: icu_56::UnicodeFilter::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_4A34:				; CODE XREF: icu_56::UnicodeFilter::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EUnicodeFilter@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4A4Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::UnicodeSet::operator!=(class icu_56::UnicodeSet const &)const
		public ??9UnicodeSet@icu_56@@QBECABV01@@Z
??9UnicodeSet@icu_56@@QBECABV01@@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+1Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9UnicodeSet@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4AA8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeSet::isFrozen(icu_56::UnicodeSet *__hidden this)
		public ?isFrozen@UnicodeSet@icu_56@@QBECXZ
?isFrozen@UnicodeSet@icu_56@@QBECXZ proc near

var_D0		= byte ptr -0D0h
var_CD		= byte ptr -0CDh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+14h], 0
		jnz	short loc_4AE6
		mov	ecx, [ebp+var_8]
		cmp	dword ptr [ecx+2Ch], 0
		jnz	short loc_4AE6
		mov	[ebp+var_CD], 0
		jmp	short loc_4AED
; ---------------------------------------------------------------------------

loc_4AE6:				; CODE XREF: icu_56::UnicodeSet::isFrozen(void)+2Aj
					; icu_56::UnicodeSet::isFrozen(void)+33j
		mov	[ebp+var_CD], 1

loc_4AED:				; CODE XREF: icu_56::UnicodeSet::isFrozen(void)+3Cj
		mov	al, [ebp+var_CD]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isFrozen@UnicodeSet@icu_56@@QBECXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4AFCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeSet::containsSome(icu_56::UnicodeSet *this, int, int)
		public ?containsSome@UnicodeSet@icu_56@@QBECHH@Z
?containsSome@UnicodeSet@icu_56@@QBECHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?containsNone@UnicodeSet@icu_56@@QBECHH@Z ; icu_56::UnicodeSet::containsNone(int,int)
		movsx	edx, al
		test	edx, edx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?containsSome@UnicodeSet@icu_56@@QBECHH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4B50h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeSet::containsSome(icu_56::UnicodeSet *this, const struct icu_56::UnicodeSet *)
		public ?containsSome@UnicodeSet@icu_56@@QBECABV12@@Z
?containsSome@UnicodeSet@icu_56@@QBECABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeSet *
		mov	ecx, [ebp+var_8] ; this
		call	?containsNone@UnicodeSet@icu_56@@QBECABV12@@Z ;	icu_56::UnicodeSet::containsNone(icu_56::UnicodeSet const &)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?containsSome@UnicodeSet@icu_56@@QBECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4BA0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeSet::containsSome(icu_56::UnicodeSet *this, const struct icu_56::UnicodeString *)
		public ?containsSome@UnicodeSet@icu_56@@QBECABVUnicodeString@2@@Z
?containsSome@UnicodeSet@icu_56@@QBECABVUnicodeString@2@@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?containsNone@UnicodeSet@icu_56@@QBECABVUnicodeString@2@@Z ; icu_56::UnicodeSet::containsNone(icu_56::UnicodeString const &)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?containsSome@UnicodeSet@icu_56@@QBECABVUnicodeString@2@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4BF0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeSet::isBogus(icu_56::UnicodeSet *__hidden this)
		public ?isBogus@UnicodeSet@icu_56@@QBECXZ
?isBogus@UnicodeSet@icu_56@@QBECXZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movzx	eax, byte ptr [eax+30h]
		and	eax, 1
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isBogus@UnicodeSet@icu_56@@QBECXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4C24h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeSet *__cdecl icu_56::UnicodeSet::fromUSet(struct USet *)
		public ?fromUSet@UnicodeSet@icu_56@@SAPAV12@PAUUSet@@@Z
?fromUSet@UnicodeSet@icu_56@@SAPAV12@PAUUSet@@@Z proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?fromUSet@UnicodeSet@icu_56@@SAPAV12@PAUUSet@@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4C4Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::UnicodeSet *__cdecl icu_56::UnicodeSet::fromUSet(const struct USet *)
		public ?fromUSet@UnicodeSet@icu_56@@SAPBV12@PBUUSet@@@Z
?fromUSet@UnicodeSet@icu_56@@SAPBV12@PBUUSet@@@Z proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?fromUSet@UnicodeSet@icu_56@@SAPBV12@PBUUSet@@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4C74h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct USet *__thiscall icu_56::UnicodeSet::toUSet(icu_56::UnicodeSet	*__hidden this)
		public ?toUSet@UnicodeSet@icu_56@@QAEPAUUSet@@XZ
?toUSet@UnicodeSet@icu_56@@QAEPAUUSet@@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?toUSet@UnicodeSet@icu_56@@QAEPAUUSet@@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4CA4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct USet *__thiscall	icu_56::UnicodeSet::toUSet(icu_56::UnicodeSet *__hidden	this)
		public ?toUSet@UnicodeSet@icu_56@@QBEPBUUSet@@XZ
?toUSet@UnicodeSet@icu_56@@QBEPBUUSet@@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?toUSet@UnicodeSet@icu_56@@QBEPBUUSet@@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4CD4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: int __thiscall icu_56::UnicodeSet::span(class	icu_56::UnicodeString const &, int, enum  USetSpanCondition)const
		public ?span@UnicodeSet@icu_56@@QBEHABVUnicodeString@2@HW4USetSpanCondition@@@Z
?span@UnicodeSet@icu_56@@QBEHABVUnicodeString@2@HW4USetSpanCondition@@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	[ebp+var_14], eax
		cmp	[ebp+arg_4], 0
		jge	short loc_4D11
		mov	[ebp+arg_4], 0
		jmp	short loc_4D1F
; ---------------------------------------------------------------------------

loc_4D11:				; CODE XREF: icu_56::UnicodeSet::span(icu_56::UnicodeString const &,int,USetSpanCondition)+32j
		mov	eax, [ebp+arg_4]
		cmp	eax, [ebp+var_14]
		jle	short loc_4D1F
		mov	eax, [ebp+var_14]
		mov	[ebp+arg_4], eax

loc_4D1F:				; CODE XREF: icu_56::UnicodeSet::span(icu_56::UnicodeString const &,int,USetSpanCondition)+3Bj
					; icu_56::UnicodeSet::span(icu_56::UnicodeString const &,int,USetSpanCondition)+43j
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+var_14]
		sub	ecx, [ebp+arg_4]
		push	ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ ; icu_56::UnicodeString::getBuffer(void)
		mov	edx, [ebp+arg_4]
		lea	eax, [eax+edx*2]
		push	eax
		mov	ecx, [ebp+var_8]
		call	?span@UnicodeSet@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z ; icu_56::UnicodeSet::span(wchar_t const *,int,USetSpanCondition)
		add	eax, [ebp+arg_4]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?span@UnicodeSet@icu_56@@QBEHABVUnicodeString@2@HW4USetSpanCondition@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4D5Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: int __thiscall icu_56::UnicodeSet::spanBack(class icu_56::UnicodeString const	&, int,	enum  USetSpanCondition)const
		public ?spanBack@UnicodeSet@icu_56@@QBEHABVUnicodeString@2@HW4USetSpanCondition@@@Z
?spanBack@UnicodeSet@icu_56@@QBEHABVUnicodeString@2@HW4USetSpanCondition@@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	[ebp+var_14], eax
		cmp	[ebp+arg_4], 0
		jge	short loc_4D99
		mov	[ebp+arg_4], 0
		jmp	short loc_4DA7
; ---------------------------------------------------------------------------

loc_4D99:				; CODE XREF: icu_56::UnicodeSet::spanBack(icu_56::UnicodeString	const &,int,USetSpanCondition)+32j
		mov	eax, [ebp+arg_4]
		cmp	eax, [ebp+var_14]
		jle	short loc_4DA7
		mov	eax, [ebp+var_14]
		mov	[ebp+arg_4], eax

loc_4DA7:				; CODE XREF: icu_56::UnicodeSet::spanBack(icu_56::UnicodeString	const &,int,USetSpanCondition)+3Bj
					; icu_56::UnicodeSet::spanBack(icu_56::UnicodeString const &,int,USetSpanCondition)+43j
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ ; icu_56::UnicodeString::getBuffer(void)
		push	eax
		mov	ecx, [ebp+var_8]
		call	?spanBack@UnicodeSet@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z ;	icu_56::UnicodeSet::spanBack(wchar_t const *,int,USetSpanCondition)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?spanBack@UnicodeSet@icu_56@@QBEHABVUnicodeString@2@HW4USetSpanCondition@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4DD8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeString __thiscall icu_56::Normalizer2::normalize(class icu_56::UnicodeString const &, enum  UErrorCode &)const
		public ?normalize@Normalizer2@icu_56@@QBE?AVUnicodeString@2@ABV32@AAW4UErrorCode@@@Z
?normalize@Normalizer2@icu_56@@QBE?AVUnicodeString@2@ABV32@AAW4UErrorCode@@@Z proc near

var_130		= byte ptr -130h
var_12C		= dword	ptr -12Ch
var_60		= byte ptr -60h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?normalize@Normalizer2@icu_56@@QBE?AVUnicodeString@2@ABV32@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 124h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_130]
		mov	ecx, 49h ; 'I'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		mov	[ebp+var_12C], 0
		lea	ecx, [ebp+var_60] ; this
		call	??0UnicodeString@icu_56@@QAE@XZ	; icu_56::UnicodeString::UnicodeString(void)
		mov	[ebp+var_4], 1
		mov	esi, esp
		mov	eax, [ebp+arg_8]
		push	eax
		lea	ecx, [ebp+var_60]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+var_18]
		mov	edx, [eax]
		mov	ecx, [ebp+var_18]
		mov	eax, [edx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		lea	eax, [ebp+var_60]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	??0UnicodeString@icu_56@@QAE@$$QAV01@@Z	; icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString &&)
		mov	ecx, [ebp+var_12C]
		or	ecx, 1
		mov	[ebp+var_12C], ecx
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_60] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		mov	eax, [ebp+arg_0]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN9
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 130h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?normalize@Normalizer2@icu_56@@QBE?AVUnicodeString@2@ABV32@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
$LN9		dd 1			; DATA XREF: icu_56::Normalizer2::normalize(icu_56::UnicodeString const	&,UErrorCode &)+AEo
		dd offset $LN8
$LN8		dd 0FFFFFFA0h, 40h	; DATA XREF: .text:00004EC4o
		dd offset $LN6		; "result"
$LN6		db 'result',0           ; DATA XREF: .text:00004ED0o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 4EDCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?normalize@Normalizer2@icu_56@@QBE?AVUnicodeString@2@ABV32@AAW4UErrorCode@@@Z$0	proc near
					; DATA XREF: .xdata$x:00004F38o
		lea	ecx, [ebp-60h]	; this
		jmp	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
__unwindfunclet$?normalize@Normalizer2@icu_56@@QBE?AVUnicodeString@2@ABV32@AAW4UErrorCode@@@Z$0	endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?normalize@Normalizer2@icu_56@@QBE?AVUnicodeString@2@ABV32@AAW4UErrorCode@@@Z$1	proc near
					; DATA XREF: .xdata$x:00004F30o
		mov	eax, [ebp-12Ch]
		and	eax, 1
		jz	$LN5
		and	dword ptr [ebp-12Ch], 0FFFFFFFEh
		mov	ecx, [ebp+8]	; this
		jmp	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
; ---------------------------------------------------------------------------

$LN5:					; CODE XREF: __unwindfunclet$?normalize@Normalizer2@icu_56@@QBE?AVUnicodeString@2@ABV32@AAW4UErrorCode@@@Z$1+9j
		retn
__unwindfunclet$?normalize@Normalizer2@icu_56@@QBE?AVUnicodeString@2@ABV32@AAW4UErrorCode@@@Z$1	endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?normalize@Normalizer2@icu_56@@QBE?AVUnicodeString@2@ABV32@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::Normalizer2::normalize(icu_56::UnicodeString const	&,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-134h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?normalize@Normalizer2@icu_56@@QBE?AVUnicodeString@2@ABV32@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?normalize@Normalizer2@icu_56@@QBE?AVUnicodeString@2@ABV32@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 4F2Ch
__unwindtable$?normalize@Normalizer2@icu_56@@QBE?AVUnicodeString@2@ABV32@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00004F44o
		dd offset __unwindfunclet$?normalize@Normalizer2@icu_56@@QBE?AVUnicodeString@2@ABV32@AAW4UErrorCode@@@Z$1
		align 8
		dd offset __unwindfunclet$?normalize@Normalizer2@icu_56@@QBE?AVUnicodeString@2@ABV32@AAW4UErrorCode@@@Z$0
__ehfuncinfo$?normalize@Normalizer2@icu_56@@QBE?AVUnicodeString@2@ABV32@AAW4UErrorCode@@@Z dd 19930522h, 2
					; DATA XREF: __ehhandler$?normalize@Normalizer2@icu_56@@QBE?AVUnicodeString@2@ABV32@AAW4UErrorCode@@@Z+1Eo
		dd offset __unwindtable$?normalize@Normalizer2@icu_56@@QBE?AVUnicodeString@2@ABV32@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4F60h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::Normalizer2::Normalizer2(icu_56::Normalizer2 *__hidden this)
		public ??0Normalizer2@icu_56@@QAE@XZ
??0Normalizer2@icu_56@@QAE@XZ proc near	; CODE XREF: icu_56::FilteredNormalizer2::FilteredNormalizer2(icu_56::Normalizer2 const	&,icu_56::UnicodeSet const &)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7Normalizer2@icu_56@@6B@ ; const icu_56::Normalizer2::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0Normalizer2@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 4FACh
		dd offset ??_R4Normalizer2@icu_56@@6B@ ; const icu_56::Normalizer2::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7Normalizer2@icu_56@@6B@
; const	icu_56::Normalizer2::`vftable'
??_7Normalizer2@icu_56@@6B@ dd offset ??_ENormalizer2@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::Normalizer2::Normalizer2(void)+2Eo
					; icu_56::Normalizer2::Normalizer2(icu_56::Normalizer2 const &)+32o
					; icu_56::Normalizer2::`vector deleting	destructor'(uint)
		dd offset ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ ;	icu_56::UObject::getDynamicClassID(void)
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
		dd offset ?getRawDecomposition@Normalizer2@icu_56@@UBECHAAVUnicodeString@2@@Z ;	icu_56::Normalizer2::getRawDecomposition(int,icu_56::UnicodeString &)
		dd offset ?composePair@Normalizer2@icu_56@@UBEHHH@Z ; icu_56::Normalizer2::composePair(int,int)
		dd offset ?getCombiningClass@Normalizer2@icu_56@@UBEEH@Z ; icu_56::Normalizer2::getCombiningClass(int)
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 4FECh
		public ??_R4Normalizer2@icu_56@@6B@
; const	icu_56::Normalizer2::`RTTI Complete Object Locator'
??_R4Normalizer2@icu_56@@6B@ dd	3 dup(0) ; DATA	XREF: .rdata:00004FACo
		dd offset ??_R0?AVNormalizer2@icu_56@@@8 ; icu_56::Normalizer2 `RTTI Type Descriptor'
		dd offset ??_R3Normalizer2@icu_56@@8 ; icu_56::Normalizer2::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 5000h
		public ??_R0?AVNormalizer2@icu_56@@@8
; class	icu_56::Normalizer2 `RTTI Type Descriptor'
??_R0?AVNormalizer2@icu_56@@@8 dd offset ??_7type_info@@6B@ ; DATA XREF: .rdata$r:00004FF8o
					; .rdata$r:icu_56::Normalizer2::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 8
a_?avnormalizer	db '.?AVNormalizer2@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 5024h
		public ??_R3Normalizer2@icu_56@@8
; icu_56::Normalizer2::`RTTI Class Hierarchy Descriptor'
??_R3Normalizer2@icu_56@@8 dd 2	dup(0)	; DATA XREF: .rdata$r:00004FFCo
					; .rdata$r:0000505Co
		dd 3
		dd offset ??_R2Normalizer2@icu_56@@8 ; icu_56::Normalizer2::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 5034h
		public ??_R2Normalizer2@icu_56@@8
; icu_56::Normalizer2::`RTTI Base Class	Array'
??_R2Normalizer2@icu_56@@8 dd offset ??_R1A@?0A@EA@Normalizer2@icu_56@@8
					; DATA XREF: .rdata$r:00005030o
					; icu_56::Normalizer2::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 5044h
		public ??_R1A@?0A@EA@Normalizer2@icu_56@@8
; icu_56::Normalizer2::`RTTI Base Class	Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@Normalizer2@icu_56@@8 dd offset ??_R0?AVNormalizer2@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::Normalizer2::`RTTI Base Class Array'o
					; .rdata$r:000052E0o
					; icu_56::Normalizer2 `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3Normalizer2@icu_56@@8 ; icu_56::Normalizer2::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5060h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::Normalizer2::Normalizer2(icu_56::Normalizer2 *this,	const struct icu_56::Normalizer2 *)
		public ??0Normalizer2@icu_56@@QAE@ABV01@@Z
??0Normalizer2@icu_56@@QAE@ABV01@@Z proc near
					; CODE XREF: icu_56::FilteredNormalizer2::FilteredNormalizer2(icu_56::FilteredNormalizer2 const	&)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UObject *
		mov	ecx, [ebp+var_8] ; this
		call	??0UObject@icu_56@@QAE@ABV01@@Z	; icu_56::UObject::UObject(icu_56::UObject const &)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7Normalizer2@icu_56@@6B@ ; const icu_56::Normalizer2::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0Normalizer2@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 50B4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::Normalizer2 & __thiscall icu_56::Normalizer2::operator=(class icu_56::Normalizer2 const	&)
		public ??4Normalizer2@icu_56@@QAEAAV01@ABV01@@Z
??4Normalizer2@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??4UObject@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::UObject::operator=(icu_56::UObject const	&)
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4Normalizer2@icu_56@@QAEAAV01@ABV01@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 50FCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::Normalizer2::`scalar deleting destructor'(unsigned int)
		public ??_GNormalizer2@icu_56@@UAEPAXI@Z
??_GNormalizer2@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1Normalizer2@icu_56@@UAE@XZ ;	icu_56::Normalizer2::~Normalizer2(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_513B
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_513B:				; CODE XREF: icu_56::Normalizer2::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GNormalizer2@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5154h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::Normalizer2::`vector deleting destructor'(unsigned int)
		public ??_ENormalizer2@icu_56@@UAEPAXI@Z
??_ENormalizer2@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::Normalizer2::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_51B5
		push	offset ??1Normalizer2@icu_56@@UAE@XZ ; icu_56::Normalizer2::~Normalizer2(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	4
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_51AD
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_51AD:				; CODE XREF: icu_56::Normalizer2::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_51D4
; ---------------------------------------------------------------------------

loc_51B5:				; CODE XREF: icu_56::Normalizer2::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1Normalizer2@icu_56@@UAE@XZ ;	icu_56::Normalizer2::~Normalizer2(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_51D1
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_51D1:				; CODE XREF: icu_56::Normalizer2::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_51D4:				; CODE XREF: icu_56::Normalizer2::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_ENormalizer2@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 51ECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::FilteredNormalizer2::FilteredNormalizer2(icu_56::FilteredNormalizer2 *this,	const struct icu_56::Normalizer2 *, const struct icu_56::UnicodeSet *)
		public ??0FilteredNormalizer2@icu_56@@QAE@ABVNormalizer2@1@ABVUnicodeSet@1@@Z
??0FilteredNormalizer2@icu_56@@QAE@ABVNormalizer2@1@ABVUnicodeSet@1@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??0Normalizer2@icu_56@@QAE@XZ ;	icu_56::Normalizer2::Normalizer2(void)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7FilteredNormalizer2@icu_56@@6B@ ; const icu_56::FilteredNormalizer2::`vftable'
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+4], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		mov	[eax+8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??0FilteredNormalizer2@icu_56@@QAE@ABVNormalizer2@1@ABVUnicodeSet@1@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 524Ch
		dd offset ??_R4FilteredNormalizer2@icu_56@@6B@ ; const icu_56::FilteredNormalizer2::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7FilteredNormalizer2@icu_56@@6B@
; const	icu_56::FilteredNormalizer2::`vftable'
??_7FilteredNormalizer2@icu_56@@6B@ dd offset ??_EFilteredNormalizer2@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::FilteredNormalizer2::FilteredNormalizer2(icu_56::Normalizer2 const	&,icu_56::UnicodeSet const &)+2Eo
					; icu_56::FilteredNormalizer2::FilteredNormalizer2(icu_56::FilteredNormalizer2 const &)+32o
					; icu_56::FilteredNormalizer2::`vector deleting	destructor'(uint)
		dd offset ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ ;	icu_56::UObject::getDynamicClassID(void)
		dd offset ?normalize@FilteredNormalizer2@icu_56@@UBEAAVUnicodeString@2@ABV32@AAV32@AAW4UErrorCode@@@Z ;	icu_56::FilteredNormalizer2::normalize(icu_56::UnicodeString const &,icu_56::UnicodeString &,UErrorCode	&)
		dd offset ?normalizeSecondAndAppend@FilteredNormalizer2@icu_56@@UBEAAVUnicodeString@2@AAV32@ABV32@AAW4UErrorCode@@@Z ; icu_56::FilteredNormalizer2::normalizeSecondAndAppend(icu_56::UnicodeString &,icu_56::UnicodeString const &,UErrorCode &)
		dd offset ?append@FilteredNormalizer2@icu_56@@UBEAAVUnicodeString@2@AAV32@ABV32@AAW4UErrorCode@@@Z ; icu_56::FilteredNormalizer2::append(icu_56::UnicodeString &,icu_56::UnicodeString const &,UErrorCode &)
		dd offset ?getDecomposition@FilteredNormalizer2@icu_56@@UBECHAAVUnicodeString@2@@Z ; icu_56::FilteredNormalizer2::getDecomposition(int,icu_56::UnicodeString &)
		dd offset ?getRawDecomposition@FilteredNormalizer2@icu_56@@UBECHAAVUnicodeString@2@@Z ;	icu_56::FilteredNormalizer2::getRawDecomposition(int,icu_56::UnicodeString &)
		dd offset ?composePair@FilteredNormalizer2@icu_56@@UBEHHH@Z ; icu_56::FilteredNormalizer2::composePair(int,int)
		dd offset ?getCombiningClass@FilteredNormalizer2@icu_56@@UBEEH@Z ; icu_56::FilteredNormalizer2::getCombiningClass(int)
		dd offset ?isNormalized@FilteredNormalizer2@icu_56@@UBECABVUnicodeString@2@AAW4UErrorCode@@@Z ;	icu_56::FilteredNormalizer2::isNormalized(icu_56::UnicodeString	const &,UErrorCode &)
		dd offset ?quickCheck@FilteredNormalizer2@icu_56@@UBE?AW4UNormalizationCheckResult@@ABVUnicodeString@2@AAW4UErrorCode@@@Z ; icu_56::FilteredNormalizer2::quickCheck(icu_56::UnicodeString const	&,UErrorCode &)
		dd offset ?spanQuickCheckYes@FilteredNormalizer2@icu_56@@UBEHABVUnicodeString@2@AAW4UErrorCode@@@Z ; icu_56::FilteredNormalizer2::spanQuickCheckYes(icu_56::UnicodeString const	&,UErrorCode &)
		dd offset ?hasBoundaryBefore@FilteredNormalizer2@icu_56@@UBECH@Z ; icu_56::FilteredNormalizer2::hasBoundaryBefore(int)
		dd offset ?hasBoundaryAfter@FilteredNormalizer2@icu_56@@UBECH@Z	; icu_56::FilteredNormalizer2::hasBoundaryAfter(int)
		dd offset ?isInert@FilteredNormalizer2@icu_56@@UBECH@Z ; icu_56::FilteredNormalizer2::isInert(int)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 528Ch
		public ??_R4FilteredNormalizer2@icu_56@@6B@
; const	icu_56::FilteredNormalizer2::`RTTI Complete Object Locator'
??_R4FilteredNormalizer2@icu_56@@6B@ dd	3 dup(0) ; DATA	XREF: .rdata:0000524Co
		dd offset ??_R0?AVFilteredNormalizer2@icu_56@@@8 ; icu_56::FilteredNormalizer2 `RTTI Type Descriptor'
		dd offset ??_R3FilteredNormalizer2@icu_56@@8 ; icu_56::FilteredNormalizer2::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 52A0h
		public ??_R0?AVFilteredNormalizer2@icu_56@@@8
; class	icu_56::FilteredNormalizer2 `RTTI Type Descriptor'
??_R0?AVFilteredNormalizer2@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:00005298o
					; .rdata$r:icu_56::FilteredNormalizer2::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 8
a_?avfilteredno	db '.?AVFilteredNormalizer2@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 52CCh
		public ??_R3FilteredNormalizer2@icu_56@@8
; icu_56::FilteredNormalizer2::`RTTI Class Hierarchy Descriptor'
??_R3FilteredNormalizer2@icu_56@@8 dd 2	dup(0) ; DATA XREF: .rdata$r:0000529Co
					; .rdata$r:00005308o
		dd 4
		dd offset ??_R2FilteredNormalizer2@icu_56@@8 ; icu_56::FilteredNormalizer2::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 52DCh
		public ??_R2FilteredNormalizer2@icu_56@@8
; icu_56::FilteredNormalizer2::`RTTI Base Class	Array'
??_R2FilteredNormalizer2@icu_56@@8 dd offset ??_R1A@?0A@EA@FilteredNormalizer2@icu_56@@8
					; DATA XREF: .rdata$r:000052D8o
					; icu_56::FilteredNormalizer2::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@Normalizer2@icu_56@@8 ;	icu_56::Normalizer2::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 52F0h
		public ??_R1A@?0A@EA@FilteredNormalizer2@icu_56@@8
; icu_56::FilteredNormalizer2::`RTTI Base Class	Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@FilteredNormalizer2@icu_56@@8 dd offset ??_R0?AVFilteredNormalizer2@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::FilteredNormalizer2::`RTTI Base Class Array'o
					; icu_56::FilteredNormalizer2 `RTTI Type Descriptor'
		dd 3, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3FilteredNormalizer2@icu_56@@8 ; icu_56::FilteredNormalizer2::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 530Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::FilteredNormalizer2::FilteredNormalizer2(icu_56::FilteredNormalizer2 *this,	const struct icu_56::FilteredNormalizer2 *)
		public ??0FilteredNormalizer2@icu_56@@QAE@ABV01@@Z
??0FilteredNormalizer2@icu_56@@QAE@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::Normalizer2 *
		mov	ecx, [ebp+var_8] ; this
		call	??0Normalizer2@icu_56@@QAE@ABV01@@Z ; icu_56::Normalizer2::Normalizer2(icu_56::Normalizer2 const &)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7FilteredNormalizer2@icu_56@@6B@ ; const icu_56::FilteredNormalizer2::`vftable'
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	[eax+4], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+8]
		mov	[eax+8], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0FilteredNormalizer2@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5378h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::FilteredNormalizer2::`scalar deleting destructor'(unsigned int)
		public ??_GFilteredNormalizer2@icu_56@@UAEPAXI@Z
??_GFilteredNormalizer2@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1FilteredNormalizer2@icu_56@@UAE@XZ ;	icu_56::FilteredNormalizer2::~FilteredNormalizer2(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_53B7
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_53B7:				; CODE XREF: icu_56::FilteredNormalizer2::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GFilteredNormalizer2@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 53D0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::FilteredNormalizer2::`vector deleting destructor'(unsigned int)
		public ??_EFilteredNormalizer2@icu_56@@UAEPAXI@Z
??_EFilteredNormalizer2@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::FilteredNormalizer2::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_5431
		push	offset ??1FilteredNormalizer2@icu_56@@UAE@XZ ; icu_56::FilteredNormalizer2::~FilteredNormalizer2(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	0Ch
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_5429
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_5429:				; CODE XREF: icu_56::FilteredNormalizer2::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_5450
; ---------------------------------------------------------------------------

loc_5431:				; CODE XREF: icu_56::FilteredNormalizer2::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1FilteredNormalizer2@icu_56@@UAE@XZ ;	icu_56::FilteredNormalizer2::~FilteredNormalizer2(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_544D
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_544D:				; CODE XREF: icu_56::FilteredNormalizer2::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_5450:				; CODE XREF: icu_56::FilteredNormalizer2::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EFilteredNormalizer2@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5468h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::IDNA::~IDNA(icu_56::IDNA *__hidden this)
		public ??1IDNA@icu_56@@UAE@XZ
??1IDNA@icu_56@@UAE@XZ proc near	; CODE XREF: icu_56::IDNA::`scalar deleting destructor'(uint)+26p
					; icu_56::IDNA::`vector	deleting destructor'(uint)+64p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7IDNA@icu_56@@6B@ ; const icu_56::IDNA::`vftable'
		mov	ecx, [ebp+var_8] ; this
		call	??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1IDNA@icu_56@@UAE@XZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 54B0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::IDNA::labelToASCII_UTF8(icu_56::IDNA *this, const struct icu_56::StringPiece *, struct icu_56::ByteSink *, struct icu_56::IDNAInfo *,	enum UErrorCode	*)
		public ?labelToASCII_UTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z
?labelToASCII_UTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z proc near
					; DATA XREF: .rdata:00003F1Co

var_174		= dword	ptr -174h
var_170		= dword	ptr -170h
var_168		= byte ptr -168h
var_60		= byte ptr -60h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?labelToASCII_UTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 168h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_174]
		mov	ecx, 5Ah ; 'Z'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax		; struct icu_56::ByteSink *
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	loc_5598
		lea	ecx, [ebp+var_60] ; this
		call	??0UnicodeString@icu_56@@QAE@XZ	; icu_56::UnicodeString::UnicodeString(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+arg_4]
		push	eax		; struct icu_56::ByteSink *
		mov	esi, esp
		mov	ecx, [ebp+arg_C]
		push	ecx
		mov	edx, [ebp+arg_8]
		push	edx
		lea	eax, [ebp+var_60]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		lea	edx, [ebp+var_168]
		push	edx
		call	?fromUTF8@UnicodeString@icu_56@@SA?AV12@ABVStringPiece@2@@Z ; icu_56::UnicodeString::fromUTF8(icu_56::StringPiece const	&)
		add	esp, 8
		mov	[ebp+var_170], eax
		mov	eax, [ebp+var_170]
		mov	[ebp+var_174], eax
		mov	byte ptr [ebp+var_4], 1
		mov	ecx, [ebp+var_174]
		push	ecx
		mov	edx, [ebp+var_18]
		mov	eax, [edx]
		mov	ecx, [ebp+var_18]
		mov	edx, [eax+8]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, eax	; this
		call	?toUTF8@UnicodeString@icu_56@@QBEXAAVByteSink@2@@Z ; icu_56::UnicodeString::toUTF8(icu_56::ByteSink &)
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_168] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_60] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)

loc_5598:				; CODE XREF: icu_56::IDNA::labelToASCII_UTF8(icu_56::StringPiece const &,icu_56::ByteSink &,icu_56::IDNAInfo &,UErrorCode &)+58j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN9_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 174h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?labelToASCII_UTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
$LN9_0		dd 1			; DATA XREF: icu_56::IDNA::labelToASCII_UTF8(icu_56::StringPiece const &,icu_56::ByteSink &,icu_56::IDNAInfo &,UErrorCode &)+ECo
		dd offset $LN8_0
$LN8_0		dd 0FFFFFFA0h, 40h	; DATA XREF: .text:000055D8o
		dd offset $LN6_0	; "destString"
$LN6_0		db 'destString',0       ; DATA XREF: .text:000055E4o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 55F4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?labelToASCII_UTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:00005634o
		lea	ecx, [ebp-60h]	; this
		jmp	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
__unwindfunclet$?labelToASCII_UTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?labelToASCII_UTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z$1 proc near
					; DATA XREF: .xdata$x:0000563Co
		lea	ecx, [ebp-168h]	; this
		jmp	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
__unwindfunclet$?labelToASCII_UTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?labelToASCII_UTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z	proc near
					; DATA XREF: icu_56::IDNA::labelToASCII_UTF8(icu_56::StringPiece const &,icu_56::ByteSink &,icu_56::IDNAInfo &,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-178h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?labelToASCII_UTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?labelToASCII_UTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 5630h
__unwindtable$?labelToASCII_UTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00005648o
		dd offset __unwindfunclet$?labelToASCII_UTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z$0
		dd 0
		dd offset __unwindfunclet$?labelToASCII_UTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z$1
__ehfuncinfo$?labelToASCII_UTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z dd 19930522h, 2
					; DATA XREF: __ehhandler$?labelToASCII_UTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z+1Eo
		dd offset __unwindtable$?labelToASCII_UTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z
		align 20h
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5664h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl U_SUCCESS(enum  UErrorCode)
?U_SUCCESS@@YACW4UErrorCode@@@Z	proc near
					; CODE XREF: icu_56::IDNA::labelToASCII_UTF8(icu_56::StringPiece const &,icu_56::ByteSink &,icu_56::IDNAInfo &,UErrorCode &)+4Bp
					; icu_56::IDNA::labelToUnicodeUTF8(icu_56::StringPiece const &,icu_56::ByteSink	&,icu_56::IDNAInfo &,UErrorCode	&)+4Bp	...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		setle	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?U_SUCCESS@@YACW4UErrorCode@@@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5690h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::IDNA::labelToUnicodeUTF8(icu_56::IDNA	*this, const struct icu_56::StringPiece	*, struct icu_56::ByteSink *, struct icu_56::IDNAInfo *, enum UErrorCode *)
		public ?labelToUnicodeUTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z
?labelToUnicodeUTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z proc near
					; DATA XREF: .rdata:00003F20o

var_174		= dword	ptr -174h
var_170		= dword	ptr -170h
var_168		= byte ptr -168h
var_60		= byte ptr -60h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?labelToUnicodeUTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 168h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_174]
		mov	ecx, 5Ah ; 'Z'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax		; struct icu_56::ByteSink *
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	loc_5778
		lea	ecx, [ebp+var_60] ; this
		call	??0UnicodeString@icu_56@@QAE@XZ	; icu_56::UnicodeString::UnicodeString(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+arg_4]
		push	eax		; struct icu_56::ByteSink *
		mov	esi, esp
		mov	ecx, [ebp+arg_C]
		push	ecx
		mov	edx, [ebp+arg_8]
		push	edx
		lea	eax, [ebp+var_60]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		lea	edx, [ebp+var_168]
		push	edx
		call	?fromUTF8@UnicodeString@icu_56@@SA?AV12@ABVStringPiece@2@@Z ; icu_56::UnicodeString::fromUTF8(icu_56::StringPiece const	&)
		add	esp, 8
		mov	[ebp+var_170], eax
		mov	eax, [ebp+var_170]
		mov	[ebp+var_174], eax
		mov	byte ptr [ebp+var_4], 1
		mov	ecx, [ebp+var_174]
		push	ecx
		mov	edx, [ebp+var_18]
		mov	eax, [edx]
		mov	ecx, [ebp+var_18]
		mov	edx, [eax+0Ch]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, eax	; this
		call	?toUTF8@UnicodeString@icu_56@@QBEXAAVByteSink@2@@Z ; icu_56::UnicodeString::toUTF8(icu_56::ByteSink &)
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_168] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_60] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)

loc_5778:				; CODE XREF: icu_56::IDNA::labelToUnicodeUTF8(icu_56::StringPiece const	&,icu_56::ByteSink &,icu_56::IDNAInfo &,UErrorCode &)+58j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN9_1
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 174h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?labelToUnicodeUTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
$LN9_1		dd 1			; DATA XREF: icu_56::IDNA::labelToUnicodeUTF8(icu_56::StringPiece const	&,icu_56::ByteSink &,icu_56::IDNAInfo &,UErrorCode &)+ECo
		dd offset $LN8_1
$LN8_1		dd 0FFFFFFA0h, 40h	; DATA XREF: .text:000057B8o
		dd offset $LN6_1	; "destString"
$LN6_1		db 'destString',0       ; DATA XREF: .text:000057C4o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 57D4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?labelToUnicodeUTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:00005814o
		lea	ecx, [ebp-60h]	; this
		jmp	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
__unwindfunclet$?labelToUnicodeUTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?labelToUnicodeUTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z$1 proc near
					; DATA XREF: .xdata$x:0000581Co
		lea	ecx, [ebp-168h]	; this
		jmp	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
__unwindfunclet$?labelToUnicodeUTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?labelToUnicodeUTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::IDNA::labelToUnicodeUTF8(icu_56::StringPiece const	&,icu_56::ByteSink &,icu_56::IDNAInfo &,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-178h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?labelToUnicodeUTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?labelToUnicodeUTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 5810h
__unwindtable$?labelToUnicodeUTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00005828o
		dd offset __unwindfunclet$?labelToUnicodeUTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z$0
		dd 0
		dd offset __unwindfunclet$?labelToUnicodeUTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z$1
__ehfuncinfo$?labelToUnicodeUTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z dd 19930522h,	2
					; DATA XREF: __ehhandler$?labelToUnicodeUTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z+1Eo
		dd offset __unwindtable$?labelToUnicodeUTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z
		align 20h
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5844h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::IDNA::nameToASCII_UTF8(icu_56::IDNA *this, const struct icu_56::StringPiece *, struct	icu_56::ByteSink *, struct icu_56::IDNAInfo *, enum UErrorCode *)
		public ?nameToASCII_UTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z
?nameToASCII_UTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z proc	near
					; DATA XREF: .rdata:00003F24o

var_174		= dword	ptr -174h
var_170		= dword	ptr -170h
var_168		= byte ptr -168h
var_60		= byte ptr -60h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?nameToASCII_UTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 168h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_174]
		mov	ecx, 5Ah ; 'Z'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax		; struct icu_56::ByteSink *
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	loc_592C
		lea	ecx, [ebp+var_60] ; this
		call	??0UnicodeString@icu_56@@QAE@XZ	; icu_56::UnicodeString::UnicodeString(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+arg_4]
		push	eax		; struct icu_56::ByteSink *
		mov	esi, esp
		mov	ecx, [ebp+arg_C]
		push	ecx
		mov	edx, [ebp+arg_8]
		push	edx
		lea	eax, [ebp+var_60]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		lea	edx, [ebp+var_168]
		push	edx
		call	?fromUTF8@UnicodeString@icu_56@@SA?AV12@ABVStringPiece@2@@Z ; icu_56::UnicodeString::fromUTF8(icu_56::StringPiece const	&)
		add	esp, 8
		mov	[ebp+var_170], eax
		mov	eax, [ebp+var_170]
		mov	[ebp+var_174], eax
		mov	byte ptr [ebp+var_4], 1
		mov	ecx, [ebp+var_174]
		push	ecx
		mov	edx, [ebp+var_18]
		mov	eax, [edx]
		mov	ecx, [ebp+var_18]
		mov	edx, [eax+10h]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, eax	; this
		call	?toUTF8@UnicodeString@icu_56@@QBEXAAVByteSink@2@@Z ; icu_56::UnicodeString::toUTF8(icu_56::ByteSink &)
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_168] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_60] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)

loc_592C:				; CODE XREF: icu_56::IDNA::nameToASCII_UTF8(icu_56::StringPiece	const &,icu_56::ByteSink &,icu_56::IDNAInfo &,UErrorCode &)+58j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN9_2
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 174h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?nameToASCII_UTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
$LN9_2		dd 1			; DATA XREF: icu_56::IDNA::nameToASCII_UTF8(icu_56::StringPiece	const &,icu_56::ByteSink &,icu_56::IDNAInfo &,UErrorCode &)+ECo
		dd offset $LN8_2
$LN8_2		dd 0FFFFFFA0h, 40h	; DATA XREF: .text:0000596Co
		dd offset $LN6_2	; "destString"
$LN6_2		db 'destString',0       ; DATA XREF: .text:00005978o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 5988h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?nameToASCII_UTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:000059C8o
		lea	ecx, [ebp-60h]	; this
		jmp	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
__unwindfunclet$?nameToASCII_UTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?nameToASCII_UTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z$1 proc near
					; DATA XREF: .xdata$x:000059D0o
		lea	ecx, [ebp-168h]	; this
		jmp	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
__unwindfunclet$?nameToASCII_UTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?nameToASCII_UTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::IDNA::nameToASCII_UTF8(icu_56::StringPiece	const &,icu_56::ByteSink &,icu_56::IDNAInfo &,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-178h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?nameToASCII_UTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?nameToASCII_UTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 59C4h
__unwindtable$?nameToASCII_UTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000059DCo
		dd offset __unwindfunclet$?nameToASCII_UTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z$0
		align 10h
		dd offset __unwindfunclet$?nameToASCII_UTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z$1
__ehfuncinfo$?nameToASCII_UTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z	dd 19930522h, 2
					; DATA XREF: __ehhandler$?nameToASCII_UTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z+1Eo
		dd offset __unwindtable$?nameToASCII_UTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 59F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::IDNA::nameToUnicodeUTF8(icu_56::IDNA *this, const struct icu_56::StringPiece *, struct icu_56::ByteSink *, struct icu_56::IDNAInfo *,	enum UErrorCode	*)
		public ?nameToUnicodeUTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z
?nameToUnicodeUTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z proc near
					; DATA XREF: .rdata:00003F28o

var_174		= dword	ptr -174h
var_170		= dword	ptr -170h
var_168		= byte ptr -168h
var_60		= byte ptr -60h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?nameToUnicodeUTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 168h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_174]
		mov	ecx, 5Ah ; 'Z'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax		; struct icu_56::ByteSink *
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	loc_5AE0
		lea	ecx, [ebp+var_60] ; this
		call	??0UnicodeString@icu_56@@QAE@XZ	; icu_56::UnicodeString::UnicodeString(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+arg_4]
		push	eax		; struct icu_56::ByteSink *
		mov	esi, esp
		mov	ecx, [ebp+arg_C]
		push	ecx
		mov	edx, [ebp+arg_8]
		push	edx
		lea	eax, [ebp+var_60]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		lea	edx, [ebp+var_168]
		push	edx
		call	?fromUTF8@UnicodeString@icu_56@@SA?AV12@ABVStringPiece@2@@Z ; icu_56::UnicodeString::fromUTF8(icu_56::StringPiece const	&)
		add	esp, 8
		mov	[ebp+var_170], eax
		mov	eax, [ebp+var_170]
		mov	[ebp+var_174], eax
		mov	byte ptr [ebp+var_4], 1
		mov	ecx, [ebp+var_174]
		push	ecx
		mov	edx, [ebp+var_18]
		mov	eax, [edx]
		mov	ecx, [ebp+var_18]
		mov	edx, [eax+14h]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, eax	; this
		call	?toUTF8@UnicodeString@icu_56@@QBEXAAVByteSink@2@@Z ; icu_56::UnicodeString::toUTF8(icu_56::ByteSink &)
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_168] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_60] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)

loc_5AE0:				; CODE XREF: icu_56::IDNA::nameToUnicodeUTF8(icu_56::StringPiece const &,icu_56::ByteSink &,icu_56::IDNAInfo &,UErrorCode &)+58j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN9_3
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 174h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?nameToUnicodeUTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
$LN9_3		dd 1			; DATA XREF: icu_56::IDNA::nameToUnicodeUTF8(icu_56::StringPiece const &,icu_56::ByteSink &,icu_56::IDNAInfo &,UErrorCode &)+ECo
		dd offset $LN8_3
$LN8_3		dd 0FFFFFFA0h, 40h	; DATA XREF: .text:00005B20o
		dd offset $LN6_3	; "destString"
$LN6_3		db 'destString',0       ; DATA XREF: .text:00005B2Co
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 5B3Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?nameToUnicodeUTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:00005B7Co
		lea	ecx, [ebp-60h]	; this
		jmp	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
__unwindfunclet$?nameToUnicodeUTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?nameToUnicodeUTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z$1 proc near
					; DATA XREF: .xdata$x:00005B84o
		lea	ecx, [ebp-168h]	; this
		jmp	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
__unwindfunclet$?nameToUnicodeUTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?nameToUnicodeUTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z	proc near
					; DATA XREF: icu_56::IDNA::nameToUnicodeUTF8(icu_56::StringPiece const &,icu_56::ByteSink &,icu_56::IDNAInfo &,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-178h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?nameToUnicodeUTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?nameToUnicodeUTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 5B78h
__unwindtable$?nameToUnicodeUTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00005B90o
		dd offset __unwindfunclet$?nameToUnicodeUTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z$0
		dd 0
		dd offset __unwindfunclet$?nameToUnicodeUTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z$1
__ehfuncinfo$?nameToUnicodeUTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z dd 19930522h, 2
					; DATA XREF: __ehhandler$?nameToUnicodeUTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z+1Eo
		dd offset __unwindtable$?nameToUnicodeUTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5BACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::IDNA *__cdecl icu_56::IDNA::createUTS46Instance(unsigned int, enum UErrorCode *)
		public ?createUTS46Instance@IDNA@icu_56@@SAPAV12@IAAW4UErrorCode@@@Z
?createUTS46Instance@IDNA@icu_56@@SAPAV12@IAAW4UErrorCode@@@Z proc near
					; CODE XREF: _uidna_openUTS46_56+26p

var_10C		= dword	ptr -10Ch
var_104		= dword	ptr -104h
var_F8		= dword	ptr -0F8h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?createUTS46Instance@IDNA@icu_56@@SAPAV12@IAAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 100h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_10C]
		mov	ecx, 40h ; '@'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	loc_5CE4
		push	0Ch		; unsigned int
		call	??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator	new(uint)
		add	esp, 4
		mov	[ebp+var_F8], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_F8], 0
		jz	short loc_5C3D
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; unsigned int
		mov	ecx, [ebp+var_F8] ; this
		call	??0UTS46@icu_56@@QAE@IAAW4UErrorCode@@@Z ; icu_56::UTS46::UTS46(uint,UErrorCode	&)
		mov	[ebp+var_10C], eax
		jmp	short loc_5C47
; ---------------------------------------------------------------------------

loc_5C3D:				; CODE XREF: icu_56::IDNA::createUTS46Instance(uint,UErrorCode &)+74j
		mov	[ebp+var_10C], 0

loc_5C47:				; CODE XREF: icu_56::IDNA::createUTS46Instance(uint,UErrorCode &)+8Fj
		mov	edx, [ebp+var_10C]
		mov	[ebp+var_104], edx
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_104]
		mov	[ebp+var_14], eax
		cmp	[ebp+var_14], 0
		jnz	short loc_5C74
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 7
		jmp	short loc_5CDD
; ---------------------------------------------------------------------------

loc_5C74:				; CODE XREF: icu_56::IDNA::createUTS46Instance(uint,UErrorCode &)+BBj
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_5CDD
		mov	eax, [ebp+var_14]
		mov	[ebp+var_E0], eax
		mov	ecx, [ebp+var_E0]
		mov	[ebp+var_EC], ecx
		cmp	[ebp+var_EC], 0
		jz	short loc_5CCC
		mov	esi, esp
		push	1
		mov	edx, [ebp+var_EC]
		mov	eax, [edx]
		mov	ecx, [ebp+var_EC]
		mov	edx, [eax]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_10C], eax
		jmp	short loc_5CD6
; ---------------------------------------------------------------------------

loc_5CCC:				; CODE XREF: icu_56::IDNA::createUTS46Instance(uint,UErrorCode &)+F9j
		mov	[ebp+var_10C], 0

loc_5CD6:				; CODE XREF: icu_56::IDNA::createUTS46Instance(uint,UErrorCode &)+11Ej
		mov	[ebp+var_14], 0

loc_5CDD:				; CODE XREF: icu_56::IDNA::createUTS46Instance(uint,UErrorCode &)+C6j
					; icu_56::IDNA::createUTS46Instance(uint,UErrorCode &)+DBj
		mov	eax, [ebp+var_14]
		jmp	short loc_5CE6
; ---------------------------------------------------------------------------
		jmp	short loc_5CE6
; ---------------------------------------------------------------------------

loc_5CE4:				; CODE XREF: icu_56::IDNA::createUTS46Instance(uint,UErrorCode &)+50j
		xor	eax, eax

loc_5CE6:				; CODE XREF: icu_56::IDNA::createUTS46Instance(uint,UErrorCode &)+134j
					; icu_56::IDNA::createUTS46Instance(uint,UErrorCode &)+136j
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 10Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?createUTS46Instance@IDNA@icu_56@@SAPAV12@IAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 5D08h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?createUTS46Instance@IDNA@icu_56@@SAPAV12@IAAW4UErrorCode@@@Z$0	proc near
					; DATA XREF: .xdata$x:00005D38o
		mov	eax, [ebp-0F8h]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		pop	ecx
		retn
__unwindfunclet$?createUTS46Instance@IDNA@icu_56@@SAPAV12@IAAW4UErrorCode@@@Z$0	endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?createUTS46Instance@IDNA@icu_56@@SAPAV12@IAAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::IDNA::createUTS46Instance(uint,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-110h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?createUTS46Instance@IDNA@icu_56@@SAPAV12@IAAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?createUTS46Instance@IDNA@icu_56@@SAPAV12@IAAW4UErrorCode@@@Z endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 5D34h
__unwindtable$?createUTS46Instance@IDNA@icu_56@@SAPAV12@IAAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00005D44o
		dd offset __unwindfunclet$?createUTS46Instance@IDNA@icu_56@@SAPAV12@IAAW4UErrorCode@@@Z$0
__ehfuncinfo$?createUTS46Instance@IDNA@icu_56@@SAPAV12@IAAW4UErrorCode@@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$?createUTS46Instance@IDNA@icu_56@@SAPAV12@IAAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$?createUTS46Instance@IDNA@icu_56@@SAPAV12@IAAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5D60h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl U_FAILURE(enum  UErrorCode)
?U_FAILURE@@YACW4UErrorCode@@@Z	proc near
					; CODE XREF: icu_56::IDNA::createUTS46Instance(uint,UErrorCode &)+CEp
					; icu_56::UTS46::process(icu_56::UnicodeString const &,signed char,signed char,icu_56::UnicodeString &,icu_56::IDNAInfo	&,UErrorCode &)+29p ...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		setnle	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?U_FAILURE@@YACW4UErrorCode@@@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5D8Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UTS46::UTS46(icu_56::UTS46 *this, unsigned int, enum UErrorCode *)
		public ??0UTS46@icu_56@@QAE@IAAW4UErrorCode@@@Z
??0UTS46@icu_56@@QAE@IAAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::IDNA::createUTS46Instance(uint,UErrorCode &)+84p

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0UTS46@icu_56@@QAE@IAAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	ecx, [ebp+var_14] ; this
		call	??0IDNA@icu_56@@QAE@XZ ; icu_56::IDNA::IDNA(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7UTS46@icu_56@@6B@ ;	const icu_56::UTS46::`vftable'
		mov	eax, [ebp+arg_4]
		push	eax
		push	0
		push	offset ??_C@_05MKHEFHGK@uts46?$AA@ ; "uts46"
		push	0
		call	?getInstance@Normalizer2@icu_56@@SAPBV12@PBD0W4UNormalization2Mode@@AAW4UErrorCode@@@Z ; icu_56::Normalizer2::getInstance(char const *,char const *,UNormalization2Mode,UErrorCode &)
		add	esp, 10h
		mov	ecx, [ebp+var_14]
		mov	[ecx+4], eax
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	[eax+8], ecx
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??0UTS46@icu_56@@QAE@IAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 5E38h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0UTS46@icu_56@@QAE@IAAW4UErrorCode@@@Z$0 proc	near
					; DATA XREF: .xdata$x:00005E98o
		mov	ecx, [ebp-14h]	; this
		jmp	??1IDNA@icu_56@@UAE@XZ ; icu_56::IDNA::~IDNA(void)
__unwindfunclet$??0UTS46@icu_56@@QAE@IAAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0UTS46@icu_56@@QAE@IAAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::UTS46::UTS46(uint,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0UTS46@icu_56@@QAE@IAAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0UTS46@icu_56@@QAE@IAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5E60h
		public ??_C@_05MKHEFHGK@uts46?$AA@
; `string'
??_C@_05MKHEFHGK@uts46?$AA@ db 'uts46',0
					; DATA XREF: icu_56::UTS46::UTS46(uint,UErrorCode &)+60o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5E68h
		dd offset ??_R4UTS46@icu_56@@6B@ ; const icu_56::UTS46::`RTTI Complete Object Locator'
		public ??_7UTS46@icu_56@@6B@
; const	icu_56::UTS46::`vftable'
??_7UTS46@icu_56@@6B@ dd offset	??_EUTS46@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::UTS46::UTS46(uint,UErrorCode &)+54o
					; icu_56::UTS46::~UTS46(void)+26o
					; icu_56::UTS46::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ ;	icu_56::UObject::getDynamicClassID(void)
		dd offset ?labelToASCII@UTS46@icu_56@@UBEAAVUnicodeString@2@ABV32@AAV32@AAVIDNAInfo@2@AAW4UErrorCode@@@Z ; icu_56::UTS46::labelToASCII(icu_56::UnicodeString const &,icu_56::UnicodeString &,icu_56::IDNAInfo &,UErrorCode &)
		dd offset ?labelToUnicode@UTS46@icu_56@@UBEAAVUnicodeString@2@ABV32@AAV32@AAVIDNAInfo@2@AAW4UErrorCode@@@Z ; icu_56::UTS46::labelToUnicode(icu_56::UnicodeString const &,icu_56::UnicodeString &,icu_56::IDNAInfo &,UErrorCode &)
		dd offset ?nameToASCII@UTS46@icu_56@@UBEAAVUnicodeString@2@ABV32@AAV32@AAVIDNAInfo@2@AAW4UErrorCode@@@Z	; icu_56::UTS46::nameToASCII(icu_56::UnicodeString const &,icu_56::UnicodeString &,icu_56::IDNAInfo &,UErrorCode &)
		dd offset ?nameToUnicode@UTS46@icu_56@@UBEAAVUnicodeString@2@ABV32@AAV32@AAVIDNAInfo@2@AAW4UErrorCode@@@Z ; icu_56::UTS46::nameToUnicode(icu_56::UnicodeString const &,icu_56::UnicodeString &,icu_56::IDNAInfo	&,UErrorCode &)
		dd offset ?labelToASCII_UTF8@UTS46@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z ; icu_56::UTS46::labelToASCII_UTF8(icu_56::StringPiece const &,icu_56::ByteSink &,icu_56::IDNAInfo &,UErrorCode &)
		dd offset ?labelToUnicodeUTF8@UTS46@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z	; icu_56::UTS46::labelToUnicodeUTF8(icu_56::StringPiece	const &,icu_56::ByteSink &,icu_56::IDNAInfo &,UErrorCode &)
		dd offset ?nameToASCII_UTF8@UTS46@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z ;	icu_56::UTS46::nameToASCII_UTF8(icu_56::StringPiece const &,icu_56::ByteSink &,icu_56::IDNAInfo	&,UErrorCode &)
		dd offset ?nameToUnicodeUTF8@UTS46@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z ; icu_56::UTS46::nameToUnicodeUTF8(icu_56::StringPiece const &,icu_56::ByteSink &,icu_56::IDNAInfo &,UErrorCode &)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 5E94h
__unwindtable$??0UTS46@icu_56@@QAE@IAAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00005EA4o
		dd offset __unwindfunclet$??0UTS46@icu_56@@QAE@IAAW4UErrorCode@@@Z$0
__ehfuncinfo$??0UTS46@icu_56@@QAE@IAAW4UErrorCode@@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$??0UTS46@icu_56@@QAE@IAAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$??0UTS46@icu_56@@QAE@IAAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 5EC0h
		public ??_R4UTS46@icu_56@@6B@
; const	icu_56::UTS46::`RTTI Complete Object Locator'
??_R4UTS46@icu_56@@6B@ dd 3 dup(0)	; DATA XREF: .rdata:00005E68o
		dd offset ??_R0?AVUTS46@icu_56@@@8 ; icu_56::UTS46 `RTTI Type Descriptor'
		dd offset ??_R3UTS46@icu_56@@8 ; icu_56::UTS46::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 5ED4h
		public ??_R0?AVUTS46@icu_56@@@8
; class	icu_56::UTS46 `RTTI Type Descriptor'
??_R0?AVUTS46@icu_56@@@8 dd offset ??_7type_info@@6B@ ;	DATA XREF: .rdata$r:00005ECCo
					; .rdata$r:icu_56::UTS46::`RTTI	Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avuts46@icu_	db '.?AVUTS46@icu_56@@',0
		align 10h
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 5EF0h
		public ??_R3UTS46@icu_56@@8
; icu_56::UTS46::`RTTI Class Hierarchy Descriptor'
??_R3UTS46@icu_56@@8 dd	2 dup(0)	; DATA XREF: .rdata$r:00005ED0o
					; .rdata$r:00005F2Co
		dd 4
		dd offset ??_R2UTS46@icu_56@@8 ; icu_56::UTS46::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 5F00h
		public ??_R2UTS46@icu_56@@8
; icu_56::UTS46::`RTTI Base Class Array'
??_R2UTS46@icu_56@@8 dd	offset ??_R1A@?0A@EA@UTS46@icu_56@@8 ; DATA XREF: .rdata$r:00005EFCo
					; icu_56::UTS46::`RTTI Base Class Descriptor at	(0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@IDNA@icu_56@@8 ; icu_56::IDNA::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 5F14h
		public ??_R1A@?0A@EA@UTS46@icu_56@@8
; icu_56::UTS46::`RTTI Base Class Descriptor at	(0, -1,	0, 64)'
??_R1A@?0A@EA@UTS46@icu_56@@8 dd offset	??_R0?AVUTS46@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UTS46::`RTTI Base	Class Array'o
					; icu_56::UTS46	`RTTI Type Descriptor'
		dd 3, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UTS46@icu_56@@8 ; icu_56::UTS46::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5F30h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UTS46::`scalar deleting destructor'(unsigned int)
		public ??_GUTS46@icu_56@@UAEPAXI@Z
??_GUTS46@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1UTS46@icu_56@@UAE@XZ	; icu_56::UTS46::~UTS46(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_5F6F
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_5F6F:				; CODE XREF: icu_56::UTS46::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GUTS46@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5F88h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UTS46::~UTS46(icu_56::UTS46	*__hidden this)
		public ??1UTS46@icu_56@@UAE@XZ
??1UTS46@icu_56@@UAE@XZ	proc near	; CODE XREF: icu_56::UTS46::`scalar deleting destructor'(uint)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UTS46@icu_56@@6B@ ;	const icu_56::UTS46::`vftable'
		mov	ecx, [ebp+var_8] ; this
		call	??1IDNA@icu_56@@UAE@XZ ; icu_56::IDNA::~IDNA(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1UTS46@icu_56@@UAE@XZ	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5FD0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UTS46::labelToASCII(icu_56::UTS46 *this, const struct icu_56::UnicodeString *, struct icu_56::UnicodeString *, struct icu_56::IDNAInfo *, enum UErrorCode *)
		public ?labelToASCII@UTS46@icu_56@@UBEAAVUnicodeString@2@ABV32@AAV32@AAVIDNAInfo@2@AAW4UErrorCode@@@Z
?labelToASCII@UTS46@icu_56@@UBEAAVUnicodeString@2@ABV32@AAV32@AAVIDNAInfo@2@AAW4UErrorCode@@@Z proc near
					; DATA XREF: .rdata:00005E74o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct icu_56::IDNAInfo *
		mov	edx, [ebp+arg_4]
		push	edx		; struct icu_56::UnicodeString *
		push	1		; char
		push	1		; char
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?process@UTS46@icu_56@@ABEAAVUnicodeString@2@ABV32@CCAAV32@AAVIDNAInfo@2@AAW4UErrorCode@@@Z ; icu_56::UTS46::process(icu_56::UnicodeString const &,signed char,signed char,icu_56::UnicodeString &,icu_56::IDNAInfo &,UErrorCode &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?labelToASCII@UTS46@icu_56@@UBEAAVUnicodeString@2@ABV32@AAV32@AAVIDNAInfo@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6028h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UTS46::labelToUnicode(icu_56::UTS46 *this, const struct icu_56::UnicodeString *, struct icu_56::UnicodeString *, struct icu_56::IDNAInfo *, enum UErrorCode *)
		public ?labelToUnicode@UTS46@icu_56@@UBEAAVUnicodeString@2@ABV32@AAV32@AAVIDNAInfo@2@AAW4UErrorCode@@@Z
?labelToUnicode@UTS46@icu_56@@UBEAAVUnicodeString@2@ABV32@AAV32@AAVIDNAInfo@2@AAW4UErrorCode@@@Z proc near
					; DATA XREF: .rdata:00005E78o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct icu_56::IDNAInfo *
		mov	edx, [ebp+arg_4]
		push	edx		; struct icu_56::UnicodeString *
		push	0		; char
		push	1		; char
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?process@UTS46@icu_56@@ABEAAVUnicodeString@2@ABV32@CCAAV32@AAVIDNAInfo@2@AAW4UErrorCode@@@Z ; icu_56::UTS46::process(icu_56::UnicodeString const &,signed char,signed char,icu_56::UnicodeString &,icu_56::IDNAInfo &,UErrorCode &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?labelToUnicode@UTS46@icu_56@@UBEAAVUnicodeString@2@ABV32@AAV32@AAVIDNAInfo@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6080h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UTS46::nameToASCII(icu_56::UTS46 *this, const struct	icu_56::UnicodeString *, struct	icu_56::UnicodeString *, struct	icu_56::IDNAInfo *, enum UErrorCode *)
		public ?nameToASCII@UTS46@icu_56@@UBEAAVUnicodeString@2@ABV32@AAV32@AAVIDNAInfo@2@AAW4UErrorCode@@@Z
?nameToASCII@UTS46@icu_56@@UBEAAVUnicodeString@2@ABV32@AAV32@AAVIDNAInfo@2@AAW4UErrorCode@@@Z proc near
					; DATA XREF: .rdata:00005E7Co

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct icu_56::IDNAInfo *
		mov	edx, [ebp+arg_4]
		push	edx		; struct icu_56::UnicodeString *
		push	1		; char
		push	0		; char
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?process@UTS46@icu_56@@ABEAAVUnicodeString@2@ABV32@CCAAV32@AAVIDNAInfo@2@AAW4UErrorCode@@@Z ; icu_56::UTS46::process(icu_56::UnicodeString const &,signed char,signed char,icu_56::UnicodeString &,icu_56::IDNAInfo &,UErrorCode &)
		mov	ecx, [ebp+arg_4] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		cmp	eax, 0FEh ; ''
		jl	short loc_611C
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		and	ecx, 4
		jnz	short loc_611C
		mov	eax, [ebp+arg_4]
		push	eax		; icu_56::UnicodeString	*
		call	?isASCIIString@icu_56@@YACABVUnicodeString@1@@Z	; icu_56::isASCIIString(icu_56::UnicodeString const &)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_611C
		mov	ecx, [ebp+arg_4] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		cmp	eax, 0FEh ; ''
		jg	short loc_610F
		push	0FDh ; ''
		mov	ecx, [ebp+arg_4]
		call	??AUnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::operator[](int)
		movzx	eax, ax
		cmp	eax, 2Eh ; '.'
		jz	short loc_611C

loc_610F:				; CODE XREF: icu_56::UTS46::nameToASCII(icu_56::UnicodeString const &,icu_56::UnicodeString &,icu_56::IDNAInfo &,UErrorCode &)+78j
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		or	ecx, 4
		mov	edx, [ebp+arg_8]
		mov	[edx], ecx

loc_611C:				; CODE XREF: icu_56::UTS46::nameToASCII(icu_56::UnicodeString const &,icu_56::UnicodeString &,icu_56::IDNAInfo &,UErrorCode &)+4Cj
					; icu_56::UTS46::nameToASCII(icu_56::UnicodeString const &,icu_56::UnicodeString &,icu_56::IDNAInfo &,UErrorCode &)+56j ...
		mov	eax, [ebp+arg_4]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?nameToASCII@UTS46@icu_56@@UBEAAVUnicodeString@2@ABV32@AAV32@AAVIDNAInfo@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6138h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl icu_56::isASCIIString(icu_56::UnicodeString *)
?isASCIIString@icu_56@@YACABVUnicodeString@1@@Z	proc near
					; CODE XREF: icu_56::UTS46::nameToASCII(icu_56::UnicodeString const &,icu_56::UnicodeString &,icu_56::IDNAInfo &,UErrorCode &)+5Cp
					; icu_56::UTS46::processUTF8(icu_56::StringPiece const &,signed	char,signed char,icu_56::ByteSink &,icu_56::IDNAInfo &,UErrorCode &)+582p

var_DC		= dword	ptr -0DCh
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0DCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_DC]
		mov	ecx, 37h ; '7'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	ecx, [ebp+arg_0] ; this
		call	?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ ; icu_56::UnicodeString::getBuffer(void)
		mov	[ebp+var_8], eax
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	ecx, [ebp+var_8]
		lea	edx, [ecx+eax*2]
		mov	[ebp+var_14], edx

loc_6172:				; CODE XREF: icu_56::isASCIIString(icu_56::UnicodeString const &):loc_61B1j
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+var_14]
		jnb	short loc_61B3
		mov	eax, [ebp+var_8]
		movzx	ecx, word ptr [eax]
		mov	edx, [ebp+var_8]
		add	edx, 2
		mov	[ebp+var_8], edx
		cmp	ecx, 7Fh ; ''
		jle	short loc_619A
		mov	[ebp+var_DC], 1
		jmp	short loc_61A4
; ---------------------------------------------------------------------------

loc_619A:				; CODE XREF: icu_56::isASCIIString(icu_56::UnicodeString const &)+54j
		mov	[ebp+var_DC], 0

loc_61A4:				; CODE XREF: icu_56::isASCIIString(icu_56::UnicodeString const &)+60j
		cmp	[ebp+var_DC], 0
		jz	short loc_61B1
		xor	al, al
		jmp	short loc_61B5
; ---------------------------------------------------------------------------

loc_61B1:				; CODE XREF: icu_56::isASCIIString(icu_56::UnicodeString const &)+73j
		jmp	short loc_6172
; ---------------------------------------------------------------------------

loc_61B3:				; CODE XREF: icu_56::isASCIIString(icu_56::UnicodeString const &)+40j
		mov	al, 1

loc_61B5:				; CODE XREF: icu_56::isASCIIString(icu_56::UnicodeString const &)+77j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0DCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?isASCIIString@icu_56@@YACABVUnicodeString@1@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 61CCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UTS46::nameToUnicode(icu_56::UTS46 *this, const struct icu_56::UnicodeString	*, struct icu_56::UnicodeString	*, struct icu_56::IDNAInfo *, enum UErrorCode *)
		public ?nameToUnicode@UTS46@icu_56@@UBEAAVUnicodeString@2@ABV32@AAV32@AAVIDNAInfo@2@AAW4UErrorCode@@@Z
?nameToUnicode@UTS46@icu_56@@UBEAAVUnicodeString@2@ABV32@AAV32@AAVIDNAInfo@2@AAW4UErrorCode@@@Z	proc near
					; DATA XREF: .rdata:00005E80o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct icu_56::IDNAInfo *
		mov	edx, [ebp+arg_4]
		push	edx		; struct icu_56::UnicodeString *
		push	0		; char
		push	0		; char
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?process@UTS46@icu_56@@ABEAAVUnicodeString@2@ABV32@CCAAV32@AAVIDNAInfo@2@AAW4UErrorCode@@@Z ; icu_56::UTS46::process(icu_56::UnicodeString const &,signed char,signed char,icu_56::UnicodeString &,icu_56::IDNAInfo &,UErrorCode &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?nameToUnicode@UTS46@icu_56@@UBEAAVUnicodeString@2@ABV32@AAV32@AAVIDNAInfo@2@AAW4UErrorCode@@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6224h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UTS46::labelToASCII_UTF8(icu_56::UTS46 *this,	const struct icu_56::StringPiece *, struct icu_56::ByteSink *, struct icu_56::IDNAInfo *, enum UErrorCode *)
		public ?labelToASCII_UTF8@UTS46@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z
?labelToASCII_UTF8@UTS46@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z proc near
					; DATA XREF: .rdata:00005E84o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct icu_56::IDNAInfo *
		mov	edx, [ebp+arg_4]
		push	edx		; struct icu_56::ByteSink *
		push	1		; char
		push	1		; char
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::StringPiece *
		mov	ecx, [ebp+var_8] ; this
		call	?processUTF8@UTS46@icu_56@@ABEXABVStringPiece@2@CCAAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z ; icu_56::UTS46::processUTF8(icu_56::StringPiece const	&,signed char,signed char,icu_56::ByteSink &,icu_56::IDNAInfo &,UErrorCode &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?labelToASCII_UTF8@UTS46@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 627Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UTS46::labelToUnicodeUTF8(icu_56::UTS46 *this, const struct icu_56::StringPiece *, struct icu_56::ByteSink *,	struct icu_56::IDNAInfo	*, enum	UErrorCode *)
		public ?labelToUnicodeUTF8@UTS46@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z
?labelToUnicodeUTF8@UTS46@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z proc near
					; DATA XREF: .rdata:00005E88o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct icu_56::IDNAInfo *
		mov	edx, [ebp+arg_4]
		push	edx		; struct icu_56::ByteSink *
		push	0		; char
		push	1		; char
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::StringPiece *
		mov	ecx, [ebp+var_8] ; this
		call	?processUTF8@UTS46@icu_56@@ABEXABVStringPiece@2@CCAAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z ; icu_56::UTS46::processUTF8(icu_56::StringPiece const	&,signed char,signed char,icu_56::ByteSink &,icu_56::IDNAInfo &,UErrorCode &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?labelToUnicodeUTF8@UTS46@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 62D4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UTS46::nameToASCII_UTF8(icu_56::UTS46	*this, const struct icu_56::StringPiece	*, struct icu_56::ByteSink *, struct icu_56::IDNAInfo *, enum UErrorCode *)
		public ?nameToASCII_UTF8@UTS46@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z
?nameToASCII_UTF8@UTS46@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z proc near
					; DATA XREF: .rdata:00005E8Co

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct icu_56::IDNAInfo *
		mov	edx, [ebp+arg_4]
		push	edx		; struct icu_56::ByteSink *
		push	1		; char
		push	0		; char
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::StringPiece *
		mov	ecx, [ebp+var_8] ; this
		call	?processUTF8@UTS46@icu_56@@ABEXABVStringPiece@2@CCAAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z ; icu_56::UTS46::processUTF8(icu_56::StringPiece const	&,signed char,signed char,icu_56::ByteSink &,icu_56::IDNAInfo &,UErrorCode &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?nameToASCII_UTF8@UTS46@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 632Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UTS46::nameToUnicodeUTF8(icu_56::UTS46 *this,	const struct icu_56::StringPiece *, struct icu_56::ByteSink *, struct icu_56::IDNAInfo *, enum UErrorCode *)
		public ?nameToUnicodeUTF8@UTS46@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z
?nameToUnicodeUTF8@UTS46@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z proc near
					; DATA XREF: .rdata:00005E90o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct icu_56::IDNAInfo *
		mov	edx, [ebp+arg_4]
		push	edx		; struct icu_56::ByteSink *
		push	0		; char
		push	0		; char
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::StringPiece *
		mov	ecx, [ebp+var_8] ; this
		call	?processUTF8@UTS46@icu_56@@ABEXABVStringPiece@2@CCAAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z ; icu_56::UTS46::processUTF8(icu_56::StringPiece const	&,signed char,signed char,icu_56::ByteSink &,icu_56::IDNAInfo &,UErrorCode &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?nameToUnicodeUTF8@UTS46@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6384h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UTS46::process(icu_56::UTS46	*this, const struct icu_56::UnicodeString *, char, char, struct	icu_56::UnicodeString *, struct	icu_56::IDNAInfo *, enum UErrorCode *)
		public ?process@UTS46@icu_56@@ABEAAVUnicodeString@2@ABV32@CCAAV32@AAVIDNAInfo@2@AAW4UErrorCode@@@Z
?process@UTS46@icu_56@@ABEAAVUnicodeString@2@ABV32@CCAAV32@AAVIDNAInfo@2@AAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::UTS46::labelToASCII(icu_56::UnicodeString const &,icu_56::UnicodeString &,icu_56::IDNAInfo	&,UErrorCode &)+3Ap
					; icu_56::UTS46::labelToUnicode(icu_56::UnicodeString const &,icu_56::UnicodeString &,icu_56::IDNAInfo &,UErrorCode &)+3Ap ...

var_12C		= byte ptr -12Ch
var_68		= dword	ptr -68h
var_5C		= word ptr -5Ch
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_35		= byte ptr -35h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= byte ptr  0Ch
arg_8		= byte ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 12Ch
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_12C]
		mov	ecx, 4Bh ; 'K'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_14]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_63CC
		mov	ecx, [ebp+arg_C] ; this
		call	?setToBogus@UnicodeString@icu_56@@QAEXXZ ; icu_56::UnicodeString::setToBogus(void)
		mov	eax, [ebp+arg_C]
		jmp	loc_6710
; ---------------------------------------------------------------------------

loc_63CC:				; CODE XREF: icu_56::UTS46::process(icu_56::UnicodeString const	&,signed char,signed char,icu_56::UnicodeString	&,icu_56::IDNAInfo &,UErrorCode	&)+36j
		mov	ecx, [ebp+arg_0] ; this
		call	?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ ; icu_56::UnicodeString::getBuffer(void)
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_C]
		cmp	eax, [ebp+arg_0]
		jz	short loc_63E5
		cmp	[ebp+var_14], 0
		jnz	short loc_63FE

loc_63E5:				; CODE XREF: icu_56::UTS46::process(icu_56::UnicodeString const	&,signed char,signed char,icu_56::UnicodeString	&,icu_56::IDNAInfo &,UErrorCode	&)+59j
		mov	eax, [ebp+arg_14]
		mov	dword ptr [eax], 1
		mov	ecx, [ebp+arg_C] ; this
		call	?setToBogus@UnicodeString@icu_56@@QAEXXZ ; icu_56::UnicodeString::setToBogus(void)
		mov	eax, [ebp+arg_C]
		jmp	loc_6710
; ---------------------------------------------------------------------------

loc_63FE:				; CODE XREF: icu_56::UTS46::process(icu_56::UnicodeString const	&,signed char,signed char,icu_56::UnicodeString	&,icu_56::IDNAInfo &,UErrorCode	&)+5Fj
		mov	ecx, [ebp+arg_C] ; this
		call	?remove@UnicodeString@icu_56@@QAEAAV12@XZ ; icu_56::UnicodeString::remove(void)
		mov	ecx, [ebp+arg_10] ; this
		call	?reset@IDNAInfo@icu_56@@AAEXXZ ; icu_56::IDNAInfo::reset(void)
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	[ebp+var_20], eax
		cmp	[ebp+var_20], 0
		jnz	short loc_6434
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		or	ecx, 1
		mov	edx, [ebp+arg_10]
		mov	[edx], ecx
		mov	eax, [ebp+arg_C]
		jmp	loc_6710
; ---------------------------------------------------------------------------

loc_6434:				; CODE XREF: icu_56::UTS46::process(icu_56::UnicodeString const	&,signed char,signed char,icu_56::UnicodeString	&,icu_56::IDNAInfo &,UErrorCode	&)+99j
		mov	eax, [ebp+var_20]
		push	eax		; int
		mov	ecx, [ebp+arg_C] ; this
		call	?getBuffer@UnicodeString@icu_56@@QAEPA_WH@Z ; icu_56::UnicodeString::getBuffer(int)
		mov	[ebp+var_2C], eax
		cmp	[ebp+var_2C], 0
		jnz	short loc_645A
		mov	eax, [ebp+arg_14]
		mov	dword ptr [eax], 7
		mov	eax, [ebp+arg_C]
		jmp	loc_6710
; ---------------------------------------------------------------------------

loc_645A:				; CODE XREF: icu_56::UTS46::process(icu_56::UnicodeString const	&,signed char,signed char,icu_56::UnicodeString	&,icu_56::IDNAInfo &,UErrorCode	&)+C3j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		and	ecx, 2
		setnz	dl
		mov	[ebp+var_35], dl
		mov	[ebp+var_44], 0
		mov	[ebp+var_50], 0
		jmp	short loc_6482
; ---------------------------------------------------------------------------

loc_6479:				; CODE XREF: icu_56::UTS46::process(icu_56::UnicodeString const	&,signed char,signed char,icu_56::UnicodeString	&,icu_56::IDNAInfo &,UErrorCode	&):loc_6658j
		mov	eax, [ebp+var_50]
		add	eax, 1
		mov	[ebp+var_50], eax

loc_6482:				; CODE XREF: icu_56::UTS46::process(icu_56::UnicodeString const	&,signed char,signed char,icu_56::UnicodeString	&,icu_56::IDNAInfo &,UErrorCode	&)+F3j
		mov	eax, [ebp+var_50]
		cmp	eax, [ebp+var_20]
		jnz	short loc_64FF
		movsx	eax, [ebp+arg_8]
		test	eax, eax
		jz	short loc_64DB
		mov	eax, [ebp+var_50]
		sub	eax, [ebp+var_44]
		cmp	eax, 3Fh ; '?'
		jle	short loc_64AC
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax+4]
		or	ecx, 2
		mov	edx, [ebp+arg_10]
		mov	[edx+4], ecx

loc_64AC:				; CODE XREF: icu_56::UTS46::process(icu_56::UnicodeString const	&,signed char,signed char,icu_56::UnicodeString	&,icu_56::IDNAInfo &,UErrorCode	&)+117j
		movsx	eax, [ebp+arg_4]
		test	eax, eax
		jnz	short loc_64DB
		cmp	[ebp+var_50], 0FEh ; ''
		jl	short loc_64DB
		cmp	[ebp+var_50], 0FEh ; ''
		jg	short loc_64CE
		mov	eax, [ebp+var_44]
		cmp	eax, [ebp+var_50]
		jge	short loc_64DB

loc_64CE:				; CODE XREF: icu_56::UTS46::process(icu_56::UnicodeString const	&,signed char,signed char,icu_56::UnicodeString	&,icu_56::IDNAInfo &,UErrorCode	&)+140j
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		or	ecx, 4
		mov	edx, [ebp+arg_10]
		mov	[edx], ecx

loc_64DB:				; CODE XREF: icu_56::UTS46::process(icu_56::UnicodeString const	&,signed char,signed char,icu_56::UnicodeString	&,icu_56::IDNAInfo &,UErrorCode	&)+10Cj
					; icu_56::UTS46::process(icu_56::UnicodeString const &,signed char,signed char,icu_56::UnicodeString &,icu_56::IDNAInfo	&,UErrorCode &)+12Ej ...
		mov	eax, [ebp+arg_10]
		mov	ecx, [ebp+arg_10]
		mov	edx, [eax]
		or	edx, [ecx+4]
		mov	eax, [ebp+arg_10]
		mov	[eax], edx
		mov	eax, [ebp+var_50]
		push	eax		; int
		mov	ecx, [ebp+arg_C] ; this
		call	?releaseBuffer@UnicodeString@icu_56@@QAEXH@Z ; icu_56::UnicodeString::releaseBuffer(int)
		mov	eax, [ebp+arg_C]
		jmp	loc_6710
; ---------------------------------------------------------------------------

loc_64FF:				; CODE XREF: icu_56::UTS46::process(icu_56::UnicodeString const	&,signed char,signed char,icu_56::UnicodeString	&,icu_56::IDNAInfo &,UErrorCode	&)+104j
		mov	eax, [ebp+var_50]
		mov	ecx, [ebp+var_14]
		mov	dx, [ecx+eax*2]
		mov	[ebp+var_5C], dx
		movzx	eax, [ebp+var_5C]
		cmp	eax, 7Fh ; ''
		jle	short loc_651B
		jmp	loc_665D
; ---------------------------------------------------------------------------

loc_651B:				; CODE XREF: icu_56::UTS46::process(icu_56::UnicodeString const	&,signed char,signed char,icu_56::UnicodeString	&,icu_56::IDNAInfo &,UErrorCode	&)+190j
		movzx	eax, [ebp+var_5C]
		movsx	ecx, ds:_asciiData[eax]
		mov	[ebp+var_68], ecx
		cmp	[ebp+var_68], 0
		jle	short loc_6545
		movzx	eax, [ebp+var_5C]
		add	eax, 20h ; ' '
		mov	ecx, [ebp+var_50]
		mov	edx, [ebp+var_2C]
		mov	[edx+ecx*2], ax
		jmp	loc_6658
; ---------------------------------------------------------------------------

loc_6545:				; CODE XREF: icu_56::UTS46::process(icu_56::UnicodeString const	&,signed char,signed char,icu_56::UnicodeString	&,icu_56::IDNAInfo &,UErrorCode	&)+1A9j
		cmp	[ebp+var_68], 0
		jge	short loc_655D
		movsx	eax, [ebp+var_35]
		test	eax, eax
		jz	short loc_655D
		jmp	loc_665D
; ---------------------------------------------------------------------------
		jmp	loc_6658
; ---------------------------------------------------------------------------

loc_655D:				; CODE XREF: icu_56::UTS46::process(icu_56::UnicodeString const	&,signed char,signed char,icu_56::UnicodeString	&,icu_56::IDNAInfo &,UErrorCode	&)+1C5j
					; icu_56::UTS46::process(icu_56::UnicodeString const &,signed char,signed char,icu_56::UnicodeString &,icu_56::IDNAInfo	&,UErrorCode &)+1CDj
		mov	eax, [ebp+var_50]
		mov	ecx, [ebp+var_2C]
		mov	dx, [ebp+var_5C]
		mov	[ecx+eax*2], dx
		movzx	eax, [ebp+var_5C]
		cmp	eax, 2Dh ; '-'
		jnz	short loc_65E0
		mov	eax, [ebp+var_44]
		add	eax, 3
		cmp	[ebp+var_50], eax
		jnz	short loc_659D
		mov	eax, [ebp+var_50]
		mov	ecx, [ebp+var_14]
		movzx	edx, word ptr [ecx+eax*2-2]
		cmp	edx, 2Dh ; '-'
		jnz	short loc_659D
		mov	eax, [ebp+var_50]
		add	eax, 1
		mov	[ebp+var_50], eax
		jmp	loc_665D
; ---------------------------------------------------------------------------

loc_659D:				; CODE XREF: icu_56::UTS46::process(icu_56::UnicodeString const	&,signed char,signed char,icu_56::UnicodeString	&,icu_56::IDNAInfo &,UErrorCode	&)+1F9j
					; icu_56::UTS46::process(icu_56::UnicodeString const &,signed char,signed char,icu_56::UnicodeString &,icu_56::IDNAInfo	&,UErrorCode &)+209j
		mov	eax, [ebp+var_50]
		cmp	eax, [ebp+var_44]
		jnz	short loc_65B4
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax+4]
		or	ecx, 8
		mov	edx, [ebp+arg_10]
		mov	[edx+4], ecx

loc_65B4:				; CODE XREF: icu_56::UTS46::process(icu_56::UnicodeString const	&,signed char,signed char,icu_56::UnicodeString	&,icu_56::IDNAInfo &,UErrorCode	&)+21Fj
		mov	eax, [ebp+var_50]
		add	eax, 1
		cmp	eax, [ebp+var_20]
		jz	short loc_65CF
		mov	eax, [ebp+var_50]
		mov	ecx, [ebp+var_14]
		movzx	edx, word ptr [ecx+eax*2+2]
		cmp	edx, 2Eh ; '.'
		jnz	short loc_65DE

loc_65CF:				; CODE XREF: icu_56::UTS46::process(icu_56::UnicodeString const	&,signed char,signed char,icu_56::UnicodeString	&,icu_56::IDNAInfo &,UErrorCode	&)+239j
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax+4]
		or	ecx, 10h
		mov	edx, [ebp+arg_10]
		mov	[edx+4], ecx

loc_65DE:				; CODE XREF: icu_56::UTS46::process(icu_56::UnicodeString const	&,signed char,signed char,icu_56::UnicodeString	&,icu_56::IDNAInfo &,UErrorCode	&)+249j
		jmp	short loc_6658
; ---------------------------------------------------------------------------

loc_65E0:				; CODE XREF: icu_56::UTS46::process(icu_56::UnicodeString const	&,signed char,signed char,icu_56::UnicodeString	&,icu_56::IDNAInfo &,UErrorCode	&)+1EEj
		movzx	eax, [ebp+var_5C]
		cmp	eax, 2Eh ; '.'
		jnz	short loc_6658
		movsx	eax, [ebp+arg_4]
		test	eax, eax
		jz	short loc_65FC
		mov	eax, [ebp+var_50]
		add	eax, 1
		mov	[ebp+var_50], eax
		jmp	short loc_665D
; ---------------------------------------------------------------------------

loc_65FC:				; CODE XREF: icu_56::UTS46::process(icu_56::UnicodeString const	&,signed char,signed char,icu_56::UnicodeString	&,icu_56::IDNAInfo &,UErrorCode	&)+26Bj
		mov	eax, [ebp+var_50]
		cmp	eax, [ebp+var_44]
		jnz	short loc_6613
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax+4]
		or	ecx, 1
		mov	edx, [ebp+arg_10]
		mov	[edx+4], ecx

loc_6613:				; CODE XREF: icu_56::UTS46::process(icu_56::UnicodeString const	&,signed char,signed char,icu_56::UnicodeString	&,icu_56::IDNAInfo &,UErrorCode	&)+27Ej
		movsx	eax, [ebp+arg_8]
		test	eax, eax
		jz	short loc_6635
		mov	eax, [ebp+var_50]
		sub	eax, [ebp+var_44]
		cmp	eax, 3Fh ; '?'
		jle	short loc_6635
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax+4]
		or	ecx, 2
		mov	edx, [ebp+arg_10]
		mov	[edx+4], ecx

loc_6635:				; CODE XREF: icu_56::UTS46::process(icu_56::UnicodeString const	&,signed char,signed char,icu_56::UnicodeString	&,icu_56::IDNAInfo &,UErrorCode	&)+295j
					; icu_56::UTS46::process(icu_56::UnicodeString const &,signed char,signed char,icu_56::UnicodeString &,icu_56::IDNAInfo	&,UErrorCode &)+2A0j
		mov	eax, [ebp+arg_10]
		mov	ecx, [ebp+arg_10]
		mov	edx, [eax]
		or	edx, [ecx+4]
		mov	eax, [ebp+arg_10]
		mov	[eax], edx
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+var_50]
		add	eax, 1
		mov	[ebp+var_44], eax

loc_6658:				; CODE XREF: icu_56::UTS46::process(icu_56::UnicodeString const	&,signed char,signed char,icu_56::UnicodeString	&,icu_56::IDNAInfo &,UErrorCode	&)+1BCj
					; icu_56::UTS46::process(icu_56::UnicodeString const &,signed char,signed char,icu_56::UnicodeString &,icu_56::IDNAInfo	&,UErrorCode &)+1D4j ...
		jmp	loc_6479
; ---------------------------------------------------------------------------

loc_665D:				; CODE XREF: icu_56::UTS46::process(icu_56::UnicodeString const	&,signed char,signed char,icu_56::UnicodeString	&,icu_56::IDNAInfo &,UErrorCode	&)+192j
					; icu_56::UTS46::process(icu_56::UnicodeString const &,signed char,signed char,icu_56::UnicodeString &,icu_56::IDNAInfo	&,UErrorCode &)+1CFj ...
		mov	eax, [ebp+arg_10]
		mov	ecx, [ebp+arg_10]
		mov	edx, [eax]
		or	edx, [ecx+4]
		mov	eax, [ebp+arg_10]
		mov	[eax], edx
		mov	eax, [ebp+var_50]
		push	eax		; int
		mov	ecx, [ebp+arg_C] ; this
		call	?releaseBuffer@UnicodeString@icu_56@@QAEXH@Z ; icu_56::UnicodeString::releaseBuffer(int)
		mov	eax, [ebp+arg_14]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_10]
		push	ecx		; struct icu_56::IDNAInfo *
		mov	edx, [ebp+arg_C]
		push	edx		; struct icu_56::UnicodeString *
		movzx	eax, [ebp+arg_8]
		push	eax		; char
		movzx	ecx, [ebp+arg_4]
		push	ecx		; char
		mov	edx, [ebp+var_50]
		push	edx		; int
		mov	eax, [ebp+var_44]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?processUnicode@UTS46@icu_56@@ABEAAVUnicodeString@2@ABV32@HHCCAAV32@AAVIDNAInfo@2@AAW4UErrorCode@@@Z ; icu_56::UTS46::processUnicode(icu_56::UnicodeString const &,int,int,signed char,signed char,icu_56::UnicodeString &,icu_56::IDNAInfo &,UErrorCode &)
		mov	eax, [ebp+arg_10]
		movsx	ecx, byte ptr [eax+9]
		test	ecx, ecx
		jz	short loc_670D
		mov	eax, [ebp+arg_14]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_670D
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		and	ecx, 7C0h
		jnz	short loc_670D
		mov	eax, [ebp+arg_10]
		movsx	ecx, byte ptr [eax+0Ah]
		test	ecx, ecx
		jz	short loc_66FD
		cmp	[ebp+var_44], 0
		jle	short loc_670D
		mov	eax, [ebp+var_44]
		push	eax
		mov	ecx, [ebp+arg_C] ; this
		call	?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ ; icu_56::UnicodeString::getBuffer(void)
		push	eax
		call	?isASCIIOkBiDi@icu_56@@YACPB_WH@Z ; icu_56::isASCIIOkBiDi(wchar_t const	*,int)
		add	esp, 8
		movsx	ecx, al
		test	ecx, ecx
		jnz	short loc_670D

loc_66FD:				; CODE XREF: icu_56::UTS46::process(icu_56::UnicodeString const	&,signed char,signed char,icu_56::UnicodeString	&,icu_56::IDNAInfo &,UErrorCode	&)+355j
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		or	ecx, 800h
		mov	edx, [ebp+arg_10]
		mov	[edx], ecx

loc_670D:				; CODE XREF: icu_56::UTS46::process(icu_56::UnicodeString const	&,signed char,signed char,icu_56::UnicodeString	&,icu_56::IDNAInfo &,UErrorCode	&)+328j
					; icu_56::UTS46::process(icu_56::UnicodeString const &,signed char,signed char,icu_56::UnicodeString &,icu_56::IDNAInfo	&,UErrorCode &)+33Dj ...
		mov	eax, [ebp+arg_C]

loc_6710:				; CODE XREF: icu_56::UTS46::process(icu_56::UnicodeString const	&,signed char,signed char,icu_56::UnicodeString	&,icu_56::IDNAInfo &,UErrorCode	&)+43j
					; icu_56::UTS46::process(icu_56::UnicodeString const &,signed char,signed char,icu_56::UnicodeString &,icu_56::IDNAInfo	&,UErrorCode &)+75j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 12Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	18h
?process@UTS46@icu_56@@ABEAAVUnicodeString@2@ABV32@CCAAV32@AAVIDNAInfo@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6728h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UTS46::processUTF8(icu_56::UTS46 *this, const	struct icu_56::StringPiece *, char, char, struct icu_56::ByteSink *, struct icu_56::IDNAInfo *,	enum UErrorCode	*)
		public ?processUTF8@UTS46@icu_56@@ABEXABVStringPiece@2@CCAAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z
?processUTF8@UTS46@icu_56@@ABEXABVStringPiece@2@CCAAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::UTS46::labelToASCII_UTF8(icu_56::StringPiece const	&,icu_56::ByteSink &,icu_56::IDNAInfo &,UErrorCode &)+3Ap
					; icu_56::UTS46::labelToUnicodeUTF8(icu_56::StringPiece	const &,icu_56::ByteSink &,icu_56::IDNAInfo &,UErrorCode &)+3Ap ...

var_3B0		= dword	ptr -3B0h
var_3AC		= dword	ptr -3ACh
var_3A4		= byte ptr -3A4h
var_35C		= byte ptr -35Ch
var_314		= byte ptr -314h
var_2CC		= byte ptr -2CCh
var_2BC		= byte ptr -2BCh
var_1EC		= dword	ptr -1ECh
var_1E0		= byte ptr -1E0h
var_1D4		= dword	ptr -1D4h
var_1C5		= byte ptr -1C5h
var_1BC		= dword	ptr -1BCh
var_1AD		= byte ptr -1ADh
var_1A4		= dword	ptr -1A4h
var_198		= byte ptr -198h
var_18C		= byte ptr -18Ch
var_84		= dword	ptr -84h
var_78		= byte ptr -78h
var_30		= dword	ptr -30h
var_24		= dword	ptr -24h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= byte ptr  0Ch
arg_8		= byte ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?processUTF8@UTS46@icu_56@@ABEXABVStringPiece@2@CCAAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 3A4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_3B0]
		mov	ecx, 0E9h ; ''
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		mov	eax, [ebp+arg_14]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_6787
		jmp	loc_6D74
; ---------------------------------------------------------------------------

loc_6787:				; CODE XREF: icu_56::UTS46::processUTF8(icu_56::StringPiece const &,signed char,signed char,icu_56::ByteSink &,icu_56::IDNAInfo	&,UErrorCode &)+58j
		mov	ecx, [ebp+arg_0] ; this
		call	?data@StringPiece@icu_56@@QBEPBDXZ ; icu_56::StringPiece::data(void)
		mov	[ebp+var_24], eax
		mov	ecx, [ebp+arg_0] ; this
		call	?length@StringPiece@icu_56@@QBEHXZ ; icu_56::StringPiece::length(void)
		mov	[ebp+var_30], eax
		cmp	[ebp+var_24], 0
		jnz	short loc_67B7
		cmp	[ebp+var_30], 0
		jz	short loc_67B7
		mov	eax, [ebp+arg_14]
		mov	dword ptr [eax], 1
		jmp	loc_6D74
; ---------------------------------------------------------------------------

loc_67B7:				; CODE XREF: icu_56::UTS46::processUTF8(icu_56::StringPiece const &,signed char,signed char,icu_56::ByteSink &,icu_56::IDNAInfo	&,UErrorCode &)+79j
					; icu_56::UTS46::processUTF8(icu_56::StringPiece const &,signed	char,signed char,icu_56::ByteSink &,icu_56::IDNAInfo &,UErrorCode &)+7Fj
		mov	ecx, [ebp+arg_10] ; this
		call	?reset@IDNAInfo@icu_56@@AAEXXZ ; icu_56::IDNAInfo::reset(void)
		cmp	[ebp+var_30], 0
		jnz	short loc_67ED
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		or	ecx, 1
		mov	edx, [ebp+arg_10]
		mov	[edx], ecx
		mov	eax, [ebp+arg_C]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+arg_C]
		mov	eax, [edx+0Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	loc_6D74
; ---------------------------------------------------------------------------

loc_67ED:				; CODE XREF: icu_56::UTS46::processUTF8(icu_56::StringPiece const &,signed char,signed char,icu_56::ByteSink &,icu_56::IDNAInfo	&,UErrorCode &)+9Bj
		lea	ecx, [ebp+var_78] ; this
		call	??0UnicodeString@icu_56@@QAE@XZ	; icu_56::UnicodeString::UnicodeString(void)
		mov	[ebp+var_4], 0
		mov	[ebp+var_84], 0
		cmp	[ebp+var_30], 100h
		jg	loc_6C09
		mov	esi, esp
		lea	eax, [ebp+var_198]
		push	eax
		push	100h
		lea	ecx, [ebp+var_18C]
		push	ecx
		mov	edx, [ebp+var_30]
		add	edx, 14h
		push	edx
		mov	eax, [ebp+var_30]
		push	eax
		mov	ecx, [ebp+arg_C]
		mov	edx, [ecx]
		mov	ecx, [ebp+arg_C]
		mov	eax, [edx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_1A4], eax
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+8]
		and	ecx, 2
		setnz	dl
		mov	[ebp+var_1AD], dl
		mov	[ebp+var_1BC], 0
		jmp	short loc_687A
; ---------------------------------------------------------------------------

loc_686B:				; CODE XREF: icu_56::UTS46::processUTF8(icu_56::StringPiece const &,signed char,signed char,icu_56::ByteSink &,icu_56::IDNAInfo	&,UErrorCode &):loc_6AE0j
		mov	eax, [ebp+var_1BC]
		add	eax, 1
		mov	[ebp+var_1BC], eax

loc_687A:				; CODE XREF: icu_56::UTS46::processUTF8(icu_56::StringPiece const &,signed char,signed char,icu_56::ByteSink &,icu_56::IDNAInfo	&,UErrorCode &)+141j
		mov	eax, [ebp+var_1BC]
		cmp	eax, [ebp+var_30]
		jnz	loc_694A
		movsx	eax, [ebp+arg_8]
		test	eax, eax
		jz	short loc_68EC
		mov	eax, [ebp+var_1BC]
		sub	eax, [ebp+var_84]
		cmp	eax, 3Fh ; '?'
		jle	short loc_68B1
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax+4]
		or	ecx, 2
		mov	edx, [ebp+arg_10]
		mov	[edx+4], ecx

loc_68B1:				; CODE XREF: icu_56::UTS46::processUTF8(icu_56::StringPiece const &,signed char,signed char,icu_56::ByteSink &,icu_56::IDNAInfo	&,UErrorCode &)+178j
		movsx	eax, [ebp+arg_4]
		test	eax, eax
		jnz	short loc_68EC
		cmp	[ebp+var_1BC], 0FEh ; ''
		jl	short loc_68EC
		cmp	[ebp+var_1BC], 0FEh ; ''
		jg	short loc_68DF
		mov	eax, [ebp+var_84]
		cmp	eax, [ebp+var_1BC]
		jge	short loc_68EC

loc_68DF:				; CODE XREF: icu_56::UTS46::processUTF8(icu_56::StringPiece const &,signed char,signed char,icu_56::ByteSink &,icu_56::IDNAInfo	&,UErrorCode &)+1A7j
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		or	ecx, 4
		mov	edx, [ebp+arg_10]
		mov	[edx], ecx

loc_68EC:				; CODE XREF: icu_56::UTS46::processUTF8(icu_56::StringPiece const &,signed char,signed char,icu_56::ByteSink &,icu_56::IDNAInfo	&,UErrorCode &)+167j
					; icu_56::UTS46::processUTF8(icu_56::StringPiece const &,signed	char,signed char,icu_56::ByteSink &,icu_56::IDNAInfo &,UErrorCode &)+18Fj ...
		mov	eax, [ebp+arg_10]
		mov	ecx, [ebp+arg_10]
		mov	edx, [eax]
		or	edx, [ecx+4]
		mov	eax, [ebp+arg_10]
		mov	[eax], edx
		mov	esi, esp
		mov	eax, [ebp+var_1BC]
		push	eax
		mov	ecx, [ebp+var_1A4]
		push	ecx
		mov	edx, [ebp+arg_C]
		mov	eax, [edx]
		mov	ecx, [ebp+arg_C]
		mov	edx, [eax+4]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_C]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+arg_C]
		mov	eax, [edx+0Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_78] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		jmp	loc_6D74
; ---------------------------------------------------------------------------

loc_694A:				; CODE XREF: icu_56::UTS46::processUTF8(icu_56::StringPiece const &,signed char,signed char,icu_56::ByteSink &,icu_56::IDNAInfo	&,UErrorCode &)+15Bj
		mov	eax, [ebp+var_24]
		add	eax, [ebp+var_1BC]
		mov	cl, [eax]
		mov	[ebp+var_1C5], cl
		movsx	eax, [ebp+var_1C5]
		test	eax, eax
		jge	short loc_696B
		jmp	loc_6AE5
; ---------------------------------------------------------------------------

loc_696B:				; CODE XREF: icu_56::UTS46::processUTF8(icu_56::StringPiece const &,signed char,signed char,icu_56::ByteSink &,icu_56::IDNAInfo	&,UErrorCode &)+23Cj
		movsx	eax, [ebp+var_1C5]
		movsx	ecx, ds:_asciiData[eax]
		mov	[ebp+var_1D4], ecx
		cmp	[ebp+var_1D4], 0
		jle	short loc_69A5
		movsx	eax, [ebp+var_1C5]
		add	eax, 20h ; ' '
		mov	ecx, [ebp+var_1A4]
		add	ecx, [ebp+var_1BC]
		mov	[ecx], al
		jmp	loc_6AE0
; ---------------------------------------------------------------------------

loc_69A5:				; CODE XREF: icu_56::UTS46::processUTF8(icu_56::StringPiece const &,signed char,signed char,icu_56::ByteSink &,icu_56::IDNAInfo	&,UErrorCode &)+25Ej
		cmp	[ebp+var_1D4], 0
		jge	short loc_69C3
		movsx	eax, [ebp+var_1AD]
		test	eax, eax
		jz	short loc_69C3
		jmp	loc_6AE5
; ---------------------------------------------------------------------------
		jmp	loc_6AE0
; ---------------------------------------------------------------------------

loc_69C3:				; CODE XREF: icu_56::UTS46::processUTF8(icu_56::StringPiece const &,signed char,signed char,icu_56::ByteSink &,icu_56::IDNAInfo	&,UErrorCode &)+284j
					; icu_56::UTS46::processUTF8(icu_56::StringPiece const &,signed	char,signed char,icu_56::ByteSink &,icu_56::IDNAInfo &,UErrorCode &)+28Fj
		mov	eax, [ebp+var_1A4]
		add	eax, [ebp+var_1BC]
		mov	cl, [ebp+var_1C5]
		mov	[eax], cl
		movsx	eax, [ebp+var_1C5]
		cmp	eax, 2Dh ; '-'
		jnz	short loc_6A5C
		mov	eax, [ebp+var_84]
		add	eax, 3
		cmp	[ebp+var_1BC], eax
		jnz	short loc_6A0B
		mov	eax, [ebp+var_24]
		add	eax, [ebp+var_1BC]
		movsx	ecx, byte ptr [eax-1]
		cmp	ecx, 2Dh ; '-'
		jnz	short loc_6A0B
		jmp	loc_6AE5
; ---------------------------------------------------------------------------

loc_6A0B:				; CODE XREF: icu_56::UTS46::processUTF8(icu_56::StringPiece const &,signed char,signed char,icu_56::ByteSink &,icu_56::IDNAInfo	&,UErrorCode &)+2CAj
					; icu_56::UTS46::processUTF8(icu_56::StringPiece const &,signed	char,signed char,icu_56::ByteSink &,icu_56::IDNAInfo &,UErrorCode &)+2DCj
		mov	eax, [ebp+var_1BC]
		cmp	eax, [ebp+var_84]
		jnz	short loc_6A28
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax+4]
		or	ecx, 8
		mov	edx, [ebp+arg_10]
		mov	[edx+4], ecx

loc_6A28:				; CODE XREF: icu_56::UTS46::processUTF8(icu_56::StringPiece const &,signed char,signed char,icu_56::ByteSink &,icu_56::IDNAInfo	&,UErrorCode &)+2EFj
		mov	eax, [ebp+var_1BC]
		add	eax, 1
		cmp	eax, [ebp+var_30]
		jz	short loc_6A48
		mov	eax, [ebp+var_24]
		add	eax, [ebp+var_1BC]
		movsx	ecx, byte ptr [eax+1]
		cmp	ecx, 2Eh ; '.'
		jnz	short loc_6A57

loc_6A48:				; CODE XREF: icu_56::UTS46::processUTF8(icu_56::StringPiece const &,signed char,signed char,icu_56::ByteSink &,icu_56::IDNAInfo	&,UErrorCode &)+30Cj
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax+4]
		or	ecx, 10h
		mov	edx, [ebp+arg_10]
		mov	[edx+4], ecx

loc_6A57:				; CODE XREF: icu_56::UTS46::processUTF8(icu_56::StringPiece const &,signed char,signed char,icu_56::ByteSink &,icu_56::IDNAInfo	&,UErrorCode &)+31Ej
		jmp	loc_6AE0
; ---------------------------------------------------------------------------

loc_6A5C:				; CODE XREF: icu_56::UTS46::processUTF8(icu_56::StringPiece const &,signed char,signed char,icu_56::ByteSink &,icu_56::IDNAInfo	&,UErrorCode &)+2B9j
		movsx	eax, [ebp+var_1C5]
		cmp	eax, 2Eh ; '.'
		jnz	short loc_6AE0
		movsx	eax, [ebp+arg_4]
		test	eax, eax
		jz	short loc_6A72
		jmp	short loc_6AE5
; ---------------------------------------------------------------------------

loc_6A72:				; CODE XREF: icu_56::UTS46::processUTF8(icu_56::StringPiece const &,signed char,signed char,icu_56::ByteSink &,icu_56::IDNAInfo	&,UErrorCode &)+346j
		mov	eax, [ebp+var_1BC]
		cmp	eax, [ebp+var_84]
		jnz	short loc_6A8F
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax+4]
		or	ecx, 1
		mov	edx, [ebp+arg_10]
		mov	[edx+4], ecx

loc_6A8F:				; CODE XREF: icu_56::UTS46::processUTF8(icu_56::StringPiece const &,signed char,signed char,icu_56::ByteSink &,icu_56::IDNAInfo	&,UErrorCode &)+356j
		movsx	eax, [ebp+arg_8]
		test	eax, eax
		jz	short loc_6AB7
		mov	eax, [ebp+var_1BC]
		sub	eax, [ebp+var_84]
		cmp	eax, 3Fh ; '?'
		jle	short loc_6AB7
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax+4]
		or	ecx, 2
		mov	edx, [ebp+arg_10]
		mov	[edx+4], ecx

loc_6AB7:				; CODE XREF: icu_56::UTS46::processUTF8(icu_56::StringPiece const &,signed char,signed char,icu_56::ByteSink &,icu_56::IDNAInfo	&,UErrorCode &)+36Dj
					; icu_56::UTS46::processUTF8(icu_56::StringPiece const &,signed	char,signed char,icu_56::ByteSink &,icu_56::IDNAInfo &,UErrorCode &)+37Ej
		mov	eax, [ebp+arg_10]
		mov	ecx, [ebp+arg_10]
		mov	edx, [eax]
		or	edx, [ecx+4]
		mov	eax, [ebp+arg_10]
		mov	[eax], edx
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+var_1BC]
		add	eax, 1
		mov	[ebp+var_84], eax

loc_6AE0:				; CODE XREF: icu_56::UTS46::processUTF8(icu_56::StringPiece const &,signed char,signed char,icu_56::ByteSink &,icu_56::IDNAInfo	&,UErrorCode &)+278j
					; icu_56::UTS46::processUTF8(icu_56::StringPiece const &,signed	char,signed char,icu_56::ByteSink &,icu_56::IDNAInfo &,UErrorCode &)+296j ...
		jmp	loc_686B
; ---------------------------------------------------------------------------

loc_6AE5:				; CODE XREF: icu_56::UTS46::processUTF8(icu_56::StringPiece const &,signed char,signed char,icu_56::ByteSink &,icu_56::IDNAInfo	&,UErrorCode &)+23Ej
					; icu_56::UTS46::processUTF8(icu_56::StringPiece const &,signed	char,signed char,icu_56::ByteSink &,icu_56::IDNAInfo &,UErrorCode &)+291j ...
		mov	eax, [ebp+arg_10]
		mov	ecx, [ebp+arg_10]
		mov	edx, [eax]
		or	edx, [ecx+4]
		mov	eax, [ebp+arg_10]
		mov	[eax], edx
		mov	eax, [ebp+var_1BC]
		sub	eax, [ebp+var_84]
		mov	dword ptr [ebp+var_1E0], eax
		mov	eax, dword ptr [ebp+var_1E0]
		push	eax		; int
		mov	ecx, [ebp+var_1A4]
		add	ecx, [ebp+var_84]
		push	ecx		; char *
		lea	ecx, [ebp+var_2CC] ; this
		call	??0StringPiece@icu_56@@QAE@PBDH@Z ; icu_56::StringPiece::StringPiece(char const	*,int)
		push	eax
		lea	edx, [ebp+var_3A4]
		push	edx
		call	?fromUTF8@UnicodeString@icu_56@@SA?AV12@ABVStringPiece@2@@Z ; icu_56::UnicodeString::fromUTF8(icu_56::StringPiece const	&)
		add	esp, 8
		mov	[ebp+var_3AC], eax
		mov	eax, [ebp+var_3AC]
		mov	[ebp+var_3B0], eax
		mov	byte ptr [ebp+var_4], 1
		mov	ecx, [ebp+var_3B0]
		push	ecx		; struct icu_56::UnicodeString *
		lea	ecx, [ebp+var_78]
		call	??4UnicodeString@icu_56@@QAEAAV01@$$QAV01@@Z ; icu_56::UnicodeString::operator=(icu_56::UnicodeString &&)
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_3A4] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		mov	esi, esp
		mov	eax, [ebp+var_84]
		push	eax
		mov	ecx, [ebp+var_1A4]
		push	ecx
		mov	edx, [ebp+arg_C]
		mov	eax, [edx]
		mov	ecx, [ebp+arg_C]
		mov	edx, [eax+4]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_14]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_10]
		push	ecx		; struct icu_56::IDNAInfo *
		lea	edx, [ebp+var_78]
		push	edx		; struct icu_56::UnicodeString *
		movzx	eax, [ebp+arg_8]
		push	eax		; char
		movzx	ecx, [ebp+arg_4]
		push	ecx		; char
		mov	edx, dword ptr [ebp+var_1E0]
		push	edx		; int
		push	0		; int
		mov	eax, [ebp+var_84]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::StringPiece *
		lea	ecx, [ebp+var_2BC] ; this
		call	??0StringPiece@icu_56@@QAE@ABV01@H@Z ; icu_56::StringPiece::StringPiece(icu_56::StringPiece const &,int)
		push	eax
		lea	edx, [ebp+var_35C]
		push	edx
		call	?fromUTF8@UnicodeString@icu_56@@SA?AV12@ABVStringPiece@2@@Z ; icu_56::UnicodeString::fromUTF8(icu_56::StringPiece const	&)
		add	esp, 8
		mov	[ebp+var_3AC], eax
		mov	eax, [ebp+var_3AC]
		mov	[ebp+var_3B0], eax
		mov	byte ptr [ebp+var_4], 2
		mov	ecx, [ebp+var_3B0]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_18] ; this
		call	?processUnicode@UTS46@icu_56@@ABEAAVUnicodeString@2@ABV32@HHCCAAV32@AAVIDNAInfo@2@AAW4UErrorCode@@@Z ; icu_56::UTS46::processUnicode(icu_56::UnicodeString const &,int,int,signed char,signed char,icu_56::UnicodeString &,icu_56::IDNAInfo &,UErrorCode &)
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_35C] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		jmp	short loc_6C6A
; ---------------------------------------------------------------------------

loc_6C09:				; CODE XREF: icu_56::UTS46::processUTF8(icu_56::StringPiece const &,signed char,signed char,icu_56::ByteSink &,icu_56::IDNAInfo	&,UErrorCode &)+E5j
		mov	eax, [ebp+arg_14]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_10]
		push	ecx		; struct icu_56::IDNAInfo *
		lea	edx, [ebp+var_78]
		push	edx		; struct icu_56::UnicodeString *
		movzx	eax, [ebp+arg_8]
		push	eax		; char
		movzx	ecx, [ebp+arg_4]
		push	ecx		; char
		push	0		; int
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx
		lea	eax, [ebp+var_314]
		push	eax
		call	?fromUTF8@UnicodeString@icu_56@@SA?AV12@ABVStringPiece@2@@Z ; icu_56::UnicodeString::fromUTF8(icu_56::StringPiece const	&)
		add	esp, 8
		mov	[ebp+var_3AC], eax
		mov	ecx, [ebp+var_3AC]
		mov	[ebp+var_3B0], ecx
		mov	byte ptr [ebp+var_4], 3
		mov	edx, [ebp+var_3B0]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_18] ; this
		call	?processUnicode@UTS46@icu_56@@ABEAAVUnicodeString@2@ABV32@HHCCAAV32@AAVIDNAInfo@2@AAW4UErrorCode@@@Z ; icu_56::UTS46::processUnicode(icu_56::UnicodeString const &,int,int,signed char,signed char,icu_56::UnicodeString &,icu_56::IDNAInfo &,UErrorCode &)
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_314] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)

loc_6C6A:				; CODE XREF: icu_56::UTS46::processUTF8(icu_56::StringPiece const &,signed char,signed char,icu_56::ByteSink &,icu_56::IDNAInfo	&,UErrorCode &)+4DFj
		mov	eax, [ebp+arg_C]
		push	eax		; struct icu_56::ByteSink *
		lea	ecx, [ebp+var_78] ; this
		call	?toUTF8@UnicodeString@icu_56@@QBEXAAVByteSink@2@@Z ; icu_56::UnicodeString::toUTF8(icu_56::ByteSink &)
		movsx	eax, [ebp+arg_8]
		test	eax, eax
		jz	short loc_6CFA
		movsx	eax, [ebp+arg_4]
		test	eax, eax
		jnz	short loc_6CFA
		lea	ecx, [ebp+var_78] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		add	eax, [ebp+var_84]
		mov	[ebp+var_1EC], eax
		cmp	[ebp+var_1EC], 0FEh ; ''
		jl	short loc_6CFA
		lea	eax, [ebp+var_78]
		push	eax		; icu_56::UnicodeString	*
		call	?isASCIIString@icu_56@@YACABVUnicodeString@1@@Z	; icu_56::isASCIIString(icu_56::UnicodeString const &)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_6CFA
		cmp	[ebp+var_1EC], 0FEh ; ''
		jg	short loc_6CED
		cmp	[ebp+var_84], 0FEh ; ''
		jge	short loc_6CFA
		mov	eax, 0FDh ; ''
		sub	eax, [ebp+var_84]
		push	eax
		lea	ecx, [ebp+var_78]
		call	??AUnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::operator[](int)
		movzx	ecx, ax
		cmp	ecx, 2Eh ; '.'
		jz	short loc_6CFA

loc_6CED:				; CODE XREF: icu_56::UTS46::processUTF8(icu_56::StringPiece const &,signed char,signed char,icu_56::ByteSink &,icu_56::IDNAInfo	&,UErrorCode &)+59Bj
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		or	ecx, 4
		mov	edx, [ebp+arg_10]
		mov	[edx], ecx

loc_6CFA:				; CODE XREF: icu_56::UTS46::processUTF8(icu_56::StringPiece const &,signed char,signed char,icu_56::ByteSink &,icu_56::IDNAInfo	&,UErrorCode &)+554j
					; icu_56::UTS46::processUTF8(icu_56::StringPiece const &,signed	char,signed char,icu_56::ByteSink &,icu_56::IDNAInfo &,UErrorCode &)+55Cj ...
		mov	eax, [ebp+arg_10]
		movsx	ecx, byte ptr [eax+9]
		test	ecx, ecx
		jz	short loc_6D65
		mov	eax, [ebp+arg_14]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_6D65
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		and	ecx, 7C0h
		jnz	short loc_6D65
		mov	eax, [ebp+arg_10]
		movsx	ecx, byte ptr [eax+0Ah]
		test	ecx, ecx
		jz	short loc_6D55
		cmp	[ebp+var_84], 0
		jle	short loc_6D65
		mov	eax, [ebp+var_84]
		push	eax
		mov	ecx, [ebp+var_24]
		push	ecx
		call	?isASCIIOkBiDi@icu_56@@YACPBDH@Z ; icu_56::isASCIIOkBiDi(char const *,int)
		add	esp, 8
		movsx	edx, al
		test	edx, edx
		jnz	short loc_6D65

loc_6D55:				; CODE XREF: icu_56::UTS46::processUTF8(icu_56::StringPiece const &,signed char,signed char,icu_56::ByteSink &,icu_56::IDNAInfo	&,UErrorCode &)+608j
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		or	ecx, 800h
		mov	edx, [ebp+arg_10]
		mov	[edx], ecx

loc_6D65:				; CODE XREF: icu_56::UTS46::processUTF8(icu_56::StringPiece const &,signed char,signed char,icu_56::ByteSink &,icu_56::IDNAInfo	&,UErrorCode &)+5DBj
					; icu_56::UTS46::processUTF8(icu_56::StringPiece const &,signed	char,signed char,icu_56::ByteSink &,icu_56::IDNAInfo &,UErrorCode &)+5F0j ...
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_78] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)

loc_6D74:				; CODE XREF: icu_56::UTS46::processUTF8(icu_56::StringPiece const &,signed char,signed char,icu_56::ByteSink &,icu_56::IDNAInfo	&,UErrorCode &)+5Aj
					; icu_56::UTS46::processUTF8(icu_56::StringPiece const &,signed	char,signed char,icu_56::ByteSink &,icu_56::IDNAInfo &,UErrorCode &)+8Aj ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN45
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 3B0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	18h
?processUTF8@UTS46@icu_56@@ABEXABVStringPiece@2@CCAAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
$LN45		dd 3			; DATA XREF: icu_56::UTS46::processUTF8(icu_56::StringPiece const &,signed char,signed char,icu_56::ByteSink &,icu_56::IDNAInfo	&,UErrorCode &)+650o
		dd offset $LN44
$LN44		db 88h,	0FFh		; DATA XREF: .text:00006DB4o
		dw 0FFFFh
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset $LN40		; "destString"
		dd 0FFFFFE74h, 100h
		dd offset $LN41		; "stackArray"
		dd 0FFFFFE68h, 4
		dd offset $LN42		; "destCapacity"
$LN42		db 'destCapacity',0     ; DATA XREF: .text:00006DD8o
$LN41		db 'stackArray',0       ; DATA XREF: .text:00006DCCo
$LN40		db 'destString',0       ; DATA XREF: .text:00006DC0o
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 6E00h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?processUTF8@UTS46@icu_56@@ABEXABVStringPiece@2@CCAAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z$0 proc	near
					; DATA XREF: .xdata$x:00006E58o
		lea	ecx, [ebp-78h]	; this
		jmp	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
__unwindfunclet$?processUTF8@UTS46@icu_56@@ABEXABVStringPiece@2@CCAAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?processUTF8@UTS46@icu_56@@ABEXABVStringPiece@2@CCAAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z$1 proc	near
					; DATA XREF: .xdata$x:00006E60o
		lea	ecx, [ebp-3A4h]	; this
		jmp	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
__unwindfunclet$?processUTF8@UTS46@icu_56@@ABEXABVStringPiece@2@CCAAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?processUTF8@UTS46@icu_56@@ABEXABVStringPiece@2@CCAAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z$2 proc	near
					; DATA XREF: .xdata$x:00006E68o
		lea	ecx, [ebp-35Ch]	; this
		jmp	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
__unwindfunclet$?processUTF8@UTS46@icu_56@@ABEXABVStringPiece@2@CCAAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z$2 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?processUTF8@UTS46@icu_56@@ABEXABVStringPiece@2@CCAAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z$3 proc	near
					; DATA XREF: .xdata$x:00006E70o
		lea	ecx, [ebp-314h]	; this
		jmp	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
__unwindfunclet$?processUTF8@UTS46@icu_56@@ABEXABVStringPiece@2@CCAAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z$3 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?processUTF8@UTS46@icu_56@@ABEXABVStringPiece@2@CCAAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::UTS46::processUTF8(icu_56::StringPiece const &,signed char,signed char,icu_56::ByteSink &,icu_56::IDNAInfo	&,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-3B4h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?processUTF8@UTS46@icu_56@@ABEXABVStringPiece@2@CCAAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?processUTF8@UTS46@icu_56@@ABEXABVStringPiece@2@CCAAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 6E54h
__unwindtable$?processUTF8@UTS46@icu_56@@ABEXABVStringPiece@2@CCAAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00006E7Co
		dd offset __unwindfunclet$?processUTF8@UTS46@icu_56@@ABEXABVStringPiece@2@CCAAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z$0
		align 10h
		dd offset __unwindfunclet$?processUTF8@UTS46@icu_56@@ABEXABVStringPiece@2@CCAAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z$1
		align 8
		dd offset __unwindfunclet$?processUTF8@UTS46@icu_56@@ABEXABVStringPiece@2@CCAAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z$2
		align 10h
		dd offset __unwindfunclet$?processUTF8@UTS46@icu_56@@ABEXABVStringPiece@2@CCAAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z$3
__ehfuncinfo$?processUTF8@UTS46@icu_56@@ABEXABVStringPiece@2@CCAAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z dd 19930522h, 4
					; DATA XREF: __ehhandler$?processUTF8@UTS46@icu_56@@ABEXABVStringPiece@2@CCAAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z+1Eo
		dd offset __unwindtable$?processUTF8@UTS46@icu_56@@ABEXABVStringPiece@2@CCAAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6E98h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UTS46::processUnicode(icu_56::UTS46 *this, const struct icu_56::UnicodeString *, int, int, char, char, struct icu_56::UnicodeString *, struct icu_56::IDNAInfo *, enum UErrorCode *)
		public ?processUnicode@UTS46@icu_56@@ABEAAVUnicodeString@2@ABV32@HHCCAAV32@AAVIDNAInfo@2@AAW4UErrorCode@@@Z
?processUnicode@UTS46@icu_56@@ABEAAVUnicodeString@2@ABV32@HHCCAAV32@AAVIDNAInfo@2@AAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::UTS46::process(icu_56::UnicodeString const	&,signed char,signed char,icu_56::UnicodeString	&,icu_56::IDNAInfo &,UErrorCode	&)+31Ap
					; icu_56::UTS46::processUTF8(icu_56::StringPiece const &,signed	char,signed char,icu_56::ByteSink &,icu_56::IDNAInfo &,UErrorCode &)+4CBp ...

var_180		= dword	ptr -180h
var_17C		= dword	ptr -17Ch
var_174		= byte ptr -174h
var_6C		= dword	ptr -6Ch
var_60		= dword	ptr -60h
var_54		= word ptr -54h
var_48		= dword	ptr -48h
var_3C		= dword	ptr -3Ch
var_30		= dword	ptr -30h
var_21		= byte ptr -21h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= byte ptr  14h
arg_10		= byte ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h
arg_1C		= dword	ptr  24h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?processUnicode@UTS46@icu_56@@ABEAAVUnicodeString@2@ABV32@HHCCAAV32@AAVIDNAInfo@2@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 174h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_180]
		mov	ecx, 5Dh ; ']'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		cmp	[ebp+arg_8], 0
		jnz	short loc_6F0F
		mov	esi, esp
		mov	eax, [ebp+arg_1C]
		push	eax
		mov	ecx, [ebp+arg_14]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+4]
		mov	edx, [ebp+var_18]
		mov	eax, [edx+4]
		mov	edx, [ecx]
		mov	ecx, eax
		mov	eax, [edx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_6F7F
; ---------------------------------------------------------------------------

loc_6F0F:				; CODE XREF: icu_56::UTS46::processUnicode(icu_56::UnicodeString const &,int,int,signed	char,signed char,icu_56::UnicodeString &,icu_56::IDNAInfo &,UErrorCode &)+49j
		mov	esi, esp
		mov	eax, [ebp+arg_1C]
		push	eax
		push	7FFFFFFFh
		mov	ecx, [ebp+arg_8]
		push	ecx
		lea	edx, [ebp+var_174]
		push	edx
		mov	ecx, [ebp+arg_0]
		call	?tempSubString@UnicodeString@icu_56@@QBE?AV12@HH@Z ; icu_56::UnicodeString::tempSubString(int,int)
		mov	[ebp+var_17C], eax
		mov	eax, [ebp+var_17C]
		mov	[ebp+var_180], eax
		mov	[ebp+var_4], 0
		mov	ecx, [ebp+var_180]
		push	ecx
		mov	edx, [ebp+arg_14]
		push	edx
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+4]
		mov	edx, [ebp+var_18]
		mov	eax, [edx+4]
		mov	edx, [ecx]
		mov	ecx, eax
		mov	eax, [edx+0Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_174] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)

loc_6F7F:				; CODE XREF: icu_56::UTS46::processUnicode(icu_56::UnicodeString const &,int,int,signed	char,signed char,icu_56::UnicodeString &,icu_56::IDNAInfo &,UErrorCode &)+75j
		mov	eax, [ebp+arg_1C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_6F9C
		mov	eax, [ebp+arg_14]
		jmp	loc_71AF
; ---------------------------------------------------------------------------

loc_6F9C:				; CODE XREF: icu_56::UTS46::processUnicode(icu_56::UnicodeString const &,int,int,signed	char,signed char,icu_56::UnicodeString &,icu_56::IDNAInfo &,UErrorCode &)+FAj
		movsx	eax, [ebp+arg_10]
		test	eax, eax
		jz	short loc_6FBC
		mov	ecx, [ebp+var_18]
		mov	edx, [ecx+8]
		and	edx, 10h
		neg	edx
		sbb	edx, edx
		add	edx, 1
		mov	[ebp+var_17C], edx
		jmp	short loc_6FD2
; ---------------------------------------------------------------------------

loc_6FBC:				; CODE XREF: icu_56::UTS46::processUnicode(icu_56::UnicodeString const &,int,int,signed	char,signed char,icu_56::UnicodeString &,icu_56::IDNAInfo &,UErrorCode &)+10Aj
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+8]
		and	ecx, 20h
		neg	ecx
		sbb	ecx, ecx
		add	ecx, 1
		mov	[ebp+var_17C], ecx

loc_6FD2:				; CODE XREF: icu_56::UTS46::processUnicode(icu_56::UnicodeString const &,int,int,signed	char,signed char,icu_56::UnicodeString &,icu_56::IDNAInfo &,UErrorCode &)+122j
		mov	dl, byte ptr [ebp+var_17C]
		mov	[ebp+var_21], dl
		mov	ecx, [ebp+arg_14] ; this
		call	?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ ; icu_56::UnicodeString::getBuffer(void)
		mov	[ebp+var_30], eax
		mov	ecx, [ebp+arg_14] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	[ebp+var_3C], eax
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_48], eax

loc_6FF7:				; CODE XREF: icu_56::UTS46::processUnicode(icu_56::UnicodeString const &,int,int,signed	char,signed char,icu_56::UnicodeString &,icu_56::IDNAInfo &,UErrorCode &):loc_7165j
		mov	eax, [ebp+var_48]
		cmp	eax, [ebp+var_3C]
		jge	loc_716A
		mov	eax, [ebp+var_48]
		mov	ecx, [ebp+var_30]
		mov	dx, [ecx+eax*2]
		mov	[ebp+var_54], dx
		movzx	eax, [ebp+var_54]
		cmp	eax, 2Eh ; '.'
		jnz	loc_70BD
		movsx	eax, [ebp+arg_C]
		test	eax, eax
		jnz	loc_70BD
		mov	eax, [ebp+var_48]
		sub	eax, [ebp+arg_4]
		mov	[ebp+var_60], eax
		mov	eax, [ebp+arg_1C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_18]
		push	ecx		; struct icu_56::IDNAInfo *
		movzx	edx, [ebp+arg_10]
		push	edx		; char
		mov	eax, [ebp+var_60]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_14]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_18] ; this
		call	?processLabel@UTS46@icu_56@@ABEHAAVUnicodeString@2@HHCAAVIDNAInfo@2@AAW4UErrorCode@@@Z ; icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed char,icu_56::IDNAInfo &,UErrorCode &)
		mov	[ebp+var_6C], eax
		mov	eax, [ebp+arg_18]
		mov	ecx, [ebp+arg_18]
		mov	edx, [eax]
		or	edx, [ecx+4]
		mov	eax, [ebp+arg_18]
		mov	[eax], edx
		mov	eax, [ebp+arg_18]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+arg_1C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_708E
		mov	eax, [ebp+arg_14]
		jmp	loc_71AF
; ---------------------------------------------------------------------------

loc_708E:				; CODE XREF: icu_56::UTS46::processUnicode(icu_56::UnicodeString const &,int,int,signed	char,signed char,icu_56::UnicodeString &,icu_56::IDNAInfo &,UErrorCode &)+1ECj
		mov	ecx, [ebp+arg_14] ; this
		call	?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ ; icu_56::UnicodeString::getBuffer(void)
		mov	[ebp+var_30], eax
		mov	eax, [ebp+var_6C]
		sub	eax, [ebp+var_60]
		add	eax, [ebp+var_3C]
		mov	[ebp+var_3C], eax
		mov	eax, [ebp+var_6C]
		mov	ecx, [ebp+arg_4]
		lea	edx, [ecx+eax+1]
		mov	[ebp+arg_4], edx
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_48], eax
		jmp	loc_7165
; ---------------------------------------------------------------------------

loc_70BD:				; CODE XREF: icu_56::UTS46::processUnicode(icu_56::UnicodeString const &,int,int,signed	char,signed char,icu_56::UnicodeString &,icu_56::IDNAInfo &,UErrorCode &)+180j
					; icu_56::UTS46::processUnicode(icu_56::UnicodeString const &,int,int,signed char,signed char,icu_56::UnicodeString &,icu_56::IDNAInfo &,UErrorCode &)+18Cj
		movzx	eax, [ebp+var_54]
		cmp	eax, 0DFh ; ''
		jl	loc_715C
		movzx	eax, [ebp+var_54]
		cmp	eax, 200Dh
		jg	loc_715C
		movzx	eax, [ebp+var_54]
		cmp	eax, 0DFh ; ''
		jz	short loc_70FC
		movzx	eax, [ebp+var_54]
		cmp	eax, 3C2h
		jz	short loc_70FC
		movzx	eax, [ebp+var_54]
		cmp	eax, 200Ch
		jl	short loc_715C

loc_70FC:				; CODE XREF: icu_56::UTS46::processUnicode(icu_56::UnicodeString const &,int,int,signed	char,signed char,icu_56::UnicodeString &,icu_56::IDNAInfo &,UErrorCode &)+24Cj
					; icu_56::UTS46::processUnicode(icu_56::UnicodeString const &,int,int,signed char,signed char,icu_56::UnicodeString &,icu_56::IDNAInfo &,UErrorCode &)+257j
		mov	eax, [ebp+arg_18]
		mov	byte ptr [eax+8], 1
		movsx	eax, [ebp+var_21]
		test	eax, eax
		jz	short loc_7151
		mov	eax, [ebp+arg_1C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_48]
		push	ecx		; int
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_14]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_18] ; this
		call	?mapDevChars@UTS46@icu_56@@ABEHAAVUnicodeString@2@HHAAW4UErrorCode@@@Z ; icu_56::UTS46::mapDevChars(icu_56::UnicodeString &,int,int,UErrorCode &)
		mov	[ebp+var_3C], eax
		mov	eax, [ebp+arg_1C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_7140
		mov	eax, [ebp+arg_14]
		jmp	short loc_71AF
; ---------------------------------------------------------------------------

loc_7140:				; CODE XREF: icu_56::UTS46::processUnicode(icu_56::UnicodeString const &,int,int,signed	char,signed char,icu_56::UnicodeString &,icu_56::IDNAInfo &,UErrorCode &)+2A1j
		mov	ecx, [ebp+arg_14] ; this
		call	?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ ; icu_56::UnicodeString::getBuffer(void)
		mov	[ebp+var_30], eax
		mov	[ebp+var_21], 0
		jmp	short loc_715A
; ---------------------------------------------------------------------------

loc_7151:				; CODE XREF: icu_56::UTS46::processUnicode(icu_56::UnicodeString const &,int,int,signed	char,signed char,icu_56::UnicodeString &,icu_56::IDNAInfo &,UErrorCode &)+271j
		mov	eax, [ebp+var_48]
		add	eax, 1
		mov	[ebp+var_48], eax

loc_715A:				; CODE XREF: icu_56::UTS46::processUnicode(icu_56::UnicodeString const &,int,int,signed	char,signed char,icu_56::UnicodeString &,icu_56::IDNAInfo &,UErrorCode &)+2B7j
		jmp	short loc_7165
; ---------------------------------------------------------------------------

loc_715C:				; CODE XREF: icu_56::UTS46::processUnicode(icu_56::UnicodeString const &,int,int,signed	char,signed char,icu_56::UnicodeString &,icu_56::IDNAInfo &,UErrorCode &)+22Ej
					; icu_56::UTS46::processUnicode(icu_56::UnicodeString const &,int,int,signed char,signed char,icu_56::UnicodeString &,icu_56::IDNAInfo &,UErrorCode &)+23Dj ...
		mov	eax, [ebp+var_48]
		add	eax, 1
		mov	[ebp+var_48], eax

loc_7165:				; CODE XREF: icu_56::UTS46::processUnicode(icu_56::UnicodeString const &,int,int,signed	char,signed char,icu_56::UnicodeString &,icu_56::IDNAInfo &,UErrorCode &)+220j
					; icu_56::UTS46::processUnicode(icu_56::UnicodeString const &,int,int,signed char,signed char,icu_56::UnicodeString &,icu_56::IDNAInfo &,UErrorCode &):loc_715Aj
		jmp	loc_6FF7
; ---------------------------------------------------------------------------

loc_716A:				; CODE XREF: icu_56::UTS46::processUnicode(icu_56::UnicodeString const &,int,int,signed	char,signed char,icu_56::UnicodeString &,icu_56::IDNAInfo &,UErrorCode &)+165j
		cmp	[ebp+arg_4], 0
		jz	short loc_7178
		mov	eax, [ebp+arg_4]
		cmp	eax, [ebp+var_48]
		jge	short loc_71AC

loc_7178:				; CODE XREF: icu_56::UTS46::processUnicode(icu_56::UnicodeString const &,int,int,signed	char,signed char,icu_56::UnicodeString &,icu_56::IDNAInfo &,UErrorCode &)+2D6j
		mov	eax, [ebp+arg_1C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_18]
		push	ecx		; struct icu_56::IDNAInfo *
		movzx	edx, [ebp+arg_10]
		push	edx		; char
		mov	eax, [ebp+var_48]
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_14]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_18] ; this
		call	?processLabel@UTS46@icu_56@@ABEHAAVUnicodeString@2@HHCAAVIDNAInfo@2@AAW4UErrorCode@@@Z ; icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed char,icu_56::IDNAInfo &,UErrorCode &)
		mov	eax, [ebp+arg_18]
		mov	ecx, [ebp+arg_18]
		mov	edx, [eax]
		or	edx, [ecx+4]
		mov	eax, [ebp+arg_18]
		mov	[eax], edx

loc_71AC:				; CODE XREF: icu_56::UTS46::processUnicode(icu_56::UnicodeString const &,int,int,signed	char,signed char,icu_56::UnicodeString &,icu_56::IDNAInfo &,UErrorCode &)+2DEj
		mov	eax, [ebp+arg_14]

loc_71AF:				; CODE XREF: icu_56::UTS46::processUnicode(icu_56::UnicodeString const &,int,int,signed	char,signed char,icu_56::UnicodeString &,icu_56::IDNAInfo &,UErrorCode &)+FFj
					; icu_56::UTS46::processUnicode(icu_56::UnicodeString const &,int,int,signed char,signed char,icu_56::UnicodeString &,icu_56::IDNAInfo &,UErrorCode &)+1F1j ...
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 180h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	20h
?processUnicode@UTS46@icu_56@@ABEAAVUnicodeString@2@ABV32@HHCCAAV32@AAVIDNAInfo@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 71DCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?processUnicode@UTS46@icu_56@@ABEAAVUnicodeString@2@ABV32@HHCCAAV32@AAVIDNAInfo@2@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:00007214o
		lea	ecx, [ebp-174h]	; this
		jmp	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
__unwindfunclet$?processUnicode@UTS46@icu_56@@ABEAAVUnicodeString@2@ABV32@HHCCAAV32@AAVIDNAInfo@2@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?processUnicode@UTS46@icu_56@@ABEAAVUnicodeString@2@ABV32@HHCCAAV32@AAVIDNAInfo@2@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::UTS46::processUnicode(icu_56::UnicodeString const &,int,int,signed	char,signed char,icu_56::UnicodeString &,icu_56::IDNAInfo &,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-184h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?processUnicode@UTS46@icu_56@@ABEAAVUnicodeString@2@ABV32@HHCCAAV32@AAVIDNAInfo@2@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?processUnicode@UTS46@icu_56@@ABEAAVUnicodeString@2@ABV32@HHCCAAV32@AAVIDNAInfo@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 7210h
__unwindtable$?processUnicode@UTS46@icu_56@@ABEAAVUnicodeString@2@ABV32@HHCCAAV32@AAVIDNAInfo@2@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00007220o
		dd offset __unwindfunclet$?processUnicode@UTS46@icu_56@@ABEAAVUnicodeString@2@ABV32@HHCCAAV32@AAVIDNAInfo@2@AAW4UErrorCode@@@Z$0
__ehfuncinfo$?processUnicode@UTS46@icu_56@@ABEAAVUnicodeString@2@ABV32@HHCCAAV32@AAVIDNAInfo@2@AAW4UErrorCode@@@Z dd 19930522h,	1
					; DATA XREF: __ehhandler$?processUnicode@UTS46@icu_56@@ABEAAVUnicodeString@2@ABV32@HHCCAAV32@AAVIDNAInfo@2@AAW4UErrorCode@@@Z+1Eo
		dd offset __unwindtable$?processUnicode@UTS46@icu_56@@ABEAAVUnicodeString@2@ABV32@HHCCAAV32@AAVIDNAInfo@2@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 723Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UTS46::mapDevChars(icu_56::UTS46 *this, struct	icu_56::UnicodeString *, int, int, enum	UErrorCode *)
		public ?mapDevChars@UTS46@icu_56@@ABEHAAVUnicodeString@2@HHAAW4UErrorCode@@@Z
?mapDevChars@UTS46@icu_56@@ABEHAAVUnicodeString@2@HHAAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::UTS46::processUnicode(icu_56::UnicodeString const &,int,int,signed	char,signed char,icu_56::UnicodeString &,icu_56::IDNAInfo &,UErrorCode &)+286p

var_1D4		= dword	ptr -1D4h
var_1D0		= dword	ptr -1D0h
var_1C8		= byte ptr -1C8h
var_180		= dword	ptr -180h
var_B4		= byte ptr -0B4h
var_6C		= word ptr -6Ch
var_60		= dword	ptr -60h
var_54		= dword	ptr -54h
var_45		= byte ptr -45h
var_3C		= dword	ptr -3Ch
var_30		= dword	ptr -30h
var_24		= dword	ptr -24h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?mapDevChars@UTS46@icu_56@@ABEHAAVUnicodeString@2@HHAAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 1C8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_1D4]
		mov	ecx, 72h ; 'r'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_729D
		xor	eax, eax
		jmp	loc_75B2
; ---------------------------------------------------------------------------

loc_729D:				; CODE XREF: icu_56::UTS46::mapDevChars(icu_56::UnicodeString &,int,int,UErrorCode &)+58j
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	[ebp+var_24], eax
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	??AUnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::operator[](int)
		movzx	ecx, ax
		cmp	ecx, 0DFh ; ''
		jnz	short loc_72CD
		mov	edx, [ebp+var_24]
		add	edx, 1
		mov	[ebp+var_1D0], edx
		jmp	short loc_72D6
; ---------------------------------------------------------------------------

loc_72CD:				; CODE XREF: icu_56::UTS46::mapDevChars(icu_56::UnicodeString &,int,int,UErrorCode &)+81j
		mov	eax, [ebp+var_24]
		mov	[ebp+var_1D0], eax

loc_72D6:				; CODE XREF: icu_56::UTS46::mapDevChars(icu_56::UnicodeString &,int,int,UErrorCode &)+8Fj
		mov	ecx, [ebp+var_1D0]
		push	ecx		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?getBuffer@UnicodeString@icu_56@@QAEPA_WH@Z ; icu_56::UnicodeString::getBuffer(int)
		mov	[ebp+var_30], eax
		cmp	[ebp+var_30], 0
		jnz	short loc_72FF
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 7
		mov	eax, [ebp+var_24]
		jmp	loc_75B2
; ---------------------------------------------------------------------------

loc_72FF:				; CODE XREF: icu_56::UTS46::mapDevChars(icu_56::UnicodeString &,int,int,UErrorCode &)+B0j
		mov	ecx, [ebp+arg_0] ; this
		call	?getCapacity@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::getCapacity(void)
		mov	[ebp+var_3C], eax
		mov	[ebp+var_45], 0
		mov	eax, [ebp+arg_8]
		mov	[ebp+var_54], eax
		mov	eax, [ebp+arg_8]
		mov	[ebp+var_60], eax

loc_731A:				; CODE XREF: icu_56::UTS46::mapDevChars(icu_56::UnicodeString &,int,int,UErrorCode &)+257j
		mov	eax, [ebp+var_54]
		mov	ecx, [ebp+var_30]
		mov	dx, [ecx+eax*2]
		mov	[ebp+var_6C], dx
		mov	eax, [ebp+var_54]
		add	eax, 1
		mov	[ebp+var_54], eax
		movzx	eax, [ebp+var_6C]
		mov	[ebp+var_1D0], eax
		cmp	[ebp+var_1D0], 3C2h
		jg	short loc_7368
		cmp	[ebp+var_1D0], 3C2h
		jz	loc_7449
		cmp	[ebp+var_1D0], 0DFh ; ''
		jz	short loc_738D
		jmp	loc_7476
; ---------------------------------------------------------------------------

loc_7368:				; CODE XREF: icu_56::UTS46::mapDevChars(icu_56::UnicodeString &,int,int,UErrorCode &)+109j
		cmp	[ebp+var_1D0], 200Ch
		jl	loc_7476
		cmp	[ebp+var_1D0], 200Dh
		jle	loc_7467
		jmp	loc_7476
; ---------------------------------------------------------------------------

loc_738D:				; CODE XREF: icu_56::UTS46::mapDevChars(icu_56::UnicodeString &,int,int,UErrorCode &)+125j
		mov	[ebp+var_45], 1
		mov	eax, 73h ; 's'
		mov	ecx, [ebp+var_60]
		mov	edx, [ebp+var_30]
		mov	[edx+ecx*2], ax
		mov	eax, [ebp+var_60]
		add	eax, 1
		mov	[ebp+var_60], eax
		mov	eax, [ebp+var_60]
		cmp	eax, [ebp+var_54]
		jnz	short loc_7426
		mov	eax, [ebp+var_24]
		cmp	eax, [ebp+var_3C]
		jnz	short loc_73F9
		mov	eax, [ebp+var_24]
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?releaseBuffer@UnicodeString@icu_56@@QAEXH@Z ; icu_56::UnicodeString::releaseBuffer(int)
		mov	eax, [ebp+var_24]
		add	eax, 1
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?getBuffer@UnicodeString@icu_56@@QAEPA_WH@Z ; icu_56::UnicodeString::getBuffer(int)
		mov	[ebp+var_30], eax
		cmp	[ebp+var_30], 0
		jnz	short loc_73EE
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 7
		mov	eax, [ebp+var_24]
		jmp	loc_75B2
; ---------------------------------------------------------------------------

loc_73EE:				; CODE XREF: icu_56::UTS46::mapDevChars(icu_56::UnicodeString &,int,int,UErrorCode &)+19Fj
		mov	ecx, [ebp+arg_0] ; this
		call	?getCapacity@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::getCapacity(void)
		mov	[ebp+var_3C], eax

loc_73F9:				; CODE XREF: icu_56::UTS46::mapDevChars(icu_56::UnicodeString &,int,int,UErrorCode &)+17Bj
		mov	eax, [ebp+var_24]
		sub	eax, [ebp+var_60]
		push	eax
		mov	ecx, [ebp+var_60]
		mov	edx, [ebp+var_30]
		lea	eax, [edx+ecx*2]
		push	eax
		mov	ecx, [ebp+var_60]
		mov	edx, [ebp+var_30]
		lea	eax, [edx+ecx*2+2]
		push	eax
		call	_u_memmove_56
		add	esp, 0Ch
		mov	eax, [ebp+var_54]
		add	eax, 1
		mov	[ebp+var_54], eax

loc_7426:				; CODE XREF: icu_56::UTS46::mapDevChars(icu_56::UnicodeString &,int,int,UErrorCode &)+173j
		mov	eax, 73h ; 's'
		mov	ecx, [ebp+var_60]
		mov	edx, [ebp+var_30]
		mov	[edx+ecx*2], ax
		mov	eax, [ebp+var_60]
		add	eax, 1
		mov	[ebp+var_60], eax
		mov	eax, [ebp+var_24]
		add	eax, 1
		mov	[ebp+var_24], eax
		jmp	short loc_748D
; ---------------------------------------------------------------------------

loc_7449:				; CODE XREF: icu_56::UTS46::mapDevChars(icu_56::UnicodeString &,int,int,UErrorCode &)+115j
		mov	[ebp+var_45], 1
		mov	eax, 3C3h
		mov	ecx, [ebp+var_60]
		mov	edx, [ebp+var_30]
		mov	[edx+ecx*2], ax
		mov	eax, [ebp+var_60]
		add	eax, 1
		mov	[ebp+var_60], eax
		jmp	short loc_748D
; ---------------------------------------------------------------------------

loc_7467:				; CODE XREF: icu_56::UTS46::mapDevChars(icu_56::UnicodeString &,int,int,UErrorCode &)+146j
		mov	[ebp+var_45], 1
		mov	eax, [ebp+var_24]
		sub	eax, 1
		mov	[ebp+var_24], eax
		jmp	short loc_748D
; ---------------------------------------------------------------------------

loc_7476:				; CODE XREF: icu_56::UTS46::mapDevChars(icu_56::UnicodeString &,int,int,UErrorCode &)+127j
					; icu_56::UTS46::mapDevChars(icu_56::UnicodeString &,int,int,UErrorCode	&)+136j ...
		mov	eax, [ebp+var_60]
		mov	ecx, [ebp+var_30]
		mov	dx, [ebp+var_6C]
		mov	[ecx+eax*2], dx
		mov	eax, [ebp+var_60]
		add	eax, 1
		mov	[ebp+var_60], eax

loc_748D:				; CODE XREF: icu_56::UTS46::mapDevChars(icu_56::UnicodeString &,int,int,UErrorCode &)+20Bj
					; icu_56::UTS46::mapDevChars(icu_56::UnicodeString &,int,int,UErrorCode	&)+229j ...
		mov	eax, [ebp+var_60]
		cmp	eax, [ebp+var_24]
		jl	loc_731A
		mov	eax, [ebp+var_24]
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?releaseBuffer@UnicodeString@icu_56@@QAEXH@Z ; icu_56::UnicodeString::releaseBuffer(int)
		movsx	eax, [ebp+var_45]
		test	eax, eax
		jz	loc_75AF
		lea	ecx, [ebp+var_B4] ; this
		call	??0UnicodeString@icu_56@@QAE@XZ	; icu_56::UnicodeString::UnicodeString(void)
		mov	[ebp+var_4], 0
		mov	esi, esp
		mov	eax, [ebp+arg_C]
		push	eax
		lea	ecx, [ebp+var_B4]
		push	ecx
		push	7FFFFFFFh
		mov	edx, [ebp+arg_4]
		push	edx
		lea	eax, [ebp+var_1C8]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	?tempSubString@UnicodeString@icu_56@@QBE?AV12@HH@Z ; icu_56::UnicodeString::tempSubString(int,int)
		mov	[ebp+var_1D0], eax
		mov	ecx, [ebp+var_1D0]
		mov	[ebp+var_1D4], ecx
		mov	byte ptr [ebp+var_4], 1
		mov	edx, [ebp+var_1D4]
		push	edx
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+4]
		mov	edx, [ebp+var_18]
		mov	eax, [edx+4]
		mov	edx, [ecx]
		mov	ecx, eax
		mov	eax, [edx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_1C8] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_759D
		lea	eax, [ebp+var_B4]
		push	eax		; struct icu_56::UnicodeString *
		push	7FFFFFFFh	; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@@Z ; icu_56::UnicodeString::replace(int,int,icu_56::UnicodeString const	&)
		mov	ecx, [ebp+arg_0] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_7575
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 7

loc_7575:				; CODE XREF: icu_56::UTS46::mapDevChars(icu_56::UnicodeString &,int,int,UErrorCode &)+32Ej
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	[ebp+var_180], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_B4] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		mov	eax, [ebp+var_180]
		jmp	short loc_75B2
; ---------------------------------------------------------------------------

loc_759D:				; CODE XREF: icu_56::UTS46::mapDevChars(icu_56::UnicodeString &,int,int,UErrorCode &)+307j
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_B4] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)

loc_75AF:				; CODE XREF: icu_56::UTS46::mapDevChars(icu_56::UnicodeString &,int,int,UErrorCode &)+26Fj
		mov	eax, [ebp+var_24]

loc_75B2:				; CODE XREF: icu_56::UTS46::mapDevChars(icu_56::UnicodeString &,int,int,UErrorCode &)+5Cj
					; icu_56::UTS46::mapDevChars(icu_56::UnicodeString &,int,int,UErrorCode	&)+BEj	...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN28
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 1D4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?mapDevChars@UTS46@icu_56@@ABEHAAVUnicodeString@2@HHAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
$LN28		dd 1			; DATA XREF: icu_56::UTS46::mapDevChars(icu_56::UnicodeString &,int,int,UErrorCode &)+37Ao
		dd offset $LN27
$LN27		dd 0FFFFFF4Ch, 40h	; DATA XREF: .text:000075F4o
		dd offset $LN25		; "normalized"
$LN25		db 'normalized',0       ; DATA XREF: .text:00007600o
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 7610h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?mapDevChars@UTS46@icu_56@@ABEHAAVUnicodeString@2@HHAAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:00007654o
		lea	ecx, [ebp-0B4h]	; this
		jmp	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
__unwindfunclet$?mapDevChars@UTS46@icu_56@@ABEHAAVUnicodeString@2@HHAAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?mapDevChars@UTS46@icu_56@@ABEHAAVUnicodeString@2@HHAAW4UErrorCode@@@Z$1 proc near
					; DATA XREF: .xdata$x:0000765Co
		lea	ecx, [ebp-1C8h]	; this
		jmp	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
__unwindfunclet$?mapDevChars@UTS46@icu_56@@ABEHAAVUnicodeString@2@HHAAW4UErrorCode@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?mapDevChars@UTS46@icu_56@@ABEHAAVUnicodeString@2@HHAAW4UErrorCode@@@Z proc	near
					; DATA XREF: icu_56::UTS46::mapDevChars(icu_56::UnicodeString &,int,int,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-1D8h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?mapDevChars@UTS46@icu_56@@ABEHAAVUnicodeString@2@HHAAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?mapDevChars@UTS46@icu_56@@ABEHAAVUnicodeString@2@HHAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 7650h
__unwindtable$?mapDevChars@UTS46@icu_56@@ABEHAAVUnicodeString@2@HHAAW4UErrorCode@@@Z dd	0FFFFFFFFh
					; DATA XREF: .xdata$x:00007668o
		dd offset __unwindfunclet$?mapDevChars@UTS46@icu_56@@ABEHAAVUnicodeString@2@HHAAW4UErrorCode@@@Z$0
		dd 0
		dd offset __unwindfunclet$?mapDevChars@UTS46@icu_56@@ABEHAAVUnicodeString@2@HHAAW4UErrorCode@@@Z$1
__ehfuncinfo$?mapDevChars@UTS46@icu_56@@ABEHAAVUnicodeString@2@HHAAW4UErrorCode@@@Z dd 19930522h, 2
					; DATA XREF: __ehhandler$?mapDevChars@UTS46@icu_56@@ABEHAAVUnicodeString@2@HHAAW4UErrorCode@@@Z+1Eo
		dd offset __unwindtable$?mapDevChars@UTS46@icu_56@@ABEHAAVUnicodeString@2@HHAAW4UErrorCode@@@Z
		align 20h
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7684h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UTS46::processLabel(icu_56::UTS46 *this, struct icu_56::UnicodeString *, int, int, char, struct icu_56::IDNAInfo *, enum UErrorCode *)
		public ?processLabel@UTS46@icu_56@@ABEHAAVUnicodeString@2@HHCAAVIDNAInfo@2@AAW4UErrorCode@@@Z
?processLabel@UTS46@icu_56@@ABEHAAVUnicodeString@2@HHCAAVIDNAInfo@2@AAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::UTS46::processUnicode(icu_56::UnicodeString const &,int,int,signed	char,signed char,icu_56::UnicodeString &,icu_56::IDNAInfo &,UErrorCode &)+1B7p
					; icu_56::UTS46::processUnicode(icu_56::UnicodeString const &,int,int,signed char,signed char,icu_56::UnicodeString &,icu_56::IDNAInfo &,UErrorCode &)+2FFp

var_2E0		= byte ptr -2E0h
var_2DC		= dword	ptr -2DCh
var_2D0		= dword	ptr -2D0h
var_2C4		= dword	ptr -2C4h
var_2B8		= dword	ptr -2B8h
var_2AC		= dword	ptr -2ACh
var_2A0		= dword	ptr -2A0h
var_294		= dword	ptr -294h
var_288		= dword	ptr -288h
var_27C		= dword	ptr -27Ch
var_270		= dword	ptr -270h
var_264		= dword	ptr -264h
var_258		= dword	ptr -258h
var_24C		= dword	ptr -24Ch
var_180		= dword	ptr -180h
var_174		= dword	ptr -174h
var_168		= byte ptr -168h
var_120		= dword	ptr -120h
var_114		= dword	ptr -114h
var_108		= word ptr -108h
var_F9		= byte ptr -0F9h
var_F0		= word ptr -0F0h
var_E4		= dword	ptr -0E4h
var_D8		= dword	ptr -0D8h
var_C9		= byte ptr -0C9h
var_C0		= dword	ptr -0C0h
var_B4		= dword	ptr -0B4h
var_A8		= dword	ptr -0A8h
var_99		= byte ptr -99h
var_90		= dword	ptr -90h
var_84		= dword	ptr -84h
var_78		= dword	ptr -78h
var_6C		= dword	ptr -6Ch
var_60		= byte ptr -60h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= byte ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?processLabel@UTS46@icu_56@@ABEHAAVUnicodeString@2@HHCAAVIDNAInfo@2@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 2D4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_2E0]
		mov	ecx, 0B5h ; ''
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		mov	eax, [ebp+arg_14]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_76E5
		xor	eax, eax
		jmp	loc_814B
; ---------------------------------------------------------------------------

loc_76E5:				; CODE XREF: icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed	char,icu_56::IDNAInfo &,UErrorCode &)+58j
		lea	ecx, [ebp+var_60] ; this
		call	??0UnicodeString@icu_56@@QAE@XZ	; icu_56::UnicodeString::UnicodeString(void)
		mov	[ebp+var_4], 0
		mov	ecx, [ebp+arg_0] ; this
		call	?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ ; icu_56::UnicodeString::getBuffer(void)
		mov	ecx, [ebp+arg_4]
		lea	edx, [eax+ecx*2]
		mov	[ebp+var_78], edx
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_84], eax
		mov	eax, [ebp+arg_8]
		mov	[ebp+var_90], eax
		cmp	[ebp+arg_8], 4
		jl	loc_79E8
		mov	eax, [ebp+var_78]
		movzx	ecx, word ptr [eax]
		cmp	ecx, 78h ; 'x'
		jnz	loc_79E8
		mov	eax, [ebp+var_78]
		movzx	ecx, word ptr [eax+2]
		cmp	ecx, 6Eh ; 'n'
		jnz	loc_79E8
		mov	eax, [ebp+var_78]
		movzx	ecx, word ptr [eax+4]
		cmp	ecx, 2Dh ; '-'
		jnz	loc_79E8
		mov	eax, [ebp+var_78]
		movzx	ecx, word ptr [eax+6]
		cmp	ecx, 2Dh ; '-'
		jnz	loc_79E8
		mov	[ebp+var_99], 1
		push	0FFFFFFFFh	; int
		lea	ecx, [ebp+var_60] ; this
		call	?getBuffer@UnicodeString@icu_56@@QAEPA_WH@Z ; icu_56::UnicodeString::getBuffer(int)
		mov	[ebp+var_A8], eax
		cmp	[ebp+var_A8], 0
		jnz	short loc_77AC
		mov	eax, [ebp+arg_14]
		mov	dword ptr [eax], 7
		mov	eax, [ebp+arg_8]
		mov	[ebp+var_2B8], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_60] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		mov	eax, [ebp+var_2B8]
		jmp	loc_814B
; ---------------------------------------------------------------------------

loc_77AC:				; CODE XREF: icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed	char,icu_56::IDNAInfo &,UErrorCode &)+FAj
		mov	[ebp+var_B4], 0
		lea	eax, [ebp+var_B4]
		push	eax
		push	0
		lea	ecx, [ebp+var_60] ; this
		call	?getCapacity@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::getCapacity(void)
		push	eax
		mov	ecx, [ebp+var_A8]
		push	ecx
		mov	edx, [ebp+arg_8]
		sub	edx, 4
		push	edx
		mov	eax, [ebp+var_78]
		add	eax, 8
		push	eax
		call	_u_strFromPunycode_56
		add	esp, 18h
		mov	[ebp+var_C0], eax
		cmp	[ebp+var_B4], 0Fh
		jnz	loc_788B
		push	0		; int
		lea	ecx, [ebp+var_60] ; this
		call	?releaseBuffer@UnicodeString@icu_56@@QAEXH@Z ; icu_56::UnicodeString::releaseBuffer(int)
		mov	eax, [ebp+var_C0]
		push	eax		; int
		lea	ecx, [ebp+var_60] ; this
		call	?getBuffer@UnicodeString@icu_56@@QAEPA_WH@Z ; icu_56::UnicodeString::getBuffer(int)
		mov	[ebp+var_A8], eax
		cmp	[ebp+var_A8], 0
		jnz	short loc_784C
		mov	eax, [ebp+arg_14]
		mov	dword ptr [eax], 7
		mov	eax, [ebp+arg_8]
		mov	[ebp+var_2AC], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_60] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		mov	eax, [ebp+var_2AC]
		jmp	loc_814B
; ---------------------------------------------------------------------------

loc_784C:				; CODE XREF: icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed	char,icu_56::IDNAInfo &,UErrorCode &)+19Aj
		mov	[ebp+var_B4], 0
		lea	eax, [ebp+var_B4]
		push	eax
		push	0
		lea	ecx, [ebp+var_60] ; this
		call	?getCapacity@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::getCapacity(void)
		push	eax
		mov	ecx, [ebp+var_A8]
		push	ecx
		mov	edx, [ebp+arg_8]
		sub	edx, 4
		push	edx
		mov	eax, [ebp+var_78]
		add	eax, 8
		push	eax
		call	_u_strFromPunycode_56
		add	esp, 18h
		mov	[ebp+var_C0], eax

loc_788B:				; CODE XREF: icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed	char,icu_56::IDNAInfo &,UErrorCode &)+16Ej
		mov	eax, [ebp+var_C0]
		push	eax		; int
		lea	ecx, [ebp+var_60] ; this
		call	?releaseBuffer@UnicodeString@icu_56@@QAEXH@Z ; icu_56::UnicodeString::releaseBuffer(int)
		mov	eax, [ebp+var_B4]
		push	eax
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_7903
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax+4]
		or	ecx, 100h
		mov	edx, [ebp+arg_10]
		mov	[edx+4], ecx
		mov	eax, [ebp+arg_14]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_10]
		push	ecx		; struct icu_56::IDNAInfo *
		movzx	edx, [ebp+arg_C]
		push	edx		; char
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_18] ; this
		call	?markBadACELabel@UTS46@icu_56@@ABEHAAVUnicodeString@2@HHCAAVIDNAInfo@2@AAW4UErrorCode@@@Z ; icu_56::UTS46::markBadACELabel(icu_56::UnicodeString &,int,int,signed char,icu_56::IDNAInfo	&,UErrorCode &)
		mov	[ebp+var_2A0], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_60] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		mov	eax, [ebp+var_2A0]
		jmp	loc_814B
; ---------------------------------------------------------------------------

loc_7903:				; CODE XREF: icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed	char,icu_56::IDNAInfo &,UErrorCode &)+22Aj
		mov	esi, esp
		mov	eax, [ebp+arg_14]
		push	eax
		lea	ecx, [ebp+var_60]
		push	ecx
		mov	edx, [ebp+var_18]
		mov	eax, [edx+4]
		mov	ecx, [ebp+var_18]
		mov	ecx, [ecx+4]
		mov	edx, [eax]
		mov	eax, [edx+24h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_C9], al
		mov	eax, [ebp+arg_14]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_7965
		mov	eax, [ebp+arg_8]
		mov	[ebp+var_294], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_60] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		mov	eax, [ebp+var_294]
		jmp	loc_814B
; ---------------------------------------------------------------------------

loc_7965:				; CODE XREF: icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed	char,icu_56::IDNAInfo &,UErrorCode &)+2BCj
		movsx	eax, [ebp+var_C9]
		test	eax, eax
		jnz	short loc_79C3
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax+4]
		or	ecx, 400h
		mov	edx, [ebp+arg_10]
		mov	[edx+4], ecx
		mov	eax, [ebp+arg_14]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_10]
		push	ecx		; struct icu_56::IDNAInfo *
		movzx	edx, [ebp+arg_C]
		push	edx		; char
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_18] ; this
		call	?markBadACELabel@UTS46@icu_56@@ABEHAAVUnicodeString@2@HHCAAVIDNAInfo@2@AAW4UErrorCode@@@Z ; icu_56::UTS46::markBadACELabel(icu_56::UnicodeString &,int,int,signed char,icu_56::IDNAInfo	&,UErrorCode &)
		mov	[ebp+var_288], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_60] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		mov	eax, [ebp+var_288]
		jmp	loc_814B
; ---------------------------------------------------------------------------

loc_79C3:				; CODE XREF: icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed	char,icu_56::IDNAInfo &,UErrorCode &)+2EAj
		lea	eax, [ebp+var_60]
		mov	[ebp+var_6C], eax
		lea	ecx, [ebp+var_60] ; this
		call	?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ ; icu_56::UnicodeString::getBuffer(void)
		mov	[ebp+var_78], eax
		mov	[ebp+arg_4], 0
		lea	ecx, [ebp+var_60] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	[ebp+arg_8], eax
		jmp	short loc_79F5
; ---------------------------------------------------------------------------

loc_79E8:				; CODE XREF: icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed	char,icu_56::IDNAInfo &,UErrorCode &)+97j
					; icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed char,icu_56::IDNAInfo &,UErrorCode	&)+A6j	...
		mov	[ebp+var_99], 0
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_6C], eax

loc_79F5:				; CODE XREF: icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed	char,icu_56::IDNAInfo &,UErrorCode &)+362j
		cmp	[ebp+arg_8], 0
		jnz	short loc_7A50
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax+4]
		or	ecx, 1
		mov	edx, [ebp+arg_10]
		mov	[edx+4], ecx
		mov	eax, [ebp+arg_14]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+var_6C]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+var_90]
		push	eax		; int
		mov	ecx, [ebp+var_84]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; icu_56::UnicodeString	*
		call	?replaceLabel@icu_56@@YAHAAVUnicodeString@1@HHABV21@HAAW4UErrorCode@@@Z	; icu_56::replaceLabel(icu_56::UnicodeString &,int,int,icu_56::UnicodeString const &,int,UErrorCode &)
		add	esp, 18h
		mov	[ebp+var_27C], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_60] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		mov	eax, [ebp+var_27C]
		jmp	loc_814B
; ---------------------------------------------------------------------------

loc_7A50:				; CODE XREF: icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed	char,icu_56::IDNAInfo &,UErrorCode &)+375j
		cmp	[ebp+arg_8], 4
		jl	short loc_7A7D
		mov	eax, [ebp+var_78]
		movzx	ecx, word ptr [eax+4]
		cmp	ecx, 2Dh ; '-'
		jnz	short loc_7A7D
		mov	eax, [ebp+var_78]
		movzx	ecx, word ptr [eax+6]
		cmp	ecx, 2Dh ; '-'
		jnz	short loc_7A7D
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax+4]
		or	ecx, 20h
		mov	edx, [ebp+arg_10]
		mov	[edx+4], ecx

loc_7A7D:				; CODE XREF: icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed	char,icu_56::IDNAInfo &,UErrorCode &)+3D0j
					; icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed char,icu_56::IDNAInfo &,UErrorCode	&)+3DCj ...
		mov	eax, [ebp+var_78]
		movzx	ecx, word ptr [eax]
		cmp	ecx, 2Dh ; '-'
		jnz	short loc_7A97
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax+4]
		or	ecx, 8
		mov	edx, [ebp+arg_10]
		mov	[edx+4], ecx

loc_7A97:				; CODE XREF: icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed	char,icu_56::IDNAInfo &,UErrorCode &)+402j
		mov	eax, [ebp+arg_8]
		mov	ecx, [ebp+var_78]
		movzx	edx, word ptr [ecx+eax*2-2]
		cmp	edx, 2Dh ; '-'
		jnz	short loc_7AB6
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax+4]
		or	ecx, 10h
		mov	edx, [ebp+arg_10]
		mov	[edx+4], ecx

loc_7AB6:				; CODE XREF: icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed	char,icu_56::IDNAInfo &,UErrorCode &)+421j
		mov	eax, [ebp+var_78]
		mov	[ebp+var_D8], eax
		mov	eax, [ebp+arg_8]
		mov	ecx, [ebp+var_78]
		lea	edx, [ecx+eax*2]
		mov	[ebp+var_E4], edx
		xor	eax, eax
		mov	[ebp+var_F0], ax
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+8]
		and	ecx, 2
		setnz	dl
		mov	[ebp+var_F9], dl

loc_7AE9:				; CODE XREF: icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed	char,icu_56::IDNAInfo &,UErrorCode &)+584j
		mov	eax, [ebp+var_D8]
		mov	cx, [eax]
		mov	[ebp+var_108], cx
		movzx	eax, [ebp+var_108]
		cmp	eax, 7Fh ; ''
		jg	short loc_7B72
		movzx	eax, [ebp+var_108]
		cmp	eax, 2Eh ; '.'
		jnz	short loc_7B33
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax+4]
		or	ecx, 200h
		mov	edx, [ebp+arg_10]
		mov	[edx+4], ecx
		mov	eax, 0FFFDh
		mov	ecx, [ebp+var_D8]
		mov	[ecx], ax
		jmp	short loc_7B70
; ---------------------------------------------------------------------------

loc_7B33:				; CODE XREF: icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed	char,icu_56::IDNAInfo &,UErrorCode &)+48Bj
		movsx	eax, [ebp+var_F9]
		test	eax, eax
		jz	short loc_7B70
		movzx	eax, [ebp+var_108]
		movsx	ecx, ds:_asciiData[eax]
		test	ecx, ecx
		jge	short loc_7B70
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax+4]
		or	ecx, 80h
		mov	edx, [ebp+arg_10]
		mov	[edx+4], ecx
		mov	eax, 0FFFDh
		mov	ecx, [ebp+var_D8]
		mov	[ecx], ax

loc_7B70:				; CODE XREF: icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed	char,icu_56::IDNAInfo &,UErrorCode &)+4ADj
					; icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed char,icu_56::IDNAInfo &,UErrorCode	&)+4B8j ...
		jmp	short loc_7BED
; ---------------------------------------------------------------------------

loc_7B72:				; CODE XREF: icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed	char,icu_56::IDNAInfo &,UErrorCode &)+47Fj
		movzx	eax, [ebp+var_108]
		movzx	ecx, [ebp+var_F0]
		or	ecx, eax
		mov	[ebp+var_F0], cx
		movsx	eax, [ebp+var_F9]
		test	eax, eax
		jz	short loc_7BCD
		movzx	eax, [ebp+var_108]
		push	eax
		call	?isNonASCIIDisallowedSTD3Valid@icu_56@@YACH@Z ;	icu_56::isNonASCIIDisallowedSTD3Valid(int)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_7BCD
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax+4]
		or	ecx, 80h
		mov	edx, [ebp+arg_10]
		mov	[edx+4], ecx
		mov	eax, 0FFFDh
		mov	ecx, [ebp+var_D8]
		mov	[ecx], ax
		jmp	short loc_7BED
; ---------------------------------------------------------------------------

loc_7BCD:				; CODE XREF: icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed	char,icu_56::IDNAInfo &,UErrorCode &)+50Ej
					; icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed char,icu_56::IDNAInfo &,UErrorCode	&)+525j
		movzx	eax, [ebp+var_108]
		cmp	eax, 0FFFDh
		jnz	short loc_7BED
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax+4]
		or	ecx, 80h
		mov	edx, [ebp+arg_10]
		mov	[edx+4], ecx

loc_7BED:				; CODE XREF: icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed	char,icu_56::IDNAInfo &,UErrorCode &):loc_7B70j
					; icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed char,icu_56::IDNAInfo &,UErrorCode	&)+547j ...
		mov	eax, [ebp+var_D8]
		add	eax, 2
		mov	[ebp+var_D8], eax
		mov	eax, [ebp+var_D8]
		cmp	eax, [ebp+var_E4]
		jb	loc_7AE9
		mov	[ebp+var_120], 0
		mov	eax, [ebp+var_120]
		mov	ecx, [ebp+var_78]
		movzx	edx, word ptr [ecx+eax*2]
		mov	[ebp+var_114], edx
		mov	eax, [ebp+var_120]
		add	eax, 1
		mov	[ebp+var_120], eax
		mov	eax, [ebp+var_114]
		and	eax, 0FFFFFC00h
		cmp	eax, 0D800h
		jnz	short loc_7C7E
		mov	eax, [ebp+var_114]
		shl	eax, 0Ah
		mov	ecx, [ebp+var_120]
		mov	edx, [ebp+var_78]
		movzx	ecx, word ptr [edx+ecx*2]
		lea	edx, [eax+ecx-35FDC00h]
		mov	[ebp+var_114], edx
		mov	eax, [ebp+var_120]
		add	eax, 1
		mov	[ebp+var_120], eax

loc_7C7E:				; CODE XREF: icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed	char,icu_56::IDNAInfo &,UErrorCode &)+5C6j
		mov	eax, [ebp+var_114]
		push	eax
		call	_u_charType_56
		add	esp, 4
		movsx	ecx, al
		mov	edx, 1
		shl	edx, cl
		and	edx, 1C0h
		jz	short loc_7CF9
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax+4]
		or	ecx, 40h
		mov	edx, [ebp+arg_10]
		mov	[edx+4], ecx
		push	0FFFDh		; wchar_t
		mov	eax, [ebp+var_120]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	ecx, [ebp+var_6C] ; this
		call	?replace@UnicodeString@icu_56@@QAEAAV12@HH_W@Z ; icu_56::UnicodeString::replace(int,int,wchar_t)
		mov	ecx, [ebp+var_6C] ; this
		call	?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ ; icu_56::UnicodeString::getBuffer(void)
		mov	ecx, [ebp+arg_4]
		lea	edx, [eax+ecx*2]
		mov	[ebp+var_78], edx
		mov	eax, 1
		sub	eax, [ebp+var_120]
		add	eax, [ebp+arg_8]
		mov	[ebp+arg_8], eax
		mov	eax, [ebp+var_6C]
		cmp	eax, [ebp+arg_0]
		jnz	short loc_7CF9
		mov	eax, [ebp+arg_8]
		mov	[ebp+var_90], eax

loc_7CF9:				; CODE XREF: icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed	char,icu_56::IDNAInfo &,UErrorCode &)+619j
					; icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed char,icu_56::IDNAInfo &,UErrorCode	&)+66Aj
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax+4]
		and	ecx, 7C0h
		jnz	loc_80A9
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+8]
		and	ecx, 4
		jz	short loc_7D40
		mov	eax, [ebp+arg_10]
		movsx	ecx, byte ptr [eax+9]
		test	ecx, ecx
		jz	short loc_7D2C
		mov	eax, [ebp+arg_10]
		movsx	ecx, byte ptr [eax+0Ah]
		test	ecx, ecx
		jz	short loc_7D40

loc_7D2C:				; CODE XREF: icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed	char,icu_56::IDNAInfo &,UErrorCode &)+69Bj
		mov	eax, [ebp+arg_10]
		push	eax		; struct icu_56::IDNAInfo *
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+var_78]
		push	edx		; wchar_t *
		mov	ecx, [ebp+var_18] ; this
		call	?checkLabelBiDi@UTS46@icu_56@@ABEXPB_WHAAVIDNAInfo@2@@Z	; icu_56::UTS46::checkLabelBiDi(wchar_t	const *,int,icu_56::IDNAInfo &)

loc_7D40:				; CODE XREF: icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed	char,icu_56::IDNAInfo &,UErrorCode &)+690j
					; icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed char,icu_56::IDNAInfo &,UErrorCode	&)+6A6j
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+8]
		and	ecx, 8
		jz	short loc_7D87
		movzx	eax, [ebp+var_F0]
		and	eax, 200Ch
		cmp	eax, 200Ch
		jnz	short loc_7D87
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+var_78]
		push	ecx		; wchar_t *
		mov	ecx, [ebp+var_18] ; this
		call	?isLabelOkContextJ@UTS46@icu_56@@ABECPB_WH@Z ; icu_56::UTS46::isLabelOkContextJ(wchar_t	const *,int)
		movsx	edx, al
		test	edx, edx
		jnz	short loc_7D87
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax+4]
		or	ecx, 1000h
		mov	edx, [ebp+arg_10]
		mov	[edx+4], ecx

loc_7D87:				; CODE XREF: icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed	char,icu_56::IDNAInfo &,UErrorCode &)+6C5j
					; icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed char,icu_56::IDNAInfo &,UErrorCode	&)+6D8j ...
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+8]
		and	ecx, 40h
		jz	short loc_7DB4
		movzx	eax, [ebp+var_F0]
		cmp	eax, 0B7h ; ''
		jl	short loc_7DB4
		mov	eax, [ebp+arg_10]
		push	eax		; struct icu_56::IDNAInfo *
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+var_78]
		push	edx		; wchar_t *
		mov	ecx, [ebp+var_18] ; this
		call	?checkLabelContextO@UTS46@icu_56@@ABEXPB_WHAAVIDNAInfo@2@@Z ; icu_56::UTS46::checkLabelContextO(wchar_t	const *,int,icu_56::IDNAInfo &)

loc_7DB4:				; CODE XREF: icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed	char,icu_56::IDNAInfo &,UErrorCode &)+70Cj
					; icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed char,icu_56::IDNAInfo &,UErrorCode	&)+71Aj
		movsx	eax, [ebp+arg_C]
		test	eax, eax
		jz	loc_80A7
		movsx	eax, [ebp+var_99]
		test	eax, eax
		jz	short loc_7E0E
		cmp	[ebp+var_90], 3Fh ; '?'
		jle	short loc_7DE3
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax+4]
		or	ecx, 2
		mov	edx, [ebp+arg_10]
		mov	[edx+4], ecx

loc_7DE3:				; CODE XREF: icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed	char,icu_56::IDNAInfo &,UErrorCode &)+74Ej
		mov	eax, [ebp+var_90]
		mov	[ebp+var_270], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_60] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		mov	eax, [ebp+var_270]
		jmp	loc_814B
; ---------------------------------------------------------------------------
		jmp	loc_80A7
; ---------------------------------------------------------------------------

loc_7E0E:				; CODE XREF: icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed	char,icu_56::IDNAInfo &,UErrorCode &)+745j
		movzx	eax, [ebp+var_F0]
		cmp	eax, 80h ; ''
		jl	loc_8092
		lea	ecx, [ebp+var_168] ; this
		call	??0UnicodeString@icu_56@@QAE@XZ	; icu_56::UnicodeString::UnicodeString(void)
		mov	byte ptr [ebp+var_4], 1
		push	3Fh ; '?'       ; int
		lea	ecx, [ebp+var_168] ; this
		call	?getBuffer@UnicodeString@icu_56@@QAEPA_WH@Z ; icu_56::UnicodeString::getBuffer(int)
		mov	[ebp+var_174], eax
		cmp	[ebp+var_174], 0
		jnz	short loc_7E89
		mov	eax, [ebp+arg_14]
		mov	dword ptr [eax], 7
		mov	eax, [ebp+var_90]
		mov	[ebp+var_264], eax
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_168] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_60] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		mov	eax, [ebp+var_264]
		jmp	loc_814B
; ---------------------------------------------------------------------------

loc_7E89:				; CODE XREF: icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed	char,icu_56::IDNAInfo &,UErrorCode &)+7C5j
		mov	eax, 78h ; 'x'
		mov	ecx, [ebp+var_174]
		mov	[ecx], ax
		mov	eax, 6Eh ; 'n'
		mov	ecx, [ebp+var_174]
		mov	[ecx+2], ax
		mov	eax, 2Dh ; '-'
		mov	ecx, [ebp+var_174]
		mov	[ecx+4], ax
		mov	eax, 2Dh ; '-'
		mov	ecx, [ebp+var_174]
		mov	[ecx+6], ax
		mov	eax, [ebp+arg_14]
		push	eax
		push	0
		lea	ecx, [ebp+var_168] ; this
		call	?getCapacity@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::getCapacity(void)
		sub	eax, 4
		push	eax
		mov	ecx, [ebp+var_174]
		add	ecx, 8
		push	ecx
		mov	edx, [ebp+arg_8]
		push	edx
		mov	eax, [ebp+var_78]
		push	eax
		call	_u_strToPunycode_56
		add	esp, 18h
		mov	[ebp+var_180], eax
		mov	eax, [ebp+arg_14]
		cmp	dword ptr [eax], 0Fh
		jnz	loc_7FB2
		mov	eax, [ebp+arg_14]
		mov	dword ptr [eax], 0
		push	4		; int
		lea	ecx, [ebp+var_168] ; this
		call	?releaseBuffer@UnicodeString@icu_56@@QAEXH@Z ; icu_56::UnicodeString::releaseBuffer(int)
		mov	eax, [ebp+var_180]
		add	eax, 4
		push	eax		; int
		lea	ecx, [ebp+var_168] ; this
		call	?getBuffer@UnicodeString@icu_56@@QAEPA_WH@Z ; icu_56::UnicodeString::getBuffer(int)
		mov	[ebp+var_174], eax
		cmp	[ebp+var_174], 0
		jnz	short loc_7F7D
		mov	eax, [ebp+arg_14]
		mov	dword ptr [eax], 7
		mov	eax, [ebp+var_90]
		mov	[ebp+var_258], eax
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_168] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_60] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		mov	eax, [ebp+var_258]
		jmp	loc_814B
; ---------------------------------------------------------------------------

loc_7F7D:				; CODE XREF: icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed	char,icu_56::IDNAInfo &,UErrorCode &)+8B9j
		mov	eax, [ebp+arg_14]
		push	eax
		push	0
		lea	ecx, [ebp+var_168] ; this
		call	?getCapacity@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::getCapacity(void)
		sub	eax, 4
		push	eax
		mov	ecx, [ebp+var_174]
		add	ecx, 8
		push	ecx
		mov	edx, [ebp+arg_8]
		push	edx
		mov	eax, [ebp+var_78]
		push	eax
		call	_u_strToPunycode_56
		add	esp, 18h
		mov	[ebp+var_180], eax

loc_7FB2:				; CODE XREF: icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed	char,icu_56::IDNAInfo &,UErrorCode &)+87Bj
		mov	eax, [ebp+var_180]
		add	eax, 4
		mov	[ebp+var_180], eax
		mov	eax, [ebp+var_180]
		push	eax		; int
		lea	ecx, [ebp+var_168] ; this
		call	?releaseBuffer@UnicodeString@icu_56@@QAEXH@Z ; icu_56::UnicodeString::releaseBuffer(int)
		mov	eax, [ebp+arg_14]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_801D
		mov	eax, [ebp+var_90]
		mov	[ebp+var_24C], eax
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_168] ; this

loc_7FFE:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::_Stdioo
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_60] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		mov	eax, [ebp+var_24C]
		jmp	loc_814B
; ---------------------------------------------------------------------------

loc_801D:				; CODE XREF: icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed	char,icu_56::IDNAInfo &,UErrorCode &)+962j
		cmp	[ebp+var_180], 3Fh ; '?'
		jle	short loc_8035
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax+4]
		or	ecx, 2
		mov	edx, [ebp+arg_10]
		mov	[edx+4], ecx

loc_8035:				; CODE XREF: icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed	char,icu_56::IDNAInfo &,UErrorCode &)+9A0j
		mov	eax, [ebp+arg_14]
		push	eax		; int
		mov	ecx, [ebp+var_180]
		push	ecx		; int
		lea	edx, [ebp+var_168]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+var_90]
		push	eax		; int
		mov	ecx, [ebp+var_84]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; icu_56::UnicodeString	*
		call	?replaceLabel@icu_56@@YAHAAVUnicodeString@1@HHABV21@HAAW4UErrorCode@@@Z	; icu_56::replaceLabel(icu_56::UnicodeString &,int,int,icu_56::UnicodeString const &,int,UErrorCode &)
		add	esp, 18h
		mov	[ebp+var_2DC], eax
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_168] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_60] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		mov	eax, [ebp+var_2DC]
		jmp	loc_814B
; ---------------------------------------------------------------------------
		jmp	short loc_80A7
; ---------------------------------------------------------------------------

loc_8092:				; CODE XREF: icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed	char,icu_56::IDNAInfo &,UErrorCode &)+796j
		cmp	[ebp+arg_8], 3Fh ; '?'
		jle	short loc_80A7
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax+4]
		or	ecx, 2
		mov	edx, [ebp+arg_10]
		mov	[edx+4], ecx

loc_80A7:				; CODE XREF: icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed	char,icu_56::IDNAInfo &,UErrorCode &)+736j
					; icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed char,icu_56::IDNAInfo &,UErrorCode	&)+785j ...
		jmp	short loc_810A
; ---------------------------------------------------------------------------

loc_80A9:				; CODE XREF: icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed	char,icu_56::IDNAInfo &,UErrorCode &)+681j
		movsx	eax, [ebp+var_99]
		test	eax, eax
		jz	short loc_810A
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax+4]
		or	ecx, 400h
		mov	edx, [ebp+arg_10]
		mov	[edx+4], ecx
		mov	eax, [ebp+arg_14]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_10]
		push	ecx		; struct icu_56::IDNAInfo *
		movzx	edx, [ebp+arg_C]
		push	edx		; char
		mov	eax, [ebp+var_90]
		push	eax		; int
		mov	ecx, [ebp+var_84]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_18] ; this
		call	?markBadACELabel@UTS46@icu_56@@ABEHAAVUnicodeString@2@HHCAAVIDNAInfo@2@AAW4UErrorCode@@@Z ; icu_56::UTS46::markBadACELabel(icu_56::UnicodeString &,int,int,signed char,icu_56::IDNAInfo	&,UErrorCode &)
		mov	[ebp+var_2D0], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_60] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		mov	eax, [ebp+var_2D0]
		jmp	short loc_814B
; ---------------------------------------------------------------------------

loc_810A:				; CODE XREF: icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed	char,icu_56::IDNAInfo &,UErrorCode &):loc_80A7j
					; icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed char,icu_56::IDNAInfo &,UErrorCode	&)+A2Ej
		mov	eax, [ebp+arg_14]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+var_6C]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+var_90]
		push	eax		; int
		mov	ecx, [ebp+var_84]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; icu_56::UnicodeString	*
		call	?replaceLabel@icu_56@@YAHAAVUnicodeString@1@HHABV21@HAAW4UErrorCode@@@Z	; icu_56::replaceLabel(icu_56::UnicodeString &,int,int,icu_56::UnicodeString const &,int,UErrorCode &)
		add	esp, 18h
		mov	[ebp+var_2C4], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_60] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		mov	eax, [ebp+var_2C4]

loc_814B:				; CODE XREF: icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed	char,icu_56::IDNAInfo &,UErrorCode &)+5Cj
					; icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed char,icu_56::IDNAInfo &,UErrorCode	&)+123j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN56
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 2E0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	18h
?processLabel@UTS46@icu_56@@ABEHAAVUnicodeString@2@HHCAAVIDNAInfo@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN56		dd 3			; DATA XREF: icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed	char,icu_56::IDNAInfo &,UErrorCode &)+ACBo
		dd offset $LN55
$LN55		dd 0FFFFFFA0h, 40h	; DATA XREF: .text:0000818Co
		dd offset $LN51		; "fromPunycode"
		dd 0FFFFFF4Ch, 4
		dd offset $LN52		; "punycodeErrorCode"
		dd 0FFFFFE98h, 40h
		dd offset $LN53		; "punycode"
$LN53		db 'punycode',0         ; DATA XREF: .text:000081B0o
$LN52		db 'punycodeErrorCode',0 ; DATA XREF: .text:000081A4o
$LN51		db 'fromPunycode',0     ; DATA XREF: .text:00008198o
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 81DCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?processLabel@UTS46@icu_56@@ABEHAAVUnicodeString@2@HHCAAVIDNAInfo@2@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:0000821Co
		lea	ecx, [ebp-60h]	; this
		jmp	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
__unwindfunclet$?processLabel@UTS46@icu_56@@ABEHAAVUnicodeString@2@HHCAAVIDNAInfo@2@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?processLabel@UTS46@icu_56@@ABEHAAVUnicodeString@2@HHCAAVIDNAInfo@2@AAW4UErrorCode@@@Z$1 proc near
					; DATA XREF: .xdata$x:00008224o
		lea	ecx, [ebp-168h]	; this
		jmp	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
__unwindfunclet$?processLabel@UTS46@icu_56@@ABEHAAVUnicodeString@2@HHCAAVIDNAInfo@2@AAW4UErrorCode@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?processLabel@UTS46@icu_56@@ABEHAAVUnicodeString@2@HHCAAVIDNAInfo@2@AAW4UErrorCode@@@Z proc	near
					; DATA XREF: icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed	char,icu_56::IDNAInfo &,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-2E4h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?processLabel@UTS46@icu_56@@ABEHAAVUnicodeString@2@HHCAAVIDNAInfo@2@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?processLabel@UTS46@icu_56@@ABEHAAVUnicodeString@2@HHCAAVIDNAInfo@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 8218h
__unwindtable$?processLabel@UTS46@icu_56@@ABEHAAVUnicodeString@2@HHCAAVIDNAInfo@2@AAW4UErrorCode@@@Z dd	0FFFFFFFFh
					; DATA XREF: .xdata$x:00008230o
		dd offset __unwindfunclet$?processLabel@UTS46@icu_56@@ABEHAAVUnicodeString@2@HHCAAVIDNAInfo@2@AAW4UErrorCode@@@Z$0
		dd 0
		dd offset __unwindfunclet$?processLabel@UTS46@icu_56@@ABEHAAVUnicodeString@2@HHCAAVIDNAInfo@2@AAW4UErrorCode@@@Z$1
__ehfuncinfo$?processLabel@UTS46@icu_56@@ABEHAAVUnicodeString@2@HHCAAVIDNAInfo@2@AAW4UErrorCode@@@Z dd 19930522h, 2
					; DATA XREF: __ehhandler$?processLabel@UTS46@icu_56@@ABEHAAVUnicodeString@2@HHCAAVIDNAInfo@2@AAW4UErrorCode@@@Z+1Eo
		dd offset __unwindtable$?processLabel@UTS46@icu_56@@ABEHAAVUnicodeString@2@HHCAAVIDNAInfo@2@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 824Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl icu_56::isNonASCIIDisallowedSTD3Valid(int)
?isNonASCIIDisallowedSTD3Valid@icu_56@@YACH@Z proc near
					; CODE XREF: icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed	char,icu_56::IDNAInfo &,UErrorCode &)+518p

var_C4		= byte ptr -0C4h
var_C1		= byte ptr -0C1h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C4]
		mov	ecx, 31h ; '1'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 2260h
		jz	short loc_828E
		cmp	[ebp+arg_0], 226Eh
		jz	short loc_828E
		cmp	[ebp+arg_0], 226Fh
		jz	short loc_828E
		mov	[ebp+var_C1], 0
		jmp	short loc_8295
; ---------------------------------------------------------------------------

loc_828E:				; CODE XREF: icu_56::isNonASCIIDisallowedSTD3Valid(int)+25j
					; icu_56::isNonASCIIDisallowedSTD3Valid(int)+2Ej ...
		mov	[ebp+var_C1], 1

loc_8295:				; CODE XREF: icu_56::isNonASCIIDisallowedSTD3Valid(int)+40j
		mov	al, [ebp+var_C1]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isNonASCIIDisallowedSTD3Valid@icu_56@@YACH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 82A4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl icu_56::replaceLabel(icu_56::UnicodeString *, int, int, struct icu_56::UnicodeString *, int, int)
?replaceLabel@icu_56@@YAHAAVUnicodeString@1@HHABV21@HAAW4UErrorCode@@@Z	proc near
					; CODE XREF: icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed	char,icu_56::IDNAInfo &,UErrorCode &)+3A4p
					; icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed char,icu_56::IDNAInfo &,UErrorCode	&)+9D5p ...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_14]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_82DB
		xor	eax, eax
		jmp	short loc_8316
; ---------------------------------------------------------------------------

loc_82DB:				; CODE XREF: icu_56::replaceLabel(icu_56::UnicodeString	&,int,int,icu_56::UnicodeString	const &,int,UErrorCode &)+31j
		mov	eax, [ebp+arg_C]
		cmp	eax, [ebp+arg_0]
		jz	short loc_8313
		mov	eax, [ebp+arg_C]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@@Z ; icu_56::UnicodeString::replace(int,int,icu_56::UnicodeString const	&)
		mov	ecx, [ebp+arg_0] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_8313
		mov	eax, [ebp+arg_14]
		mov	dword ptr [eax], 7
		xor	eax, eax
		jmp	short loc_8316
; ---------------------------------------------------------------------------

loc_8313:				; CODE XREF: icu_56::replaceLabel(icu_56::UnicodeString	&,int,int,icu_56::UnicodeString	const &,int,UErrorCode &)+3Dj
					; icu_56::replaceLabel(icu_56::UnicodeString &,int,int,icu_56::UnicodeString const &,int,UErrorCode &)+60j
		mov	eax, [ebp+arg_10]

loc_8316:				; CODE XREF: icu_56::replaceLabel(icu_56::UnicodeString	&,int,int,icu_56::UnicodeString	const &,int,UErrorCode &)+35j
					; icu_56::replaceLabel(icu_56::UnicodeString &,int,int,icu_56::UnicodeString const &,int,UErrorCode &)+6Dj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?replaceLabel@icu_56@@YAHAAVUnicodeString@1@HHABV21@HAAW4UErrorCode@@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 832Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UTS46::markBadACELabel(icu_56::UTS46 *this, struct icu_56::UnicodeString *, int, int, char, struct icu_56::IDNAInfo *,	enum UErrorCode	*)
		public ?markBadACELabel@UTS46@icu_56@@ABEHAAVUnicodeString@2@HHCAAVIDNAInfo@2@AAW4UErrorCode@@@Z
?markBadACELabel@UTS46@icu_56@@ABEHAAVUnicodeString@2@HHCAAVIDNAInfo@2@AAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed	char,icu_56::IDNAInfo &,UErrorCode &)+25Ap
					; icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed char,icu_56::IDNAInfo &,UErrorCode	&)+31Ap ...

var_120		= byte ptr -120h
var_5C		= word ptr -5Ch
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_29		= byte ptr -29h
var_1D		= byte ptr -1Dh
var_11		= byte ptr -11h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= byte ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 120h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_120]
		mov	ecx, 48h ; 'H'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_14]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_836B
		xor	eax, eax
		jmp	loc_84A3
; ---------------------------------------------------------------------------

loc_836B:				; CODE XREF: icu_56::UTS46::markBadACELabel(icu_56::UnicodeString &,int,int,signed char,icu_56::IDNAInfo &,UErrorCode &)+36j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		and	ecx, 2
		setnz	dl
		mov	[ebp+var_11], dl
		mov	[ebp+var_1D], 1
		mov	[ebp+var_29], 1
		mov	ecx, [ebp+arg_0] ; this
		call	?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ ; icu_56::UnicodeString::getBuffer(void)
		mov	ecx, [ebp+arg_4]
		lea	edx, [eax+ecx*2]
		mov	[ebp+var_38], edx
		mov	eax, [ebp+var_38]
		add	eax, 8
		mov	[ebp+var_44], eax
		mov	eax, [ebp+arg_8]
		mov	ecx, [ebp+var_38]
		lea	edx, [ecx+eax*2]
		mov	[ebp+var_50], edx

loc_83A8:				; CODE XREF: icu_56::UTS46::markBadACELabel(icu_56::UnicodeString &,int,int,signed char,icu_56::IDNAInfo &,UErrorCode &)+106j
		mov	eax, [ebp+var_44]
		mov	cx, [eax]
		mov	[ebp+var_5C], cx
		movzx	eax, [ebp+var_5C]
		cmp	eax, 7Fh ; ''
		jg	short loc_8419
		movzx	eax, [ebp+var_5C]
		cmp	eax, 2Eh ; '.'
		jnz	short loc_83ED
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax+4]
		or	ecx, 200h
		mov	edx, [ebp+arg_10]
		mov	[edx+4], ecx
		mov	eax, 0FFFDh
		mov	ecx, [ebp+var_44]
		mov	[ecx], ax
		mov	[ebp+var_29], 0
		mov	al, [ebp+var_29]
		mov	[ebp+var_1D], al
		jmp	short loc_8417
; ---------------------------------------------------------------------------

loc_83ED:				; CODE XREF: icu_56::UTS46::markBadACELabel(icu_56::UnicodeString &,int,int,signed char,icu_56::IDNAInfo &,UErrorCode &)+96j
		movzx	eax, [ebp+var_5C]
		movsx	ecx, ds:_asciiData[eax]
		test	ecx, ecx
		jge	short loc_8417
		mov	[ebp+var_29], 0
		movsx	eax, [ebp+var_11]
		test	eax, eax
		jz	short loc_8417
		mov	eax, 0FFFDh
		mov	ecx, [ebp+var_44]
		mov	[ecx], ax
		mov	[ebp+var_1D], 0

loc_8417:				; CODE XREF: icu_56::UTS46::markBadACELabel(icu_56::UnicodeString &,int,int,signed char,icu_56::IDNAInfo &,UErrorCode &)+BFj
					; icu_56::UTS46::markBadACELabel(icu_56::UnicodeString &,int,int,signed	char,icu_56::IDNAInfo &,UErrorCode &)+CEj ...
		jmp	short loc_8423
; ---------------------------------------------------------------------------

loc_8419:				; CODE XREF: icu_56::UTS46::markBadACELabel(icu_56::UnicodeString &,int,int,signed char,icu_56::IDNAInfo &,UErrorCode &)+8Dj
		mov	[ebp+var_29], 0
		mov	al, [ebp+var_29]
		mov	[ebp+var_1D], al

loc_8423:				; CODE XREF: icu_56::UTS46::markBadACELabel(icu_56::UnicodeString &,int,int,signed char,icu_56::IDNAInfo &,UErrorCode &):loc_8417j
		mov	eax, [ebp+var_44]
		add	eax, 2
		mov	[ebp+var_44], eax
		mov	ecx, [ebp+var_44]
		cmp	ecx, [ebp+var_50]
		jb	loc_83A8
		movsx	eax, [ebp+var_29]
		test	eax, eax
		jz	short loc_847B
		push	0FFFDh		; wchar_t
		mov	eax, [ebp+arg_4]
		add	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?insert@UnicodeString@icu_56@@QAEAAV12@H_W@Z ; icu_56::UnicodeString::insert(int,wchar_t)
		mov	ecx, [ebp+arg_0] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_8470
		mov	eax, [ebp+arg_14]
		mov	dword ptr [eax], 7
		xor	eax, eax
		jmp	short loc_84A3
; ---------------------------------------------------------------------------

loc_8470:				; CODE XREF: icu_56::UTS46::markBadACELabel(icu_56::UnicodeString &,int,int,signed char,icu_56::IDNAInfo &,UErrorCode &)+135j
		mov	eax, [ebp+arg_8]
		add	eax, 1
		mov	[ebp+arg_8], eax
		jmp	short loc_84A0
; ---------------------------------------------------------------------------

loc_847B:				; CODE XREF: icu_56::UTS46::markBadACELabel(icu_56::UnicodeString &,int,int,signed char,icu_56::IDNAInfo &,UErrorCode &)+112j
		movsx	eax, [ebp+arg_C]
		test	eax, eax
		jz	short loc_84A0
		movsx	eax, [ebp+var_1D]
		test	eax, eax
		jz	short loc_84A0
		cmp	[ebp+arg_8], 3Fh ; '?'
		jle	short loc_84A0
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax+4]
		or	ecx, 2
		mov	edx, [ebp+arg_10]
		mov	[edx+4], ecx

loc_84A0:				; CODE XREF: icu_56::UTS46::markBadACELabel(icu_56::UnicodeString &,int,int,signed char,icu_56::IDNAInfo &,UErrorCode &)+14Dj
					; icu_56::UTS46::markBadACELabel(icu_56::UnicodeString &,int,int,signed	char,icu_56::IDNAInfo &,UErrorCode &)+155j ...
		mov	eax, [ebp+arg_8]

loc_84A3:				; CODE XREF: icu_56::UTS46::markBadACELabel(icu_56::UnicodeString &,int,int,signed char,icu_56::IDNAInfo &,UErrorCode &)+3Aj
					; icu_56::UTS46::markBadACELabel(icu_56::UnicodeString &,int,int,signed	char,icu_56::IDNAInfo &,UErrorCode &)+142j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 120h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	18h
?markBadACELabel@UTS46@icu_56@@ABEHAAVUnicodeString@2@HHCAAVIDNAInfo@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 84BCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UTS46::checkLabelBiDi(icu_56::UTS46 *this, const wchar_t *, int, struct icu_56::IDNAInfo *)
		public ?checkLabelBiDi@UTS46@icu_56@@ABEXPB_WHAAVIDNAInfo@2@@Z
?checkLabelBiDi@UTS46@icu_56@@ABEXPB_WHAAVIDNAInfo@2@@Z	proc near
					; CODE XREF: icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed	char,icu_56::IDNAInfo &,UErrorCode &)+6B7p

var_118		= dword	ptr -118h
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 118h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_118]
		mov	ecx, 46h ; 'F'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_20], 0
		mov	eax, [ebp+var_20]
		mov	ecx, [ebp+arg_0]
		movzx	edx, word ptr [ecx+eax*2]
		mov	[ebp+var_14], edx
		mov	eax, [ebp+var_20]
		add	eax, 1
		mov	[ebp+var_20], eax
		mov	eax, [ebp+var_14]
		and	eax, 0FFFFFC00h
		cmp	eax, 0D800h
		jnz	short loc_852E
		mov	eax, [ebp+var_14]
		shl	eax, 0Ah
		mov	ecx, [ebp+var_20]
		mov	edx, [ebp+arg_0]
		movzx	ecx, word ptr [edx+ecx*2]
		lea	edx, [eax+ecx-35FDC00h]
		mov	[ebp+var_14], edx
		mov	eax, [ebp+var_20]
		add	eax, 1
		mov	[ebp+var_20], eax

loc_852E:				; CODE XREF: icu_56::UTS46::checkLabelBiDi(wchar_t const *,int,icu_56::IDNAInfo	&)+4Dj
		mov	eax, [ebp+var_14]
		push	eax
		call	_u_charDirection_56
		add	esp, 4
		mov	edx, 1
		mov	ecx, eax
		shl	edx, cl
		mov	[ebp+var_2C], edx
		mov	eax, [ebp+var_2C]
		and	eax, 0FFFFDFFCh
		jz	short loc_8557
		mov	eax, [ebp+arg_8]
		mov	byte ptr [eax+0Ah], 0

loc_8557:				; CODE XREF: icu_56::UTS46::checkLabelBiDi(wchar_t const *,int,icu_56::IDNAInfo	&)+92j
					; icu_56::UTS46::checkLabelBiDi(wchar_t	const *,int,icu_56::IDNAInfo &):loc_85D3j
		mov	eax, [ebp+var_20]
		cmp	eax, [ebp+arg_4]
		jl	short loc_8567
		mov	eax, [ebp+var_2C]
		mov	[ebp+var_38], eax
		jmp	short loc_85D5
; ---------------------------------------------------------------------------

loc_8567:				; CODE XREF: icu_56::UTS46::checkLabelBiDi(wchar_t const *,int,icu_56::IDNAInfo	&)+A1j
		mov	eax, [ebp+arg_4]
		sub	eax, 1
		mov	[ebp+arg_4], eax
		mov	ecx, [ebp+arg_4]
		mov	edx, [ebp+arg_0]
		movzx	eax, word ptr [edx+ecx*2]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_14]
		and	eax, 0FFFFFC00h
		cmp	eax, 0DC00h
		jnz	short loc_85AF
		mov	eax, [ebp+arg_4]
		sub	eax, 1
		mov	[ebp+arg_4], eax
		mov	ecx, [ebp+arg_4]
		mov	edx, [ebp+arg_0]
		movzx	eax, word ptr [edx+ecx*2]
		shl	eax, 0Ah
		mov	ecx, [ebp+var_14]
		lea	edx, [eax+ecx-35FDC00h]
		mov	[ebp+var_14], edx

loc_85AF:				; CODE XREF: icu_56::UTS46::checkLabelBiDi(wchar_t const *,int,icu_56::IDNAInfo	&)+CEj
		mov	eax, [ebp+var_14]
		push	eax
		call	_u_charDirection_56
		add	esp, 4
		mov	[ebp+var_44], eax
		cmp	[ebp+var_44], 11h
		jz	short loc_85D3
		mov	eax, 1
		mov	ecx, [ebp+var_44]
		shl	eax, cl
		mov	[ebp+var_38], eax
		jmp	short loc_85D5
; ---------------------------------------------------------------------------

loc_85D3:				; CODE XREF: icu_56::UTS46::checkLabelBiDi(wchar_t const *,int,icu_56::IDNAInfo	&)+106j
		jmp	short loc_8557
; ---------------------------------------------------------------------------

loc_85D5:				; CODE XREF: icu_56::UTS46::checkLabelBiDi(wchar_t const *,int,icu_56::IDNAInfo	&)+A9j
					; icu_56::UTS46::checkLabelBiDi(wchar_t	const *,int,icu_56::IDNAInfo &)+115j
		mov	eax, [ebp+var_2C]
		and	eax, 1
		jz	short loc_85F1
		mov	ecx, [ebp+var_38]
		and	ecx, 0FFFFFFFAh
		neg	ecx
		sbb	ecx, ecx
		neg	ecx
		mov	[ebp+var_118], ecx
		jmp	short loc_8606
; ---------------------------------------------------------------------------

loc_85F1:				; CODE XREF: icu_56::UTS46::checkLabelBiDi(wchar_t const *,int,icu_56::IDNAInfo	&)+11Fj
		mov	edx, [ebp+var_38]
		and	edx, 0FFFFDFD9h
		neg	edx
		sbb	edx, edx
		neg	edx
		mov	[ebp+var_118], edx

loc_8606:				; CODE XREF: icu_56::UTS46::checkLabelBiDi(wchar_t const *,int,icu_56::IDNAInfo	&)+133j
		cmp	[ebp+var_118], 0
		jz	short loc_8616
		mov	eax, [ebp+arg_8]
		mov	byte ptr [eax+0Ah], 0

loc_8616:				; CODE XREF: icu_56::UTS46::checkLabelBiDi(wchar_t const *,int,icu_56::IDNAInfo	&)+151j
		mov	[ebp+var_50], 0

loc_861D:				; CODE XREF: icu_56::UTS46::checkLabelBiDi(wchar_t const *,int,icu_56::IDNAInfo	&)+1CCj
		mov	eax, [ebp+var_20]
		cmp	eax, [ebp+arg_4]
		jge	short loc_868A
		mov	eax, [ebp+var_20]
		mov	ecx, [ebp+arg_0]
		movzx	edx, word ptr [ecx+eax*2]
		mov	[ebp+var_14], edx
		mov	eax, [ebp+var_20]
		add	eax, 1
		mov	[ebp+var_20], eax
		mov	eax, [ebp+var_14]
		and	eax, 0FFFFFC00h
		cmp	eax, 0D800h
		jnz	short loc_866D
		mov	eax, [ebp+var_14]
		shl	eax, 0Ah
		mov	ecx, [ebp+var_20]
		mov	edx, [ebp+arg_0]
		movzx	ecx, word ptr [edx+ecx*2]
		lea	edx, [eax+ecx-35FDC00h]
		mov	[ebp+var_14], edx
		mov	eax, [ebp+var_20]
		add	eax, 1
		mov	[ebp+var_20], eax

loc_866D:				; CODE XREF: icu_56::UTS46::checkLabelBiDi(wchar_t const *,int,icu_56::IDNAInfo	&)+18Cj
		mov	eax, [ebp+var_14]
		push	eax
		call	_u_charDirection_56
		add	esp, 4
		mov	edx, 1
		mov	ecx, eax
		shl	edx, cl
		or	edx, [ebp+var_50]
		mov	[ebp+var_50], edx
		jmp	short loc_861D
; ---------------------------------------------------------------------------

loc_868A:				; CODE XREF: icu_56::UTS46::checkLabelBiDi(wchar_t const *,int,icu_56::IDNAInfo	&)+167j
		mov	eax, [ebp+var_2C]
		and	eax, 1
		jz	short loc_86A5
		mov	eax, [ebp+var_50]
		and	eax, 0FFF9FBA2h
		jz	short loc_86A3
		mov	eax, [ebp+arg_8]
		mov	byte ptr [eax+0Ah], 0

loc_86A3:				; CODE XREF: icu_56::UTS46::checkLabelBiDi(wchar_t const *,int,icu_56::IDNAInfo	&)+1DEj
		jmp	short loc_86C8
; ---------------------------------------------------------------------------

loc_86A5:				; CODE XREF: icu_56::UTS46::checkLabelBiDi(wchar_t const *,int,icu_56::IDNAInfo	&)+1D4j
		mov	eax, [ebp+var_50]
		and	eax, 0FFF9DB81h
		jz	short loc_86B6
		mov	eax, [ebp+arg_8]
		mov	byte ptr [eax+0Ah], 0

loc_86B6:				; CODE XREF: icu_56::UTS46::checkLabelBiDi(wchar_t const *,int,icu_56::IDNAInfo	&)+1F1j
		mov	eax, [ebp+var_50]
		and	eax, 24h
		cmp	eax, 24h ; '$'
		jnz	short loc_86C8
		mov	eax, [ebp+arg_8]
		mov	byte ptr [eax+0Ah], 0

loc_86C8:				; CODE XREF: icu_56::UTS46::checkLabelBiDi(wchar_t const *,int,icu_56::IDNAInfo	&):loc_86A3j
					; icu_56::UTS46::checkLabelBiDi(wchar_t	const *,int,icu_56::IDNAInfo &)+203j
		mov	eax, [ebp+var_2C]
		or	eax, [ebp+var_50]
		or	eax, [ebp+var_38]
		and	eax, 2022h
		jz	short loc_86DF
		mov	eax, [ebp+arg_8]
		mov	byte ptr [eax+9], 1

loc_86DF:				; CODE XREF: icu_56::UTS46::checkLabelBiDi(wchar_t const *,int,icu_56::IDNAInfo	&)+21Aj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 118h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?checkLabelBiDi@UTS46@icu_56@@ABEXPB_WHAAVIDNAInfo@2@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 86F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl icu_56::isASCIIOkBiDi(wchar_t const *, int)
?isASCIIOkBiDi@icu_56@@YACPB_WH@Z proc near
					; CODE XREF: icu_56::UTS46::process(icu_56::UnicodeString const	&,signed char,signed char,icu_56::UnicodeString	&,icu_56::IDNAInfo &,UErrorCode	&)+36Ap

var_E4		= byte ptr -0E4h
var_20		= word ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	[ebp+var_14], 0
		jmp	short loc_872F
; ---------------------------------------------------------------------------

loc_8726:				; CODE XREF: icu_56::isASCIIOkBiDi(wchar_t const *,int):loc_87E4j
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_872F:				; CODE XREF: icu_56::isASCIIOkBiDi(wchar_t const *,int)+2Cj
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+arg_4]
		jge	loc_87E9
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	dx, [ecx+eax*2]
		mov	[ebp+var_20], dx
		movzx	eax, [ebp+var_20]
		cmp	eax, 2Eh ; '.'
		jnz	short loc_879C
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_8]
		jle	short loc_8791
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	dx, [ecx+eax*2-2]
		mov	[ebp+var_20], dx
		movzx	eax, [ebp+var_20]
		cmp	eax, 61h ; 'a'
		jl	short loc_877B
		movzx	eax, [ebp+var_20]
		cmp	eax, 7Ah ; 'z'
		jle	short loc_8791

loc_877B:				; CODE XREF: icu_56::isASCIIOkBiDi(wchar_t const *,int)+78j
		movzx	eax, [ebp+var_20]
		cmp	eax, 30h ; '0'
		jl	short loc_878D
		movzx	eax, [ebp+var_20]
		cmp	eax, 39h ; '9'
		jle	short loc_8791

loc_878D:				; CODE XREF: icu_56::isASCIIOkBiDi(wchar_t const *,int)+8Aj
		xor	al, al
		jmp	short loc_87EB
; ---------------------------------------------------------------------------

loc_8791:				; CODE XREF: icu_56::isASCIIOkBiDi(wchar_t const *,int)+60j
					; icu_56::isASCIIOkBiDi(wchar_t	const *,int)+81j ...
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_8], eax
		jmp	short loc_87E4
; ---------------------------------------------------------------------------

loc_879C:				; CODE XREF: icu_56::isASCIIOkBiDi(wchar_t const *,int)+58j
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_8]
		jnz	short loc_87BC
		movzx	eax, [ebp+var_20]
		cmp	eax, 61h ; 'a'
		jl	short loc_87B6
		movzx	eax, [ebp+var_20]
		cmp	eax, 7Ah ; 'z'
		jle	short loc_87BA

loc_87B6:				; CODE XREF: icu_56::isASCIIOkBiDi(wchar_t const *,int)+B3j
		xor	al, al
		jmp	short loc_87EB
; ---------------------------------------------------------------------------

loc_87BA:				; CODE XREF: icu_56::isASCIIOkBiDi(wchar_t const *,int)+BCj
		jmp	short loc_87E4
; ---------------------------------------------------------------------------

loc_87BC:				; CODE XREF: icu_56::isASCIIOkBiDi(wchar_t const *,int)+AAj
		movzx	eax, [ebp+var_20]
		cmp	eax, 20h ; ' '
		jg	short loc_87E4
		movzx	eax, [ebp+var_20]
		cmp	eax, 1Ch
		jge	short loc_87E0
		movzx	eax, [ebp+var_20]
		cmp	eax, 9
		jl	short loc_87E4
		movzx	eax, [ebp+var_20]
		cmp	eax, 0Dh
		jg	short loc_87E4

loc_87E0:				; CODE XREF: icu_56::isASCIIOkBiDi(wchar_t const *,int)+D4j
		xor	al, al
		jmp	short loc_87EB
; ---------------------------------------------------------------------------

loc_87E4:				; CODE XREF: icu_56::isASCIIOkBiDi(wchar_t const *,int)+A2j
					; icu_56::isASCIIOkBiDi(wchar_t	const *,int):loc_87BAj	...
		jmp	loc_8726
; ---------------------------------------------------------------------------

loc_87E9:				; CODE XREF: icu_56::isASCIIOkBiDi(wchar_t const *,int)+3Dj
		mov	al, 1

loc_87EB:				; CODE XREF: icu_56::isASCIIOkBiDi(wchar_t const *,int)+97j
					; icu_56::isASCIIOkBiDi(wchar_t	const *,int)+C0j ...
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isASCIIOkBiDi@icu_56@@YACPB_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 87F4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl icu_56::isASCIIOkBiDi(char const *, int)
?isASCIIOkBiDi@icu_56@@YACPBDH@Z proc near
					; CODE XREF: icu_56::UTS46::processUTF8(icu_56::StringPiece const &,signed char,signed char,icu_56::ByteSink &,icu_56::IDNAInfo	&,UErrorCode &)+61Ep

var_E4		= byte ptr -0E4h
var_1D		= byte ptr -1Dh
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	[ebp+var_14], 0
		jmp	short loc_882B
; ---------------------------------------------------------------------------

loc_8822:				; CODE XREF: icu_56::isASCIIOkBiDi(char	const *,int):loc_88FEj
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_882B:				; CODE XREF: icu_56::isASCIIOkBiDi(char	const *,int)+2Cj
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+arg_4]
		jge	loc_8903
		mov	eax, [ebp+arg_0]
		add	eax, [ebp+var_14]
		mov	cl, [eax]
		mov	[ebp+var_1D], cl
		movsx	eax, [ebp+var_1D]
		cmp	eax, 2Eh ; '.'
		jnz	short loc_88A4
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_8]
		jle	short loc_8899
		mov	eax, [ebp+arg_0]
		add	eax, [ebp+var_14]
		mov	cl, [eax-1]
		mov	[ebp+var_1D], cl
		movsx	eax, [ebp+var_1D]
		cmp	eax, 61h ; 'a'
		jl	short loc_8871
		movsx	eax, [ebp+var_1D]
		cmp	eax, 7Ah ; 'z'
		jle	short loc_8899

loc_8871:				; CODE XREF: icu_56::isASCIIOkBiDi(char	const *,int)+72j
		movsx	eax, [ebp+var_1D]
		cmp	eax, 41h ; 'A'
		jl	short loc_8883
		movsx	eax, [ebp+var_1D]
		cmp	eax, 5Ah ; 'Z'
		jle	short loc_8899

loc_8883:				; CODE XREF: icu_56::isASCIIOkBiDi(char	const *,int)+84j
		movsx	eax, [ebp+var_1D]
		cmp	eax, 30h ; '0'
		jl	short loc_8895
		movsx	eax, [ebp+var_1D]
		cmp	eax, 39h ; '9'
		jle	short loc_8899

loc_8895:				; CODE XREF: icu_56::isASCIIOkBiDi(char	const *,int)+96j
		xor	al, al
		jmp	short loc_8905
; ---------------------------------------------------------------------------

loc_8899:				; CODE XREF: icu_56::isASCIIOkBiDi(char	const *,int)+5Dj
					; icu_56::isASCIIOkBiDi(char const *,int)+7Bj ...
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_8], eax
		jmp	short loc_88FE
; ---------------------------------------------------------------------------

loc_88A4:				; CODE XREF: icu_56::isASCIIOkBiDi(char	const *,int)+55j
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_8]
		jnz	short loc_88D6
		movsx	eax, [ebp+var_1D]
		cmp	eax, 61h ; 'a'
		jl	short loc_88BE
		movsx	eax, [ebp+var_1D]
		cmp	eax, 7Ah ; 'z'
		jle	short loc_88D4

loc_88BE:				; CODE XREF: icu_56::isASCIIOkBiDi(char	const *,int)+BFj
		movsx	eax, [ebp+var_1D]
		cmp	eax, 41h ; 'A'
		jl	short loc_88D0
		movsx	eax, [ebp+var_1D]
		cmp	eax, 5Ah ; 'Z'
		jle	short loc_88D4

loc_88D0:				; CODE XREF: icu_56::isASCIIOkBiDi(char	const *,int)+D1j
		xor	al, al
		jmp	short loc_8905
; ---------------------------------------------------------------------------

loc_88D4:				; CODE XREF: icu_56::isASCIIOkBiDi(char	const *,int)+C8j
					; icu_56::isASCIIOkBiDi(char const *,int)+DAj
		jmp	short loc_88FE
; ---------------------------------------------------------------------------

loc_88D6:				; CODE XREF: icu_56::isASCIIOkBiDi(char	const *,int)+B6j
		movsx	eax, [ebp+var_1D]
		cmp	eax, 20h ; ' '
		jg	short loc_88FE
		movsx	eax, [ebp+var_1D]
		cmp	eax, 1Ch
		jge	short loc_88FA
		movsx	eax, [ebp+var_1D]
		cmp	eax, 9
		jl	short loc_88FE
		movsx	eax, [ebp+var_1D]
		cmp	eax, 0Dh
		jg	short loc_88FE

loc_88FA:				; CODE XREF: icu_56::isASCIIOkBiDi(char	const *,int)+F2j
		xor	al, al
		jmp	short loc_8905
; ---------------------------------------------------------------------------

loc_88FE:				; CODE XREF: icu_56::isASCIIOkBiDi(char	const *,int)+AEj
					; icu_56::isASCIIOkBiDi(char const *,int):loc_88D4j ...
		jmp	loc_8822
; ---------------------------------------------------------------------------

loc_8903:				; CODE XREF: icu_56::isASCIIOkBiDi(char	const *,int)+3Dj
		mov	al, 1

loc_8905:				; CODE XREF: icu_56::isASCIIOkBiDi(char	const *,int)+A3j
					; icu_56::isASCIIOkBiDi(char const *,int)+DEj ...
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isASCIIOkBiDi@icu_56@@YACPBDH@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 890Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UTS46::isLabelOkContextJ(icu_56::UTS46 *this, const wchar_t *, int)
		public ?isLabelOkContextJ@UTS46@icu_56@@ABECPB_WH@Z
?isLabelOkContextJ@UTS46@icu_56@@ABECPB_WH@Z proc near
					; CODE XREF: icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed	char,icu_56::IDNAInfo &,UErrorCode &)+6E5p

var_12C		= byte ptr -12Ch
var_68		= dword	ptr -68h
var_5C		= dword	ptr -5Ch
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 12Ch
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_12C]
		mov	ecx, 4Bh ; 'K'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		call	_ubidi_getSingleton_56
		mov	[ebp+var_14], eax
		mov	[ebp+var_20], 0
		jmp	short loc_8949
; ---------------------------------------------------------------------------

loc_8940:				; CODE XREF: icu_56::UTS46::isLabelOkContextJ(wchar_t const *,int)+E2j
					; icu_56::UTS46::isLabelOkContextJ(wchar_t const *,int):loc_8BB8j
		mov	eax, [ebp+var_20]
		add	eax, 1
		mov	[ebp+var_20], eax

loc_8949:				; CODE XREF: icu_56::UTS46::isLabelOkContextJ(wchar_t const *,int)+32j
		mov	eax, [ebp+var_20]
		cmp	eax, [ebp+arg_4]
		jge	loc_8BBD
		mov	eax, [ebp+var_20]
		mov	ecx, [ebp+arg_0]
		movzx	edx, word ptr [ecx+eax*2]
		cmp	edx, 200Ch
		jnz	loc_8B1B
		cmp	[ebp+var_20], 0
		jnz	short loc_8978
		xor	al, al
		jmp	loc_8BBF
; ---------------------------------------------------------------------------

loc_8978:				; CODE XREF: icu_56::UTS46::isLabelOkContextJ(wchar_t const *,int)+63j
		mov	eax, [ebp+var_20]
		mov	[ebp+var_38], eax
		mov	eax, [ebp+var_38]
		sub	eax, 1
		mov	[ebp+var_38], eax
		mov	ecx, [ebp+var_38]
		mov	edx, [ebp+arg_0]
		movzx	eax, word ptr [edx+ecx*2]
		mov	[ebp+var_2C], eax
		mov	eax, [ebp+var_2C]
		and	eax, 0FFFFFC00h
		cmp	eax, 0DC00h
		jnz	short loc_89C6
		mov	eax, [ebp+var_38]
		sub	eax, 1
		mov	[ebp+var_38], eax
		mov	ecx, [ebp+var_38]
		mov	edx, [ebp+arg_0]
		movzx	eax, word ptr [edx+ecx*2]
		shl	eax, 0Ah
		mov	ecx, [ebp+var_2C]
		lea	edx, [eax+ecx-35FDC00h]
		mov	[ebp+var_2C], edx

loc_89C6:				; CODE XREF: icu_56::UTS46::isLabelOkContextJ(wchar_t const *,int)+95j
		mov	esi, esp
		mov	eax, [ebp+var_2C]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+4]
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	edx, [edx]
		mov	eax, [edx+20h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movzx	ecx, al
		cmp	ecx, 9
		jnz	short loc_89F3
		jmp	loc_8940
; ---------------------------------------------------------------------------

loc_89F3:				; CODE XREF: icu_56::UTS46::isLabelOkContextJ(wchar_t const *,int)+E0j
					; icu_56::UTS46::isLabelOkContextJ(wchar_t const *,int):loc_8A7Aj
		mov	eax, [ebp+var_2C]
		push	eax
		mov	ecx, [ebp+var_14]
		push	ecx
		call	_ubidi_getJoiningType_56
		add	esp, 8
		mov	[ebp+var_44], eax
		cmp	[ebp+var_44], 5
		jnz	short loc_8A63
		cmp	[ebp+var_38], 0
		jnz	short loc_8A19
		xor	al, al
		jmp	loc_8BBF
; ---------------------------------------------------------------------------

loc_8A19:				; CODE XREF: icu_56::UTS46::isLabelOkContextJ(wchar_t const *,int)+104j
		mov	eax, [ebp+var_38]
		sub	eax, 1
		mov	[ebp+var_38], eax
		mov	ecx, [ebp+var_38]
		mov	edx, [ebp+arg_0]
		movzx	eax, word ptr [edx+ecx*2]
		mov	[ebp+var_2C], eax
		mov	eax, [ebp+var_2C]
		and	eax, 0FFFFFC00h
		cmp	eax, 0DC00h
		jnz	short loc_8A61
		mov	eax, [ebp+var_38]
		sub	eax, 1
		mov	[ebp+var_38], eax
		mov	ecx, [ebp+var_38]
		mov	edx, [ebp+arg_0]
		movzx	eax, word ptr [edx+ecx*2]
		shl	eax, 0Ah
		mov	ecx, [ebp+var_2C]
		lea	edx, [eax+ecx-35FDC00h]
		mov	[ebp+var_2C], edx

loc_8A61:				; CODE XREF: icu_56::UTS46::isLabelOkContextJ(wchar_t const *,int)+130j
		jmp	short loc_8A7A
; ---------------------------------------------------------------------------

loc_8A63:				; CODE XREF: icu_56::UTS46::isLabelOkContextJ(wchar_t const *,int)+FEj
		cmp	[ebp+var_44], 3
		jz	short loc_8A6F
		cmp	[ebp+var_44], 2
		jnz	short loc_8A73

loc_8A6F:				; CODE XREF: icu_56::UTS46::isLabelOkContextJ(wchar_t const *,int)+15Bj
		jmp	short loc_8A7F
; ---------------------------------------------------------------------------
		jmp	short loc_8A7A
; ---------------------------------------------------------------------------

loc_8A73:				; CODE XREF: icu_56::UTS46::isLabelOkContextJ(wchar_t const *,int)+161j
		xor	al, al
		jmp	loc_8BBF
; ---------------------------------------------------------------------------

loc_8A7A:				; CODE XREF: icu_56::UTS46::isLabelOkContextJ(wchar_t const *,int):loc_8A61j
					; icu_56::UTS46::isLabelOkContextJ(wchar_t const *,int)+165j
		jmp	loc_89F3
; ---------------------------------------------------------------------------

loc_8A7F:				; CODE XREF: icu_56::UTS46::isLabelOkContextJ(wchar_t const *,int):loc_8A6Fj
		mov	eax, [ebp+var_20]
		add	eax, 1
		mov	[ebp+var_38], eax

loc_8A88:				; CODE XREF: icu_56::UTS46::isLabelOkContextJ(wchar_t const *,int):loc_8B11j
		mov	eax, [ebp+var_38]
		cmp	eax, [ebp+arg_4]
		jnz	short loc_8A97
		xor	al, al
		jmp	loc_8BBF
; ---------------------------------------------------------------------------

loc_8A97:				; CODE XREF: icu_56::UTS46::isLabelOkContextJ(wchar_t const *,int)+182j
		mov	eax, [ebp+var_38]
		mov	ecx, [ebp+arg_0]
		movzx	edx, word ptr [ecx+eax*2]
		mov	[ebp+var_2C], edx
		mov	eax, [ebp+var_38]
		add	eax, 1
		mov	[ebp+var_38], eax
		mov	eax, [ebp+var_2C]
		and	eax, 0FFFFFC00h
		cmp	eax, 0D800h
		jnz	short loc_8ADF
		mov	eax, [ebp+var_2C]
		shl	eax, 0Ah
		mov	ecx, [ebp+var_38]
		mov	edx, [ebp+arg_0]
		movzx	ecx, word ptr [edx+ecx*2]
		lea	edx, [eax+ecx-35FDC00h]
		mov	[ebp+var_2C], edx
		mov	eax, [ebp+var_38]
		add	eax, 1
		mov	[ebp+var_38], eax

loc_8ADF:				; CODE XREF: icu_56::UTS46::isLabelOkContextJ(wchar_t const *,int)+1AEj
		mov	eax, [ebp+var_2C]
		push	eax
		mov	ecx, [ebp+var_14]
		push	ecx
		call	_ubidi_getJoiningType_56
		add	esp, 8
		mov	[ebp+var_50], eax
		cmp	[ebp+var_50], 5
		jnz	short loc_8AFA
		jmp	short loc_8B11
; ---------------------------------------------------------------------------

loc_8AFA:				; CODE XREF: icu_56::UTS46::isLabelOkContextJ(wchar_t const *,int)+1EAj
		cmp	[ebp+var_50], 4
		jz	short loc_8B06
		cmp	[ebp+var_50], 2
		jnz	short loc_8B0A

loc_8B06:				; CODE XREF: icu_56::UTS46::isLabelOkContextJ(wchar_t const *,int)+1F2j
		jmp	short loc_8B16
; ---------------------------------------------------------------------------
		jmp	short loc_8B11
; ---------------------------------------------------------------------------

loc_8B0A:				; CODE XREF: icu_56::UTS46::isLabelOkContextJ(wchar_t const *,int)+1F8j
		xor	al, al
		jmp	loc_8BBF
; ---------------------------------------------------------------------------

loc_8B11:				; CODE XREF: icu_56::UTS46::isLabelOkContextJ(wchar_t const *,int)+1ECj
					; icu_56::UTS46::isLabelOkContextJ(wchar_t const *,int)+1FCj
		jmp	loc_8A88
; ---------------------------------------------------------------------------

loc_8B16:				; CODE XREF: icu_56::UTS46::isLabelOkContextJ(wchar_t const *,int):loc_8B06j
		jmp	loc_8BB8
; ---------------------------------------------------------------------------

loc_8B1B:				; CODE XREF: icu_56::UTS46::isLabelOkContextJ(wchar_t const *,int)+59j
		mov	eax, [ebp+var_20]
		mov	ecx, [ebp+arg_0]
		movzx	edx, word ptr [ecx+eax*2]
		cmp	edx, 200Dh
		jnz	loc_8BB8
		cmp	[ebp+var_20], 0
		jnz	short loc_8B3E
		xor	al, al
		jmp	loc_8BBF
; ---------------------------------------------------------------------------

loc_8B3E:				; CODE XREF: icu_56::UTS46::isLabelOkContextJ(wchar_t const *,int)+229j
		mov	eax, [ebp+var_20]
		mov	[ebp+var_68], eax
		mov	eax, [ebp+var_68]
		sub	eax, 1
		mov	[ebp+var_68], eax
		mov	ecx, [ebp+var_68]
		mov	edx, [ebp+arg_0]
		movzx	eax, word ptr [edx+ecx*2]
		mov	[ebp+var_5C], eax
		mov	eax, [ebp+var_5C]
		and	eax, 0FFFFFC00h
		cmp	eax, 0DC00h
		jnz	short loc_8B8C
		mov	eax, [ebp+var_68]
		sub	eax, 1
		mov	[ebp+var_68], eax
		mov	ecx, [ebp+var_68]
		mov	edx, [ebp+arg_0]
		movzx	eax, word ptr [edx+ecx*2]
		shl	eax, 0Ah
		mov	ecx, [ebp+var_5C]
		lea	edx, [eax+ecx-35FDC00h]
		mov	[ebp+var_5C], edx

loc_8B8C:				; CODE XREF: icu_56::UTS46::isLabelOkContextJ(wchar_t const *,int)+25Bj
		mov	esi, esp
		mov	eax, [ebp+var_5C]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+4]
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	edx, [edx]
		mov	eax, [edx+20h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movzx	ecx, al
		cmp	ecx, 9
		jz	short loc_8BB8
		xor	al, al
		jmp	short loc_8BBF
; ---------------------------------------------------------------------------

loc_8BB8:				; CODE XREF: icu_56::UTS46::isLabelOkContextJ(wchar_t const *,int):loc_8B16j
					; icu_56::UTS46::isLabelOkContextJ(wchar_t const *,int)+21Fj ...
		jmp	loc_8940
; ---------------------------------------------------------------------------

loc_8BBD:				; CODE XREF: icu_56::UTS46::isLabelOkContextJ(wchar_t const *,int)+43j
		mov	al, 1

loc_8BBF:				; CODE XREF: icu_56::UTS46::isLabelOkContextJ(wchar_t const *,int)+67j
					; icu_56::UTS46::isLabelOkContextJ(wchar_t const *,int)+108j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 12Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?isLabelOkContextJ@UTS46@icu_56@@ABECPB_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8BD8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UTS46::checkLabelContextO(icu_56::UTS46 *this, const wchar_t *, int, struct icu_56::IDNAInfo *)
		public ?checkLabelContextO@UTS46@icu_56@@ABEXPB_WHAAVIDNAInfo@2@@Z
?checkLabelContextO@UTS46@icu_56@@ABEXPB_WHAAVIDNAInfo@2@@Z proc near
					; CODE XREF: icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed	char,icu_56::IDNAInfo &,UErrorCode &)+72Bp

var_18C		= byte ptr -18Ch
var_C8		= dword	ptr -0C8h
var_BC		= word ptr -0BCh
var_B0		= dword	ptr -0B0h
var_A4		= dword	ptr -0A4h
var_98		= word ptr -98h
var_8C		= dword	ptr -8Ch
var_80		= dword	ptr -80h
var_74		= dword	ptr -74h
var_68		= word ptr -68h
var_5C		= dword	ptr -5Ch
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 18Ch
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_18C]
		mov	ecx, 63h ; 'c'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		sub	eax, 1
		mov	[ebp+var_14], eax
		mov	[ebp+var_20], 0
		mov	[ebp+var_2C], 0
		jmp	short loc_8C1D
; ---------------------------------------------------------------------------

loc_8C14:				; CODE XREF: icu_56::UTS46::checkLabelContextO(wchar_t const *,int,icu_56::IDNAInfo &):loc_8FB4j
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax

loc_8C1D:				; CODE XREF: icu_56::UTS46::checkLabelContextO(wchar_t const *,int,icu_56::IDNAInfo &)+3Aj
		mov	eax, [ebp+var_2C]
		cmp	eax, [ebp+var_14]
		jg	loc_8FB9
		mov	eax, [ebp+var_2C]
		mov	ecx, [ebp+arg_0]
		movzx	edx, word ptr [ecx+eax*2]
		mov	[ebp+var_38], edx
		cmp	[ebp+var_38], 0B7h ; ''
		jge	short loc_8C44
		jmp	loc_8FB4
; ---------------------------------------------------------------------------

loc_8C44:				; CODE XREF: icu_56::UTS46::checkLabelContextO(wchar_t const *,int,icu_56::IDNAInfo &)+65j
		cmp	[ebp+var_38], 6F9h
		jg	loc_8EB0
		cmp	[ebp+var_38], 0B7h ; ''
		jnz	short loc_8C9F
		cmp	[ebp+var_2C], 0
		jle	short loc_8C88
		mov	eax, [ebp+var_2C]
		mov	ecx, [ebp+arg_0]
		movzx	edx, word ptr [ecx+eax*2-2]
		cmp	edx, 6Ch ; 'l'
		jnz	short loc_8C88
		mov	eax, [ebp+var_2C]
		cmp	eax, [ebp+var_14]
		jge	short loc_8C88
		mov	eax, [ebp+var_2C]
		mov	ecx, [ebp+arg_0]
		movzx	edx, word ptr [ecx+eax*2+2]
		cmp	edx, 6Ch ; 'l'
		jz	short loc_8C9A

loc_8C88:				; CODE XREF: icu_56::UTS46::checkLabelContextO(wchar_t const *,int,icu_56::IDNAInfo &)+86j
					; icu_56::UTS46::checkLabelContextO(wchar_t const *,int,icu_56::IDNAInfo &)+96j ...
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax+4]
		or	ecx, 2000h
		mov	edx, [ebp+arg_8]
		mov	[edx+4], ecx

loc_8C9A:				; CODE XREF: icu_56::UTS46::checkLabelContextO(wchar_t const *,int,icu_56::IDNAInfo &)+AEj
		jmp	loc_8EAB
; ---------------------------------------------------------------------------

loc_8C9F:				; CODE XREF: icu_56::UTS46::checkLabelContextO(wchar_t const *,int,icu_56::IDNAInfo &)+80j
		cmp	[ebp+var_38], 375h
		jnz	loc_8D67
		mov	[ebp+var_44], 0FFFFFFFFh
		mov	eax, [ebp+var_2C]
		cmp	eax, [ebp+var_14]
		jge	loc_8D4A
		mov	[ebp+var_50], 0
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_5C], eax
		mov	eax, [ebp+var_5C]
		mov	ecx, [ebp+arg_0]
		movzx	edx, word ptr [ecx+eax*2]
		mov	[ebp+var_38], edx
		mov	eax, [ebp+var_5C]
		add	eax, 1
		mov	[ebp+var_5C], eax
		mov	eax, [ebp+var_38]
		and	eax, 0FFFFFC00h
		cmp	eax, 0D800h
		jnz	short loc_8D37
		mov	eax, [ebp+var_5C]
		cmp	eax, [ebp+arg_4]
		jz	short loc_8D37
		mov	eax, [ebp+var_5C]
		mov	ecx, [ebp+arg_0]
		mov	dx, [ecx+eax*2]
		mov	[ebp+var_68], dx
		movzx	eax, [ebp+var_68]
		and	eax, 0FFFFFC00h
		cmp	eax, 0DC00h
		jnz	short loc_8D37
		mov	eax, [ebp+var_5C]
		add	eax, 1
		mov	[ebp+var_5C], eax
		mov	eax, [ebp+var_38]
		shl	eax, 0Ah
		movzx	ecx, [ebp+var_68]
		lea	edx, [eax+ecx-35FDC00h]
		mov	[ebp+var_38], edx

loc_8D37:				; CODE XREF: icu_56::UTS46::checkLabelContextO(wchar_t const *,int,icu_56::IDNAInfo &)+11Aj
					; icu_56::UTS46::checkLabelContextO(wchar_t const *,int,icu_56::IDNAInfo &)+122j ...
		lea	eax, [ebp+var_50]
		push	eax
		mov	ecx, [ebp+var_38]
		push	ecx
		call	_uscript_getScript_56
		add	esp, 8
		mov	[ebp+var_44], eax

loc_8D4A:				; CODE XREF: icu_56::UTS46::checkLabelContextO(wchar_t const *,int,icu_56::IDNAInfo &)+E1j
		cmp	[ebp+var_44], 0Eh
		jz	short loc_8D62
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax+4]
		or	ecx, 2000h
		mov	edx, [ebp+arg_8]
		mov	[edx+4], ecx

loc_8D62:				; CODE XREF: icu_56::UTS46::checkLabelContextO(wchar_t const *,int,icu_56::IDNAInfo &)+176j
		jmp	loc_8EAB
; ---------------------------------------------------------------------------

loc_8D67:				; CODE XREF: icu_56::UTS46::checkLabelContextO(wchar_t const *,int,icu_56::IDNAInfo &)+CEj
		cmp	[ebp+var_38], 5F3h
		jz	short loc_8D7D
		cmp	[ebp+var_38], 5F4h
		jnz	loc_8E50

loc_8D7D:				; CODE XREF: icu_56::UTS46::checkLabelContextO(wchar_t const *,int,icu_56::IDNAInfo &)+196j
		mov	[ebp+var_74], 0FFFFFFFFh
		cmp	[ebp+var_2C], 0
		jle	loc_8E36
		mov	[ebp+var_80], 0
		mov	eax, [ebp+var_2C]
		mov	[ebp+var_8C], eax
		mov	eax, [ebp+var_8C]
		sub	eax, 1
		mov	[ebp+var_8C], eax
		mov	ecx, [ebp+var_8C]
		mov	edx, [ebp+arg_0]
		movzx	eax, word ptr [edx+ecx*2]
		mov	[ebp+var_38], eax
		mov	eax, [ebp+var_38]
		and	eax, 0FFFFFC00h
		cmp	eax, 0DC00h
		jnz	short loc_8E23
		cmp	[ebp+var_8C], 0
		jle	short loc_8E23
		mov	eax, [ebp+var_8C]
		mov	ecx, [ebp+arg_0]
		mov	dx, [ecx+eax*2-2]
		mov	[ebp+var_98], dx
		movzx	eax, [ebp+var_98]
		and	eax, 0FFFFFC00h
		cmp	eax, 0D800h
		jnz	short loc_8E23
		mov	eax, [ebp+var_8C]
		sub	eax, 1
		mov	[ebp+var_8C], eax
		movzx	eax, [ebp+var_98]
		shl	eax, 0Ah
		mov	ecx, [ebp+var_38]
		lea	edx, [eax+ecx-35FDC00h]
		mov	[ebp+var_38], edx

loc_8E23:				; CODE XREF: icu_56::UTS46::checkLabelContextO(wchar_t const *,int,icu_56::IDNAInfo &)+1F2j
					; icu_56::UTS46::checkLabelContextO(wchar_t const *,int,icu_56::IDNAInfo &)+1FBj ...
		lea	eax, [ebp+var_80]
		push	eax
		mov	ecx, [ebp+var_38]
		push	ecx
		call	_uscript_getScript_56
		add	esp, 8
		mov	[ebp+var_74], eax

loc_8E36:				; CODE XREF: icu_56::UTS46::checkLabelContextO(wchar_t const *,int,icu_56::IDNAInfo &)+1B0j
		cmp	[ebp+var_74], 13h
		jz	short loc_8E4E
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax+4]
		or	ecx, 2000h
		mov	edx, [ebp+arg_8]
		mov	[edx+4], ecx

loc_8E4E:				; CODE XREF: icu_56::UTS46::checkLabelContextO(wchar_t const *,int,icu_56::IDNAInfo &)+262j
		jmp	short loc_8EAB
; ---------------------------------------------------------------------------

loc_8E50:				; CODE XREF: icu_56::UTS46::checkLabelContextO(wchar_t const *,int,icu_56::IDNAInfo &)+19Fj
		cmp	[ebp+var_38], 660h
		jl	short loc_8EAB
		cmp	[ebp+var_38], 669h
		jg	short loc_8E83
		cmp	[ebp+var_20], 0
		jle	short loc_8E7A
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax+4]
		or	ecx, 4000h
		mov	edx, [ebp+arg_8]
		mov	[edx+4], ecx

loc_8E7A:				; CODE XREF: icu_56::UTS46::checkLabelContextO(wchar_t const *,int,icu_56::IDNAInfo &)+28Ej
		mov	[ebp+var_20], 0FFFFFFFFh
		jmp	short loc_8EAB
; ---------------------------------------------------------------------------

loc_8E83:				; CODE XREF: icu_56::UTS46::checkLabelContextO(wchar_t const *,int,icu_56::IDNAInfo &)+288j
		cmp	[ebp+var_38], 6F0h
		jl	short loc_8EAB
		cmp	[ebp+var_20], 0
		jge	short loc_8EA4
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax+4]
		or	ecx, 4000h
		mov	edx, [ebp+arg_8]
		mov	[edx+4], ecx

loc_8EA4:				; CODE XREF: icu_56::UTS46::checkLabelContextO(wchar_t const *,int,icu_56::IDNAInfo &)+2B8j
		mov	[ebp+var_20], 1

loc_8EAB:				; CODE XREF: icu_56::UTS46::checkLabelContextO(wchar_t const *,int,icu_56::IDNAInfo &):loc_8C9Aj
					; icu_56::UTS46::checkLabelContextO(wchar_t const *,int,icu_56::IDNAInfo &):loc_8D62j ...
		jmp	loc_8FB4
; ---------------------------------------------------------------------------

loc_8EB0:				; CODE XREF: icu_56::UTS46::checkLabelContextO(wchar_t const *,int,icu_56::IDNAInfo &)+73j
		cmp	[ebp+var_38], 30FBh
		jnz	loc_8FB4
		mov	[ebp+var_A4], 0
		mov	[ebp+var_B0], 0

loc_8ED1:				; CODE XREF: icu_56::UTS46::checkLabelContextO(wchar_t const *,int,icu_56::IDNAInfo &):loc_8FAFj
		mov	eax, [ebp+var_B0]
		cmp	eax, [ebp+var_14]
		jle	short loc_8EF3
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax+4]
		or	ecx, 2000h
		mov	edx, [ebp+arg_8]
		mov	[edx+4], ecx
		jmp	loc_8FB4
; ---------------------------------------------------------------------------

loc_8EF3:				; CODE XREF: icu_56::UTS46::checkLabelContextO(wchar_t const *,int,icu_56::IDNAInfo &)+302j
		mov	eax, [ebp+var_B0]
		mov	ecx, [ebp+arg_0]
		movzx	edx, word ptr [ecx+eax*2]
		mov	[ebp+var_38], edx
		mov	eax, [ebp+var_B0]
		add	eax, 1
		mov	[ebp+var_B0], eax
		mov	eax, [ebp+var_38]
		and	eax, 0FFFFFC00h
		cmp	eax, 0D800h
		jnz	short loc_8F79
		mov	eax, [ebp+var_B0]
		cmp	eax, [ebp+arg_4]
		jz	short loc_8F79
		mov	eax, [ebp+var_B0]
		mov	ecx, [ebp+arg_0]
		mov	dx, [ecx+eax*2]
		mov	[ebp+var_BC], dx
		movzx	eax, [ebp+var_BC]
		and	eax, 0FFFFFC00h
		cmp	eax, 0DC00h
		jnz	short loc_8F79
		mov	eax, [ebp+var_B0]
		add	eax, 1
		mov	[ebp+var_B0], eax
		mov	eax, [ebp+var_38]
		shl	eax, 0Ah
		movzx	ecx, [ebp+var_BC]
		lea	edx, [eax+ecx-35FDC00h]
		mov	[ebp+var_38], edx

loc_8F79:				; CODE XREF: icu_56::UTS46::checkLabelContextO(wchar_t const *,int,icu_56::IDNAInfo &)+347j
					; icu_56::UTS46::checkLabelContextO(wchar_t const *,int,icu_56::IDNAInfo &)+352j ...
		lea	eax, [ebp+var_A4]
		push	eax
		mov	ecx, [ebp+var_38]
		push	ecx
		call	_uscript_getScript_56
		add	esp, 8
		mov	[ebp+var_C8], eax
		cmp	[ebp+var_C8], 14h
		jz	short loc_8FAD
		cmp	[ebp+var_C8], 16h
		jz	short loc_8FAD
		cmp	[ebp+var_C8], 11h
		jnz	short loc_8FAF

loc_8FAD:				; CODE XREF: icu_56::UTS46::checkLabelContextO(wchar_t const *,int,icu_56::IDNAInfo &)+3C1j
					; icu_56::UTS46::checkLabelContextO(wchar_t const *,int,icu_56::IDNAInfo &)+3CAj
		jmp	short loc_8FB4
; ---------------------------------------------------------------------------

loc_8FAF:				; CODE XREF: icu_56::UTS46::checkLabelContextO(wchar_t const *,int,icu_56::IDNAInfo &)+3D3j
		jmp	loc_8ED1
; ---------------------------------------------------------------------------

loc_8FB4:				; CODE XREF: icu_56::UTS46::checkLabelContextO(wchar_t const *,int,icu_56::IDNAInfo &)+67j
					; icu_56::UTS46::checkLabelContextO(wchar_t const *,int,icu_56::IDNAInfo &):loc_8EABj ...
		jmp	loc_8C14
; ---------------------------------------------------------------------------

loc_8FB9:				; CODE XREF: icu_56::UTS46::checkLabelContextO(wchar_t const *,int,icu_56::IDNAInfo &)+4Bj
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN45_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 18Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?checkLabelContextO@UTS46@icu_56@@ABEXPB_WHAAVIDNAInfo@2@@Z endp

; ---------------------------------------------------------------------------
$LN45_0		dd 3			; DATA XREF: icu_56::UTS46::checkLabelContextO(wchar_t const *,int,icu_56::IDNAInfo &)+3E5o
		dd offset $LN44_0
$LN44_0		dd 0FFFFFFB0h, 4	; DATA XREF: .text:00008FE4o
		dd offset $LN41_0	; "errorCode"
		dd 0FFFFFF80h, 4
		dd offset $LN42_0	; "errorCode"
		dd 0FFFFFF5Ch, 4
		dd offset $LN43		; "errorCode"
$LN43		db 'errorCode',0        ; DATA XREF: .text:00009008o
$LN42_0		db 'errorCode',0        ; DATA XREF: .text:00008FFCo
$LN41_0		db 'errorCode',0        ; DATA XREF: .text:00008FF0o
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 902Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl uidna_openUTS46_56(unsigned int, enum UErrorCode *)
		public _uidna_openUTS46_56
_uidna_openUTS46_56 proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; unsigned int
		call	?createUTS46Instance@IDNA@icu_56@@SAPAV12@IAAW4UErrorCode@@@Z ;	icu_56::IDNA::createUTS46Instance(uint,UErrorCode &)
		add	esp, 8
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uidna_openUTS46_56 endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9070h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uidna_close_56
_uidna_close_56	proc near

var_DC		= dword	ptr -0DCh
var_D4		= dword	ptr -0D4h
var_C8		= dword	ptr -0C8h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0DCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_DC]
		mov	ecx, 37h ; '7'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_C8], eax
		mov	ecx, [ebp+var_C8]
		mov	[ebp+var_D4], ecx
		cmp	[ebp+var_D4], 0
		jz	short loc_90D1
		mov	esi, esp
		push	1
		mov	edx, [ebp+var_D4]
		mov	eax, [edx]
		mov	ecx, [ebp+var_D4]
		mov	edx, [eax]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_DC], eax
		jmp	short loc_90DB
; ---------------------------------------------------------------------------

loc_90D1:				; CODE XREF: _uidna_close_56+3Aj
		mov	[ebp+var_DC], 0

loc_90DB:				; CODE XREF: _uidna_close_56+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0DCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uidna_close_56	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 90F0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl uidna_labelToASCII_56(int, wchar_t *, int, wchar_t *, int, int, enum UErrorCode *)
		public _uidna_labelToASCII_56
_uidna_labelToASCII_56 proc near

var_174		= byte ptr -174h
var_170		= dword	ptr -170h
var_A4		= byte ptr -0A4h
var_90		= byte ptr -90h
var_48		= byte ptr -48h
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h

		push	ebp
		mov	ebp, esp
		sub	esp, 174h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_174]
		mov	ecx, 5Dh ; ']'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	eax, [ebp+arg_18]
		push	eax
		mov	ecx, [ebp+arg_14]
		push	ecx
		mov	edx, [ebp+arg_10]
		push	edx
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		call	?checkArgs@@YACPBXHPAXHPAUUIDNAInfo@@PAW4UErrorCode@@@Z	; checkArgs(void const *,int,void *,int,UIDNAInfo *,UErrorCode *)
		add	esp, 18h
		movsx	eax, al
		test	eax, eax
		jnz	short loc_9146
		xor	eax, eax
		jmp	loc_91F6
; ---------------------------------------------------------------------------

loc_9146:				; CODE XREF: _uidna_labelToASCII_56+4Dj
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; wchar_t *
		cmp	[ebp+arg_8], 0
		setl	dl
		movzx	eax, dl
		push	eax		; signed __int8
		lea	ecx, [ebp+var_48] ; this
		call	??0UnicodeString@icu_56@@QAE@CPB_WH@Z ;	icu_56::UnicodeString::UnicodeString(signed char,wchar_t const *,int)
		mov	eax, [ebp+arg_10]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; wchar_t *
		lea	ecx, [ebp+var_90] ; this
		call	??0UnicodeString@icu_56@@QAE@PA_WHH@Z ;	icu_56::UnicodeString::UnicodeString(wchar_t *,int,int)
		lea	ecx, [ebp+var_A4] ; this
		call	??0IDNAInfo@icu_56@@QAE@XZ ; icu_56::IDNAInfo::IDNAInfo(void)
		mov	esi, esp
		mov	eax, [ebp+arg_18]
		push	eax
		lea	ecx, [ebp+var_A4]
		push	ecx
		lea	edx, [ebp+var_90]
		push	edx
		lea	eax, [ebp+var_48]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	ecx, [ebp+arg_0]
		mov	eax, [edx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_14]
		push	eax		; int
		lea	ecx, [ebp+var_A4]
		push	ecx		; icu_56::IDNAInfo *
		call	?idnaInfoToStruct@@YAXAAVIDNAInfo@icu_56@@PAUUIDNAInfo@@@Z ; idnaInfoToStruct(icu_56::IDNAInfo &,UIDNAInfo *)
		add	esp, 8
		mov	eax, [ebp+arg_18]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_10]
		push	ecx		; int
		mov	edx, [ebp+arg_C]
		push	edx		; wchar_t *
		lea	ecx, [ebp+var_90] ; this
		call	?extract@UnicodeString@icu_56@@QBEHPA_WHAAW4UErrorCode@@@Z ; icu_56::UnicodeString::extract(wchar_t *,int,UErrorCode &)
		mov	[ebp+var_170], eax
		lea	ecx, [ebp+var_90] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		lea	ecx, [ebp+var_48] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		mov	eax, [ebp+var_170]

loc_91F6:				; CODE XREF: _uidna_labelToASCII_56+51j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN8_4
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 174h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uidna_labelToASCII_56 endp

; ---------------------------------------------------------------------------
		align 4
$LN8_4		dd 3			; DATA XREF: _uidna_labelToASCII_56+10Ao
		dd offset $LN7
$LN7		dd 0FFFFFFB8h, 40h	; DATA XREF: .text:0000922Co
		dd offset $LN4		; "src"
		dd 0FFFFFF70h, 40h
		dd offset $LN5_0	; "destString"
		dd 0FFFFFF5Ch, 0Ch
		dd offset $LN6_4	; "info"
$LN6_4		db 'info',0             ; DATA XREF: .text:00009250o
$LN5_0		db 'destString',0       ; DATA XREF: .text:00009244o
$LN4		db 'src',0              ; DATA XREF: .text:00009238o
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9268h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl checkArgs(void const *, int, void	*, int,	struct UIDNAInfo *, enum  UErrorCode *)
?checkArgs@@YACPBXHPAXHPAUUIDNAInfo@@PAW4UErrorCode@@@Z	proc near
					; CODE XREF: _uidna_labelToASCII_56+40p
					; _uidna_labelToUnicode_56+40p	...

var_C4		= dword	ptr -0C4h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C4]
		mov	ecx, 31h ; '1'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_14]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_92A2
		xor	al, al
		jmp	loc_9359
; ---------------------------------------------------------------------------

loc_92A2:				; CODE XREF: checkArgs(void const *,int,void *,int,UIDNAInfo *,UErrorCode *)+31j
		cmp	[ebp+arg_10], 0
		jz	short loc_92B3
		mov	eax, [ebp+arg_10]
		movsx	ecx, word ptr [eax]
		cmp	ecx, 10h
		jge	short loc_92C3

loc_92B3:				; CODE XREF: checkArgs(void const *,int,void *,int,UIDNAInfo *,UErrorCode *)+3Ej
		mov	eax, [ebp+arg_14]
		mov	dword ptr [eax], 1
		xor	al, al
		jmp	loc_9359
; ---------------------------------------------------------------------------

loc_92C3:				; CODE XREF: checkArgs(void const *,int,void *,int,UIDNAInfo *,UErrorCode *)+49j
		cmp	[ebp+arg_0], 0
		jnz	short loc_92DA
		xor	eax, eax
		cmp	[ebp+arg_4], 0
		setnz	al
		mov	[ebp+var_C4], eax
		jmp	short loc_92E9
; ---------------------------------------------------------------------------

loc_92DA:				; CODE XREF: checkArgs(void const *,int,void *,int,UIDNAInfo *,UErrorCode *)+5Fj
		xor	ecx, ecx
		cmp	[ebp+arg_4], 0FFFFFFFFh
		setl	cl
		mov	[ebp+var_C4], ecx

loc_92E9:				; CODE XREF: checkArgs(void const *,int,void *,int,UIDNAInfo *,UErrorCode *)+70j
		cmp	[ebp+var_C4], 0
		jnz	short loc_932F
		cmp	[ebp+arg_8], 0
		jnz	short loc_9309
		xor	eax, eax
		cmp	[ebp+arg_C], 0
		setnz	al
		mov	[ebp+var_C4], eax
		jmp	short loc_9318
; ---------------------------------------------------------------------------

loc_9309:				; CODE XREF: checkArgs(void const *,int,void *,int,UIDNAInfo *,UErrorCode *)+8Ej
		xor	ecx, ecx
		cmp	[ebp+arg_C], 0
		setl	cl
		mov	[ebp+var_C4], ecx

loc_9318:				; CODE XREF: checkArgs(void const *,int,void *,int,UIDNAInfo *,UErrorCode *)+9Fj
		cmp	[ebp+var_C4], 0
		jnz	short loc_932F
		mov	eax, [ebp+arg_8]
		cmp	eax, [ebp+arg_0]
		jnz	short loc_933C
		cmp	[ebp+arg_0], 0
		jz	short loc_933C

loc_932F:				; CODE XREF: checkArgs(void const *,int,void *,int,UIDNAInfo *,UErrorCode *)+88j
					; checkArgs(void const *,int,void *,int,UIDNAInfo *,UErrorCode *)+B7j
		mov	eax, [ebp+arg_14]
		mov	dword ptr [eax], 1
		xor	al, al
		jmp	short loc_9359
; ---------------------------------------------------------------------------

loc_933C:				; CODE XREF: checkArgs(void const *,int,void *,int,UIDNAInfo *,UErrorCode *)+BFj
					; checkArgs(void const *,int,void *,int,UIDNAInfo *,UErrorCode *)+C5j
		mov	eax, [ebp+arg_10]
		movsx	ecx, word ptr [eax]
		sub	ecx, 2
		push	ecx		; Size
		push	0		; Val
		mov	edx, [ebp+arg_10]
		add	edx, 2
		push	edx		; Dst
		call	_memset
		add	esp, 0Ch
		mov	al, 1

loc_9359:				; CODE XREF: checkArgs(void const *,int,void *,int,UIDNAInfo *,UErrorCode *)+35j
					; checkArgs(void const *,int,void *,int,UIDNAInfo *,UErrorCode *)+56j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?checkArgs@@YACPBXHPAXHPAUUIDNAInfo@@PAW4UErrorCode@@@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9370h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl idnaInfoToStruct(icu_56::IDNAInfo	*, int)
?idnaInfoToStruct@@YAXAAVIDNAInfo@icu_56@@PAUUIDNAInfo@@@Z proc	near
					; CODE XREF: _uidna_labelToASCII_56+C8p
					; _uidna_labelToUnicode_56+C8p	...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	ecx, [ebp+arg_0] ; this
		call	?isTransitionalDifferent@IDNAInfo@icu_56@@QBECXZ ; icu_56::IDNAInfo::isTransitionalDifferent(void)
		mov	ecx, [ebp+arg_4]
		mov	[ecx+2], al
		mov	ecx, [ebp+arg_0] ; this
		call	?getErrors@IDNAInfo@icu_56@@QBEIXZ ; icu_56::IDNAInfo::getErrors(void)
		mov	ecx, [ebp+arg_4]
		mov	[ecx+4], eax
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?idnaInfoToStruct@@YAXAAVIDNAInfo@icu_56@@PAUUIDNAInfo@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 93C0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl uidna_labelToUnicode_56(int, wchar_t *, int, wchar_t *, int, int,	enum UErrorCode	*)
		public _uidna_labelToUnicode_56
_uidna_labelToUnicode_56 proc near

var_174		= byte ptr -174h
var_170		= dword	ptr -170h
var_A4		= byte ptr -0A4h
var_90		= byte ptr -90h
var_48		= byte ptr -48h
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h

		push	ebp
		mov	ebp, esp
		sub	esp, 174h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_174]
		mov	ecx, 5Dh ; ']'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	eax, [ebp+arg_18]
		push	eax
		mov	ecx, [ebp+arg_14]
		push	ecx
		mov	edx, [ebp+arg_10]
		push	edx
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		call	?checkArgs@@YACPBXHPAXHPAUUIDNAInfo@@PAW4UErrorCode@@@Z	; checkArgs(void const *,int,void *,int,UIDNAInfo *,UErrorCode *)
		add	esp, 18h
		movsx	eax, al
		test	eax, eax
		jnz	short loc_9416
		xor	eax, eax
		jmp	loc_94C6
; ---------------------------------------------------------------------------

loc_9416:				; CODE XREF: _uidna_labelToUnicode_56+4Dj
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; wchar_t *
		cmp	[ebp+arg_8], 0
		setl	dl
		movzx	eax, dl
		push	eax		; signed __int8
		lea	ecx, [ebp+var_48] ; this
		call	??0UnicodeString@icu_56@@QAE@CPB_WH@Z ;	icu_56::UnicodeString::UnicodeString(signed char,wchar_t const *,int)
		mov	eax, [ebp+arg_10]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; wchar_t *
		lea	ecx, [ebp+var_90] ; this
		call	??0UnicodeString@icu_56@@QAE@PA_WHH@Z ;	icu_56::UnicodeString::UnicodeString(wchar_t *,int,int)
		lea	ecx, [ebp+var_A4] ; this
		call	??0IDNAInfo@icu_56@@QAE@XZ ; icu_56::IDNAInfo::IDNAInfo(void)
		mov	esi, esp
		mov	eax, [ebp+arg_18]
		push	eax
		lea	ecx, [ebp+var_A4]
		push	ecx
		lea	edx, [ebp+var_90]
		push	edx
		lea	eax, [ebp+var_48]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	ecx, [ebp+arg_0]
		mov	eax, [edx+0Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_14]
		push	eax		; int
		lea	ecx, [ebp+var_A4]
		push	ecx		; icu_56::IDNAInfo *
		call	?idnaInfoToStruct@@YAXAAVIDNAInfo@icu_56@@PAUUIDNAInfo@@@Z ; idnaInfoToStruct(icu_56::IDNAInfo &,UIDNAInfo *)
		add	esp, 8
		mov	eax, [ebp+arg_18]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_10]
		push	ecx		; int
		mov	edx, [ebp+arg_C]
		push	edx		; wchar_t *
		lea	ecx, [ebp+var_90] ; this
		call	?extract@UnicodeString@icu_56@@QBEHPA_WHAAW4UErrorCode@@@Z ; icu_56::UnicodeString::extract(wchar_t *,int,UErrorCode &)
		mov	[ebp+var_170], eax
		lea	ecx, [ebp+var_90] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		lea	ecx, [ebp+var_48] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		mov	eax, [ebp+var_170]

loc_94C6:				; CODE XREF: _uidna_labelToUnicode_56+51j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN8_5
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 174h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uidna_labelToUnicode_56 endp

; ---------------------------------------------------------------------------
		align 4
$LN8_5		dd 3			; DATA XREF: _uidna_labelToUnicode_56+10Ao
		dd offset $LN7_0
$LN7_0		dd 0FFFFFFB8h, 40h	; DATA XREF: .text:000094FCo
		dd offset $LN4_0	; "src"
		dd 0FFFFFF70h, 40h
		dd offset $LN5_1	; "destString"
		dd 0FFFFFF5Ch, 0Ch
		dd offset $LN6_5	; "info"
$LN6_5		db 'info',0             ; DATA XREF: .text:00009520o
$LN5_1		db 'destString',0       ; DATA XREF: .text:00009514o
$LN4_0		db 'src',0              ; DATA XREF: .text:00009508o
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9538h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl uidna_nameToASCII_56(int,	wchar_t	*, int,	wchar_t	*, int,	int, enum UErrorCode *)
		public _uidna_nameToASCII_56
_uidna_nameToASCII_56 proc near

var_174		= byte ptr -174h
var_170		= dword	ptr -170h
var_A4		= byte ptr -0A4h
var_90		= byte ptr -90h
var_48		= byte ptr -48h
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h

		push	ebp
		mov	ebp, esp
		sub	esp, 174h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_174]
		mov	ecx, 5Dh ; ']'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	eax, [ebp+arg_18]
		push	eax
		mov	ecx, [ebp+arg_14]
		push	ecx
		mov	edx, [ebp+arg_10]
		push	edx
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		call	?checkArgs@@YACPBXHPAXHPAUUIDNAInfo@@PAW4UErrorCode@@@Z	; checkArgs(void const *,int,void *,int,UIDNAInfo *,UErrorCode *)
		add	esp, 18h
		movsx	eax, al
		test	eax, eax
		jnz	short loc_958E
		xor	eax, eax
		jmp	loc_963E
; ---------------------------------------------------------------------------

loc_958E:				; CODE XREF: _uidna_nameToASCII_56+4Dj
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; wchar_t *
		cmp	[ebp+arg_8], 0
		setl	dl
		movzx	eax, dl
		push	eax		; signed __int8
		lea	ecx, [ebp+var_48] ; this
		call	??0UnicodeString@icu_56@@QAE@CPB_WH@Z ;	icu_56::UnicodeString::UnicodeString(signed char,wchar_t const *,int)
		mov	eax, [ebp+arg_10]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; wchar_t *
		lea	ecx, [ebp+var_90] ; this
		call	??0UnicodeString@icu_56@@QAE@PA_WHH@Z ;	icu_56::UnicodeString::UnicodeString(wchar_t *,int,int)
		lea	ecx, [ebp+var_A4] ; this
		call	??0IDNAInfo@icu_56@@QAE@XZ ; icu_56::IDNAInfo::IDNAInfo(void)
		mov	esi, esp
		mov	eax, [ebp+arg_18]
		push	eax
		lea	ecx, [ebp+var_A4]
		push	ecx
		lea	edx, [ebp+var_90]
		push	edx
		lea	eax, [ebp+var_48]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	ecx, [ebp+arg_0]
		mov	eax, [edx+10h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_14]
		push	eax		; int
		lea	ecx, [ebp+var_A4]
		push	ecx		; icu_56::IDNAInfo *
		call	?idnaInfoToStruct@@YAXAAVIDNAInfo@icu_56@@PAUUIDNAInfo@@@Z ; idnaInfoToStruct(icu_56::IDNAInfo &,UIDNAInfo *)
		add	esp, 8
		mov	eax, [ebp+arg_18]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_10]
		push	ecx		; int
		mov	edx, [ebp+arg_C]
		push	edx		; wchar_t *
		lea	ecx, [ebp+var_90] ; this
		call	?extract@UnicodeString@icu_56@@QBEHPA_WHAAW4UErrorCode@@@Z ; icu_56::UnicodeString::extract(wchar_t *,int,UErrorCode &)
		mov	[ebp+var_170], eax
		lea	ecx, [ebp+var_90] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		lea	ecx, [ebp+var_48] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		mov	eax, [ebp+var_170]

loc_963E:				; CODE XREF: _uidna_nameToASCII_56+51j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN8_6
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 174h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uidna_nameToASCII_56 endp

; ---------------------------------------------------------------------------
		align 10h
$LN8_6		dd 3			; DATA XREF: _uidna_nameToASCII_56+10Ao
		dd offset $LN7_1
$LN7_1		dd 0FFFFFFB8h, 40h	; DATA XREF: .text:00009674o
		dd offset $LN4_1	; "src"
		dd 0FFFFFF70h, 40h
		dd offset $LN5_2	; "destString"
		dd 0FFFFFF5Ch, 0Ch
		dd offset $LN6_6	; "info"
$LN6_6		db 'info',0             ; DATA XREF: .text:00009698o
$LN5_2		db 'destString',0       ; DATA XREF: .text:0000968Co
$LN4_1		db 'src',0              ; DATA XREF: .text:00009680o
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 96B0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl uidna_nameToUnicode_56(int, wchar_t *, int, wchar_t *, int, int, enum UErrorCode *)
		public _uidna_nameToUnicode_56
_uidna_nameToUnicode_56	proc near

var_174		= byte ptr -174h
var_170		= dword	ptr -170h
var_A4		= byte ptr -0A4h
var_90		= byte ptr -90h
var_48		= byte ptr -48h
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h

		push	ebp
		mov	ebp, esp
		sub	esp, 174h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_174]
		mov	ecx, 5Dh ; ']'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	eax, [ebp+arg_18]
		push	eax
		mov	ecx, [ebp+arg_14]
		push	ecx
		mov	edx, [ebp+arg_10]
		push	edx
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		call	?checkArgs@@YACPBXHPAXHPAUUIDNAInfo@@PAW4UErrorCode@@@Z	; checkArgs(void const *,int,void *,int,UIDNAInfo *,UErrorCode *)
		add	esp, 18h
		movsx	eax, al
		test	eax, eax
		jnz	short loc_9706
		xor	eax, eax
		jmp	loc_97B6
; ---------------------------------------------------------------------------

loc_9706:				; CODE XREF: _uidna_nameToUnicode_56+4Dj
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; wchar_t *
		cmp	[ebp+arg_8], 0
		setl	dl
		movzx	eax, dl
		push	eax		; signed __int8
		lea	ecx, [ebp+var_48] ; this
		call	??0UnicodeString@icu_56@@QAE@CPB_WH@Z ;	icu_56::UnicodeString::UnicodeString(signed char,wchar_t const *,int)
		mov	eax, [ebp+arg_10]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; wchar_t *
		lea	ecx, [ebp+var_90] ; this
		call	??0UnicodeString@icu_56@@QAE@PA_WHH@Z ;	icu_56::UnicodeString::UnicodeString(wchar_t *,int,int)
		lea	ecx, [ebp+var_A4] ; this
		call	??0IDNAInfo@icu_56@@QAE@XZ ; icu_56::IDNAInfo::IDNAInfo(void)
		mov	esi, esp
		mov	eax, [ebp+arg_18]
		push	eax
		lea	ecx, [ebp+var_A4]
		push	ecx
		lea	edx, [ebp+var_90]
		push	edx
		lea	eax, [ebp+var_48]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	ecx, [ebp+arg_0]
		mov	eax, [edx+14h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_14]
		push	eax		; int
		lea	ecx, [ebp+var_A4]
		push	ecx		; icu_56::IDNAInfo *
		call	?idnaInfoToStruct@@YAXAAVIDNAInfo@icu_56@@PAUUIDNAInfo@@@Z ; idnaInfoToStruct(icu_56::IDNAInfo &,UIDNAInfo *)
		add	esp, 8
		mov	eax, [ebp+arg_18]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_10]
		push	ecx		; int
		mov	edx, [ebp+arg_C]
		push	edx		; wchar_t *
		lea	ecx, [ebp+var_90] ; this
		call	?extract@UnicodeString@icu_56@@QBEHPA_WHAAW4UErrorCode@@@Z ; icu_56::UnicodeString::extract(wchar_t *,int,UErrorCode &)
		mov	[ebp+var_170], eax
		lea	ecx, [ebp+var_90] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		lea	ecx, [ebp+var_48] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		mov	eax, [ebp+var_170]

loc_97B6:				; CODE XREF: _uidna_nameToUnicode_56+51j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN8_7
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 174h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uidna_nameToUnicode_56	endp

; ---------------------------------------------------------------------------
		align 4
$LN8_7		dd 3			; DATA XREF: _uidna_nameToUnicode_56+10Ao
		dd offset $LN7_2
$LN7_2		dd 0FFFFFFB8h, 40h	; DATA XREF: .text:000097ECo
		dd offset $LN4_2	; "src"
		dd 0FFFFFF70h, 40h
		dd offset $LN5_3	; "destString"
		dd 0FFFFFF5Ch, 0Ch
		dd offset $LN6_7	; "info"
$LN6_7		db 'info',0             ; DATA XREF: .text:00009810o
$LN5_3		db 'destString',0       ; DATA XREF: .text:00009804o
$LN4_2		db 'src',0              ; DATA XREF: .text:000097F8o
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9828h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl uidna_labelToASCII_UTF8_56(int, char *Str, int, char *, int, int,	int)
		public _uidna_labelToASCII_UTF8_56
_uidna_labelToASCII_UTF8_56 proc near

var_114		= dword	ptr -114h
var_10C		= dword	ptr -10Ch
var_40		= byte ptr -40h
var_2C		= byte ptr -2Ch
var_C		= byte ptr -0Ch
arg_0		= dword	ptr  8
Str		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h

		push	ebp
		mov	ebp, esp
		sub	esp, 114h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_114]
		mov	ecx, 45h ; 'E'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_18]
		push	eax
		mov	ecx, [ebp+arg_14]
		push	ecx
		mov	edx, [ebp+arg_10]
		push	edx
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+Str]
		push	edx
		call	?checkArgs@@YACPBXHPAXHPAUUIDNAInfo@@PAW4UErrorCode@@@Z	; checkArgs(void const *,int,void *,int,UIDNAInfo *,UErrorCode *)
		add	esp, 18h
		movsx	eax, al
		test	eax, eax
		jnz	short loc_9874
		xor	eax, eax
		jmp	loc_9929
; ---------------------------------------------------------------------------

loc_9874:				; CODE XREF: _uidna_labelToASCII_UTF8_56+43j
		cmp	[ebp+arg_8], 0
		jge	short loc_988E
		mov	eax, [ebp+Str]
		push	eax		; Str
		call	_strlen
		add	esp, 4
		mov	[ebp+var_114], eax
		jmp	short loc_9897
; ---------------------------------------------------------------------------

loc_988E:				; CODE XREF: _uidna_labelToASCII_UTF8_56+50j
		mov	ecx, [ebp+arg_8]
		mov	[ebp+var_114], ecx

loc_9897:				; CODE XREF: _uidna_labelToASCII_UTF8_56+64j
		mov	edx, [ebp+var_114]
		push	edx		; int
		mov	eax, [ebp+Str]
		push	eax		; char *
		lea	ecx, [ebp+var_C] ; this
		call	??0StringPiece@icu_56@@QAE@PBDH@Z ; icu_56::StringPiece::StringPiece(char const	*,int)
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; char *
		lea	ecx, [ebp+var_2C] ; this
		call	??0CheckedArrayByteSink@icu_56@@QAE@PADH@Z ; icu_56::CheckedArrayByteSink::CheckedArrayByteSink(char *,int)
		lea	ecx, [ebp+var_40] ; this
		call	??0IDNAInfo@icu_56@@QAE@XZ ; icu_56::IDNAInfo::IDNAInfo(void)
		mov	esi, esp
		mov	eax, [ebp+arg_18]
		push	eax
		lea	ecx, [ebp+var_40]
		push	ecx
		lea	edx, [ebp+var_2C]
		push	edx
		lea	eax, [ebp+var_C]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	ecx, [ebp+arg_0]
		mov	eax, [edx+18h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_14]
		push	eax		; int
		lea	ecx, [ebp+var_40]
		push	ecx		; icu_56::IDNAInfo *
		call	?idnaInfoToStruct@@YAXAAVIDNAInfo@icu_56@@PAUUIDNAInfo@@@Z ; idnaInfoToStruct(icu_56::IDNAInfo &,UIDNAInfo *)
		add	esp, 8
		mov	eax, [ebp+arg_18]
		push	eax
		lea	ecx, [ebp+var_2C] ; this
		call	?NumberOfBytesAppended@CheckedArrayByteSink@icu_56@@QBEHXZ ; icu_56::CheckedArrayByteSink::NumberOfBytesAppended(void)
		push	eax
		mov	ecx, [ebp+arg_10]
		push	ecx
		mov	edx, [ebp+arg_C]
		push	edx
		call	_u_terminateChars_56
		add	esp, 10h
		mov	[ebp+var_10C], eax
		lea	ecx, [ebp+var_2C] ; this
		call	??1CheckedArrayByteSink@icu_56@@UAE@XZ ; icu_56::CheckedArrayByteSink::~CheckedArrayByteSink(void)
		mov	eax, [ebp+var_10C]

loc_9929:				; CODE XREF: _uidna_labelToASCII_UTF8_56+47j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN10
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 114h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uidna_labelToASCII_UTF8_56 endp

; ---------------------------------------------------------------------------
		align 10h
$LN10		dd 3			; DATA XREF: _uidna_labelToASCII_UTF8_56+105o
		dd offset $LN9_4
$LN9_4		dd 0FFFFFFF4h, 8	; DATA XREF: .text:00009954o
		dd offset $LN6_8	; "src"
		dd 0FFFFFFD4h, 18h
		dd offset $LN7_3	; "sink"
		dd 0FFFFFFC0h, 0Ch
		dd offset $LN8_8	; "info"
$LN8_8		db 'info',0             ; DATA XREF: .text:00009978o
$LN7_3		db 'sink',0             ; DATA XREF: .text:0000996Co
$LN6_8		db 'src',0              ; DATA XREF: .text:00009960o
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 998Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl uidna_labelToUnicodeUTF8_56(int, char *Str, int, char *, int, int, int)
		public _uidna_labelToUnicodeUTF8_56
_uidna_labelToUnicodeUTF8_56 proc near

var_114		= dword	ptr -114h
var_10C		= dword	ptr -10Ch
var_40		= byte ptr -40h
var_2C		= byte ptr -2Ch
var_C		= byte ptr -0Ch
arg_0		= dword	ptr  8
Str		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h

		push	ebp
		mov	ebp, esp
		sub	esp, 114h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_114]
		mov	ecx, 45h ; 'E'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_18]
		push	eax
		mov	ecx, [ebp+arg_14]
		push	ecx
		mov	edx, [ebp+arg_10]
		push	edx
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+Str]
		push	edx
		call	?checkArgs@@YACPBXHPAXHPAUUIDNAInfo@@PAW4UErrorCode@@@Z	; checkArgs(void const *,int,void *,int,UIDNAInfo *,UErrorCode *)
		add	esp, 18h
		movsx	eax, al
		test	eax, eax
		jnz	short loc_99D8
		xor	eax, eax
		jmp	loc_9A8D
; ---------------------------------------------------------------------------

loc_99D8:				; CODE XREF: _uidna_labelToUnicodeUTF8_56+43j
		cmp	[ebp+arg_8], 0
		jge	short loc_99F2
		mov	eax, [ebp+Str]
		push	eax		; Str
		call	_strlen
		add	esp, 4
		mov	[ebp+var_114], eax
		jmp	short loc_99FB
; ---------------------------------------------------------------------------

loc_99F2:				; CODE XREF: _uidna_labelToUnicodeUTF8_56+50j
		mov	ecx, [ebp+arg_8]
		mov	[ebp+var_114], ecx

loc_99FB:				; CODE XREF: _uidna_labelToUnicodeUTF8_56+64j
		mov	edx, [ebp+var_114]
		push	edx		; int
		mov	eax, [ebp+Str]
		push	eax		; char *
		lea	ecx, [ebp+var_C] ; this
		call	??0StringPiece@icu_56@@QAE@PBDH@Z ; icu_56::StringPiece::StringPiece(char const	*,int)
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; char *
		lea	ecx, [ebp+var_2C] ; this
		call	??0CheckedArrayByteSink@icu_56@@QAE@PADH@Z ; icu_56::CheckedArrayByteSink::CheckedArrayByteSink(char *,int)
		lea	ecx, [ebp+var_40] ; this
		call	??0IDNAInfo@icu_56@@QAE@XZ ; icu_56::IDNAInfo::IDNAInfo(void)
		mov	esi, esp
		mov	eax, [ebp+arg_18]
		push	eax
		lea	ecx, [ebp+var_40]
		push	ecx
		lea	edx, [ebp+var_2C]
		push	edx
		lea	eax, [ebp+var_C]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	ecx, [ebp+arg_0]
		mov	eax, [edx+1Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_14]
		push	eax		; int
		lea	ecx, [ebp+var_40]
		push	ecx		; icu_56::IDNAInfo *
		call	?idnaInfoToStruct@@YAXAAVIDNAInfo@icu_56@@PAUUIDNAInfo@@@Z ; idnaInfoToStruct(icu_56::IDNAInfo &,UIDNAInfo *)
		add	esp, 8
		mov	eax, [ebp+arg_18]
		push	eax
		lea	ecx, [ebp+var_2C] ; this
		call	?NumberOfBytesAppended@CheckedArrayByteSink@icu_56@@QBEHXZ ; icu_56::CheckedArrayByteSink::NumberOfBytesAppended(void)
		push	eax
		mov	ecx, [ebp+arg_10]
		push	ecx
		mov	edx, [ebp+arg_C]
		push	edx
		call	_u_terminateChars_56
		add	esp, 10h
		mov	[ebp+var_10C], eax
		lea	ecx, [ebp+var_2C] ; this
		call	??1CheckedArrayByteSink@icu_56@@UAE@XZ ; icu_56::CheckedArrayByteSink::~CheckedArrayByteSink(void)
		mov	eax, [ebp+var_10C]

loc_9A8D:				; CODE XREF: _uidna_labelToUnicodeUTF8_56+47j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN10_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 114h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uidna_labelToUnicodeUTF8_56 endp

; ---------------------------------------------------------------------------
		align 4
$LN10_0		dd 3			; DATA XREF: _uidna_labelToUnicodeUTF8_56+105o
		dd offset $LN9_5
$LN9_5		dd 0FFFFFFF4h, 8	; DATA XREF: .text:00009AB8o
		dd offset $LN6_9	; "src"
		dd 0FFFFFFD4h, 18h
		dd offset $LN7_4	; "sink"
		dd 0FFFFFFC0h, 0Ch
		dd offset $LN8_9	; "info"
$LN8_9		db 'info',0             ; DATA XREF: .text:00009ADCo
$LN7_4		db 'sink',0             ; DATA XREF: .text:00009AD0o
$LN6_9		db 'src',0              ; DATA XREF: .text:00009AC4o
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9AF0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl uidna_nameToASCII_UTF8_56(int, char *Str,	int, char *, int, int, int)
		public _uidna_nameToASCII_UTF8_56
_uidna_nameToASCII_UTF8_56 proc	near

var_114		= dword	ptr -114h
var_10C		= dword	ptr -10Ch
var_40		= byte ptr -40h
var_2C		= byte ptr -2Ch
var_C		= byte ptr -0Ch
arg_0		= dword	ptr  8
Str		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h

		push	ebp
		mov	ebp, esp
		sub	esp, 114h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_114]
		mov	ecx, 45h ; 'E'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_18]
		push	eax
		mov	ecx, [ebp+arg_14]
		push	ecx
		mov	edx, [ebp+arg_10]
		push	edx
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+Str]
		push	edx
		call	?checkArgs@@YACPBXHPAXHPAUUIDNAInfo@@PAW4UErrorCode@@@Z	; checkArgs(void const *,int,void *,int,UIDNAInfo *,UErrorCode *)
		add	esp, 18h
		movsx	eax, al
		test	eax, eax
		jnz	short loc_9B3C
		xor	eax, eax
		jmp	loc_9BF1
; ---------------------------------------------------------------------------

loc_9B3C:				; CODE XREF: _uidna_nameToASCII_UTF8_56+43j
		cmp	[ebp+arg_8], 0
		jge	short loc_9B56
		mov	eax, [ebp+Str]
		push	eax		; Str
		call	_strlen
		add	esp, 4
		mov	[ebp+var_114], eax
		jmp	short loc_9B5F
; ---------------------------------------------------------------------------

loc_9B56:				; CODE XREF: _uidna_nameToASCII_UTF8_56+50j
		mov	ecx, [ebp+arg_8]
		mov	[ebp+var_114], ecx

loc_9B5F:				; CODE XREF: _uidna_nameToASCII_UTF8_56+64j
		mov	edx, [ebp+var_114]
		push	edx		; int
		mov	eax, [ebp+Str]
		push	eax		; char *
		lea	ecx, [ebp+var_C] ; this
		call	??0StringPiece@icu_56@@QAE@PBDH@Z ; icu_56::StringPiece::StringPiece(char const	*,int)
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; char *
		lea	ecx, [ebp+var_2C] ; this
		call	??0CheckedArrayByteSink@icu_56@@QAE@PADH@Z ; icu_56::CheckedArrayByteSink::CheckedArrayByteSink(char *,int)
		lea	ecx, [ebp+var_40] ; this
		call	??0IDNAInfo@icu_56@@QAE@XZ ; icu_56::IDNAInfo::IDNAInfo(void)
		mov	esi, esp
		mov	eax, [ebp+arg_18]
		push	eax
		lea	ecx, [ebp+var_40]
		push	ecx
		lea	edx, [ebp+var_2C]
		push	edx
		lea	eax, [ebp+var_C]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	ecx, [ebp+arg_0]
		mov	eax, [edx+20h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_14]
		push	eax		; int
		lea	ecx, [ebp+var_40]
		push	ecx		; icu_56::IDNAInfo *
		call	?idnaInfoToStruct@@YAXAAVIDNAInfo@icu_56@@PAUUIDNAInfo@@@Z ; idnaInfoToStruct(icu_56::IDNAInfo &,UIDNAInfo *)
		add	esp, 8
		mov	eax, [ebp+arg_18]
		push	eax
		lea	ecx, [ebp+var_2C] ; this
		call	?NumberOfBytesAppended@CheckedArrayByteSink@icu_56@@QBEHXZ ; icu_56::CheckedArrayByteSink::NumberOfBytesAppended(void)
		push	eax
		mov	ecx, [ebp+arg_10]
		push	ecx
		mov	edx, [ebp+arg_C]
		push	edx
		call	_u_terminateChars_56
		add	esp, 10h
		mov	[ebp+var_10C], eax
		lea	ecx, [ebp+var_2C] ; this
		call	??1CheckedArrayByteSink@icu_56@@UAE@XZ ; icu_56::CheckedArrayByteSink::~CheckedArrayByteSink(void)
		mov	eax, [ebp+var_10C]

loc_9BF1:				; CODE XREF: _uidna_nameToASCII_UTF8_56+47j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN10_1
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 114h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uidna_nameToASCII_UTF8_56 endp

; ---------------------------------------------------------------------------
		align 4
$LN10_1		dd 3			; DATA XREF: _uidna_nameToASCII_UTF8_56+105o
		dd offset $LN9_6
$LN9_6		dd 0FFFFFFF4h, 8	; DATA XREF: .text:00009C1Co
		dd offset $LN6_10	; "src"
		dd 0FFFFFFD4h, 18h
		dd offset $LN7_5	; "sink"
		dd 0FFFFFFC0h, 0Ch
		dd offset $LN8_10	; "info"
$LN8_10		db 'info',0             ; DATA XREF: .text:00009C40o
$LN7_5		db 'sink',0             ; DATA XREF: .text:00009C34o
$LN6_10		db 'src',0              ; DATA XREF: .text:00009C28o
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9C54h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl uidna_nameToUnicodeUTF8_56(int, char *Str, int, char *, int, int,	int)
		public _uidna_nameToUnicodeUTF8_56
_uidna_nameToUnicodeUTF8_56 proc near

var_114		= dword	ptr -114h
var_10C		= dword	ptr -10Ch
var_40		= byte ptr -40h
var_2C		= byte ptr -2Ch
var_C		= byte ptr -0Ch
arg_0		= dword	ptr  8
Str		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h

		push	ebp
		mov	ebp, esp
		sub	esp, 114h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_114]
		mov	ecx, 45h ; 'E'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_18]
		push	eax
		mov	ecx, [ebp+arg_14]
		push	ecx
		mov	edx, [ebp+arg_10]
		push	edx
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+Str]
		push	edx
		call	?checkArgs@@YACPBXHPAXHPAUUIDNAInfo@@PAW4UErrorCode@@@Z	; checkArgs(void const *,int,void *,int,UIDNAInfo *,UErrorCode *)
		add	esp, 18h
		movsx	eax, al
		test	eax, eax
		jnz	short loc_9CA0
		xor	eax, eax
		jmp	loc_9D55
; ---------------------------------------------------------------------------

loc_9CA0:				; CODE XREF: _uidna_nameToUnicodeUTF8_56+43j
		cmp	[ebp+arg_8], 0
		jge	short loc_9CBA
		mov	eax, [ebp+Str]
		push	eax		; Str
		call	_strlen
		add	esp, 4
		mov	[ebp+var_114], eax
		jmp	short loc_9CC3
; ---------------------------------------------------------------------------

loc_9CBA:				; CODE XREF: _uidna_nameToUnicodeUTF8_56+50j
		mov	ecx, [ebp+arg_8]
		mov	[ebp+var_114], ecx

loc_9CC3:				; CODE XREF: _uidna_nameToUnicodeUTF8_56+64j
		mov	edx, [ebp+var_114]
		push	edx		; int
		mov	eax, [ebp+Str]
		push	eax		; char *
		lea	ecx, [ebp+var_C] ; this
		call	??0StringPiece@icu_56@@QAE@PBDH@Z ; icu_56::StringPiece::StringPiece(char const	*,int)
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; char *
		lea	ecx, [ebp+var_2C] ; this
		call	??0CheckedArrayByteSink@icu_56@@QAE@PADH@Z ; icu_56::CheckedArrayByteSink::CheckedArrayByteSink(char *,int)
		lea	ecx, [ebp+var_40] ; this
		call	??0IDNAInfo@icu_56@@QAE@XZ ; icu_56::IDNAInfo::IDNAInfo(void)
		mov	esi, esp
		mov	eax, [ebp+arg_18]
		push	eax
		lea	ecx, [ebp+var_40]
		push	ecx
		lea	edx, [ebp+var_2C]
		push	edx
		lea	eax, [ebp+var_C]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	ecx, [ebp+arg_0]
		mov	eax, [edx+24h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_14]
		push	eax		; int
		lea	ecx, [ebp+var_40]
		push	ecx		; icu_56::IDNAInfo *
		call	?idnaInfoToStruct@@YAXAAVIDNAInfo@icu_56@@PAUUIDNAInfo@@@Z ; idnaInfoToStruct(icu_56::IDNAInfo &,UIDNAInfo *)
		add	esp, 8
		mov	eax, [ebp+arg_18]
		push	eax
		lea	ecx, [ebp+var_2C] ; this
		call	?NumberOfBytesAppended@CheckedArrayByteSink@icu_56@@QBEHXZ ; icu_56::CheckedArrayByteSink::NumberOfBytesAppended(void)
		push	eax
		mov	ecx, [ebp+arg_10]
		push	ecx
		mov	edx, [ebp+arg_C]
		push	edx
		call	_u_terminateChars_56
		add	esp, 10h
		mov	[ebp+var_10C], eax
		lea	ecx, [ebp+var_2C] ; this
		call	??1CheckedArrayByteSink@icu_56@@UAE@XZ ; icu_56::CheckedArrayByteSink::~CheckedArrayByteSink(void)
		mov	eax, [ebp+var_10C]

loc_9D55:				; CODE XREF: _uidna_nameToUnicodeUTF8_56+47j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN10_2
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 114h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uidna_nameToUnicodeUTF8_56 endp

; ---------------------------------------------------------------------------
		align 4
$LN10_2		dd 3			; DATA XREF: _uidna_nameToUnicodeUTF8_56+105o
		dd offset $LN9_7
$LN9_7		dd 0FFFFFFF4h, 8	; DATA XREF: .text:00009D80o
		dd offset $LN6_11	; "src"
		dd 0FFFFFFD4h, 18h
		dd offset $LN7_6	; "sink"
		dd 0FFFFFFC0h, 0Ch
		dd offset $LN8_11	; "info"
$LN8_11		db 'info',0             ; DATA XREF: .text:00009DA4o
$LN7_6		db 'sink',0             ; DATA XREF: .text:00009D98o
$LN6_11		db 'src',0              ; DATA XREF: .text:00009D8Co
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9DB8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char const * __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::data(void)const
		public ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ proc near
					; CODE XREF: icu_56::StringPiece::StringPiece(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::c_str(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9DF8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char const * __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::c_str(void)const
		public ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::data(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ;	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Myptr(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9E38h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
		public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
					; CODE XREF: icu_56::StringPiece::StringPiece(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&)+33p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+14h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9E68h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char const * __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Myptr(void)const
		public ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::c_str(void)+26p

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+18h], 10h
		jb	short loc_9EA2
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+4]
		mov	[ebp+var_D0], edx
		jmp	short loc_9EAE
; ---------------------------------------------------------------------------

loc_9EA2:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Myptr(void)+2Aj
		mov	eax, [ebp+var_8]
		add	eax, 4
		mov	[ebp+var_D0], eax

loc_9EAE:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Myptr(void)+38j
		mov	eax, [ebp+var_D0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9EBCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; [thunk]:public: virtual void * __thiscall icu_56::UnicodeFilter::`vector deleting destructor'`adjustor{4}' (unsigned int)
		public ??_EUnicodeFilter@icu_56@@W3AEPAXI@Z
??_EUnicodeFilter@icu_56@@W3AEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::UnicodeFilter::`vftable'{for `icu_56::UnicodeMatcher'}o
		sub	ecx, 4
		jmp	??_EUnicodeFilter@icu_56@@UAEPAXI@Z ; icu_56::UnicodeFilter::`vector deleting destructor'(uint)
??_EUnicodeFilter@icu_56@@W3AEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn __RTC_Shutdown:near ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
		extrn __RTC_InitBase:near ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
; const	type_info::`vftable'
		extrn ??_7type_info@@6B@:near
					; DATA XREF: .data:icu_56::UObject `RTTI Type Descriptor'o
					; .data:icu_56::UMemory	`RTTI Type Descriptor'o ...
; public: virtual void * __thiscall icu_56::UObject::getDynamicClassID(void)const
		extrn ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ:near
					; DATA XREF: .rdata:000002ACo
					; .rdata:00000B00o ...
; void __cdecl icu_56::UMemory::operator delete(void *)
		extrn ??3UMemory@icu_56@@SAXPAX@Z:near
					; CODE XREF: icu_56::UObject::`scalar deleting destructor'(uint)+37p
					; icu_56::UObject::`vector deleting destructor'(uint)+75p ...
; _DWORD __thiscall icu_56::UObject::~UObject(icu_56::UObject *__hidden	this)
		extrn ??1UObject@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::UObject::`scalar deleting destructor'(uint)+26p
					; icu_56::UObject::`vector deleting destructor'(uint)+64p ...
		extrn __RTC_CheckEsp:near
					; CODE XREF: icu_56::UObject::`scalar deleting destructor'(uint)+4Dp
					; icu_56::UObject::`vector deleting destructor'(uint)+8Bp ...
; void __cdecl icu_56::UMemory::operator delete[](void *)
		extrn ??_VUMemory@icu_56@@SAXPAX@Z:near
					; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+51p
					; icu_56::ByteSink::`vector deleting destructor'(uint)+51p ...
; void __stdcall `eh vector destructor iterator'(void *, unsigned int, int, void (__thiscall *)(void *))
		extrn ??_M@YGXPAXIHP6EX0@Z@Z:near
					; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+3Dp
					; icu_56::ByteSink::`vector deleting destructor'(uint)+3Dp ...
		extrn __purecall:near	; DATA XREF: .rdata:00000544o
					; .rdata:00000B04o ...
; public: virtual char * __thiscall icu_56::ByteSink::GetAppendBuffer(int, int,	char *,	int, int *)
		extrn ?GetAppendBuffer@ByteSink@icu_56@@UAEPADHHPADHPAH@Z:near
					; DATA XREF: .rdata:00000548o
; public: virtual void __thiscall icu_56::ByteSink::Flush(void)
		extrn ?Flush@ByteSink@icu_56@@UAEXXZ:near ; DATA XREF: .rdata:0000054Co
; _DWORD __thiscall icu_56::ByteSink::~ByteSink(icu_56::ByteSink *__hidden this)
		extrn ??1ByteSink@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::ByteSink::`scalar deleting	destructor'(uint)+26p
					; icu_56::ByteSink::`vector deleting destructor'(uint)+64p
					; DATA XREF: ...
; _DWORD __thiscall icu_56::StringPiece::StringPiece(icu_56::StringPiece *__hidden this, const struct icu_56::StringPiece *, int, int)
		extrn ??0StringPiece@icu_56@@QAE@ABV01@HH@Z:near
					; CODE XREF: icu_56::StringPiece::substr(int,int)+32p
; public: virtual signed char __thiscall icu_56::Replaceable::hasMetaData(void)const
		extrn ?hasMetaData@Replaceable@icu_56@@UBECXZ:near
					; DATA XREF: .rdata:00000B10o
; public: virtual class	icu_56::Replaceable * __thiscall icu_56::Replaceable::clone(void)const
		extrn ?clone@Replaceable@icu_56@@UBEPAV12@XZ:near
					; DATA XREF: .rdata:00000B14o
; _DWORD __thiscall icu_56::Replaceable::~Replaceable(icu_56::Replaceable *__hidden this)
		extrn ??1Replaceable@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::Replaceable::`scalar deleting destructor'(uint)+26p
					; icu_56::Replaceable::`vector deleting	destructor'(uint)+64p
					; DATA XREF: ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::moveFrom(icu_56::UnicodeString *__hidden this, struct	icu_56::UnicodeString *)
		extrn ?moveFrom@UnicodeString@icu_56@@QAEAAV12@AAV12@@Z:near
					; CODE XREF: icu_56::UnicodeString::operator=(icu_56::UnicodeString &&)+2Ap
; void __thiscall icu_56::UnicodeString::swap(icu_56::UnicodeString *__hidden this, struct icu_56::UnicodeString *)
		extrn ?swap@UnicodeString@icu_56@@QAEXAAV12@@Z:near
					; CODE XREF: icu_56::swap(icu_56::UnicodeString	&,icu_56::UnicodeString	&)+25p
; _DWORD __thiscall icu_56::UnicodeString::~UnicodeString(icu_56::UnicodeString	*__hidden this)
		extrn ??1UnicodeString@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::UnicodeString::`scalar deleting destructor'(uint)+26p
					; icu_56::UnicodeString::`vector deleting destructor'(uint)+64p ...
; public: virtual void * __thiscall icu_56::UnicodeString::getDynamicClassID(void)const
		extrn ?getDynamicClassID@UnicodeString@icu_56@@UBEPAXXZ:near
					; DATA XREF: .rdata:0000119Co
; public: virtual void __thiscall icu_56::UnicodeString::extractBetween(int, int, class	icu_56::UnicodeString &)const
		extrn ?extractBetween@UnicodeString@icu_56@@UBEXHHAAV12@@Z:near
					; DATA XREF: .rdata:000011A0o
; public: virtual void __thiscall icu_56::UnicodeString::handleReplaceBetween(int, int,	class icu_56::UnicodeString const &)
		extrn ?handleReplaceBetween@UnicodeString@icu_56@@UAEXHHABV12@@Z:near
					; DATA XREF: .rdata:000011A4o
; public: virtual void __thiscall icu_56::UnicodeString::copy(int, int,	int)
		extrn ?copy@UnicodeString@icu_56@@UAEXHHH@Z:near
					; DATA XREF: .rdata:000011A8o
; public: virtual signed char __thiscall icu_56::UnicodeString::hasMetaData(void)const
		extrn ?hasMetaData@UnicodeString@icu_56@@UBECXZ:near
					; DATA XREF: .rdata:000011ACo
; public: virtual class	icu_56::Replaceable * __thiscall icu_56::UnicodeString::clone(void)const
		extrn ?clone@UnicodeString@icu_56@@UBEPAVReplaceable@2@XZ:near
					; DATA XREF: .rdata:000011B0o
; protected: virtual int __thiscall icu_56::UnicodeString::getLength(void)const
		extrn ?getLength@UnicodeString@icu_56@@MBEHXZ:near
					; DATA XREF: .rdata:000011B4o
; protected: virtual wchar_t __thiscall	icu_56::UnicodeString::getCharAt(int)const
		extrn ?getCharAt@UnicodeString@icu_56@@MBE_WH@Z:near
					; DATA XREF: .rdata:000011B8o
; protected: virtual int __thiscall icu_56::UnicodeString::getChar32At(int)const
		extrn ?getChar32At@UnicodeString@icu_56@@MBEHH@Z:near
					; DATA XREF: .rdata:000011BCo
; int __thiscall icu_56::UnicodeString::doHashCode(icu_56::UnicodeString *__hidden this)
		extrn ?doHashCode@UnicodeString@icu_56@@ABEHXZ:near
					; CODE XREF: icu_56::UnicodeString::hashCode(void)+26p
; int __thiscall icu_56::UnicodeString::refCount(icu_56::UnicodeString *__hidden this)
		extrn ?refCount@UnicodeString@icu_56@@ABEHXZ:near
					; CODE XREF: icu_56::UnicodeString::isBufferWritable(void)+3Ep
; signed __int8	__thiscall icu_56::UnicodeString::doCompare(icu_56::UnicodeString *__hidden this, int, int, const wchar_t *, int, int)
		extrn ?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z:near
					; CODE XREF: icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+72p
					; icu_56::UnicodeString::compare(wchar_t const *,int)+3Bp ...
; signed __int8	__thiscall icu_56::UnicodeString::doEquals(icu_56::UnicodeString *__hidden this, const struct icu_56::UnicodeString *, int)
		extrn ?doEquals@UnicodeString@icu_56@@ABECABV12@H@Z:near
					; CODE XREF: icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)+76p
; signed __int8	__thiscall icu_56::UnicodeString::doCompareCodePointOrder(icu_56::UnicodeString	*__hidden this,	int, int, const	wchar_t	*, int,	int)
		extrn ?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHPB_WHH@Z:near
					; CODE XREF: icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const	&,int,int)+72p
					; icu_56::UnicodeString::compareCodePointOrder(wchar_t const *,int)+3Bp ...
; signed __int8	__thiscall icu_56::UnicodeString::doCaseCompare(icu_56::UnicodeString *__hidden	this, int, int,	const wchar_t *, int, int, unsigned int)
		extrn ?doCaseCompare@UnicodeString@icu_56@@ABECHHPB_WHHI@Z:near
					; CODE XREF: icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString	const &,int,int,uint)+76p
					; icu_56::UnicodeString::caseCompare(wchar_t const *,int,uint)+3Fp ...
; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *__hidden	this, const wchar_t *, int, int, int, int)
		extrn ?indexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z:near
					; CODE XREF: icu_56::UnicodeString::indexOf(icu_56::UnicodeString const	&,int,int,int,int)+64p
					; icu_56::UnicodeString::indexOf(wchar_t const *,int,int)+4Cp ...
; int __thiscall icu_56::UnicodeString::doIndexOf(icu_56::UnicodeString	*__hidden this,	wchar_t, int, int)
		extrn ?doIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z:near
					; CODE XREF: icu_56::UnicodeString::indexOf(wchar_t,int,int)+33p
					; icu_56::UnicodeString::indexOf(wchar_t)+36p ...
; int __thiscall icu_56::UnicodeString::doIndexOf(icu_56::UnicodeString	*__hidden this,	int, int, int)
		extrn ?doIndexOf@UnicodeString@icu_56@@ABEHHHH@Z:near
					; CODE XREF: icu_56::UnicodeString::indexOf(int,int,int)+32p
; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *__hidden this, const	wchar_t	*, int,	int, int, int)
		extrn ?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z:near
					; CODE XREF: icu_56::UnicodeString::lastIndexOf(wchar_t	const *,int,int,int)+38p
					; icu_56::UnicodeString::lastIndexOf(wchar_t const *,int,int)+4Cp ...
; int __thiscall icu_56::UnicodeString::doLastIndexOf(icu_56::UnicodeString *__hidden this, wchar_t, int, int)
		extrn ?doLastIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z:near
					; CODE XREF: icu_56::UnicodeString::lastIndexOf(wchar_t,int,int)+33p
					; icu_56::UnicodeString::lastIndexOf(wchar_t)+36p ...
; int __thiscall icu_56::UnicodeString::doLastIndexOf(icu_56::UnicodeString *__hidden this, int, int, int)
		extrn ?doLastIndexOf@UnicodeString@icu_56@@ABEHHHH@Z:near
					; CODE XREF: icu_56::UnicodeString::lastIndexOf(int,int,int)+32p
		extrn _u_strlen_56:near	; CODE XREF: icu_56::UnicodeString::startsWith(wchar_t const *,int)+2Dp
					; icu_56::UnicodeString::startsWith(wchar_t const *,int,int)+2Dp ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::doReplace(icu_56::UnicodeString *__hidden this, int, int, const struct icu_56::UnicodeString *, int, int)
		extrn ?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z:near
					; CODE XREF: icu_56::UnicodeString::replace(int,int,icu_56::UnicodeString const	&)+3Dp
					; icu_56::UnicodeString::replace(int,int,icu_56::UnicodeString const &,int,int)+3Ap ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::doReplace(icu_56::UnicodeString *__hidden this, int, int, const wchar_t *, int, int)
		extrn ?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z:near
					; CODE XREF: icu_56::UnicodeString::replace(int,int,wchar_t const *,int)+38p
					; icu_56::UnicodeString::replace(int,int,wchar_t const *,int,int)+3Ap ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::findAndReplace(icu_56::UnicodeString *__hidden this, int, int, const struct icu_56::UnicodeString *, int, int, const struct icu_56::UnicodeString *, int, int)
		extrn ?findAndReplace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH0HH@Z:near
					; CODE XREF: icu_56::UnicodeString::findAndReplace(icu_56::UnicodeString const &,icu_56::UnicodeString const &)+4Fp
					; icu_56::UnicodeString::findAndReplace(int,int,icu_56::UnicodeString const &,icu_56::UnicodeString const &):loc_2FFCp
; void __thiscall icu_56::UnicodeString::doExtract(icu_56::UnicodeString *__hidden this, int, int, wchar_t *, int)
		extrn ?doExtract@UnicodeString@icu_56@@ABEXHHPA_WH@Z:near
					; CODE XREF: icu_56::UnicodeString::extract(int,int,wchar_t *,int)+36p
					; icu_56::UnicodeString::extractBetween(int,int,wchar_t	*,int)+51p
; int __thiscall icu_56::UnicodeString::extract(icu_56::UnicodeString *__hidden	this, int, int,	char *,	unsigned int, const char *)
		extrn ?extract@UnicodeString@icu_56@@QBEHHHPADIPBD@Z:near
					; CODE XREF: icu_56::UnicodeString::extract(int,int,char *,char	const *)+3Ep
; struct icu_56::UnicodeString __thiscall __high icu_56::UnicodeString::tempSubString(int, int)
		extrn ?tempSubString@UnicodeString@icu_56@@QBE?AV12@HH@Z:near
					; CODE XREF: icu_56::UnicodeString::tempSubStringBetween(int,int)+3Fp
					; icu_56::UTS46::processUnicode(icu_56::UnicodeString const &,int,int,signed char,signed char,icu_56::UnicodeString &,icu_56::IDNAInfo &,UErrorCode &)+90p ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replace(icu_56::UnicodeString	*__hidden this,	int, int, int)
		extrn ?replace@UnicodeString@icu_56@@QAEAAV12@HHH@Z:near
					; CODE XREF: icu_56::UnicodeString::operator=(int)+35p
					; icu_56::UnicodeString::setTo(int)+3Dp ...
; void __thiscall icu_56::UnicodeString::unBogus(icu_56::UnicodeString *__hidden this)
		extrn ?unBogus@UnicodeString@icu_56@@AAEXXZ:near
					; CODE XREF: icu_56::UnicodeString::setTo(icu_56::UnicodeString	const &,int,int)+26p
					; icu_56::UnicodeString::setTo(icu_56::UnicodeString const &,int)+26p ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::copyFrom(icu_56::UnicodeString *__hidden this, const struct icu_56::UnicodeString *, signed __int8)
		extrn ?copyFrom@UnicodeString@icu_56@@AAEAAV12@ABV12@C@Z:near
					; CODE XREF: icu_56::UnicodeString::setTo(icu_56::UnicodeString	const &)+2Cp
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::doAppend(icu_56::UnicodeString *__hidden this, const struct icu_56::UnicodeString *, int, int)
		extrn ?doAppend@UnicodeString@icu_56@@AAEAAV12@ABV12@HH@Z:near
					; CODE XREF: icu_56::UnicodeString::append(icu_56::UnicodeString const &,int,int)+32p
					; icu_56::UnicodeString::append(icu_56::UnicodeString const &)+35p ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::doAppend(icu_56::UnicodeString *__hidden this, const wchar_t *, int, int)
		extrn ?doAppend@UnicodeString@icu_56@@AAEAAV12@PB_WHH@Z:near
					; CODE XREF: icu_56::UnicodeString::append(wchar_t const *,int,int)+32p
					; icu_56::UnicodeString::append(wchar_t	const *,int)+30p ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *__hidden this, int)
		extrn ?append@UnicodeString@icu_56@@QAEAAV12@H@Z:near
					; CODE XREF: icu_56::UnicodeString::operator+=(int)+2Ap
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::doReverse(icu_56::UnicodeString *__hidden this, int, int)
		extrn ?doReverse@UnicodeString@icu_56@@AAEAAV12@HH@Z:near
					; CODE XREF: icu_56::UnicodeString::reverse(void)+31p
					; icu_56::UnicodeString::reverse(int,int)+2Ep
; public: virtual class	icu_56::UnicodeMatcher * __thiscall icu_56::UnicodeFunctor::toMatcher(void)const
		extrn ?toMatcher@UnicodeFunctor@icu_56@@UBEPAVUnicodeMatcher@2@XZ:near
					; DATA XREF: .rdata:000042C0o
; public: virtual class	icu_56::UnicodeReplacer	* __thiscall icu_56::UnicodeFunctor::toReplacer(void)const
		extrn ?toReplacer@UnicodeFunctor@icu_56@@UBEPAVUnicodeReplacer@2@XZ:near
					; DATA XREF: .rdata:000042C4o
					; .rdata:000047A0o
; _DWORD __thiscall icu_56::UnicodeFunctor::~UnicodeFunctor(icu_56::UnicodeFunctor *__hidden this)
		extrn ??1UnicodeFunctor@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::UnicodeFunctor::`scalar deleting destructor'(uint)+26p
					; icu_56::UnicodeFunctor::`vector deleting destructor'(uint)+64p
					; DATA XREF: ...
; _DWORD __thiscall icu_56::UnicodeMatcher::~UnicodeMatcher(icu_56::UnicodeMatcher *__hidden this)
		extrn ??1UnicodeMatcher@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::UnicodeMatcher::`scalar deleting destructor'(uint)+26p
					; icu_56::UnicodeMatcher::`vector deleting destructor'(uint)+64p
					; DATA XREF: ...
; public: virtual class	icu_56::UnicodeMatcher * __thiscall icu_56::UnicodeFilter::toMatcher(void)const
		extrn ?toMatcher@UnicodeFilter@icu_56@@UBEPAVUnicodeMatcher@2@XZ:near
					; DATA XREF: .rdata:0000479Co
; public: virtual void __thiscall icu_56::UnicodeFilter::setData(class icu_56::TransliterationRuleData const *)
		extrn ?setData@UnicodeFilter@icu_56@@UAEXPBVTransliterationRuleData@2@@Z:near
					; DATA XREF: .rdata:000047A4o
; public: virtual enum	icu_56::UMatchDegree __thiscall	icu_56::UnicodeFilter::matches(class icu_56::Replaceable const &, int &, int, signed char)
		extrn ?matches@UnicodeFilter@icu_56@@UAE?AW4UMatchDegree@2@ABVReplaceable@2@AAHHC@Z:near
					; DATA XREF: .rdata:0000477Co
; _DWORD __thiscall icu_56::UnicodeFilter::~UnicodeFilter(icu_56::UnicodeFilter	*__hidden this)
		extrn ??1UnicodeFilter@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::UnicodeFilter::`scalar deleting destructor'(uint)+26p
					; icu_56::UnicodeFilter::`vector deleting destructor'(uint)+64p
					; DATA XREF: ...
; signed __int8	__thiscall icu_56::UnicodeSet::containsNone(icu_56::UnicodeSet *__hidden this, int, int)
		extrn ?containsNone@UnicodeSet@icu_56@@QBECHH@Z:near
					; CODE XREF: icu_56::UnicodeSet::containsSome(int,int)+2Ep
; signed __int8	__thiscall icu_56::UnicodeSet::containsNone(icu_56::UnicodeSet *__hidden this, const struct icu_56::UnicodeSet *)
		extrn ?containsNone@UnicodeSet@icu_56@@QBECABV12@@Z:near
					; CODE XREF: icu_56::UnicodeSet::containsSome(icu_56::UnicodeSet const &)+2Ap
; signed __int8	__thiscall icu_56::UnicodeSet::containsNone(icu_56::UnicodeSet *__hidden this, const struct icu_56::UnicodeString *)
		extrn ?containsNone@UnicodeSet@icu_56@@QBECABVUnicodeString@2@@Z:near
					; CODE XREF: icu_56::UnicodeSet::containsSome(icu_56::UnicodeString const &)+2Ap
; int __thiscall __high	icu_56::UnicodeSet::span(const wchar_t *, int, enum USetSpanCondition)
		extrn ?span@UnicodeSet@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z:near
					; CODE XREF: icu_56::UnicodeSet::span(icu_56::UnicodeString const &,int,USetSpanCondition)+68p
; int __thiscall __high	icu_56::UnicodeSet::spanBack(const wchar_t *, int, enum	USetSpanCondition)
		extrn ?spanBack@UnicodeSet@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z:near
					; CODE XREF: icu_56::UnicodeSet::spanBack(icu_56::UnicodeString	const &,int,USetSpanCondition)+5Fp
; public: __thiscall icu_56::UnicodeString::UnicodeString(class	icu_56::UnicodeString &&)
		extrn ??0UnicodeString@icu_56@@QAE@$$QAV01@@Z:near
					; CODE XREF: icu_56::Normalizer2::normalize(icu_56::UnicodeString const	&,UErrorCode &)+87p
		extrn ___security_cookie:near
					; DATA XREF: icu_56::Normalizer2::normalize(icu_56::UnicodeString const	&,UErrorCode &)+2Er
					; icu_56::IDNA::labelToASCII_UTF8(icu_56::StringPiece const &,icu_56::ByteSink &,icu_56::IDNAInfo &,UErrorCode &)+2Er ...
		extrn ___CxxFrameHandler3:near
					; CODE XREF: __ehhandler$?normalize@Normalizer2@icu_56@@QBE?AVUnicodeString@2@ABV32@AAW4UErrorCode@@@Z+23j
					; __ehhandler$?labelToASCII_UTF8@IDNA@icu_56@@UBEXABVStringPiece@2@AAVByteSink@2@AAVIDNAInfo@2@AAW4UErrorCode@@@Z+23j ...
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near
					; CODE XREF: icu_56::Normalizer2::normalize(icu_56::UnicodeString const	&,UErrorCode &)+CEp
					; __ehhandler$?normalize@Normalizer2@icu_56@@QBE?AVUnicodeString@2@ABV32@AAW4UErrorCode@@@Z+Fp	...
; __fastcall _RTC_CheckStackVars(x, x)
		extrn @_RTC_CheckStackVars@8:near
					; CODE XREF: icu_56::Normalizer2::normalize(icu_56::UnicodeString const	&,UErrorCode &)+B4p
					; icu_56::IDNA::labelToASCII_UTF8(icu_56::StringPiece const &,icu_56::ByteSink &,icu_56::IDNAInfo &,UErrorCode &)+F2p ...
; public: virtual signed char __thiscall icu_56::Normalizer2::getRawDecomposition(int, class icu_56::UnicodeString &)const
		extrn ?getRawDecomposition@Normalizer2@icu_56@@UBECHAAVUnicodeString@2@@Z:near
					; DATA XREF: .rdata:00004FC8o
; public: virtual int __thiscall icu_56::Normalizer2::composePair(int, int)const
		extrn ?composePair@Normalizer2@icu_56@@UBEHHH@Z:near
					; DATA XREF: .rdata:00004FCCo
; public: virtual unsigned char	__thiscall icu_56::Normalizer2::getCombiningClass(int)const
		extrn ?getCombiningClass@Normalizer2@icu_56@@UBEEH@Z:near
					; DATA XREF: .rdata:00004FD0o
; _DWORD __thiscall icu_56::Normalizer2::~Normalizer2(icu_56::Normalizer2 *__hidden this)
		extrn ??1Normalizer2@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::Normalizer2::`scalar deleting destructor'(uint)+26p
					; icu_56::Normalizer2::`vector deleting	destructor'(uint)+64p
					; DATA XREF: ...
; public: virtual class	icu_56::UnicodeString &	__thiscall icu_56::FilteredNormalizer2::normalize(class	icu_56::UnicodeString const &, class icu_56::UnicodeString &, enum  UErrorCode &)const
		extrn ?normalize@FilteredNormalizer2@icu_56@@UBEAAVUnicodeString@2@ABV32@AAV32@AAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:00005258o
; public: virtual class	icu_56::UnicodeString &	__thiscall icu_56::FilteredNormalizer2::normalizeSecondAndAppend(class icu_56::UnicodeString &,	class icu_56::UnicodeString const &, enum  UErrorCode &)const
		extrn ?normalizeSecondAndAppend@FilteredNormalizer2@icu_56@@UBEAAVUnicodeString@2@AAV32@ABV32@AAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:0000525Co
; public: virtual class	icu_56::UnicodeString &	__thiscall icu_56::FilteredNormalizer2::append(class icu_56::UnicodeString &, class icu_56::UnicodeString const	&, enum	 UErrorCode &)const
		extrn ?append@FilteredNormalizer2@icu_56@@UBEAAVUnicodeString@2@AAV32@ABV32@AAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:00005260o
; public: virtual signed char __thiscall icu_56::FilteredNormalizer2::getDecomposition(int, class icu_56::UnicodeString	&)const
		extrn ?getDecomposition@FilteredNormalizer2@icu_56@@UBECHAAVUnicodeString@2@@Z:near
					; DATA XREF: .rdata:00005264o
; public: virtual signed char __thiscall icu_56::FilteredNormalizer2::getRawDecomposition(int, class icu_56::UnicodeString &)const
		extrn ?getRawDecomposition@FilteredNormalizer2@icu_56@@UBECHAAVUnicodeString@2@@Z:near
					; DATA XREF: .rdata:00005268o
; public: virtual int __thiscall icu_56::FilteredNormalizer2::composePair(int, int)const
		extrn ?composePair@FilteredNormalizer2@icu_56@@UBEHHH@Z:near
					; DATA XREF: .rdata:0000526Co
; public: virtual unsigned char	__thiscall icu_56::FilteredNormalizer2::getCombiningClass(int)const
		extrn ?getCombiningClass@FilteredNormalizer2@icu_56@@UBEEH@Z:near
					; DATA XREF: .rdata:00005270o
; public: virtual signed char __thiscall icu_56::FilteredNormalizer2::isNormalized(class icu_56::UnicodeString const &,	enum  UErrorCode &)const
		extrn ?isNormalized@FilteredNormalizer2@icu_56@@UBECABVUnicodeString@2@AAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:00005274o
; public: virtual enum	UNormalizationCheckResult __thiscall icu_56::FilteredNormalizer2::quickCheck(class icu_56::UnicodeString const &, enum	UErrorCode &)const
		extrn ?quickCheck@FilteredNormalizer2@icu_56@@UBE?AW4UNormalizationCheckResult@@ABVUnicodeString@2@AAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:00005278o
; public: virtual int __thiscall icu_56::FilteredNormalizer2::spanQuickCheckYes(class icu_56::UnicodeString const &, enum  UErrorCode &)const
		extrn ?spanQuickCheckYes@FilteredNormalizer2@icu_56@@UBEHABVUnicodeString@2@AAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:0000527Co
; public: virtual signed char __thiscall icu_56::FilteredNormalizer2::hasBoundaryBefore(int)const
		extrn ?hasBoundaryBefore@FilteredNormalizer2@icu_56@@UBECH@Z:near
					; DATA XREF: .rdata:00005280o
; public: virtual signed char __thiscall icu_56::FilteredNormalizer2::hasBoundaryAfter(int)const
		extrn ?hasBoundaryAfter@FilteredNormalizer2@icu_56@@UBECH@Z:near
					; DATA XREF: .rdata:00005284o
; public: virtual signed char __thiscall icu_56::FilteredNormalizer2::isInert(int)const
		extrn ?isInert@FilteredNormalizer2@icu_56@@UBECH@Z:near
					; DATA XREF: .rdata:00005288o
; _DWORD __thiscall icu_56::FilteredNormalizer2::~FilteredNormalizer2(icu_56::FilteredNormalizer2 *__hidden this)
		extrn ??1FilteredNormalizer2@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::FilteredNormalizer2::`scalar deleting destructor'(uint)+26p
					; icu_56::FilteredNormalizer2::`vector deleting	destructor'(uint)+64p
					; DATA XREF: ...
; void __thiscall icu_56::UnicodeString::toUTF8(icu_56::UnicodeString *__hidden	this, struct icu_56::ByteSink *)
		extrn ?toUTF8@UnicodeString@icu_56@@QBEXAAVByteSink@2@@Z:near
					; CODE XREF: icu_56::IDNA::labelToASCII_UTF8(icu_56::StringPiece const &,icu_56::ByteSink &,icu_56::IDNAInfo &,UErrorCode &)+C5p
					; icu_56::IDNA::labelToUnicodeUTF8(icu_56::StringPiece const &,icu_56::ByteSink	&,icu_56::IDNAInfo &,UErrorCode	&)+C5p	...
; struct icu_56::UnicodeString __cdecl __high static icu_56::UnicodeString::fromUTF8(const struct icu_56::StringPiece *)
		extrn ?fromUTF8@UnicodeString@icu_56@@SA?AV12@ABVStringPiece@2@@Z:near
					; CODE XREF: icu_56::IDNA::labelToASCII_UTF8(icu_56::StringPiece const &,icu_56::ByteSink &,icu_56::IDNAInfo &,UErrorCode &)+8Ap
					; icu_56::IDNA::labelToUnicodeUTF8(icu_56::StringPiece const &,icu_56::ByteSink	&,icu_56::IDNAInfo &,UErrorCode	&)+8Ap	...
; void *__cdecl	static icu_56::UMemory::operator new(unsigned int)
		extrn ??2UMemory@icu_56@@SAPAXI@Z:near
					; CODE XREF: icu_56::IDNA::createUTS46Instance(uint,UErrorCode &)+58p
; const	struct icu_56::Normalizer2 *__cdecl __high static icu_56::Normalizer2::getInstance(const char *, const char *, enum UNormalization2Mode, enum UErrorCode *)
		extrn ?getInstance@Normalizer2@icu_56@@SAPBV12@PBD0W4UNormalization2Mode@@AAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::UTS46::UTS46(uint,UErrorCode &)+67p
; public: virtual void * __thiscall icu_56::UTS46::`scalar deleting destructor'(unsigned int)
		extrn ??_GUTS46@icu_56@@UAEPAXI@Z_0:near
; public: virtual void * __thiscall icu_56::UTS46::`vector deleting destructor'(unsigned int)
		extrn ??_EUTS46@icu_56@@UAEPAXI@Z:near ; weak
					; DATA XREF: .rdata:const icu_56::UTS46::`vftable'o
; void __thiscall icu_56::UnicodeString::releaseBuffer(icu_56::UnicodeString *__hidden this, int)
		extrn ?releaseBuffer@UnicodeString@icu_56@@QAEXH@Z:near
					; CODE XREF: icu_56::UTS46::process(icu_56::UnicodeString const	&,signed char,signed char,icu_56::UnicodeString	&,icu_56::IDNAInfo &,UErrorCode	&)+16Ep
					; icu_56::UTS46::process(icu_56::UnicodeString const &,signed char,signed char,icu_56::UnicodeString &,icu_56::IDNAInfo	&,UErrorCode &)+2F0p ...
; wchar_t *__thiscall icu_56::UnicodeString::getBuffer(icu_56::UnicodeString *__hidden this, int)
		extrn ?getBuffer@UnicodeString@icu_56@@QAEPA_WH@Z:near
					; CODE XREF: icu_56::UTS46::process(icu_56::UnicodeString const	&,signed char,signed char,icu_56::UnicodeString	&,icu_56::IDNAInfo &,UErrorCode	&)+B7p
					; icu_56::UTS46::mapDevChars(icu_56::UnicodeString &,int,int,UErrorCode	&)+A4p	...
; void __thiscall icu_56::UnicodeString::setToBogus(icu_56::UnicodeString *__hidden this)
		extrn ?setToBogus@UnicodeString@icu_56@@QAEXXZ:near
					; CODE XREF: icu_56::UTS46::process(icu_56::UnicodeString const	&,signed char,signed char,icu_56::UnicodeString	&,icu_56::IDNAInfo &,UErrorCode	&)+3Bp
					; icu_56::UTS46::process(icu_56::UnicodeString const &,signed char,signed char,icu_56::UnicodeString &,icu_56::IDNAInfo	&,UErrorCode &)+6Dp
; _DWORD __thiscall icu_56::StringPiece::StringPiece(icu_56::StringPiece *__hidden this, const struct icu_56::StringPiece *, int)
		extrn ??0StringPiece@icu_56@@QAE@ABV01@H@Z:near
					; CODE XREF: icu_56::UTS46::processUTF8(icu_56::StringPiece const &,signed char,signed char,icu_56::ByteSink &,icu_56::IDNAInfo	&,UErrorCode &)+496p
		extrn _u_memmove_56:near
					; CODE XREF: icu_56::UTS46::mapDevChars(icu_56::UnicodeString &,int,int,UErrorCode &)+1D9p
		extrn _u_strToPunycode_56:near
					; CODE XREF: icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed	char,icu_56::IDNAInfo &,UErrorCode &)+867p
					; icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed char,icu_56::IDNAInfo &,UErrorCode	&)+920p
		extrn _u_charType_56:near
					; CODE XREF: icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed	char,icu_56::IDNAInfo &,UErrorCode &)+601p
		extrn _u_strFromPunycode_56:near
					; CODE XREF: icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed	char,icu_56::IDNAInfo &,UErrorCode &)+159p
					; icu_56::UTS46::processLabel(icu_56::UnicodeString &,int,int,signed char,icu_56::IDNAInfo &,UErrorCode	&)+1F9p
		extrn _u_charDirection_56:near
					; CODE XREF: icu_56::UTS46::checkLabelBiDi(wchar_t const *,int,icu_56::IDNAInfo	&)+76p
					; icu_56::UTS46::checkLabelBiDi(wchar_t	const *,int,icu_56::IDNAInfo &)+F7p ...
		extrn _ubidi_getJoiningType_56:near
					; CODE XREF: icu_56::UTS46::isLabelOkContextJ(wchar_t const *,int)+EFp
					; icu_56::UTS46::isLabelOkContextJ(wchar_t const *,int)+1DBp
		extrn _ubidi_getSingleton_56:near
					; CODE XREF: icu_56::UTS46::isLabelOkContextJ(wchar_t const *,int)+23p
		extrn _uscript_getScript_56:near
					; CODE XREF: icu_56::UTS46::checkLabelContextO(wchar_t const *,int,icu_56::IDNAInfo &)+167p
					; icu_56::UTS46::checkLabelContextO(wchar_t const *,int,icu_56::IDNAInfo &)+253p ...
; int __thiscall icu_56::UnicodeString::extract(icu_56::UnicodeString *__hidden	this, wchar_t *, int, enum UErrorCode *)
		extrn ?extract@UnicodeString@icu_56@@QBEHPA_WHAAW4UErrorCode@@@Z:near
					; CODE XREF: _uidna_labelToASCII_56+E2p
					; _uidna_labelToUnicode_56+E2p	...
; _DWORD __thiscall icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString *__hidden this, wchar_t *, int, int)
		extrn ??0UnicodeString@icu_56@@QAE@PA_WHH@Z:near
					; CODE XREF: _uidna_labelToASCII_56+81p
					; _uidna_labelToUnicode_56+81p	...
; _DWORD __thiscall icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString *__hidden this, signed __int8, const wchar_t *, int)
		extrn ??0UnicodeString@icu_56@@QAE@CPB_WH@Z:near
					; CODE XREF: _uidna_labelToASCII_56+6Cp
					; _uidna_labelToUnicode_56+6Cp	...
; void *__cdecl	memset(void *Dst, int Val, size_t Size)
		extrn _memset:near	; CODE XREF: checkArgs(void const *,int,void *,int,UIDNAInfo *,UErrorCode *)+E7p
; _DWORD __thiscall icu_56::CheckedArrayByteSink::~CheckedArrayByteSink(icu_56::CheckedArrayByteSink *__hidden this)
		extrn ??1CheckedArrayByteSink@icu_56@@UAE@XZ:near
					; CODE XREF: _uidna_labelToASCII_UTF8_56+F6p
					; _uidna_labelToUnicodeUTF8_56+F6p ...
		extrn _u_terminateChars_56:near	; CODE XREF: _uidna_labelToASCII_UTF8_56+E5p
					; _uidna_labelToUnicodeUTF8_56+E5p ...
; _DWORD __thiscall icu_56::CheckedArrayByteSink::CheckedArrayByteSink(icu_56::CheckedArrayByteSink *__hidden this, char *, int)
		extrn ??0CheckedArrayByteSink@icu_56@@QAE@PADH@Z:near
					; CODE XREF: _uidna_labelToASCII_UTF8_56+8Dp
					; _uidna_labelToUnicodeUTF8_56+8Dp ...
; size_t __cdecl strlen(const char *Str)
		extrn _strlen:near	; CODE XREF: _uidna_labelToASCII_UTF8_56+56p
					; _uidna_labelToUnicodeUTF8_56+56p ...


		end
