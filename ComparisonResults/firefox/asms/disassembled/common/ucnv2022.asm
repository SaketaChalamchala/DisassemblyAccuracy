;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	AB21374FA6A8707880681F2FCDA6D4F9
; Input	CRC32 :	8EC7DB95

; File Name   :	D:\compspace\objfiles\firefox\common\ucnv2022.obj
; Format      :	COFF (X386MAGIC)
; includelib "msvcprtd"
; includelib "MSVCRTD"
; includelib "OLDNAMES"

		include	uni.inc	; see unicode subdir of	ida for	info on	unicode

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		public ?value@?$integral_constant@_N$0A@@tr1@std@@2_NB
; public: static bool const std::tr1::integral_constant<bool, 0>::value
?value@?$integral_constant@_N$0A@@tr1@std@@2_NB	db 0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		;org 4
		public ?value@?$integral_constant@_N$00@tr1@std@@2_NB
; public: static bool const std::tr1::integral_constant<bool, 1>::value
?value@?$integral_constant@_N$00@tr1@std@@2_NB db 1
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8
		public ?value@?$integral_constant@I$0A@@tr1@std@@2IB
; public: static unsigned int const std::tr1::integral_constant<unsigned int, 0>::value
?value@?$integral_constant@I$0A@@tr1@std@@2IB dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0Ch
		public ?_Rank@?$_Arithmetic_traits@_N@std@@2HB
; public: static int const std::_Arithmetic_traits<bool>::_Rank
?_Rank@?$_Arithmetic_traits@_N@std@@2HB	dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 10h
		public ?_Rank@?$_Arithmetic_traits@D@std@@2HB
; public: static int const std::_Arithmetic_traits<char>::_Rank
?_Rank@?$_Arithmetic_traits@D@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 14h
		public ?_Rank@?$_Arithmetic_traits@C@std@@2HB
; public: static int const std::_Arithmetic_traits<signed char>::_Rank
?_Rank@?$_Arithmetic_traits@C@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 18h
		public ?_Rank@?$_Arithmetic_traits@E@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned char>::_Rank
?_Rank@?$_Arithmetic_traits@E@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1Ch
		public ?_Rank@?$_Arithmetic_traits@F@std@@2HB
; public: static int const std::_Arithmetic_traits<short>::_Rank
?_Rank@?$_Arithmetic_traits@F@std@@2HB dd 3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 20h
		public ?_Rank@?$_Arithmetic_traits@G@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned short>::_Rank
?_Rank@?$_Arithmetic_traits@G@std@@2HB dd 3
					; DATA XREF: .rdata:int	const std::_Locbase<int>::messageso
					; .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::showposo ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 24h
		public ?_Rank@?$_Arithmetic_traits@H@std@@2HB
; public: static int const std::_Arithmetic_traits<int>::_Rank
?_Rank@?$_Arithmetic_traits@H@std@@2HB dd 4 ; DATA XREF: .rdata:00000210o
					; .rdata:00000214o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 28h
		public ?_Rank@?$_Arithmetic_traits@I@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned int>::_Rank
?_Rank@?$_Arithmetic_traits@I@std@@2HB dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2Ch
		public ?_Rank@?$_Arithmetic_traits@J@std@@2HB
; public: static int const std::_Arithmetic_traits<long>::_Rank
?_Rank@?$_Arithmetic_traits@J@std@@2HB dd 5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 30h
		public ?_Rank@?$_Arithmetic_traits@K@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned long>::_Rank
?_Rank@?$_Arithmetic_traits@K@std@@2HB dd 5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 34h
		public ?_Rank@?$_Arithmetic_traits@_J@std@@2HB
; public: static int const std::_Arithmetic_traits<__int64>::_Rank
?_Rank@?$_Arithmetic_traits@_J@std@@2HB	dd 6 ; DATA XREF: .rdata:00000218o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 38h
		public ?_Rank@?$_Arithmetic_traits@_K@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned __int64>::_Rank
?_Rank@?$_Arithmetic_traits@_K@std@@2HB	dd 6 ; DATA XREF: .rdata:0000021Co
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3Ch
		public ?_Rank@?$_Arithmetic_traits@M@std@@2HB
; public: static int const std::_Arithmetic_traits<float>::_Rank
?_Rank@?$_Arithmetic_traits@M@std@@2HB dd 7 ; DATA XREF: .rdata:00000220o
					; .rdata:00000224o ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 40h
		public ?_Rank@?$_Arithmetic_traits@N@std@@2HB
; public: static int const std::_Arithmetic_traits<double>::_Rank
?_Rank@?$_Arithmetic_traits@N@std@@2HB dd 8
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::lefto
					; .rdata:std::_Iosb<int>::_Openmode const std::_Iosb<int>::_Nocreateo ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 44h
		public ?_Rank@?$_Arithmetic_traits@O@std@@2HB
; public: static int const std::_Arithmetic_traits<long	double>::_Rank
?_Rank@?$_Arithmetic_traits@O@std@@2HB dd 9
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 48h
		public ?collate@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::collate
?collate@?$_Locbase@H@std@@2HB dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4Ch
		public ?ctype@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::ctype
?ctype@?$_Locbase@H@std@@2HB dd	2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 50h
		public ?monetary@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::monetary
?monetary@?$_Locbase@H@std@@2HB	dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 54h
		public ?numeric@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::numeric
?numeric@?$_Locbase@H@std@@2HB dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 58h
		public ?time@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::time
?time@?$_Locbase@H@std@@2HB dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5Ch
		public ?messages@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::messages
?messages@?$_Locbase@H@std@@2HB	dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 60h
		public ?all@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::all
?all@?$_Locbase@H@std@@2HB dd offset ?_Rank@?$_Arithmetic_traits@M@std@@2HB+3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 64h
		public ?none@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::none
?none@?$_Locbase@H@std@@2HB dd 0	; DATA XREF: .rdata:__ISO2022StaticDatao
					; .rdata:__ISO2022JPStaticDatao ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 68h
		public ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::skipws
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6Ch
		public ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::unitbuf
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 70h
		public ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::uppercase
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 74h
		public ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showbase
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 78h
		public ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showpoint
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 7Ch
		public ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showpos
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 80h
		public ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::left
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::righto
					; .rdata:std::_Iosb<int>::_Openmode const std::_Iosb<int>::_Noreplaceo
_rdata		ends			; int const std::_Arithmetic_traits<double>::_Rank

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 84h
		public ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::right
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B	dd offset ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B ; std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::left
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 88h
		public ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::internal
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset dword_100
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8Ch
		public ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::dec
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	dword_200
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 90h
		public ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::oct
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	dword_400
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 94h
		public ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::hex
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	dword_800
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 98h
		public ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::scientific
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd	offset aReplaceable@ic ; "Replaceable@icu_56@@"
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 9Ch
		public ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::fixed
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B	dd offset loc_2000
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A0h
		public ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::hexfloat
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z ; icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int,int,int)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A4h
		public ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::boolalpha
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_3FFB+5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A8h
		public ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::_Stdio
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_8000
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0ACh
		public ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::adjustfield
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	dword_1C0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B0h
		public ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::basefield
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_E00
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B4h
		public ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::floatfield
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd	offset ?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z ; icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int,int,int)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B8h
		public ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::goodbit
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0BCh
		public ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::eofbit
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B	dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C0h
		public ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::failbit
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C4h
		public ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::badbit
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B	dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C8h
		public ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::_Hardfail
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0CCh
		public ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::in
?in@?$_Iosb@H@std@@2W4_Openmode@12@B dd	1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D0h
		public ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::out
?out@?$_Iosb@H@std@@2W4_Openmode@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D4h
		public ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::ate
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D8h
		public ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::app
?app@?$_Iosb@H@std@@2W4_Openmode@12@B dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0DCh
		public ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::trunc
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B	dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E0h
		public ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::_Nocreate
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB
					; DATA XREF: .text:00005380o
_rdata		ends			; int const std::_Arithmetic_traits<double>::_Rank

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E4h
		public ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::_Noreplace
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B dd	offset ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
					; DATA XREF: .rdata:__ISO2022Data_56o
					; .rdata:UConverterSharedData const `anonymous namespace'::_ISO2022JPDatao ...
_rdata		ends			; std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::left

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E8h
		public ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::binary
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int	const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0ECh
		public ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::beg
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F0h
		public ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::cur
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F4h
		public ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::end
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 0F8h
_SHIFT_IN_STR	dd 0Fh			; DATA XREF: .rdata:_escSeqCharsCNo
					; UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)+5B4o ...
_jpCharsetMasks	dw 119h			; DATA XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+19Er
					; _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+201r ...
		dw 139h
dword_100	dd 1FF01FFh, 1FFh	; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::internalo
_normalize_esq_chars_2022 db 0		; DATA XREF: getKey_2022(char,int *,int	*)+37r
		align 4
		dd 5 dup(0)
		dd 1000000h, 2 dup(0)
		dd 1D0704h, 1B1A1802h, 6170300h, 4 dup(0)
		dd 0A090805h, 0E0D0C0Bh, 1211100Fh, 1C191413h, 150000h
		dd 0
		dd 160000h, 17h	dup(0)
dword_1C0	dd 10h dup(0)		; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::adjustfieldo
dword_200	dd 2 dup(0)		; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::deco
_escSeqStateTable_Key_2022 dd 1		; DATA XREF: getKey_2022(char,int *,int	*)+8Fr
					; getKey_2022(char,int *,int *)+A6r
		dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB+2
		dd offset ?_Rank@?$_Arithmetic_traits@H@std@@2HB ; int const std::_Arithmetic_traits<int>::_Rank
		dd offset ?_Rank@?$_Arithmetic_traits@H@std@@2HB+3
		dd offset ?_Rank@?$_Arithmetic_traits@_J@std@@2HB+3
		dd offset ?_Rank@?$_Arithmetic_traits@_K@std@@2HB+1
		dd offset ?_Rank@?$_Arithmetic_traits@M@std@@2HB ; int const std::_Arithmetic_traits<float>::_Rank
		dd offset ?_Rank@?$_Arithmetic_traits@M@std@@2HB+1
		dd offset byte_445
		dd offset off_448
		dd offset off_448+1
		dd offset off_448+2
		dd offset off_448+3
		dd offset byte_44C
		dd offset off_44D
		dd offset off_44D+1
		dd offset off_44D+2
		dd offset off_44D+3
		dd offset byte_451
		dd offset word_452
		dd offset byte_455
		dd offset word_482
		dd offset byte_485
		dd offset _hwkana_fb
		dd offset byte_489
		dd offset byte_498
		dd offset byte_49A
		dd offset byte_49B
		dd offset a_ABDFHIJKLMOS ; "_%`%a%b%d%f%h%i%j%k%l%m%o%s%+!,!"
		dd offset a_ABDFHIJKLMOS+3 ; "%a%b%d%f%h%i%j%k%l%m%o%s%+!,!"
		dd offset dword_6E8
		dd offset byte_6ED
		dd offset byte_7A5
		dd offset loc_891C+5
		dd offset loc_9045
		dd offset loc_9047+1
		dd offset loc_9047+2
		dd offset loc_9047+3
		dd offset loc_9047+4
		dd offset loc_9047+5
		dd offset loc_904D+1
		dd offset loc_904D+2
		dd offset loc_9050
		dd offset loc_9050+1
		dd offset loc_9050+2
		dd offset loc_9050+3
		dd offset loc_9050+4
		dd offset ??_C@_1FO@NKNFLGG@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@+38h	; "ommon\\ucnv2022.cpp"
		dd offset ??_C@_1FO@NKNFLGG@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@+3Ah	; "mmon\\ucnv2022.cpp"
		dd offset ??_C@_1FO@NKNFLGG@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@+3Ch	; "mon\\ucnv2022.cpp"
		dd offset ??_C@_1FO@NKNFLGG@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@+3Eh	; "on\\ucnv2022.cpp"
		dd offset loc_934B+4
		dd offset loc_936D+3
		dd offset loc_936D+4
		dd offset loc_936D+5
		dd offset loc_936D+6
		dd offset loc_9374
		dd offset loc_9CC3+2
		dd offset loc_9CC8
		dd offset loc_9CC8+2
		dd offset loc_9CCB
		dd offset loc_9CCB+1
		dd offset loc_9CCB+2
		dd 112423h, 2248468h, 2248469h,	224846Ah, 224846Bh, 224846Dh
		dd 224846Eh, 224846Fh, 2248473h, 2248474h, 2248476h
_escSeqStateTable_Value_2022 db	0	; DATA XREF: getKey_2022(char,int *,int	*)+CDr
		align 4
		dd 10100h, 1020101h, 2 dup(1010101h), 1010001h,	1, 1010100h
		dd 1010001h, 6 dup(1010101h), 10101h, 2	dup(1010101h)
		dd 101h, 0
_nextStateToUnicodeJP db 0FFh		; DATA XREF: changeState_2022(UConverter *,char	const *	*,char const *,Variant2022,UErrorCode *)+153r
		db 3 dup(0FFh)
		dd 0FFFF10FFh, 0FF00FFFFh, 0FFFFFFFFh, 0FF030803h, 604FFFFh
		dd 0FFFFFF04h, 201FFFFh, 0FFFFFF04h, 0FF0507FFh, 8 dup(0FFFFFFFFh)
		dd 0FFFFh, 0
_nextStateToUnicodeCN db 0FFh		; DATA XREF: changeState_2022(UConverter *,char	const *	*,char const *,Variant2022,UErrorCode *)+245r
		db 3 dup(0FFh)
		dd 0FF1110FFh, 9 dup(0FFFFFFFFh), 1FFFFFFh
dword_400	dd 222102FFh, 26252423h, 0FFFFFF27h, 3 dup(0FFFFFFFFh)
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::octo
		dd 0FFFFh
_jpCharsetPref	db 0			; DATA XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+2E6r
		align 10h
		dd 3, 1, 4, 2, 5, 6, 7,	8
_escSeqChars	dd 42281Bh		; DATA XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+846o
					; UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)+865o ...
		db 0
byte_445	db 0, 1Bh, 2Eh		; DATA XREF: .rdata:00000228o
off_448		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB+1
					; DATA XREF: .rdata:0000022Co
					; .rdata:00000230o ...
byte_44C	db 1Bh			; DATA XREF: .rdata:0000023Co
off_44D		dd offset loc_462C+2	; DATA XREF: .rdata:00000240o
					; .rdata:00000244o ...
byte_451	db 0			; DATA XREF: .rdata:00000250o
word_452	dw 281Bh		; DATA XREF: .rdata:00000254o
		db 4Ah
byte_455	db 3 dup(0)		; DATA XREF: .rdata:00000258o
		dd 42241Bh, 241B0000h, 4428h, 41241Bh, 241B0000h, 4328h
		dd 49281Bh, 0
_escSeqCharsLen	db 3			; DATA XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+82Dr
					; UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)+B9Fr
		db 3 dup(3)
		dd 4030403h
		db 3, 0
word_482	dw 0			; DATA XREF: .rdata:0000025Co
		db 0
byte_485	db 3 dup(0)		; DATA XREF: .rdata:00000260o
_hwkana_fb	db 23h			; DATA XREF: .rdata:00000264o
byte_489	db 21h,	56h, 21h	; DATA XREF: .rdata:00000268o
		dd 21222157h, 25722126h, 25232521h
byte_498	db 2 dup(25h)		; DATA XREF: .rdata:0000026Co
byte_49A	db 27h			; DATA XREF: .rdata:00000270o
byte_49B	db 25h			; DATA XREF: .rdata:00000274o
		dd 25632529h, 25672565h, 213C2543h, 25242522h, 25282526h
		dd 252B252Ah, 252F252Dh, 25332531h, 25372535h, 253B2539h
		dd 253F253Dh, 25442541h, 25482546h, 254B254Ah, 254D254Ch
; void *Src
Src		dd 254F254Eh		; DATA XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+5E0r
					; UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)+5F9r
		dd 25552552h, 255B2558h
		db 5Eh,	25h
a_ABDFHIJKLMOS	db '_%`%a%b%d%f%h%i%j%k%l%m%o%s%+!,!',0 ; DATA XREF: .rdata:00000278o
					; .rdata:0000027Co
		align 4
_GB_2312_80_STR	db 1Bh,'$)A',0          ; DATA XREF: .rdata:00000554o
		align 10h
_ISO_IR_165_STR	db 1Bh,'$)E',0          ; DATA XREF: .rdata:00000558o
		align 4
_CNS_11643_1992_Plane_1_STR db 1Bh,'$)G',0 ; DATA XREF: .rdata:0000055Co
		align 10h
_CNS_11643_1992_Plane_2_STR db 1Bh,'$*H',0 ; DATA XREF: .rdata:00000560o
		align 4
_CNS_11643_1992_Plane_3_STR db 1Bh,'$+I',0 ; DATA XREF: .rdata:00000564o
		align 10h
_CNS_11643_1992_Plane_4_STR db 1Bh,'$+J',0 ; DATA XREF: .rdata:00000568o
		align 4
_CNS_11643_1992_Plane_5_STR db 1Bh,'$+K',0 ; DATA XREF: .rdata:0000056Co
		align 10h
_CNS_11643_1992_Plane_6_STR db 1Bh,'$+L',0 ; DATA XREF: .rdata:00000570o
		align 4
_CNS_11643_1992_Plane_7_STR db 1Bh,'$+M',0 ; DATA XREF: .rdata:00000574o
		align 10h
; void *escSeqCharsCN
_escSeqCharsCN	dd offset _SHIFT_IN_STR	; DATA XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+56Cr
					; UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)+585r
		dd offset _GB_2312_80_STR ; "\x1B$)A"
		dd offset _ISO_IR_165_STR ; "\x1B$)E"
		dd offset _CNS_11643_1992_Plane_1_STR ;	"\x1B$)G"
		dd offset _CNS_11643_1992_Plane_2_STR ;	"\x1B$*H"
		dd offset _CNS_11643_1992_Plane_3_STR ;	"\x1B$+I"
		dd offset _CNS_11643_1992_Plane_4_STR ;	"\x1B$+J"
		dd offset _CNS_11643_1992_Plane_5_STR ;	"\x1B$+K"
		dd offset _CNS_11643_1992_Plane_6_STR ;	"\x1B$+L"
		dd offset _CNS_11643_1992_Plane_7_STR ;	"\x1B$+M"
__ISO2022Impl	dd 0Ah,	2 dup(0)	; DATA XREF: .rdata:0000063Co
		dd offset ?_ISO2022Open@@YAXPAUUConverter@@PAUUConverterLoadArgs@@PAW4UErrorCode@@@Z ; _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)
		dd offset ?_ISO2022Close@@YAXPAUUConverter@@@Z ; _ISO2022Close(UConverter *)
		dd offset ?_ISO2022Reset@@YAXPAUUConverter@@W4UConverterResetChoice@@@Z	; _ISO2022Reset(UConverter *,UConverterResetChoice)
		dd 6 dup(0)
		dd offset ?_ISO2022getName@@YAPBDPBUUConverter@@@Z ; _ISO2022getName(UConverter	const *)
		dd offset ?_ISO_2022_WriteSub@@YAXPAUUConverterFromUnicodeArgs@@HPAW4UErrorCode@@@Z ; _ISO_2022_WriteSub(UConverterFromUnicodeArgs *,int,UErrorCode *)
		dd offset ?_ISO_2022_SafeClone@@YAPAUUConverter@@PBU1@PAXPAHPAW4UErrorCode@@@Z ; _ISO_2022_SafeClone(UConverter	const *,void *,int *,UErrorCode	*)
		dd offset ?_ISO_2022_GetUnicodeSet@@YAXPBUUConverter@@PBUUSetAdder@@W4UConverterUnicodeSet@@PAW4UErrorCode@@@Z ; _ISO_2022_GetUnicodeSet(UConverter const *,USetAdder const *,UConverterUnicodeSet,UErrorCode *)
		align 10h
__ISO2022StaticData dd offset ?none@?$_Locbase@H@std@@2HB ; DATA XREF: .rdata:00000634o
					; int const std::_Locbase<int>::none
aIso_2022	db 'ISO_2022',0
		align 40h
		dd offset word_7E6
		dd 3010A00h, 1Ah, 1, 6 dup(0)
		public __ISO2022Data_56
__ISO2022Data_56 dd offset ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Openmode const std::_Iosb<int>::_Noreplace
		dd 0FFFFFFFFh, 0
		dd offset __ISO2022StaticData
		dd 0
		dd offset __ISO2022Impl
		dd 2Ah dup(0)
dword_6E8	dd 0			; DATA XREF: .rdata:00000280o
		db 0
byte_6ED	db 3 dup(0)		; DATA XREF: .rdata:00000284o
		dd 8 dup(0)
__ISO2022JPImpl	dd 0Ah,	2 dup(0)	; DATA XREF: .rdata:000007D4o
		dd offset ?_ISO2022Open@@YAXPAUUConverter@@PAUUConverterLoadArgs@@PAW4UErrorCode@@@Z ; _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)
		dd offset ?_ISO2022Close@@YAXPAUUConverter@@@Z ; _ISO2022Close(UConverter *)
		dd offset ?_ISO2022Reset@@YAXPAUUConverter@@W4UConverterResetChoice@@@Z	; _ISO2022Reset(UConverter *,UConverterResetChoice)
		dd offset ?UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC@@YAXPAUUConverterToUnicodeArgs@@PAW4UErrorCode@@@Z ; UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)
		dd offset ?UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC@@YAXPAUUConverterToUnicodeArgs@@PAW4UErrorCode@@@Z ; UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)
		dd offset ?UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC@@YAXPAUUConverterFromUnicodeArgs@@PAW4UErrorCode@@@Z ; UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)
		dd offset ?UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC@@YAXPAUUConverterFromUnicodeArgs@@PAW4UErrorCode@@@Z ; UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)
		align 10h
		dd offset ?_ISO2022getName@@YAPBDPBUUConverter@@@Z ; _ISO2022getName(UConverter	const *)
		dd offset ?_ISO_2022_WriteSub@@YAXPAUUConverterFromUnicodeArgs@@HPAW4UErrorCode@@@Z ; _ISO_2022_WriteSub(UConverterFromUnicodeArgs *,int,UErrorCode *)
		dd offset ?_ISO_2022_SafeClone@@YAPAUUConverter@@PBU1@PAXPAHPAW4UErrorCode@@@Z ; _ISO_2022_SafeClone(UConverter	const *,void *,int *,UErrorCode	*)
		dd offset ?_ISO_2022_GetUnicodeSet@@YAXPBUUConverter@@PBUUSetAdder@@W4UConverterUnicodeSet@@PAW4UErrorCode@@@Z ; _ISO_2022_GetUnicodeSet(UConverter const *,USetAdder const *,UConverterUnicodeSet,UErrorCode *)
		dd 2 dup(0)
__ISO2022JPStaticData dd offset	?none@?$_Locbase@H@std@@2HB ; DATA XREF: .rdata:000007CCo
					; int const std::_Locbase<int>::none
aIso_2022_jp	db 'ISO_2022_JP',0
		dd 0Dh dup(0)
		dd 6010A00h, 1Ah
		db 1
byte_7A5	db 3 dup(0)		; DATA XREF: .rdata:00000288o
		align 20h
		public ?_ISO2022JPData@?A0x5ec8f556@@3UUConverterSharedData@@B
; struct UConverterSharedData const `anonymous namespace'::_ISO2022JPData
?_ISO2022JPData@?A0x5ec8f556@@3UUConverterSharedData@@B	dd offset ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
					; DATA XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+2B2o
					; std::_Iosb<int>::_Openmode const std::_Iosb<int>::_Noreplace
		dd 0FFFFFFFFh, 0
		dd offset __ISO2022JPStaticData
		dd 0
		dd offset __ISO2022JPImpl
		dd 3 dup(0)
		db 2 dup(0)
word_7E6	dw 0			; DATA XREF: .rdata:00000600o
		align 20h
dword_800	dd 2Ah dup(0)		; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::hexo
__ISO2022KRImpl	dd 0Ah,	2 dup(0)	; DATA XREF: .rdata:0000096Co
		dd offset ?_ISO2022Open@@YAXPAUUConverter@@PAUUConverterLoadArgs@@PAW4UErrorCode@@@Z ; _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)
		dd offset ?_ISO2022Close@@YAXPAUUConverter@@@Z ; _ISO2022Close(UConverter *)
		dd offset ?_ISO2022Reset@@YAXPAUUConverter@@W4UConverterResetChoice@@@Z	; _ISO2022Reset(UConverter *,UConverterResetChoice)
		dd offset ?UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC@@YAXPAUUConverterToUnicodeArgs@@PAW4UErrorCode@@@Z ; UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)
		dd offset ?UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC@@YAXPAUUConverterToUnicodeArgs@@PAW4UErrorCode@@@Z ; UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)
		dd offset ?UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC@@YAXPAUUConverterFromUnicodeArgs@@PAW4UErrorCode@@@Z ; UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)
		dd offset ?UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC@@YAXPAUUConverterFromUnicodeArgs@@PAW4UErrorCode@@@Z ; UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)
		dd 2 dup(0)
		dd offset ?_ISO2022getName@@YAPBDPBUUConverter@@@Z ; _ISO2022getName(UConverter	const *)
		dd offset ?_ISO_2022_WriteSub@@YAXPAUUConverterFromUnicodeArgs@@HPAW4UErrorCode@@@Z ; _ISO_2022_WriteSub(UConverterFromUnicodeArgs *,int,UErrorCode *)
		dd offset ?_ISO_2022_SafeClone@@YAPAUUConverter@@PBU1@PAXPAHPAW4UErrorCode@@@Z ; _ISO_2022_SafeClone(UConverter	const *,void *,int *,UErrorCode	*)
		dd offset ?_ISO_2022_GetUnicodeSet@@YAXPBUUConverter@@PBUUSetAdder@@W4UConverterUnicodeSet@@PAW4UErrorCode@@@Z ; _ISO_2022_GetUnicodeSet(UConverter const *,USetAdder const *,UConverterUnicodeSet,UErrorCode *)
		align 10h
__ISO2022KRStaticData dd offset	?none@?$_Locbase@H@std@@2HB ; DATA XREF: .rdata:00000964o
					; int const std::_Locbase<int>::none
aIso_2022_kr	db 'ISO_2022_KR',0
		dd 0Dh dup(0)
		dd 3010A00h, 1Ah, 1, 6 dup(0)
		public ?_ISO2022KRData@?A0x5ec8f556@@3UUConverterSharedData@@B
; struct UConverterSharedData const `anonymous namespace'::_ISO2022KRData
?_ISO2022KRData@?A0x5ec8f556@@3UUConverterSharedData@@B	dd offset ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
					; DATA XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+4E2o
					; std::_Iosb<int>::_Openmode const std::_Iosb<int>::_Noreplace
		dd 0FFFFFFFFh, 0
		dd offset __ISO2022KRStaticData
		dd 0
		dd offset __ISO2022KRImpl
		dd 34h dup(0)
__ISO2022CNImpl	dd 0Ah,	2 dup(0)	; DATA XREF: .rdata:00000B04o
		dd offset ?_ISO2022Open@@YAXPAUUConverter@@PAUUConverterLoadArgs@@PAW4UErrorCode@@@Z ; _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)
		dd offset ?_ISO2022Close@@YAXPAUUConverter@@@Z ; _ISO2022Close(UConverter *)
		dd offset ?_ISO2022Reset@@YAXPAUUConverter@@W4UConverterResetChoice@@@Z	; _ISO2022Reset(UConverter *,UConverterResetChoice)
		dd offset ?UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC@@YAXPAUUConverterToUnicodeArgs@@PAW4UErrorCode@@@Z ; UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)
		dd offset ?UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC@@YAXPAUUConverterToUnicodeArgs@@PAW4UErrorCode@@@Z ; UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)
		dd offset ?UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC@@YAXPAUUConverterFromUnicodeArgs@@PAW4UErrorCode@@@Z ; UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)
		dd offset ?UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC@@YAXPAUUConverterFromUnicodeArgs@@PAW4UErrorCode@@@Z ; UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)
		align 10h
		dd offset ?_ISO2022getName@@YAPBDPBUUConverter@@@Z ; _ISO2022getName(UConverter	const *)
		dd offset ?_ISO_2022_WriteSub@@YAXPAUUConverterFromUnicodeArgs@@HPAW4UErrorCode@@@Z ; _ISO_2022_WriteSub(UConverterFromUnicodeArgs *,int,UErrorCode *)
		dd offset ?_ISO_2022_SafeClone@@YAPAUUConverter@@PBU1@PAXPAHPAW4UErrorCode@@@Z ; _ISO_2022_SafeClone(UConverter	const *,void *,int *,UErrorCode	*)
		dd offset ?_ISO_2022_GetUnicodeSet@@YAXPBUUConverter@@PBUUSetAdder@@W4UConverterUnicodeSet@@PAW4UErrorCode@@@Z ; _ISO_2022_GetUnicodeSet(UConverter const *,USetAdder const *,UConverterUnicodeSet,UErrorCode *)
		dd 2 dup(0)
__ISO2022CNStaticData dd offset	?none@?$_Locbase@H@std@@2HB ; DATA XREF: .rdata:00000AFCo
					; int const std::_Locbase<int>::none
aIso_2022_cn	db 'ISO_2022_CN',0
		dd 0Dh dup(0)
		dd 8010A00h, 1Ah, 1, 6 dup(0)
		public ?_ISO2022CNData@?A0x5ec8f556@@3UUConverterSharedData@@B
; struct UConverterSharedData const `anonymous namespace'::_ISO2022CNData
?_ISO2022CNData@?A0x5ec8f556@@3UUConverterSharedData@@B	dd offset ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
					; DATA XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+5E1o
					; std::_Iosb<int>::_Openmode const std::_Iosb<int>::_Noreplace
		dd 0FFFFFFFFh, 0
		dd offset __ISO2022CNStaticData
		dd 0
		dd offset __ISO2022CNImpl
		dd 14h dup(0)
		db 2 dup(0)
word_B5A	dw 0			; DATA XREF: .data:?__LINE__Var@?1??UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC@@YAXPAUUConverterFromUnicodeArgs@@PAW4UErrorCode@@@Z@4JA@d3633fb2o
		dd 1Dh dup(0)
		db 3 dup(0)
byte_BD3	db 0			; DATA XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+61Fr
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0BD4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	operator new(unsigned int)
		public ??2@YAPAXI@Z
??2@YAPAXI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??2@YAPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$TMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$TMZ
		;org 0C0Ch
__RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
_rtc$TMZ	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$IMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$IMZ
		;org 0C10h
__RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
_rtc$IMZ	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C14h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl operator	delete(void *)
		public ??3@YAXPAX@Z
??3@YAXPAX@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??3@YAXPAX@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C48h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	icu_56::UMemory::operator new(unsigned int, void *)
		public ??2UMemory@icu_56@@SAPAXIPAX@Z
??2UMemory@icu_56@@SAPAXIPAX@Z proc near

var_C0		= byte ptr -0C0h
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??2UMemory@icu_56@@SAPAXIPAX@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C70h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl icu_56::UMemory::operator delete(void *)
		public ??3UMemory@icu_56@@SAXPAX0@Z
??3UMemory@icu_56@@SAXPAX0@Z proc near

var_C0		= byte ptr -0C0h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??3UMemory@icu_56@@SAXPAX0@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C98h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UMemory	& __thiscall icu_56::UMemory::operator=(class icu_56::UMemory const &)
		public ??4UMemory@icu_56@@QAEAAV01@ABV01@@Z
??4UMemory@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4UMemory@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0CC8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UObject::UObject(icu_56::UObject *__hidden this)
		public ??0UObject@icu_56@@QAE@XZ
??0UObject@icu_56@@QAE@XZ proc near	; CODE XREF: icu_56::Replaceable::Replaceable(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UObject@icu_56@@6B@	; const	icu_56::UObject::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0UObject@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D00h
		dd offset ??_R4UObject@icu_56@@6B@ ; const icu_56::UObject::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7UObject@icu_56@@6B@
; const	icu_56::UObject::`vftable'
??_7UObject@icu_56@@6B@	dd offset ??_EUObject@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::UObject::UObject(void)+26o
					; icu_56::UObject::UObject(icu_56::UObject const &)+44o
					; icu_56::UObject::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ ;	icu_56::UObject::getDynamicClassID(void)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0D0Ch
		public ??_R4UObject@icu_56@@6B@
; const	icu_56::UObject::`RTTI Complete	Object Locator'
??_R4UObject@icu_56@@6B@ dd 3 dup(0)	; DATA XREF: .rdata:00000D00o
		dd offset ??_R0?AVUObject@icu_56@@@8 ; icu_56::UObject `RTTI Type Descriptor'
		dd offset ??_R3UObject@icu_56@@8 ; icu_56::UObject::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 0D20h
		public ??_R0?AVUObject@icu_56@@@8
; class	icu_56::UObject	`RTTI Type Descriptor'
??_R0?AVUObject@icu_56@@@8 dd offset ??_7type_info@@6B@	; DATA XREF: .rdata$r:00000D18o
					; .rdata$r:icu_56::UObject::`RTTI Base Class Descriptor	at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 8
a_?avuobject@ic	db '.?AVUObject@icu_56@@',0
		align 10h
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0D40h
		public ??_R3UObject@icu_56@@8
; icu_56::UObject::`RTTI Class Hierarchy Descriptor'
??_R3UObject@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:00000D1Co
					; .rdata$r:00000D74o
		dd 2
		dd offset ??_R2UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0D50h
		public ??_R2UObject@icu_56@@8
; icu_56::UObject::`RTTI Base Class Array'
??_R2UObject@icu_56@@8 dd offset ??_R1A@?0A@EA@UObject@icu_56@@8
					; DATA XREF: .rdata$r:00000D4Co
					; icu_56::UObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0D5Ch
		public ??_R1A@?0A@EA@UObject@icu_56@@8
; icu_56::UObject::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UObject@icu_56@@8	dd offset ??_R0?AVUObject@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UObject::`RTTI Base Class	Array'o
					; .rdata$r:0000102Co ...
					; icu_56::UObject `RTTI	Type Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UObject@icu_56@@8 ; icu_56::UObject::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0D78h
		public ??_R13?0A@EA@UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Descriptor at (4, -1, 0, 64)'
??_R13?0A@EA@UMemory@icu_56@@8 dd offset ??_R0?AVUMemory@icu_56@@@8
					; DATA XREF: .rdata$r:00000D54o
					; .rdata$r:00001030o ...
					; icu_56::UMemory `RTTI	Type Descriptor'
		align 10h
		dd 4, 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 0D94h
		public ??_R0?AVUMemory@icu_56@@@8
; class	icu_56::UMemory	`RTTI Type Descriptor'
??_R0?AVUMemory@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::UMemory::`RTTI Base Class	Descriptor at (4,-1,0,64)'o
					; .rdata$r:icu_56::UMemory::`RTTI Base Class Descriptor	at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avumemory@ic	db '.?AVUMemory@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0DB4h
		public ??_R3UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Class Hierarchy Descriptor'
??_R3UMemory@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:00000D90o
					; .rdata$r:00000DE4o
		dd 1
		dd offset ??_R2UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0DC4h
		public ??_R2UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Array'
??_R2UMemory@icu_56@@8 dd offset ??_R1A@?0A@EA@UMemory@icu_56@@8
					; DATA XREF: .rdata$r:00000DC0o
					; icu_56::UMemory::`RTTI Base Class Descriptor at (0,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0DCCh
		public ??_R1A@?0A@EA@UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UMemory@icu_56@@8	dd offset ??_R0?AVUMemory@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UMemory::`RTTI Base Class	Array'o
					; icu_56::UMemory `RTTI	Type Descriptor'
		dd 2 dup(0)
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0DE8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UObject::UObject(icu_56::UObject *this, const struct icu_56::UObject *)
		public ??0UObject@icu_56@@QAE@ABV01@@Z
??0UObject@icu_56@@QAE@ABV01@@Z	proc near
					; CODE XREF: icu_56::Replaceable::Replaceable(icu_56::Replaceable const	&)+2Ap
					; icu_56::StringEnumeration::StringEnumeration(icu_56::StringEnumeration const &)+49p

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'

loc_E00:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::basefieldo
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jz	short loc_E1F
		mov	eax, [ebp+arg_0]
		add	eax, 4
		mov	[ebp+var_D0], eax
		jmp	short loc_E29
; ---------------------------------------------------------------------------

loc_E1F:				; CODE XREF: icu_56::UObject::UObject(icu_56::UObject const &)+27j
		mov	[ebp+var_D0], 0

loc_E29:				; CODE XREF: icu_56::UObject::UObject(icu_56::UObject const &)+35j
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UObject@icu_56@@6B@	; const	icu_56::UObject::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??0UObject@icu_56@@QAE@ABV01@@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0E40h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UObject	& __thiscall icu_56::UObject::operator=(class icu_56::UObject const &)
		public ??4UObject@icu_56@@QAEAAV01@ABV01@@Z
??4UObject@icu_56@@QAEAAV01@ABV01@@Z proc near
					; CODE XREF: icu_56::Replaceable::operator=(icu_56::Replaceable	const &)+2Ap
					; icu_56::StringEnumeration::operator=(icu_56::StringEnumeration const &)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4UObject@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0E70h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UObject::`scalar deleting destructor'(unsigned int)
		public ??_GUObject@icu_56@@UAEPAXI@Z
??_GUObject@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_EAF
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_EAF:				; CODE XREF: icu_56::UObject::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GUObject@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0EC8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UObject::`vector deleting destructor'(unsigned int)
		public ??_EUObject@icu_56@@UAEPAXI@Z
??_EUObject@icu_56@@UAEPAXI@Z proc near	; DATA XREF: .rdata:const icu_56::UObject::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_F29
		push	offset ??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	4
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_F21
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_F21:				; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_F48
; ---------------------------------------------------------------------------

loc_F29:				; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_F45
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_F45:				; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_F48:				; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EUObject@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0F60h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::Replaceable::Replaceable(icu_56::Replaceable *this,	const struct icu_56::Replaceable *)
		public ??0Replaceable@icu_56@@QAE@ABV01@@Z
??0Replaceable@icu_56@@QAE@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UObject *
		mov	ecx, [ebp+var_8] ; this
		call	??0UObject@icu_56@@QAE@ABV01@@Z	; icu_56::UObject::UObject(icu_56::UObject const &)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7Replaceable@icu_56@@6B@ ; const icu_56::Replaceable::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0Replaceable@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0FB4h
		dd offset ??_R4Replaceable@icu_56@@6B@ ; const icu_56::Replaceable::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7Replaceable@icu_56@@6B@
; const	icu_56::Replaceable::`vftable'
??_7Replaceable@icu_56@@6B@ dd offset ??_EReplaceable@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::Replaceable::Replaceable(icu_56::Replaceable const	&)+32o
					; icu_56::Replaceable::Replaceable(void)+2Eo
					; icu_56::Replaceable::`vector deleting	destructor'(uint)
		dd offset ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ ;	icu_56::UObject::getDynamicClassID(void)
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
		dd offset ?hasMetaData@Replaceable@icu_56@@UBECXZ ; icu_56::Replaceable::hasMetaData(void)
		dd offset ?clone@Replaceable@icu_56@@UBEPAV12@XZ ; icu_56::Replaceable::clone(void)
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0FE0h
		public ??_R4Replaceable@icu_56@@6B@
; const	icu_56::Replaceable::`RTTI Complete Object Locator'
??_R4Replaceable@icu_56@@6B@ dd	3 dup(0) ; DATA	XREF: .rdata:00000FB4o
		dd offset ??_R0?AVReplaceable@icu_56@@@8 ; icu_56::Replaceable `RTTI Type Descriptor'
		dd offset ??_R3Replaceable@icu_56@@8 ; icu_56::Replaceable::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 0FF4h
		public ??_R0?AVReplaceable@icu_56@@@8
; class	icu_56::Replaceable `RTTI Type Descriptor'
??_R0?AVReplaceable@icu_56@@@8 dd offset ??_7type_info@@6B@ ; DATA XREF: .rdata$r:00000FECo
					; .rdata$r:icu_56::Replaceable::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
		dd 56413F2Eh
aReplaceable@ic	db 'Replaceable@icu_56@@',0
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::scientifico
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1018h
		public ??_R3Replaceable@icu_56@@8
; icu_56::Replaceable::`RTTI Class Hierarchy Descriptor'
??_R3Replaceable@icu_56@@8 dd 2	dup(0)	; DATA XREF: .rdata$r:00000FF0o
					; .rdata$r:00001050o
		dd 3
		dd offset ??_R2Replaceable@icu_56@@8 ; icu_56::Replaceable::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1028h
		public ??_R2Replaceable@icu_56@@8
; icu_56::Replaceable::`RTTI Base Class	Array'
??_R2Replaceable@icu_56@@8 dd offset ??_R1A@?0A@EA@Replaceable@icu_56@@8
					; DATA XREF: .rdata$r:00001024o
					; icu_56::Replaceable::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1038h
		public ??_R1A@?0A@EA@Replaceable@icu_56@@8
; icu_56::Replaceable::`RTTI Base Class	Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@Replaceable@icu_56@@8 dd offset ??_R0?AVReplaceable@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::Replaceable::`RTTI Base Class Array'o
					; .rdata$r:00001C68o
					; icu_56::Replaceable `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3Replaceable@icu_56@@8 ; icu_56::Replaceable::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1054h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::Replaceable & __thiscall icu_56::Replaceable::operator=(class icu_56::Replaceable const	&)
		public ??4Replaceable@icu_56@@QAEAAV01@ABV01@@Z
??4Replaceable@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??4UObject@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::UObject::operator=(icu_56::UObject const	&)
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4Replaceable@icu_56@@QAEAAV01@ABV01@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 109Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::Replaceable::`scalar deleting destructor'(unsigned int)
		public ??_GReplaceable@icu_56@@UAEPAXI@Z
??_GReplaceable@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1Replaceable@icu_56@@UAE@XZ ;	icu_56::Replaceable::~Replaceable(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_10DB
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_10DB:				; CODE XREF: icu_56::Replaceable::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GReplaceable@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 10F4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::Replaceable::`vector deleting destructor'(unsigned int)
		public ??_EReplaceable@icu_56@@UAEPAXI@Z
??_EReplaceable@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::Replaceable::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_1155
		push	offset ??1Replaceable@icu_56@@UAE@XZ ; icu_56::Replaceable::~Replaceable(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	4
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_114D
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_114D:				; CODE XREF: icu_56::Replaceable::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_1174
; ---------------------------------------------------------------------------

loc_1155:				; CODE XREF: icu_56::Replaceable::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1Replaceable@icu_56@@UAE@XZ ;	icu_56::Replaceable::~Replaceable(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_1171
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_1171:				; CODE XREF: icu_56::Replaceable::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_1174:				; CODE XREF: icu_56::Replaceable::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EReplaceable@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 118Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::Replaceable::Replaceable(icu_56::Replaceable *__hidden this)
		public ??0Replaceable@icu_56@@IAE@XZ
??0Replaceable@icu_56@@IAE@XZ proc near	; CODE XREF: icu_56::UnicodeString::UnicodeString(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7Replaceable@icu_56@@6B@ ; const icu_56::Replaceable::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0Replaceable@icu_56@@IAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 11D8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::Replaceable::length(icu_56::Replaceable *__hidden this)
		public ?length@Replaceable@icu_56@@QBEHXZ
?length@Replaceable@icu_56@@QBEHXZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+1Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?length@Replaceable@icu_56@@QBEHXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1228h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; wchar_t __thiscall icu_56::Replaceable::charAt(icu_56::Replaceable *this, int)
		public ?charAt@Replaceable@icu_56@@QBE_WH@Z
?charAt@Replaceable@icu_56@@QBE_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+20h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?charAt@Replaceable@icu_56@@QBE_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 127Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::Replaceable::char32At(icu_56::Replaceable *this, int)
		public ?char32At@Replaceable@icu_56@@QBEHH@Z
?char32At@Replaceable@icu_56@@QBEHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+24h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?char32At@Replaceable@icu_56@@QBEHH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 12D0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::StringPiece::StringPiece(icu_56::StringPiece *__hidden this)
		public ??0StringPiece@icu_56@@QAE@XZ
??0StringPiece@icu_56@@QAE@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0StringPiece@icu_56@@QAE@XZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1310h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::StringPiece::StringPiece(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &)
		public ??0StringPiece@icu_56@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
??0StringPiece@icu_56@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0]
		call	?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::data(void)
		mov	ecx, [ebp+var_8]
		mov	[ecx], eax
		mov	ecx, [ebp+arg_0]
		call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
		mov	ecx, [ebp+var_8]
		mov	[ecx+4], eax
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0StringPiece@icu_56@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1368h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::StringPiece::StringPiece(icu_56::StringPiece *this,	const char *, int)
		public ??0StringPiece@icu_56@@QAE@PBDH@Z
??0StringPiece@icu_56@@QAE@PBDH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		mov	[eax+4], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	8
??0StringPiece@icu_56@@QAE@PBDH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 13A8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	char *__thiscall icu_56::StringPiece::data(icu_56::StringPiece *__hidden this)
		public ?data@StringPiece@icu_56@@QBEPBDXZ
?data@StringPiece@icu_56@@QBEPBDXZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?data@StringPiece@icu_56@@QBEPBDXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 13D8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::StringPiece::size(icu_56::StringPiece *__hidden this)
		public ?size@StringPiece@icu_56@@QBEHXZ
?size@StringPiece@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?size@StringPiece@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1408h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::StringPiece::length(icu_56::StringPiece *__hidden this)
		public ?length@StringPiece@icu_56@@QBEHXZ
?length@StringPiece@icu_56@@QBEHXZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?length@StringPiece@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1438h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::StringPiece::empty(icu_56::StringPiece *__hidden this)
		public ?empty@StringPiece@icu_56@@QBECXZ
?empty@StringPiece@icu_56@@QBECXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4], 0
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?empty@StringPiece@icu_56@@QBECXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 146Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::StringPiece::clear(icu_56::StringPiece *__hidden this)
		public ?clear@StringPiece@icu_56@@QAEXXZ
?clear@StringPiece@icu_56@@QAEXXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?clear@StringPiece@icu_56@@QAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 14ACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::StringPiece::set(icu_56::StringPiece *this, const char *, int)
		public ?set@StringPiece@icu_56@@QAEXPBDH@Z
?set@StringPiece@icu_56@@QAEXPBDH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		mov	[eax+4], ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	8
?set@StringPiece@icu_56@@QAEXPBDH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 14ECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::StringPiece::remove_prefix(icu_56::StringPiece *this,	int)
		public ?remove_prefix@StringPiece@icu_56@@QAEXH@Z
?remove_prefix@StringPiece@icu_56@@QAEXH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jl	short loc_1545
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		cmp	ecx, [eax+4]
		jle	short loc_1529
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	[ebp+arg_0], ecx

loc_1529:				; CODE XREF: icu_56::StringPiece::remove_prefix(int)+32j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		add	ecx, [ebp+arg_0]
		mov	edx, [ebp+var_8]
		mov	[edx], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		sub	ecx, [ebp+arg_0]
		mov	edx, [ebp+var_8]
		mov	[edx+4], ecx

loc_1545:				; CODE XREF: icu_56::StringPiece::remove_prefix(int)+27j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?remove_prefix@StringPiece@icu_56@@QAEXH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1550h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::StringPiece::remove_suffix(icu_56::StringPiece *this,	int)
		public ?remove_suffix@StringPiece@icu_56@@QAEXH@Z
?remove_suffix@StringPiece@icu_56@@QAEXH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jl	short loc_159F
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		cmp	ecx, [eax+4]
		jg	short loc_1595
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		sub	ecx, [ebp+arg_0]
		mov	edx, [ebp+var_8]
		mov	[edx+4], ecx
		jmp	short loc_159F
; ---------------------------------------------------------------------------

loc_1595:				; CODE XREF: icu_56::StringPiece::remove_suffix(int)+32j
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0

loc_159F:				; CODE XREF: icu_56::StringPiece::remove_suffix(int)+27j
					; icu_56::StringPiece::remove_suffix(int)+43j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?remove_suffix@StringPiece@icu_56@@QAEXH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 15A8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::StringPiece __thiscall icu_56::StringPiece::substr(int,	int)const
		public ?substr@StringPiece@icu_56@@QBE?AV12@HH@Z
?substr@StringPiece@icu_56@@QBE?AV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+var_8]
		push	edx		; struct icu_56::StringPiece *
		mov	ecx, [ebp+arg_0] ; this
		call	??0StringPiece@icu_56@@QAE@ABV01@HH@Z ;	icu_56::StringPiece::StringPiece(icu_56::StringPiece const &,int,int)
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?substr@StringPiece@icu_56@@QBE?AV12@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 15F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::StringPiece & __thiscall icu_56::StringPiece::operator=(class icu_56::StringPiece const	&)
		public ??4StringPiece@icu_56@@QAEAAV01@ABV01@@Z
??4StringPiece@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [eax+4]
		mov	eax, [ebp+var_8]
		mov	[eax], ecx
		mov	[eax+4], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4StringPiece@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1638h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::ByteSink::ByteSink(icu_56::ByteSink	*__hidden this)
		public ??0ByteSink@icu_56@@QAE@XZ
??0ByteSink@icu_56@@QAE@XZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7ByteSink@icu_56@@6B@ ; const icu_56::ByteSink::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0ByteSink@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1670h
		dd offset ??_R4ByteSink@icu_56@@6B@ ; const icu_56::ByteSink::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7ByteSink@icu_56@@6B@
; const	icu_56::ByteSink::`vftable'
??_7ByteSink@icu_56@@6B@ dd offset ??_EByteSink@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::ByteSink::ByteSink(void)+26o
					; icu_56::ByteSink::`vector deleting destructor'(uint)
		dd offset __purecall
		dd offset ?GetAppendBuffer@ByteSink@icu_56@@UAEPADHHPADHPAH@Z ;	icu_56::ByteSink::GetAppendBuffer(int,int,char *,int,int *)
		dd offset ?Flush@ByteSink@icu_56@@UAEXXZ ; icu_56::ByteSink::Flush(void)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1684h
		public ??_R4ByteSink@icu_56@@6B@
; const	icu_56::ByteSink::`RTTI	Complete Object	Locator'
??_R4ByteSink@icu_56@@6B@ dd 3 dup(0)	; DATA XREF: .rdata:00001670o
		dd offset ??_R0?AVByteSink@icu_56@@@8 ;	icu_56::ByteSink `RTTI Type Descriptor'
		dd offset ??_R3ByteSink@icu_56@@8 ; icu_56::ByteSink::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 1698h
		public ??_R0?AVByteSink@icu_56@@@8
; class	icu_56::ByteSink `RTTI Type Descriptor'
??_R0?AVByteSink@icu_56@@@8 dd offset ??_7type_info@@6B@ ; DATA	XREF: .rdata$r:00001690o
					; .rdata$r:icu_56::ByteSink::`RTTI Base	Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 10h
a_?avbytesink@i	db '.?AVByteSink@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 16B8h
		public ??_R3ByteSink@icu_56@@8
; icu_56::ByteSink::`RTTI Class	Hierarchy Descriptor'
??_R3ByteSink@icu_56@@8	dd 2 dup(0)	; DATA XREF: .rdata$r:00001694o
					; .rdata$r:000016ECo
		dd 2
		dd offset ??_R2ByteSink@icu_56@@8 ; icu_56::ByteSink::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 16C8h
		public ??_R2ByteSink@icu_56@@8
; icu_56::ByteSink::`RTTI Base Class Array'
??_R2ByteSink@icu_56@@8	dd offset ??_R1A@?0A@EA@ByteSink@icu_56@@8
					; DATA XREF: .rdata$r:000016C4o
					; icu_56::ByteSink::`RTTI Base Class Descriptor	at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 16D4h
		public ??_R1A@?0A@EA@ByteSink@icu_56@@8
; icu_56::ByteSink::`RTTI Base Class Descriptor	at (0, -1, 0, 64)'
??_R1A@?0A@EA@ByteSink@icu_56@@8 dd offset ??_R0?AVByteSink@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::ByteSink::`RTTI Base Class Array'o
					; icu_56::ByteSink `RTTI Type Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3ByteSink@icu_56@@8 ; icu_56::ByteSink::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 16F0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::ByteSink::`scalar deleting destructor'(unsigned int)
		public ??_GByteSink@icu_56@@UAEPAXI@Z
??_GByteSink@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1ByteSink@icu_56@@UAE@XZ ; icu_56::ByteSink::~ByteSink(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_172F
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_172F:				; CODE XREF: icu_56::ByteSink::`scalar deleting	destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GByteSink@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1748h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::ByteSink::`vector deleting destructor'(unsigned int)
		public ??_EByteSink@icu_56@@UAEPAXI@Z
??_EByteSink@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::ByteSink::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_17A9
		push	offset ??1ByteSink@icu_56@@UAE@XZ ; icu_56::ByteSink::~ByteSink(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	4
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_17A1
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_17A1:				; CODE XREF: icu_56::ByteSink::`vector deleting	destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_17C8
; ---------------------------------------------------------------------------

loc_17A9:				; CODE XREF: icu_56::ByteSink::`vector deleting	destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1ByteSink@icu_56@@UAE@XZ ; icu_56::ByteSink::~ByteSink(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_17C5
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_17C5:				; CODE XREF: icu_56::ByteSink::`vector deleting	destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_17C8:				; CODE XREF: icu_56::ByteSink::`vector deleting	destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EByteSink@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 17E0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::CheckedArrayByteSink::NumberOfBytesWritten(icu_56::CheckedArrayByteSink *__hidden this)
		public ?NumberOfBytesWritten@CheckedArrayByteSink@icu_56@@QBEHXZ
?NumberOfBytesWritten@CheckedArrayByteSink@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+0Ch]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?NumberOfBytesWritten@CheckedArrayByteSink@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1810h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::CheckedArrayByteSink::Overflowed(icu_56::CheckedArrayByteSink *__hidden this)
		public ?Overflowed@CheckedArrayByteSink@icu_56@@QBECXZ
?Overflowed@CheckedArrayByteSink@icu_56@@QBECXZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	al, [eax+14h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?Overflowed@CheckedArrayByteSink@icu_56@@QBECXZ	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1840h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::CheckedArrayByteSink::NumberOfBytesAppended(icu_56::CheckedArrayByteSink *__hidden this)
		public ?NumberOfBytesAppended@CheckedArrayByteSink@icu_56@@QBEHXZ
?NumberOfBytesAppended@CheckedArrayByteSink@icu_56@@QBEHXZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+10h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?NumberOfBytesAppended@CheckedArrayByteSink@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1870h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator=(struct	icu_56::UnicodeString *)
		public ??4UnicodeString@icu_56@@QAEAAV01@$$QAV01@@Z
??4UnicodeString@icu_56@@QAEAAV01@$$QAV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?moveFrom@UnicodeString@icu_56@@QAEAAV12@AAV12@@Z ; icu_56::UnicodeString::moveFrom(icu_56::UnicodeString &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4UnicodeString@icu_56@@QAEAAV01@$$QAV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 18B8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl icu_56::swap(icu_56 *this, struct icu_56::UnicodeString *, struct icu_56::UnicodeString *)
		public ?swap@icu_56@@YAXAAVUnicodeString@1@0@Z
?swap@icu_56@@YAXAAVUnicodeString@1@0@Z	proc near

var_C0		= byte ptr -0C0h
this		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+this]	; this
		call	?swap@UnicodeString@icu_56@@QAEXAAV12@@Z ; icu_56::UnicodeString::swap(icu_56::UnicodeString &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?swap@icu_56@@YAXAAVUnicodeString@1@0@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 18F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UnicodeString::`scalar deleting destructor'(unsigned int)
		public ??_GUnicodeString@icu_56@@UAEPAXI@Z
??_GUnicodeString@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_1937
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_1937:				; CODE XREF: icu_56::UnicodeString::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GUnicodeString@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1950h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UnicodeString::`vector deleting destructor'(unsigned int)
		public ??_EUnicodeString@icu_56@@UAEPAXI@Z
??_EUnicodeString@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::UnicodeString::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_19B1
		push	offset ??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	40h ; '@'
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_19A9
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_19A9:				; CODE XREF: icu_56::UnicodeString::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_19D0
; ---------------------------------------------------------------------------

loc_19B1:				; CODE XREF: icu_56::UnicodeString::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_19CD
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_19CD:				; CODE XREF: icu_56::UnicodeString::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_19D0:				; CODE XREF: icu_56::UnicodeString::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EUnicodeString@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 19E8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::pinIndex(icu_56::UnicodeString	*this, int *)
		public ?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z
?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z proc near
					; CODE XREF: icu_56::UnicodeString::indexOf(icu_56::UnicodeString const	&,int)+2Ap
					; icu_56::UnicodeString::indexOf(wchar_t const *,int,int)+2Ap ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax], 0
		jge	short loc_1A1E
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 0
		jmp	short loc_1A3A
; ---------------------------------------------------------------------------

loc_1A1E:				; CODE XREF: icu_56::UnicodeString::pinIndex(int &)+29j
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	ecx, [ebp+arg_0]
		cmp	[ecx], eax
		jle	short loc_1A3A
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	ecx, [ebp+arg_0]
		mov	[ecx], eax

loc_1A3A:				; CODE XREF: icu_56::UnicodeString::pinIndex(int &)+34j
					; icu_56::UnicodeString::pinIndex(int &)+43j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1A50h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::pinIndices(icu_56::UnicodeString *this, int *,	int *)
		public ?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z
?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z proc near
					; CODE XREF: icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+51p
					; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)+51p ...

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax], 0
		jge	short loc_1A91
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 0
		jmp	short loc_1AA3
; ---------------------------------------------------------------------------

loc_1A91:				; CODE XREF: icu_56::UnicodeString::pinIndices(int &,int &)+34j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		cmp	ecx, [ebp+var_14]
		jle	short loc_1AA3
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		mov	[eax], ecx

loc_1AA3:				; CODE XREF: icu_56::UnicodeString::pinIndices(int &,int &)+3Fj
					; icu_56::UnicodeString::pinIndices(int	&,int &)+49j
		mov	eax, [ebp+arg_4]
		cmp	dword ptr [eax], 0
		jge	short loc_1AB6
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0
		jmp	short loc_1AD2
; ---------------------------------------------------------------------------

loc_1AB6:				; CODE XREF: icu_56::UnicodeString::pinIndices(int &,int &)+59j
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		sub	ecx, [eax]
		mov	edx, [ebp+arg_4]
		cmp	[edx], ecx
		jle	short loc_1AD2
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		sub	ecx, [eax]
		mov	edx, [ebp+arg_4]
		mov	[edx], ecx

loc_1AD2:				; CODE XREF: icu_56::UnicodeString::pinIndices(int &,int &)+64j
					; icu_56::UnicodeString::pinIndices(int	&,int &)+73j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1AE8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; wchar_t *__thiscall icu_56::UnicodeString::getArrayStart(icu_56::UnicodeString *__hidden this)
		public ?getArrayStart@UnicodeString@icu_56@@AAEPA_WXZ
?getArrayStart@UnicodeString@icu_56@@AAEPA_WXZ proc near

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 2
		jz	short loc_1B25
		mov	edx, [ebp+var_8]
		add	edx, 6
		mov	[ebp+var_D0], edx
		jmp	short loc_1B31
; ---------------------------------------------------------------------------

loc_1B25:				; CODE XREF: icu_56::UnicodeString::getArrayStart(void)+2Dj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	[ebp+var_D0], ecx

loc_1B31:				; CODE XREF: icu_56::UnicodeString::getArrayStart(void)+3Bj
		mov	eax, [ebp+var_D0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getArrayStart@UnicodeString@icu_56@@AAEPA_WXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1B40h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	wchar_t	*__thiscall icu_56::UnicodeString::getArrayStart(icu_56::UnicodeString *__hidden this)
		public ?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ
?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ proc near
					; CODE XREF: icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+61p
					; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)+61p ...

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 2
		jz	short loc_1B7D
		mov	edx, [ebp+var_8]
		add	edx, 6
		mov	[ebp+var_D0], edx
		jmp	short loc_1B89
; ---------------------------------------------------------------------------

loc_1B7D:				; CODE XREF: icu_56::UnicodeString::getArrayStart(void)+2Dj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	[ebp+var_D0], ecx

loc_1B89:				; CODE XREF: icu_56::UnicodeString::getArrayStart(void)+3Bj
		mov	eax, [ebp+var_D0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1B98h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString *__hidden this)
		public ??0UnicodeString@icu_56@@QAE@XZ
??0UnicodeString@icu_56@@QAE@XZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??0Replaceable@icu_56@@IAE@XZ ;	icu_56::Replaceable::Replaceable(void)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UnicodeString@icu_56@@6B@ ;	const icu_56::UnicodeString::`vftable'
		mov	eax, 2
		mov	ecx, [ebp+var_8]
		mov	[ecx+4], ax
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0UnicodeString@icu_56@@QAE@XZ	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1BF0h
		dd offset ??_R4UnicodeString@icu_56@@6B@ ; const icu_56::UnicodeString::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7UnicodeString@icu_56@@6B@
; const	icu_56::UnicodeString::`vftable'
??_7UnicodeString@icu_56@@6B@ dd offset	??_EUnicodeString@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::UnicodeString::UnicodeString(void)+2Eo
					; icu_56::UnicodeString::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@UnicodeString@icu_56@@UBEPAXXZ ; icu_56::UnicodeString::getDynamicClassID(void)
		dd offset ?extractBetween@UnicodeString@icu_56@@UBEXHHAAV12@@Z ; icu_56::UnicodeString::extractBetween(int,int,icu_56::UnicodeString &)
		dd offset ?handleReplaceBetween@UnicodeString@icu_56@@UAEXHHABV12@@Z ; icu_56::UnicodeString::handleReplaceBetween(int,int,icu_56::UnicodeString const &)
		dd offset ?copy@UnicodeString@icu_56@@UAEXHHH@Z	; icu_56::UnicodeString::copy(int,int,int)
		dd offset ?hasMetaData@UnicodeString@icu_56@@UBECXZ ; icu_56::UnicodeString::hasMetaData(void)
		dd offset ?clone@UnicodeString@icu_56@@UBEPAVReplaceable@2@XZ ;	icu_56::UnicodeString::clone(void)
		dd offset ?getLength@UnicodeString@icu_56@@MBEHXZ ; icu_56::UnicodeString::getLength(void)
		dd offset ?getCharAt@UnicodeString@icu_56@@MBE_WH@Z ; icu_56::UnicodeString::getCharAt(int)
		dd offset ?getChar32At@UnicodeString@icu_56@@MBEHH@Z ; icu_56::UnicodeString::getChar32At(int)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1C1Ch
		public ??_R4UnicodeString@icu_56@@6B@
; const	icu_56::UnicodeString::`RTTI Complete Object Locator'
??_R4UnicodeString@icu_56@@6B@ dd 3 dup(0) ; DATA XREF:	.rdata:00001BF0o
		dd offset ??_R0?AVUnicodeString@icu_56@@@8 ; icu_56::UnicodeString `RTTI Type Descriptor'
		dd offset ??_R3UnicodeString@icu_56@@8 ; icu_56::UnicodeString::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 1C30h
		public ??_R0?AVUnicodeString@icu_56@@@8
; class	icu_56::UnicodeString `RTTI Type Descriptor'
??_R0?AVUnicodeString@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:00001C28o
					; .rdata$r:icu_56::UnicodeString::`RTTI	Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 8
a_?avunicodestr	db '.?AVUnicodeString@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1C54h
		public ??_R3UnicodeString@icu_56@@8
; icu_56::UnicodeString::`RTTI Class Hierarchy Descriptor'
??_R3UnicodeString@icu_56@@8 dd	2 dup(0) ; DATA	XREF: .rdata$r:00001C2Co
					; .rdata$r:00001C90o
		dd 4
		dd offset ??_R2UnicodeString@icu_56@@8 ; icu_56::UnicodeString::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1C64h
		public ??_R2UnicodeString@icu_56@@8
; icu_56::UnicodeString::`RTTI Base Class Array'
??_R2UnicodeString@icu_56@@8 dd	offset ??_R1A@?0A@EA@UnicodeString@icu_56@@8
					; DATA XREF: .rdata$r:00001C60o
					; icu_56::UnicodeString::`RTTI Base Class Descriptor at	(0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@Replaceable@icu_56@@8 ;	icu_56::Replaceable::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1C78h
		public ??_R1A@?0A@EA@UnicodeString@icu_56@@8
; icu_56::UnicodeString::`RTTI Base Class Descriptor at	(0, -1,	0, 64)'
??_R1A@?0A@EA@UnicodeString@icu_56@@8 dd offset	??_R0?AVUnicodeString@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UnicodeString::`RTTI Base	Class Array'o
					; icu_56::UnicodeString	`RTTI Type Descriptor'
		dd 3, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UnicodeString@icu_56@@8 ; icu_56::UnicodeString::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1C94h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::hasShortLength(icu_56::UnicodeString *__hidden this)
		public ?hasShortLength@UnicodeString@icu_56@@ABECXZ
?hasShortLength@UnicodeString@icu_56@@ABECXZ proc near
					; CODE XREF: icu_56::UnicodeString::length(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		test	ecx, ecx
		setnl	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?hasShortLength@UnicodeString@icu_56@@ABECXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1CCCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::getShortLength(icu_56::UnicodeString *__hidden this)
		public ?getShortLength@UnicodeString@icu_56@@ABEHXZ
?getShortLength@UnicodeString@icu_56@@ABEHXZ proc near
					; CODE XREF: icu_56::UnicodeString::length(void)+35p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	eax, word ptr [eax+4]
		sar	eax, 5
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getShortLength@UnicodeString@icu_56@@ABEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1D00h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::length(icu_56::UnicodeString *__hidden this)
		public ?length@UnicodeString@icu_56@@QBEHXZ
?length@UnicodeString@icu_56@@QBEHXZ proc near
					; CODE XREF: icu_56::UnicodeString::pinIndex(int &)+39p
					; icu_56::UnicodeString::pinIndex(int &)+48p ...

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?hasShortLength@UnicodeString@icu_56@@ABECXZ ; icu_56::UnicodeString::hasShortLength(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_1D42
		mov	ecx, [ebp+var_8] ; this
		call	?getShortLength@UnicodeString@icu_56@@ABEHXZ ; icu_56::UnicodeString::getShortLength(void)
		mov	[ebp+var_D0], eax
		jmp	short loc_1D4E
; ---------------------------------------------------------------------------

loc_1D42:				; CODE XREF: icu_56::UnicodeString::length(void)+30j
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+8]
		mov	[ebp+var_D0], edx

loc_1D4E:				; CODE XREF: icu_56::UnicodeString::length(void)+40j
		mov	eax, [ebp+var_D0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?length@UnicodeString@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1D68h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::getCapacity(icu_56::UnicodeString *__hidden this)
		public ?getCapacity@UnicodeString@icu_56@@QBEHXZ
?getCapacity@UnicodeString@icu_56@@QBEHXZ proc near

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 2
		jz	short loc_1DA3
		mov	[ebp+var_D0], 1Dh
		jmp	short loc_1DAF
; ---------------------------------------------------------------------------

loc_1DA3:				; CODE XREF: icu_56::UnicodeString::getCapacity(void)+2Dj
		mov	edx, [ebp+var_8]
		mov	eax, [edx+0Ch]
		mov	[ebp+var_D0], eax

loc_1DAF:				; CODE XREF: icu_56::UnicodeString::getCapacity(void)+39j
		mov	eax, [ebp+var_D0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getCapacity@UnicodeString@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1DBCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::hashCode(icu_56::UnicodeString *__hidden this)
		public ?hashCode@UnicodeString@icu_56@@QBEHXZ
?hashCode@UnicodeString@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?doHashCode@UnicodeString@icu_56@@ABEHXZ ; icu_56::UnicodeString::doHashCode(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?hashCode@UnicodeString@icu_56@@QBEHXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1DFCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::isBogus(icu_56::UnicodeString	*__hidden this)
		public ?isBogus@UnicodeString@icu_56@@QBECXZ
?isBogus@UnicodeString@icu_56@@QBECXZ proc near
					; CODE XREF: icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+26p
					; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+35p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	eax, word ptr [eax+4]
		and	eax, 1
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isBogus@UnicodeString@icu_56@@QBECXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1E30h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::isWritable(icu_56::UnicodeString *__hidden this)
		public ?isWritable@UnicodeString@icu_56@@ABECXZ
?isWritable@UnicodeString@icu_56@@ABECXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 11h
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isWritable@UnicodeString@icu_56@@ABECXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1E68h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::isBufferWritable(icu_56::UnicodeString *__hidden this)
		public ?isBufferWritable@UnicodeString@icu_56@@ABECXZ
?isBufferWritable@UnicodeString@icu_56@@ABECXZ proc near

var_D0		= byte ptr -0D0h
var_CD		= byte ptr -0CDh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 19h
		jnz	short loc_1EB9
		mov	edx, [ebp+var_8]
		movsx	eax, word ptr [edx+4]
		and	eax, 4
		jz	short loc_1EB0
		mov	ecx, [ebp+var_8] ; this
		call	?refCount@UnicodeString@icu_56@@ABEHXZ ; icu_56::UnicodeString::refCount(void)
		cmp	eax, 1
		jnz	short loc_1EB9

loc_1EB0:				; CODE XREF: icu_56::UnicodeString::isBufferWritable(void)+39j
		mov	[ebp+var_CD], 1
		jmp	short loc_1EC0
; ---------------------------------------------------------------------------

loc_1EB9:				; CODE XREF: icu_56::UnicodeString::isBufferWritable(void)+2Dj
					; icu_56::UnicodeString::isBufferWritable(void)+46j
		mov	[ebp+var_CD], 0

loc_1EC0:				; CODE XREF: icu_56::UnicodeString::isBufferWritable(void)+4Fj
		mov	al, [ebp+var_CD]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?isBufferWritable@UnicodeString@icu_56@@ABECXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1EDCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	wchar_t	*__thiscall icu_56::UnicodeString::getBuffer(icu_56::UnicodeString *__hidden this)
		public ?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ
?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 11h
		jz	short loc_1F11
		xor	eax, eax
		jmp	short loc_1F2D
; ---------------------------------------------------------------------------
		jmp	short loc_1F2D
; ---------------------------------------------------------------------------

loc_1F11:				; CODE XREF: icu_56::UnicodeString::getBuffer(void)+2Dj
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 2
		jz	short loc_1F27
		mov	eax, [ebp+var_8]
		add	eax, 6
		jmp	short loc_1F2D
; ---------------------------------------------------------------------------
		jmp	short loc_1F2D
; ---------------------------------------------------------------------------

loc_1F27:				; CODE XREF: icu_56::UnicodeString::getBuffer(void)+3Fj
		mov	eax, [ebp+var_8]
		mov	eax, [eax+10h]

loc_1F2D:				; CODE XREF: icu_56::UnicodeString::getBuffer(void)+31j
					; icu_56::UnicodeString::getBuffer(void)+33j ...
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1F34h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::doCompare(icu_56::UnicodeString *this, int, int, const struct	icu_56::UnicodeString *, int, int)
		public ?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z
?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z proc near
					; CODE XREF: icu_56::UnicodeString::operator>(icu_56::UnicodeString const &)+40p
					; icu_56::UnicodeString::operator<(icu_56::UnicodeString const &)+40p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_1F7A
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		setz	al
		jmp	short loc_1FAB
; ---------------------------------------------------------------------------
		jmp	short loc_1FAB
; ---------------------------------------------------------------------------

loc_1F7A:				; CODE XREF: icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+30j
		lea	eax, [ebp+arg_10]
		push	eax		; int *
		lea	ecx, [ebp+arg_C]
		push	ecx		; int *
		mov	ecx, [ebp+arg_8] ; this
		call	?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z ; icu_56::UnicodeString::pinIndices(int &,int &)
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	ecx, [ebp+arg_8] ; this
		call	?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ ; icu_56::UnicodeString::getArrayStart(void)
		push	eax		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)

loc_1FAB:				; CODE XREF: icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+42j
					; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+44j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1FC4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator==(icu_56::UnicodeString	*)
		public ??8UnicodeString@icu_56@@QBECABV01@@Z
??8UnicodeString@icu_56@@QBECABV01@@Z proc near
					; CODE XREF: icu_56::UnicodeString::operator!=(icu_56::UnicodeString const &)+2Ap

var_E8		= byte ptr -0E8h
var_E5		= byte ptr -0E5h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E8]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_2002
		mov	ecx, [ebp+arg_0] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		jmp	short loc_205C
; ---------------------------------------------------------------------------

loc_2000:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::fixedo
		jmp	short loc_205C
; ---------------------------------------------------------------------------

loc_2002:				; CODE XREF: icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)+30j
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	[ebp+var_14], eax
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	[ebp+var_20], eax
		mov	ecx, [ebp+arg_0] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_204F
		mov	ecx, [ebp+var_14]
		cmp	ecx, [ebp+var_20]
		jnz	short loc_204F
		mov	edx, [ebp+var_14]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?doEquals@UnicodeString@icu_56@@ABECABV12@H@Z ;	icu_56::UnicodeString::doEquals(icu_56::UnicodeString const &,int)
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_204F
		mov	[ebp+var_E5], 1
		jmp	short loc_2056
; ---------------------------------------------------------------------------

loc_204F:				; CODE XREF: icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)+61j
					; icu_56::UnicodeString::operator==(icu_56::UnicodeString const	&)+69j	...
		mov	[ebp+var_E5], 0

loc_2056:				; CODE XREF: icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)+89j
		mov	al, [ebp+var_E5]

loc_205C:				; CODE XREF: icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)+3Aj
					; icu_56::UnicodeString::operator==(icu_56::UnicodeString const	&):loc_2000j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??8UnicodeString@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2074h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator!=(icu_56::UnicodeString	*)
		public ??9UnicodeString@icu_56@@QBECABV01@@Z
??9UnicodeString@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; icu_56::UnicodeString	*
		mov	ecx, [ebp+var_8]
		call	??8UnicodeString@icu_56@@QBECABV01@@Z ;	icu_56::UnicodeString::operator==(icu_56::UnicodeString	const &)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9UnicodeString@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 20C4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator>(icu_56::UnicodeString *)
		public ??OUnicodeString@icu_56@@QBECABV01@@Z
??OUnicodeString@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		cmp	ecx, 1
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??OUnicodeString@icu_56@@QBECABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2128h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator<(icu_56::UnicodeString *)
		public ??MUnicodeString@icu_56@@QBECABV01@@Z
??MUnicodeString@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		cmp	ecx, 0FFFFFFFFh
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??MUnicodeString@icu_56@@QBECABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 218Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator>=(icu_56::UnicodeString	*)
		public ??PUnicodeString@icu_56@@QBECABV01@@Z
??PUnicodeString@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		cmp	ecx, 0FFFFFFFFh
		setnz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??PUnicodeString@icu_56@@QBECABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 21F0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator<=(icu_56::UnicodeString	*)
		public ??NUnicodeString@icu_56@@QBECABV01@@Z
??NUnicodeString@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		cmp	ecx, 1
		setnz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??NUnicodeString@icu_56@@QBECABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2254h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compare(icu_56::UnicodeString	*this, const struct icu_56::UnicodeString *)
		public ?compare@UnicodeString@icu_56@@QBECABV12@@Z
?compare@UnicodeString@icu_56@@QBECABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?compare@UnicodeString@icu_56@@QBECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 22B0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compare(icu_56::UnicodeString	*this, int, int, const struct icu_56::UnicodeString *)
		public ?compare@UnicodeString@icu_56@@QBECHHABV12@@Z
?compare@UnicodeString@icu_56@@QBECHHABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?compare@UnicodeString@icu_56@@QBECHHABV12@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2308h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compare(icu_56::UnicodeString	*this, const wchar_t *,	int)
		public ?compare@UnicodeString@icu_56@@QBECPB_WH@Z
?compare@UnicodeString@icu_56@@QBECPB_WH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?compare@UnicodeString@icu_56@@QBECPB_WH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2360h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compare(icu_56::UnicodeString	*this, int, int, const struct icu_56::UnicodeString *, int, int)
		public ?compare@UnicodeString@icu_56@@QBECHHABV12@HH@Z
?compare@UnicodeString@icu_56@@QBECHHABV12@HH@Z	proc near
					; CODE XREF: icu_56::UnicodeString::startsWith(icu_56::UnicodeString const &)+40p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?compare@UnicodeString@icu_56@@QBECHHABV12@HH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 23B8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compare(icu_56::UnicodeString	*this, int, int, const wchar_t *)
		public ?compare@UnicodeString@icu_56@@QBECHHPB_W@Z
?compare@UnicodeString@icu_56@@QBECHHPB_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?compare@UnicodeString@icu_56@@QBECHHPB_W@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 240Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compare(icu_56::UnicodeString	*this, int, int, const wchar_t *, int, int)
		public ?compare@UnicodeString@icu_56@@QBECHHPB_WHH@Z
?compare@UnicodeString@icu_56@@QBECHHPB_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?compare@UnicodeString@icu_56@@QBECHHPB_WHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2464h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareBetween(icu_56::UnicodeString *this, int, int,	const struct icu_56::UnicodeString *, int, int)
		public ?compareBetween@UnicodeString@icu_56@@QBECHHABV12@HH@Z
?compareBetween@UnicodeString@icu_56@@QBECHHABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		sub	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_4]
		sub	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?compareBetween@UnicodeString@icu_56@@QBECHHABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 24C0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::doCompareCodePointOrder(icu_56::UnicodeString	*this, int, int, const struct icu_56::UnicodeString *, int, int)
		public ?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z
?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z	proc near
					; CODE XREF: icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString	const &)+40p
					; icu_56::UnicodeString::compareCodePointOrder(int,int,icu_56::UnicodeString const &)+3Dp ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_2506
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		setz	al
		jmp	short loc_2537
; ---------------------------------------------------------------------------
		jmp	short loc_2537
; ---------------------------------------------------------------------------

loc_2506:				; CODE XREF: icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const	&,int,int)+30j
		lea	eax, [ebp+arg_10]
		push	eax		; int *
		lea	ecx, [ebp+arg_C]
		push	ecx		; int *
		mov	ecx, [ebp+arg_8] ; this
		call	?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z ; icu_56::UnicodeString::pinIndices(int &,int &)
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	ecx, [ebp+arg_8] ; this
		call	?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ ; icu_56::UnicodeString::getArrayStart(void)
		push	eax		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHPB_WHH@Z ;	icu_56::UnicodeString::doCompareCodePointOrder(int,int,wchar_t const *,int,int)

loc_2537:				; CODE XREF: icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const	&,int,int)+42j
					; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)+44j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2550h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*)
		public ?compareCodePointOrder@UnicodeString@icu_56@@QBECABV12@@Z
?compareCodePointOrder@UnicodeString@icu_56@@QBECABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z	; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?compareCodePointOrder@UnicodeString@icu_56@@QBECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 25ACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString *this, int, int, const struct icu_56::UnicodeString *)
		public ?compareCodePointOrder@UnicodeString@icu_56@@QBECHHABV12@@Z
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z	; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHABV12@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2604h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString *this, const wchar_t *, int)
		public ?compareCodePointOrder@UnicodeString@icu_56@@QBECPB_WH@Z
?compareCodePointOrder@UnicodeString@icu_56@@QBECPB_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHPB_WHH@Z ;	icu_56::UnicodeString::doCompareCodePointOrder(int,int,wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?compareCodePointOrder@UnicodeString@icu_56@@QBECPB_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 265Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString *this, int, int, const struct icu_56::UnicodeString *, int, int)
		public ?compareCodePointOrder@UnicodeString@icu_56@@QBECHHABV12@HH@Z
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z	; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 26B4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString *this, int, int, const wchar_t *)
		public ?compareCodePointOrder@UnicodeString@icu_56@@QBECHHPB_W@Z
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHPB_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHPB_WHH@Z ;	icu_56::UnicodeString::doCompareCodePointOrder(int,int,wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHPB_W@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2708h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString *this, int, int, const wchar_t *,	int, int)
		public ?compareCodePointOrder@UnicodeString@icu_56@@QBECHHPB_WHH@Z
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHPB_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHPB_WHH@Z ;	icu_56::UnicodeString::doCompareCodePointOrder(int,int,wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHPB_WHH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2760h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrderBetween(icu_56::UnicodeString *this, int, int, const struct icu_56::UnicodeString *, int, int)
		public ?compareCodePointOrderBetween@UnicodeString@icu_56@@QBECHHABV12@HH@Z
?compareCodePointOrderBetween@UnicodeString@icu_56@@QBECHHABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		sub	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_4]
		sub	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z	; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?compareCodePointOrderBetween@UnicodeString@icu_56@@QBECHHABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 27BCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::doCaseCompare(icu_56::UnicodeString *this, int, int, const struct icu_56::UnicodeString *, int, int, unsigned	int)
		public ?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z
?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z proc near
					; CODE XREF: icu_56::UnicodeString::caseCompare(icu_56::UnicodeString const &,uint)+44p
					; icu_56::UnicodeString::caseCompare(int,int,icu_56::UnicodeString const &,uint)+41p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_2802
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		setz	al
		jmp	short loc_2837
; ---------------------------------------------------------------------------
		jmp	short loc_2837
; ---------------------------------------------------------------------------

loc_2802:				; CODE XREF: icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString	const &,int,int,uint)+30j
		lea	eax, [ebp+arg_10]
		push	eax		; int *
		lea	ecx, [ebp+arg_C]
		push	ecx		; int *
		mov	ecx, [ebp+arg_8] ; this
		call	?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z ; icu_56::UnicodeString::pinIndices(int &,int &)
		mov	eax, [ebp+arg_14]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_10]
		push	ecx		; int
		mov	edx, [ebp+arg_C]
		push	edx		; int
		mov	ecx, [ebp+arg_8] ; this
		call	?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ ; icu_56::UnicodeString::getArrayStart(void)
		push	eax		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHPB_WHHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,wchar_t const *,int,int,uint)

loc_2837:				; CODE XREF: icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString	const &,int,int,uint)+42j
					; icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString const &,int,int,uint)+44j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	18h
?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2850h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompare(icu_56::UnicodeString *this, const struct	icu_56::UnicodeString *, unsigned int)
		public ?caseCompare@UnicodeString@icu_56@@QBECABV12@I@Z
?caseCompare@UnicodeString@icu_56@@QBECABV12@I@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString const &,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?caseCompare@UnicodeString@icu_56@@QBECABV12@I@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 28B0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompare(icu_56::UnicodeString *this, int,	int, const struct icu_56::UnicodeString	*, unsigned int)
		public ?caseCompare@UnicodeString@icu_56@@QBECHHABV12@I@Z
?caseCompare@UnicodeString@icu_56@@QBECHHABV12@I@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct icu_56::UnicodeString *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString const &,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?caseCompare@UnicodeString@icu_56@@QBECHHABV12@I@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 290Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompare(icu_56::UnicodeString *this, const wchar_t *, int, unsigned int)
		public ?caseCompare@UnicodeString@icu_56@@QBECPB_WHI@Z
?caseCompare@UnicodeString@icu_56@@QBECPB_WHI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHPB_WHHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,wchar_t const *,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?caseCompare@UnicodeString@icu_56@@QBECPB_WHI@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2968h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompare(icu_56::UnicodeString *this, int,	int, const struct icu_56::UnicodeString	*, int,	int, unsigned int)
		public ?caseCompare@UnicodeString@icu_56@@QBECHHABV12@HHI@Z
?caseCompare@UnicodeString@icu_56@@QBECHHABV12@HHI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_14]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_10]
		push	ecx		; int
		mov	edx, [ebp+arg_C]
		push	edx		; int
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString const &,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	18h
?caseCompare@UnicodeString@icu_56@@QBECHHABV12@HHI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 29C4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompare(icu_56::UnicodeString *this, int,	int, const wchar_t *, unsigned int)
		public ?caseCompare@UnicodeString@icu_56@@QBECHHPB_WI@Z
?caseCompare@UnicodeString@icu_56@@QBECHHPB_WI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		push	0		; int
		mov	edx, [ebp+arg_8]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHPB_WHHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,wchar_t const *,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?caseCompare@UnicodeString@icu_56@@QBECHHPB_WI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2A1Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompare(icu_56::UnicodeString *this, int,	int, const wchar_t *, int, int,	unsigned int)
		public ?caseCompare@UnicodeString@icu_56@@QBECHHPB_WHHI@Z
?caseCompare@UnicodeString@icu_56@@QBECHHPB_WHHI@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_14]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_10]
		push	ecx		; int
		mov	edx, [ebp+arg_C]
		push	edx		; int
		mov	eax, [ebp+arg_8]
		push	eax		; wchar_t *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHPB_WHHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,wchar_t const *,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	18h
?caseCompare@UnicodeString@icu_56@@QBECHHPB_WHHI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2A78h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompareBetween(icu_56::UnicodeString *this, int, int, const struct icu_56::UnicodeString *, int, int, unsigned int)
		public ?caseCompareBetween@UnicodeString@icu_56@@QBECHHABV12@HHI@Z
?caseCompareBetween@UnicodeString@icu_56@@QBECHHABV12@HHI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_14]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_10]
		sub	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_C]
		push	edx		; int
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		sub	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString const &,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	18h
?caseCompareBetween@UnicodeString@icu_56@@QBECHHABV12@HHI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2AD8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*, int,	int, int, int)
		public ?indexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z
?indexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z	proc near
					; CODE XREF: icu_56::UnicodeString::indexOf(icu_56::UnicodeString const	&)+40p
					; icu_56::UnicodeString::indexOf(icu_56::UnicodeString const &,int)+51p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_2B43
		lea	eax, [ebp+arg_8]
		push	eax		; int *
		lea	ecx, [ebp+arg_4]
		push	ecx		; int *
		mov	ecx, [ebp+arg_0] ; this
		call	?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z ; icu_56::UnicodeString::pinIndices(int &,int &)
		cmp	[ebp+arg_8], 0
		jle	short loc_2B43
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ ; icu_56::UnicodeString::getArrayStart(void)
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z ;	icu_56::UnicodeString::indexOf(wchar_t const *,int,int,int,int)
		jmp	short loc_2B46
; ---------------------------------------------------------------------------

loc_2B43:				; CODE XREF: icu_56::UnicodeString::indexOf(icu_56::UnicodeString const	&,int,int,int,int)+30j
					; icu_56::UnicodeString::indexOf(icu_56::UnicodeString const &,int,int,int,int)+46j
		or	eax, 0FFFFFFFFh

loc_2B46:				; CODE XREF: icu_56::UnicodeString::indexOf(icu_56::UnicodeString const	&,int,int,int,int)+69j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?indexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2B5Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*)
		public ?indexOf@UnicodeString@icu_56@@QBEHABV12@@Z
?indexOf@UnicodeString@icu_56@@QBEHABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z	; icu_56::UnicodeString::indexOf(icu_56::UnicodeString const &,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?indexOf@UnicodeString@icu_56@@QBEHABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2BB8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*, int)
		public ?indexOf@UnicodeString@icu_56@@QBEHABV12@H@Z
?indexOf@UnicodeString@icu_56@@QBEHABV12@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z	; icu_56::UnicodeString::indexOf(icu_56::UnicodeString const &,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?indexOf@UnicodeString@icu_56@@QBEHABV12@H@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2C24h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*, int,	int)
		public ?indexOf@UnicodeString@icu_56@@QBEHABV12@HH@Z
?indexOf@UnicodeString@icu_56@@QBEHABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z	; icu_56::UnicodeString::indexOf(icu_56::UnicodeString const &,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?indexOf@UnicodeString@icu_56@@QBEHABV12@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2C7Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, const wchar_t *, int, int)
		public ?indexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z
?indexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_8]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_8]
		push	eax		; int
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z ;	icu_56::UnicodeString::indexOf(wchar_t const *,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?indexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2CE4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, const wchar_t *, int, int,	int)
		public ?indexOf@UnicodeString@icu_56@@QBEHPB_WHHH@Z
?indexOf@UnicodeString@icu_56@@QBEHPB_WHHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+arg_4]
		push	edx		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z ;	icu_56::UnicodeString::indexOf(wchar_t const *,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?indexOf@UnicodeString@icu_56@@QBEHPB_WHHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2D38h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, wchar_t, int, int)
		public ?indexOf@UnicodeString@icu_56@@QBEH_WHH@Z
?indexOf@UnicodeString@icu_56@@QBEH_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		movzx	edx, [ebp+arg_0]
		push	edx		; wchar_t
		mov	ecx, [ebp+var_8] ; this
		call	?doIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z ; icu_56::UnicodeString::doIndexOf(wchar_t,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?indexOf@UnicodeString@icu_56@@QBEH_WHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2D88h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, int, int, int)
		public ?indexOf@UnicodeString@icu_56@@QBEHHHH@Z
?indexOf@UnicodeString@icu_56@@QBEHHHH@Z proc near
					; CODE XREF: icu_56::UnicodeString::indexOf(int)+35p
					; icu_56::UnicodeString::indexOf(int,int)+46p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doIndexOf@UnicodeString@icu_56@@ABEHHHH@Z ; icu_56::UnicodeString::doIndexOf(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?indexOf@UnicodeString@icu_56@@QBEHHHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2DD8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, wchar_t)
		public ?indexOf@UnicodeString@icu_56@@QBEH_W@Z
?indexOf@UnicodeString@icu_56@@QBEH_W@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		movzx	eax, [ebp+arg_0]
		push	eax		; wchar_t
		mov	ecx, [ebp+var_8] ; this
		call	?doIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z ; icu_56::UnicodeString::doIndexOf(wchar_t,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?indexOf@UnicodeString@icu_56@@QBEH_W@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2E2Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, int)
		public ?indexOf@UnicodeString@icu_56@@QBEHH@Z
?indexOf@UnicodeString@icu_56@@QBEHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHHHH@Z ; icu_56::UnicodeString::indexOf(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?indexOf@UnicodeString@icu_56@@QBEHH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2E7Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, wchar_t, int)
		public ?indexOf@UnicodeString@icu_56@@QBEH_WH@Z
?indexOf@UnicodeString@icu_56@@QBEH_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		movzx	ecx, [ebp+arg_0]
		push	ecx		; wchar_t
		mov	ecx, [ebp+var_8] ; this
		call	?doIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z ; icu_56::UnicodeString::doIndexOf(wchar_t,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?indexOf@UnicodeString@icu_56@@QBEH_WH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2EE0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, int, int)
		public ?indexOf@UnicodeString@icu_56@@QBEHHH@Z
?indexOf@UnicodeString@icu_56@@QBEHHH@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHHHH@Z ; icu_56::UnicodeString::indexOf(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?indexOf@UnicodeString@icu_56@@QBEHHH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2F44h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, const wchar_t *, int, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+arg_4]
		push	edx		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z ; icu_56::UnicodeString::lastIndexOf(wchar_t const *,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2F98h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, const wchar_t *, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_8]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_8]
		push	eax		; int
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z ; icu_56::UnicodeString::lastIndexOf(wchar_t const *,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3000h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *, int, int, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z proc near
					; CODE XREF: icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int)+3Dp
					; icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int)+51p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_306B
		lea	eax, [ebp+arg_8]
		push	eax		; int *
		lea	ecx, [ebp+arg_4]
		push	ecx		; int *
		mov	ecx, [ebp+arg_0] ; this
		call	?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z ; icu_56::UnicodeString::pinIndices(int &,int &)
		cmp	[ebp+arg_8], 0
		jle	short loc_306B
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ ; icu_56::UnicodeString::getArrayStart(void)
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z ; icu_56::UnicodeString::lastIndexOf(wchar_t const *,int,int,int,int)
		jmp	short loc_306E
; ---------------------------------------------------------------------------

loc_306B:				; CODE XREF: icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int,int,int)+30j
					; icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int,int,int)+46j
		or	eax, 0FFFFFFFFh

loc_306E:				; CODE XREF: icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int,int,int)+69j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3084h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z ; icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 30DCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@H@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z ; icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@H@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3148h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z ; icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 31A4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, wchar_t, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEH_WHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEH_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		movzx	edx, [ebp+arg_0]
		push	edx		; wchar_t
		mov	ecx, [ebp+var_8] ; this
		call	?doLastIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z	; icu_56::UnicodeString::doLastIndexOf(wchar_t,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?lastIndexOf@UnicodeString@icu_56@@QBEH_WHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 31F4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, int, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHHHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHHHH@Z proc near
					; CODE XREF: icu_56::UnicodeString::lastIndexOf(int)+35p
					; icu_56::UnicodeString::lastIndexOf(int,int)+46p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doLastIndexOf@UnicodeString@icu_56@@ABEHHHH@Z ; icu_56::UnicodeString::doLastIndexOf(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?lastIndexOf@UnicodeString@icu_56@@QBEHHHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3244h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, wchar_t)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEH_W@Z
?lastIndexOf@UnicodeString@icu_56@@QBEH_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		movzx	eax, [ebp+arg_0]
		push	eax		; wchar_t
		mov	ecx, [ebp+var_8] ; this
		call	?doLastIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z	; icu_56::UnicodeString::doLastIndexOf(wchar_t,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?lastIndexOf@UnicodeString@icu_56@@QBEH_W@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3298h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHHHH@Z ; icu_56::UnicodeString::lastIndexOf(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?lastIndexOf@UnicodeString@icu_56@@QBEHH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 32E8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, wchar_t, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEH_WH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEH_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		movzx	ecx, [ebp+arg_0]
		push	ecx		; wchar_t
		mov	ecx, [ebp+var_8] ; this
		call	?doLastIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z	; icu_56::UnicodeString::doLastIndexOf(wchar_t,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?lastIndexOf@UnicodeString@icu_56@@QBEH_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 334Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHHHH@Z ; icu_56::UnicodeString::lastIndexOf(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?lastIndexOf@UnicodeString@icu_56@@QBEHHH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 33B0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::startsWith(icu_56::UnicodeString *this, const	struct icu_56::UnicodeString *)
		public ?startsWith@UnicodeString@icu_56@@QBECABV12@@Z
?startsWith@UnicodeString@icu_56@@QBECABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?compare@UnicodeString@icu_56@@QBECHHABV12@HH@Z	; icu_56::UnicodeString::compare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?startsWith@UnicodeString@icu_56@@QBECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3414h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::startsWith(icu_56::UnicodeString *this, const	struct icu_56::UnicodeString *,	int, int)
		public ?startsWith@UnicodeString@icu_56@@QBECABV12@HH@Z
?startsWith@UnicodeString@icu_56@@QBECABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_8]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?startsWith@UnicodeString@icu_56@@QBECABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3470h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::startsWith(icu_56::UnicodeString *this, const	wchar_t	*, int)
		public ?startsWith@UnicodeString@icu_56@@QBECPB_WH@Z
?startsWith@UnicodeString@icu_56@@QBECPB_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_4], 0
		jge	short loc_34A8
		mov	eax, [ebp+arg_0]
		push	eax
		call	_u_strlen_56
		add	esp, 4
		mov	[ebp+arg_4], eax

loc_34A8:				; CODE XREF: icu_56::UnicodeString::startsWith(wchar_t const *,int)+27j
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		movsx	eax, al
		test	eax, eax
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?startsWith@UnicodeString@icu_56@@QBECPB_WH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 34E0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::startsWith(icu_56::UnicodeString *this, const	wchar_t	*, int,	int)
		public ?startsWith@UnicodeString@icu_56@@QBECPB_WHH@Z
?startsWith@UnicodeString@icu_56@@QBECPB_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_8], 0
		jge	short loc_3518
		mov	eax, [ebp+arg_0]
		push	eax
		call	_u_strlen_56
		add	esp, 4
		mov	[ebp+arg_8], eax

loc_3518:				; CODE XREF: icu_56::UnicodeString::startsWith(wchar_t const *,int,int)+27j
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_8]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?startsWith@UnicodeString@icu_56@@QBECPB_WHH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3550h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::endsWith(icu_56::UnicodeString *this,	const struct icu_56::UnicodeString *)
		public ?endsWith@UnicodeString@icu_56@@QBECABV12@@Z
?endsWith@UnicodeString@icu_56@@QBECABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	esi, eax
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	esi, eax
		push	esi		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?endsWith@UnicodeString@icu_56@@QBECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 35C8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::endsWith(icu_56::UnicodeString *this,	const struct icu_56::UnicodeString *, int, int)
		public ?endsWith@UnicodeString@icu_56@@QBECABV12@HH@Z
?endsWith@UnicodeString@icu_56@@QBECABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_8]
		push	eax		; int *
		lea	ecx, [ebp+arg_4]
		push	ecx		; int *
		mov	ecx, [ebp+arg_0] ; this
		call	?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z ; icu_56::UnicodeString::pinIndices(int &,int &)
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?endsWith@UnicodeString@icu_56@@QBECABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3640h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::endsWith(icu_56::UnicodeString *this,	const wchar_t *, int)
		public ?endsWith@UnicodeString@icu_56@@QBECPB_WH@Z
?endsWith@UnicodeString@icu_56@@QBECPB_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_4], 0
		jge	short loc_3678
		mov	eax, [ebp+arg_0]
		push	eax
		call	_u_strlen_56
		add	esp, 4
		mov	[ebp+arg_4], eax

loc_3678:				; CODE XREF: icu_56::UnicodeString::endsWith(wchar_t const *,int)+27j
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		movsx	eax, al
		test	eax, eax
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?endsWith@UnicodeString@icu_56@@QBECPB_WH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 36B8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::endsWith(icu_56::UnicodeString *this,	const wchar_t *, int, int)
		public ?endsWith@UnicodeString@icu_56@@QBECPB_WHH@Z
?endsWith@UnicodeString@icu_56@@QBECPB_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_8], 0
		jge	short loc_36F6
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+arg_0]
		lea	edx, [ecx+eax*2]
		push	edx
		call	_u_strlen_56
		add	esp, 4
		mov	[ebp+arg_8], eax

loc_36F6:				; CODE XREF: icu_56::UnicodeString::endsWith(wchar_t const *,int,int)+27j
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?endsWith@UnicodeString@icu_56@@QBECPB_WHH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3738h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replace(icu_56::UnicodeString	*this, int, int, const struct icu_56::UnicodeString *)
		public ?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@@Z
?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3790h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replace(icu_56::UnicodeString	*this, int, int, const struct icu_56::UnicodeString *, int, int)
		public ?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z
?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z proc near
					; CODE XREF: icu_56::UnicodeString::doExtract(int,int,icu_56::UnicodeString &)+3Dp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 37E8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replace(icu_56::UnicodeString	*this, int, int, const wchar_t *, int)
		public ?replace@UnicodeString@icu_56@@QAEAAV12@HHPB_WH@Z
?replace@UnicodeString@icu_56@@QAEAAV12@HHPB_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?replace@UnicodeString@icu_56@@QAEAAV12@HHPB_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 383Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replace(icu_56::UnicodeString	*this, int, int, const wchar_t *, int, int)
		public ?replace@UnicodeString@icu_56@@QAEAAV12@HHPB_WHH@Z
?replace@UnicodeString@icu_56@@QAEAAV12@HHPB_WHH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?replace@UnicodeString@icu_56@@QAEAAV12@HHPB_WHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3894h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replace(icu_56::UnicodeString	*this, int, int, wchar_t)
		public ?replace@UnicodeString@icu_56@@QAEAAV12@HH_W@Z
?replace@UnicodeString@icu_56@@QAEAAV12@HH_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= word ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	1		; int
		push	0		; int
		lea	eax, [ebp+arg_8]
		push	eax		; wchar_t *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?replace@UnicodeString@icu_56@@QAEAAV12@HH_W@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 38E8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replaceBetween(icu_56::UnicodeString *this, int, int,	const struct icu_56::UnicodeString *)
		public ?replaceBetween@UnicodeString@icu_56@@QAEAAV12@HHABV12@@Z
?replaceBetween@UnicodeString@icu_56@@QAEAAV12@HHABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		sub	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?replaceBetween@UnicodeString@icu_56@@QAEAAV12@HHABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3944h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replaceBetween(icu_56::UnicodeString *this, int, int,	const struct icu_56::UnicodeString *, int, int)
		public ?replaceBetween@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z
?replaceBetween@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		sub	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_4]
		sub	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?replaceBetween@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 39A0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::findAndReplace(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *, const struct icu_56::UnicodeString *)
		public ?findAndReplace@UnicodeString@icu_56@@QAEAAV12@ABV12@0@Z
?findAndReplace@UnicodeString@icu_56@@QAEAAV12@ABV12@0@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_4] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_4]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?findAndReplace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH0HH@Z ; icu_56::UnicodeString::findAndReplace(int,int,icu_56::UnicodeString const &,int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?findAndReplace@UnicodeString@icu_56@@QAEAAV12@ABV12@0@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3A0Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::findAndReplace(icu_56::UnicodeString *this, int, int,	const struct icu_56::UnicodeString *, const struct icu_56::UnicodeString *)
		public ?findAndReplace@UnicodeString@icu_56@@QAEAAV12@HHABV12@0@Z
?findAndReplace@UnicodeString@icu_56@@QAEAAV12@HHABV12@0@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_C] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_C]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct icu_56::UnicodeString *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?findAndReplace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH0HH@Z ; icu_56::UnicodeString::findAndReplace(int,int,icu_56::UnicodeString const &,int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?findAndReplace@UnicodeString@icu_56@@QAEAAV12@HHABV12@0@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3A74h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::doExtract(icu_56::UnicodeString *this,	int, int, struct icu_56::UnicodeString *)
		public ?doExtract@UnicodeString@icu_56@@ABEXHHAAV12@@Z
?doExtract@UnicodeString@icu_56@@ABEXHHAAV12@@Z	proc near
					; CODE XREF: icu_56::UnicodeString::extract(int,int,icu_56::UnicodeString &)+32p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	edx, [ebp+var_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_8] ; this
		call	?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::replace(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?doExtract@UnicodeString@icu_56@@ABEXHHAAV12@@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3ACCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::extract(icu_56::UnicodeString *this, int, int,	wchar_t	*, int)
		public ?extract@UnicodeString@icu_56@@QBEXHHPA_WH@Z
?extract@UnicodeString@icu_56@@QBEXHHPA_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doExtract@UnicodeString@icu_56@@ABEXHHPA_WH@Z ; icu_56::UnicodeString::doExtract(int,int,wchar_t *,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?extract@UnicodeString@icu_56@@QBEXHHPA_WH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3B20h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::extract(icu_56::UnicodeString *this, int, int,	struct icu_56::UnicodeString *)
		public ?extract@UnicodeString@icu_56@@QBEXHHAAV12@@Z
?extract@UnicodeString@icu_56@@QBEXHHAAV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doExtract@UnicodeString@icu_56@@ABEXHHAAV12@@Z	; icu_56::UnicodeString::doExtract(int,int,icu_56::UnicodeString &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?extract@UnicodeString@icu_56@@QBEXHHAAV12@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3B70h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::extract(icu_56::UnicodeString *this, int, int, char *, const char *)
		public ?extract@UnicodeString@icu_56@@QBEHHHPADPBD@Z
?extract@UnicodeString@icu_56@@QBEHHHPADPBD@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; char *
		mov	ecx, [ebp+arg_8]
		neg	ecx
		sbb	ecx, ecx
		push	ecx		; unsigned int
		mov	edx, [ebp+arg_8]
		push	edx		; char *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?extract@UnicodeString@icu_56@@QBEHHHPADIPBD@Z ; icu_56::UnicodeString::extract(int,int,char *,uint,char const *)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?extract@UnicodeString@icu_56@@QBEHHHPADPBD@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3BCCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::extractBetween(icu_56::UnicodeString *this, int, int, wchar_t *, int)
		public ?extractBetween@UnicodeString@icu_56@@QBEXHHPA_WH@Z
?extractBetween@UnicodeString@icu_56@@QBEXHHPA_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_0]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		sub	edx, [ebp+arg_0]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doExtract@UnicodeString@icu_56@@ABEXHHPA_WH@Z ; icu_56::UnicodeString::doExtract(int,int,wchar_t *,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?extractBetween@UnicodeString@icu_56@@QBEXHHPA_WH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3C38h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeString __thiscall icu_56::UnicodeString::tempSubStringBetween(int, int)const
		public ?tempSubStringBetween@UnicodeString@icu_56@@QBE?AV12@HH@Z
?tempSubStringBetween@UnicodeString@icu_56@@QBE?AV12@HH@Z proc near

var_D8		= byte ptr -0D8h
var_D4		= dword	ptr -0D4h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_D4], 0
		mov	eax, [ebp+arg_8]
		sub	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		mov	ecx, [ebp+var_8]
		call	?tempSubString@UnicodeString@icu_56@@QBE?AV12@HH@Z ; icu_56::UnicodeString::tempSubString(int,int)
		mov	eax, [ebp+var_D4]
		or	eax, 1
		mov	[ebp+var_D4], eax
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?tempSubStringBetween@UnicodeString@icu_56@@QBE?AV12@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3CA4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; wchar_t __thiscall icu_56::UnicodeString::doCharAt(icu_56::UnicodeString *this, int)
		public ?doCharAt@UnicodeString@icu_56@@ABE_WH@Z
?doCharAt@UnicodeString@icu_56@@ABE_WH@Z proc near
					; CODE XREF: icu_56::UnicodeString::charAt(int)+2Ap
					; icu_56::UnicodeString::operator[](int)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		cmp	[ebp+arg_0], eax
		jnb	short loc_3CE7
		mov	ecx, [ebp+var_8] ; this
		call	?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ ; icu_56::UnicodeString::getArrayStart(void)
		mov	ecx, [ebp+arg_0]
		mov	ax, [eax+ecx*2]
		jmp	short loc_3CEC
; ---------------------------------------------------------------------------
		jmp	short loc_3CEC
; ---------------------------------------------------------------------------

loc_3CE7:				; CODE XREF: icu_56::UnicodeString::doCharAt(int)+2Ej
		mov	eax, 0FFFFh

loc_3CEC:				; CODE XREF: icu_56::UnicodeString::doCharAt(int)+3Fj
					; icu_56::UnicodeString::doCharAt(int)+41j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?doCharAt@UnicodeString@icu_56@@ABE_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3D04h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; wchar_t __thiscall icu_56::UnicodeString::charAt(icu_56::UnicodeString *this,	int)
		public ?charAt@UnicodeString@icu_56@@QBE_WH@Z
?charAt@UnicodeString@icu_56@@QBE_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCharAt@UnicodeString@icu_56@@ABE_WH@Z ; icu_56::UnicodeString::doCharAt(int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?charAt@UnicodeString@icu_56@@QBE_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3D4Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: wchar_t __thiscall icu_56::UnicodeString::operator[](int)const
		public ??AUnicodeString@icu_56@@QBE_WH@Z
??AUnicodeString@icu_56@@QBE_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCharAt@UnicodeString@icu_56@@ABE_WH@Z ; icu_56::UnicodeString::doCharAt(int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??AUnicodeString@icu_56@@QBE_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3D94h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::isEmpty(icu_56::UnicodeString	*__hidden this)
		public ?isEmpty@UnicodeString@icu_56@@QBECXZ
?isEmpty@UnicodeString@icu_56@@QBECXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		sar	ecx, 5
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isEmpty@UnicodeString@icu_56@@QBECXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3DD0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::setZeroLength(icu_56::UnicodeString *__hidden this)
		public ?setZeroLength@UnicodeString@icu_56@@AAEXXZ
?setZeroLength@UnicodeString@icu_56@@AAEXXZ proc near
					; CODE XREF: icu_56::UnicodeString::remove(void)+3Fp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 1Fh
		mov	edx, [ebp+var_8]
		mov	[edx+4], cx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?setZeroLength@UnicodeString@icu_56@@AAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3E0Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::setShortLength(icu_56::UnicodeString *this, int)
		public ?setShortLength@UnicodeString@icu_56@@AAEXH@Z
?setShortLength@UnicodeString@icu_56@@AAEXH@Z proc near
					; CODE XREF: icu_56::UnicodeString::setLength(int)+33p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 1Fh
		mov	edx, [ebp+arg_0]
		shl	edx, 5
		or	ecx, edx
		mov	eax, [ebp+var_8]
		mov	[eax+4], cx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?setShortLength@UnicodeString@icu_56@@AAEXH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3E54h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::setLength(icu_56::UnicodeString *this,	int)
		public ?setLength@UnicodeString@icu_56@@AAEXH@Z
?setLength@UnicodeString@icu_56@@AAEXH@Z proc near
					; CODE XREF: icu_56::UnicodeString::setArray(wchar_t *,int,int)+2Ap
					; icu_56::UnicodeString::truncate(int)+5Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 3FFh
		jg	short loc_3E8E
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?setShortLength@UnicodeString@icu_56@@AAEXH@Z ;	icu_56::UnicodeString::setShortLength(int)
		jmp	short loc_3EAB
; ---------------------------------------------------------------------------

loc_3E8E:				; CODE XREF: icu_56::UnicodeString::setLength(int)+2Aj
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		or	ecx, 0FFE0h
		mov	edx, [ebp+var_8]
		mov	[edx+4], cx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+8], ecx

loc_3EAB:				; CODE XREF: icu_56::UnicodeString::setLength(int)+38j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setLength@UnicodeString@icu_56@@AAEXH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3EC4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::setToEmpty(icu_56::UnicodeString *__hidden this)
		public ?setToEmpty@UnicodeString@icu_56@@AAEXXZ
?setToEmpty@UnicodeString@icu_56@@AAEXXZ proc near
					; CODE XREF: icu_56::UnicodeString::remove(void)+35p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, 2
		mov	ecx, [ebp+var_8]
		mov	[ecx+4], ax
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?setToEmpty@UnicodeString@icu_56@@AAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3EFCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::setArray(icu_56::UnicodeString	*this, wchar_t *, int, int)
		public ?setArray@UnicodeString@icu_56@@AAEXPA_WHH@Z
?setArray@UnicodeString@icu_56@@AAEXPA_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?setLength@UnicodeString@icu_56@@AAEXH@Z ; icu_56::UnicodeString::setLength(int)
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+10h], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_8]
		mov	[eax+0Ch], ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?setArray@UnicodeString@icu_56@@AAEXPA_WHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3F54h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator=(wchar_t)
		public ??4UnicodeString@icu_56@@QAEAAV01@_W@Z
??4UnicodeString@icu_56@@QAEAAV01@_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	1		; int
		push	0		; int
		lea	eax, [ebp+arg_0]
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4UnicodeString@icu_56@@QAEAAV01@_W@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3FA8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeString &	__thiscall icu_56::UnicodeString::operator=(int)
		public ??4UnicodeString@icu_56@@QAEAAV01@H@Z
??4UnicodeString@icu_56@@QAEAAV01@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?replace@UnicodeString@icu_56@@QAEAAV12@HHH@Z ;	icu_56::UnicodeString::replace(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4UnicodeString@icu_56@@QAEAAV01@H@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3FF8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*, int,	int)
		public ?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z
?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp

loc_3FFB:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::boolalphao
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?unBogus@UnicodeString@icu_56@@AAEXXZ ;	icu_56::UnicodeString::unBogus(void)
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4058h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*, int)
		public ?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@H@Z
?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@H@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?unBogus@UnicodeString@icu_56@@AAEXXZ ;	icu_56::UnicodeString::unBogus(void)
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+arg_0] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@H@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 40CCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*)
		public ?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z
?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	0		; signed __int8
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?copyFrom@UnicodeString@icu_56@@AAEAAV12@ABV12@C@Z ; icu_56::UnicodeString::copyFrom(icu_56::UnicodeString const &,signed char)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4114h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *this, const wchar_t *, int)
		public ?setTo@UnicodeString@icu_56@@QAEAAV12@PB_WH@Z
?setTo@UnicodeString@icu_56@@QAEAAV12@PB_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?unBogus@UnicodeString@icu_56@@AAEXXZ ;	icu_56::UnicodeString::unBogus(void)
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?setTo@UnicodeString@icu_56@@QAEAAV12@PB_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4174h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *this, wchar_t)
		public ?setTo@UnicodeString@icu_56@@QAEAAV12@_W@Z
?setTo@UnicodeString@icu_56@@QAEAAV12@_W@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?unBogus@UnicodeString@icu_56@@AAEXXZ ;	icu_56::UnicodeString::unBogus(void)
		push	1		; int
		push	0		; int
		lea	eax, [ebp+arg_0]
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setTo@UnicodeString@icu_56@@QAEAAV12@_W@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 41D0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *this, int)
		public ?setTo@UnicodeString@icu_56@@QAEAAV12@H@Z
?setTo@UnicodeString@icu_56@@QAEAAV12@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?unBogus@UnicodeString@icu_56@@AAEXXZ ;	icu_56::UnicodeString::unBogus(void)
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?replace@UnicodeString@icu_56@@QAEAAV12@HHH@Z ;	icu_56::UnicodeString::replace(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setTo@UnicodeString@icu_56@@QAEAAV12@H@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4228h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *, int, int)
		public ?append@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z
?append@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@ABV12@HH@Z ; icu_56::UnicodeString::doAppend(icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?append@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4278h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *)
		public ?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z
?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@ABV12@HH@Z ; icu_56::UnicodeString::doAppend(icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 42C8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *this, const wchar_t *, int, int)
		public ?append@UnicodeString@icu_56@@QAEAAV12@PB_WHH@Z
?append@UnicodeString@icu_56@@QAEAAV12@PB_WHH@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@PB_WHH@Z ; icu_56::UnicodeString::doAppend(wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?append@UnicodeString@icu_56@@QAEAAV12@PB_WHH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4318h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *this, const wchar_t *, int)
		public ?append@UnicodeString@icu_56@@QAEAAV12@PB_WH@Z
?append@UnicodeString@icu_56@@QAEAAV12@PB_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@PB_WHH@Z ; icu_56::UnicodeString::doAppend(wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?append@UnicodeString@icu_56@@QAEAAV12@PB_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4364h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *this, wchar_t)
		public ?append@UnicodeString@icu_56@@QAEAAV12@_W@Z
?append@UnicodeString@icu_56@@QAEAAV12@_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	1		; int
		push	0		; int
		lea	eax, [ebp+arg_0]
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@PB_WHH@Z ; icu_56::UnicodeString::doAppend(wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?append@UnicodeString@icu_56@@QAEAAV12@_W@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 43B0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator+=(wchar_t)
		public ??YUnicodeString@icu_56@@QAEAAV01@_W@Z
??YUnicodeString@icu_56@@QAEAAV01@_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	1		; int
		push	0		; int
		lea	eax, [ebp+arg_0]
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@PB_WHH@Z ; icu_56::UnicodeString::doAppend(wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??YUnicodeString@icu_56@@QAEAAV01@_W@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 43FCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeString &	__thiscall icu_56::UnicodeString::operator+=(int)
		public ??YUnicodeString@icu_56@@QAEAAV01@H@Z
??YUnicodeString@icu_56@@QAEAAV01@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?append@UnicodeString@icu_56@@QAEAAV12@H@Z ; icu_56::UnicodeString::append(int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??YUnicodeString@icu_56@@QAEAAV01@H@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4444h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator+=(struct icu_56::UnicodeString *)
		public ??YUnicodeString@icu_56@@QAEAAV01@ABV01@@Z
??YUnicodeString@icu_56@@QAEAAV01@ABV01@@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@ABV12@HH@Z ; icu_56::UnicodeString::doAppend(icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??YUnicodeString@icu_56@@QAEAAV01@ABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4494h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::insert(icu_56::UnicodeString *this, int, const struct	icu_56::UnicodeString *, int, int)
		public ?insert@UnicodeString@icu_56@@QAEAAV12@HABV12@HH@Z
?insert@UnicodeString@icu_56@@QAEAAV12@HABV12@HH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+arg_4]
		push	edx		; struct icu_56::UnicodeString *
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?insert@UnicodeString@icu_56@@QAEAAV12@HABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 44E8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::insert(icu_56::UnicodeString *this, int, const struct	icu_56::UnicodeString *)
		public ?insert@UnicodeString@icu_56@@QAEAAV12@HABV12@@Z
?insert@UnicodeString@icu_56@@QAEAAV12@HABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_4] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_4]
		push	eax		; struct icu_56::UnicodeString *
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?insert@UnicodeString@icu_56@@QAEAAV12@HABV12@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4540h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::insert(icu_56::UnicodeString *this, int, const wchar_t *, int, int)
		public ?insert@UnicodeString@icu_56@@QAEAAV12@HPB_WHH@Z
?insert@UnicodeString@icu_56@@QAEAAV12@HPB_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+arg_4]
		push	edx		; wchar_t *
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?insert@UnicodeString@icu_56@@QAEAAV12@HPB_WHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4594h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::insert(icu_56::UnicodeString *this, int, const wchar_t *, int)
		public ?insert@UnicodeString@icu_56@@QAEAAV12@HPB_WH@Z
?insert@UnicodeString@icu_56@@QAEAAV12@HPB_WH@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; wchar_t *
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?insert@UnicodeString@icu_56@@QAEAAV12@HPB_WH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 45E8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::insert(icu_56::UnicodeString *this, int, wchar_t)
		public ?insert@UnicodeString@icu_56@@QAEAAV12@H_W@Z
?insert@UnicodeString@icu_56@@QAEAAV12@H_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= word ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	1		; int
		push	0		; int
		lea	eax, [ebp+arg_4]
		push	eax		; wchar_t *
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp

loc_462C:				; DATA XREF: .rdata:off_44Do
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?insert@UnicodeString@icu_56@@QAEAAV12@H_W@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4638h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::insert(icu_56::UnicodeString *this, int, int)
		public ?insert@UnicodeString@icu_56@@QAEAAV12@HH@Z
?insert@UnicodeString@icu_56@@QAEAAV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?replace@UnicodeString@icu_56@@QAEAAV12@HHH@Z ;	icu_56::UnicodeString::replace(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?insert@UnicodeString@icu_56@@QAEAAV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4684h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::remove(icu_56::UnicodeString *__hidden this)
		public ?remove@UnicodeString@icu_56@@QAEAAV12@XZ
?remove@UnicodeString@icu_56@@QAEAAV12@XZ proc near
					; CODE XREF: icu_56::UnicodeString::remove(int,int)+35p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_46C0
		mov	ecx, [ebp+var_8] ; this
		call	?setToEmpty@UnicodeString@icu_56@@AAEXXZ ; icu_56::UnicodeString::setToEmpty(void)
		jmp	short loc_46C8
; ---------------------------------------------------------------------------

loc_46C0:				; CODE XREF: icu_56::UnicodeString::remove(void)+30j
		mov	ecx, [ebp+var_8] ; this
		call	?setZeroLength@UnicodeString@icu_56@@AAEXXZ ; icu_56::UnicodeString::setZeroLength(void)

loc_46C8:				; CODE XREF: icu_56::UnicodeString::remove(void)+3Aj
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?remove@UnicodeString@icu_56@@QAEAAV12@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 46E0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::remove(icu_56::UnicodeString *this, int, int)
		public ?remove@UnicodeString@icu_56@@QAEAAV12@HH@Z
?remove@UnicodeString@icu_56@@QAEAAV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jg	short loc_471C
		cmp	[ebp+arg_4], 7FFFFFFFh
		jnz	short loc_471C
		mov	ecx, [ebp+var_8] ; this
		call	?remove@UnicodeString@icu_56@@QAEAAV12@XZ ; icu_56::UnicodeString::remove(void)
		jmp	short loc_4732
; ---------------------------------------------------------------------------

loc_471C:				; CODE XREF: icu_56::UnicodeString::remove(int,int)+27j
					; icu_56::UnicodeString::remove(int,int)+30j
		push	0		; int
		push	0		; int
		push	0		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)

loc_4732:				; CODE XREF: icu_56::UnicodeString::remove(int,int)+3Aj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?remove@UnicodeString@icu_56@@QAEAAV12@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4748h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::removeBetween(icu_56::UnicodeString *this, int, int)
		public ?removeBetween@UnicodeString@icu_56@@QAEAAV12@HH@Z
?removeBetween@UnicodeString@icu_56@@QAEAAV12@HH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	0		; int
		push	0		; int
		push	0		; wchar_t *
		mov	eax, [ebp+arg_4]
		sub	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?removeBetween@UnicodeString@icu_56@@QAEAAV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 479Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::retainBetween(icu_56::UnicodeString *this, int, int)
		public ?retainBetween@UnicodeString@icu_56@@QAEAAV12@HH@Z
?retainBetween@UnicodeString@icu_56@@QAEAAV12@HH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?truncate@UnicodeString@icu_56@@QAECH@Z	; icu_56::UnicodeString::truncate(int)
		push	0		; int
		push	0		; int
		push	0		; wchar_t *
		mov	eax, [ebp+arg_0]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?retainBetween@UnicodeString@icu_56@@QAEAAV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 47F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::truncate(icu_56::UnicodeString *this,	int)
		public ?truncate@UnicodeString@icu_56@@QAECH@Z
?truncate@UnicodeString@icu_56@@QAECH@Z	proc near
					; CODE XREF: icu_56::UnicodeString::retainBetween(int,int)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_483E
		cmp	[ebp+arg_0], 0
		jnz	short loc_483E
		mov	ecx, [ebp+var_8] ; this
		call	?unBogus@UnicodeString@icu_56@@AAEXXZ ;	icu_56::UnicodeString::unBogus(void)
		xor	al, al
		jmp	short loc_485F
; ---------------------------------------------------------------------------
		jmp	short loc_485F
; ---------------------------------------------------------------------------

loc_483E:				; CODE XREF: icu_56::UnicodeString::truncate(int)+30j
					; icu_56::UnicodeString::truncate(int)+36j
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		cmp	[ebp+arg_0], eax
		jnb	short loc_485D
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?setLength@UnicodeString@icu_56@@AAEXH@Z ; icu_56::UnicodeString::setLength(int)
		mov	al, 1
		jmp	short loc_485F
; ---------------------------------------------------------------------------
		jmp	short loc_485F
; ---------------------------------------------------------------------------

loc_485D:				; CODE XREF: icu_56::UnicodeString::truncate(int)+51j
		xor	al, al

loc_485F:				; CODE XREF: icu_56::UnicodeString::truncate(int)+42j
					; icu_56::UnicodeString::truncate(int)+44j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?truncate@UnicodeString@icu_56@@QAECH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4878h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::reverse(icu_56::UnicodeString	*__hidden this)
		public ?reverse@UnicodeString@icu_56@@QAEAAV12@XZ
?reverse@UnicodeString@icu_56@@QAEAAV12@XZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReverse@UnicodeString@icu_56@@AAEAAV12@HH@Z ; icu_56::UnicodeString::doReverse(int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?reverse@UnicodeString@icu_56@@QAEAAV12@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 48C4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::reverse(icu_56::UnicodeString	*this, int, int)
		public ?reverse@UnicodeString@icu_56@@QAEAAV12@HH@Z
?reverse@UnicodeString@icu_56@@QAEAAV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReverse@UnicodeString@icu_56@@AAEAAV12@HH@Z ; icu_56::UnicodeString::doReverse(int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?reverse@UnicodeString@icu_56@@QAEAAV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4910h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::StringEnumeration::StringEnumeration(icu_56::StringEnumeration *this, const	struct icu_56::StringEnumeration *)
		public ??0StringEnumeration@icu_56@@QAE@ABV01@@Z
??0StringEnumeration@icu_56@@QAE@ABV01@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0StringEnumeration@icu_56@@QAE@ABV01@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UObject *
		mov	ecx, [ebp+var_14] ; this
		call	??0UObject@icu_56@@QAE@ABV01@@Z	; icu_56::UObject::UObject(icu_56::UObject const &)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7StringEnumeration@icu_56@@6B@ ; const icu_56::StringEnumeration::`vftable'
		mov	eax, [ebp+arg_0]
		add	eax, 4
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_14]
		add	ecx, 4		; this
		call	??0UnicodeString@icu_56@@QAE@ABV01@@Z ;	icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString const &)
		mov	esi, [ebp+arg_0]
		add	esi, 44h ; 'D'
		mov	edi, [ebp+var_14]
		add	edi, 44h ; 'D'
		mov	ecx, 8
		rep movsd
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+64h]
		mov	[eax+64h], edx
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+68h]
		mov	[eax+68h], edx
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0StringEnumeration@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 49D8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0StringEnumeration@icu_56@@QAE@ABV01@@Z$0 proc near
					; DATA XREF: .xdata$x:00004A30o
		mov	ecx, [ebp-14h]	; this
		jmp	??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
__unwindfunclet$??0StringEnumeration@icu_56@@QAE@ABV01@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0StringEnumeration@icu_56@@QAE@ABV01@@Z proc near
					; DATA XREF: icu_56::StringEnumeration::StringEnumeration(icu_56::StringEnumeration const &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0StringEnumeration@icu_56@@QAE@ABV01@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0StringEnumeration@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4A00h
		dd offset ??_R4StringEnumeration@icu_56@@6B@ ; const icu_56::StringEnumeration::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7StringEnumeration@icu_56@@6B@
; const	icu_56::StringEnumeration::`vftable'
??_7StringEnumeration@icu_56@@6B@ dd offset ??_EStringEnumeration@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::StringEnumeration::StringEnumeration(icu_56::StringEnumeration const &)+58o
					; icu_56::StringEnumeration::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ ;	icu_56::UObject::getDynamicClassID(void)
		dd offset ?clone@StringEnumeration@icu_56@@UBEPAV12@XZ ; icu_56::StringEnumeration::clone(void)
		dd offset __purecall
		dd offset ?next@StringEnumeration@icu_56@@UAEPBDPAHAAW4UErrorCode@@@Z ;	icu_56::StringEnumeration::next(int *,UErrorCode &)
		dd offset ?unext@StringEnumeration@icu_56@@UAEPB_WPAHAAW4UErrorCode@@@Z	; icu_56::StringEnumeration::unext(int *,UErrorCode &)
		dd offset ?snext@StringEnumeration@icu_56@@UAEPBVUnicodeString@2@AAW4UErrorCode@@@Z ; icu_56::StringEnumeration::snext(UErrorCode &)
		dd offset __purecall
		dd offset ??8StringEnumeration@icu_56@@UBECABV01@@Z ; icu_56::StringEnumeration::operator==(icu_56::StringEnumeration const &)
		dd offset ??9StringEnumeration@icu_56@@UBECABV01@@Z ; icu_56::StringEnumeration::operator!=(icu_56::StringEnumeration const &)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 4A2Ch
__unwindtable$??0StringEnumeration@icu_56@@QAE@ABV01@@Z	dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00004A3Co
		dd offset __unwindfunclet$??0StringEnumeration@icu_56@@QAE@ABV01@@Z$0
__ehfuncinfo$??0StringEnumeration@icu_56@@QAE@ABV01@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$??0StringEnumeration@icu_56@@QAE@ABV01@@Z+14o
		dd offset __unwindtable$??0StringEnumeration@icu_56@@QAE@ABV01@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 4A58h
		public ??_R4StringEnumeration@icu_56@@6B@
; const	icu_56::StringEnumeration::`RTTI Complete Object Locator'
??_R4StringEnumeration@icu_56@@6B@ dd 3	dup(0) ; DATA XREF: .rdata:00004A00o
		dd offset ??_R0?AVStringEnumeration@icu_56@@@8 ; icu_56::StringEnumeration `RTTI Type Descriptor'
		dd offset ??_R3StringEnumeration@icu_56@@8 ; icu_56::StringEnumeration::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 4A6Ch
		public ??_R0?AVStringEnumeration@icu_56@@@8
; class	icu_56::StringEnumeration `RTTI	Type Descriptor'
??_R0?AVStringEnumeration@icu_56@@@8 dd	offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:00004A64o
					; .rdata$r:icu_56::StringEnumeration::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avstringenum	db '.?AVStringEnumeration@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 4A94h
		public ??_R3StringEnumeration@icu_56@@8
; icu_56::StringEnumeration::`RTTI Class Hierarchy Descriptor'
??_R3StringEnumeration@icu_56@@8 dd 2 dup(0) ; DATA XREF: .rdata$r:00004A68o
					; .rdata$r:00004ACCo
		dd 3
		dd offset ??_R2StringEnumeration@icu_56@@8 ; icu_56::StringEnumeration::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 4AA4h
		public ??_R2StringEnumeration@icu_56@@8
; icu_56::StringEnumeration::`RTTI Base	Class Array'
??_R2StringEnumeration@icu_56@@8 dd offset ??_R1A@?0A@EA@StringEnumeration@icu_56@@8
					; DATA XREF: .rdata$r:00004AA0o
					; icu_56::StringEnumeration::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 4AB4h
		public ??_R1A@?0A@EA@StringEnumeration@icu_56@@8
; icu_56::StringEnumeration::`RTTI Base	Class Descriptor at (0,	-1, 0, 64)'
??_R1A@?0A@EA@StringEnumeration@icu_56@@8 dd offset ??_R0?AVStringEnumeration@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::StringEnumeration::`RTTI Base Class Array'o
					; icu_56::StringEnumeration `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3StringEnumeration@icu_56@@8 ; icu_56::StringEnumeration::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4AD0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::StringEnumeration & __thiscall icu_56::StringEnumeration::operator=(class icu_56::StringEnumeration const &)
		public ??4StringEnumeration@icu_56@@QAEAAV01@ABV01@@Z
??4StringEnumeration@icu_56@@QAEAAV01@ABV01@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??4UObject@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::UObject::operator=(icu_56::UObject const	&)
		mov	eax, [ebp+arg_0]
		add	eax, 4
		push	eax
		mov	ecx, [ebp+var_8]
		add	ecx, 4
		call	??4UnicodeString@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::UnicodeString::operator=(icu_56::UnicodeString const &)
		mov	[ebp+var_14], 0
		jmp	short loc_4B23
; ---------------------------------------------------------------------------

loc_4B1A:				; CODE XREF: icu_56::StringEnumeration::operator=(icu_56::StringEnumeration const &)+6Bj
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_4B23:				; CODE XREF: icu_56::StringEnumeration::operator=(icu_56::StringEnumeration const &)+48j
		cmp	[ebp+var_14], 20h ; ' '
		jnb	short loc_4B3D
		mov	eax, [ebp+var_8]
		add	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		add	ecx, [ebp+var_14]
		mov	dl, [ecx+44h]
		mov	[eax+44h], dl
		jmp	short loc_4B1A
; ---------------------------------------------------------------------------

loc_4B3D:				; CODE XREF: icu_56::StringEnumeration::operator=(icu_56::StringEnumeration const &)+57j
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+64h]
		mov	[eax+64h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+68h]
		mov	[eax+68h], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4StringEnumeration@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4B70h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::StringEnumeration::`scalar deleting	destructor'(unsigned int)
		public ??_GStringEnumeration@icu_56@@UAEPAXI@Z
??_GStringEnumeration@icu_56@@UAEPAXI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1StringEnumeration@icu_56@@UAE@XZ ; icu_56::StringEnumeration::~StringEnumeration(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_4BAF
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_4BAF:				; CODE XREF: icu_56::StringEnumeration::`scalar	deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GStringEnumeration@icu_56@@UAEPAXI@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4BC8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::StringEnumeration::`vector deleting	destructor'(unsigned int)
		public ??_EStringEnumeration@icu_56@@UAEPAXI@Z
??_EStringEnumeration@icu_56@@UAEPAXI@Z	proc near
					; DATA XREF: .rdata:const icu_56::StringEnumeration::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_4C29
		push	offset ??1StringEnumeration@icu_56@@UAE@XZ ; icu_56::StringEnumeration::~StringEnumeration(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	6Ch ; 'l'
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_4C21
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_4C21:				; CODE XREF: icu_56::StringEnumeration::`vector	deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_4C48
; ---------------------------------------------------------------------------

loc_4C29:				; CODE XREF: icu_56::StringEnumeration::`vector	deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1StringEnumeration@icu_56@@UAE@XZ ; icu_56::StringEnumeration::~StringEnumeration(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_4C45
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_4C45:				; CODE XREF: icu_56::StringEnumeration::`vector	deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_4C48:				; CODE XREF: icu_56::StringEnumeration::`vector	deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EStringEnumeration@icu_56@@UAEPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4C60h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl _ISO2022Open(struct UConverter *, struct	UConverterLoadArgs *, enum  UErrorCode *)
?_ISO2022Open@@YAXPAUUConverter@@PAUUConverterLoadArgs@@PAW4UErrorCode@@@Z proc	near
					; DATA XREF: .rdata:00000584o
					; .rdata:0000071Co ...

var_210		= byte ptr -210h
var_14C		= dword	ptr -14Ch
var_140		= dword	ptr -140h
var_134		= dword	ptr -134h
Dst		= dword	ptr -128h
var_11C		= dword	ptr -11Ch
var_118		= dword	ptr -118h
var_114		= byte ptr -114h
var_113		= byte ptr -113h
var_112		= word ptr -112h
var_110		= dword	ptr -110h
var_10C		= dword	ptr -10Ch
var_108		= dword	ptr -108h
var_104		= dword	ptr -104h
var_F8		= byte ptr -0F8h
Dest		= byte ptr -10h
var_F		= byte ptr -0Fh
var_E		= byte ptr -0Eh
var_D		= byte ptr -0Dh
var_C		= byte ptr -0Ch
var_B		= byte ptr -0Bh
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 210h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_210]
		mov	ecx, 84h ; ''
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	[ebp+Dest], 20h	; ' '
		mov	[ebp+var_F], 20h ; ' '
		mov	[ebp+var_E], 20h ; ' '
		mov	[ebp+var_D], 20h ; ' '
		mov	[ebp+var_C], 20h ; ' '
		mov	[ebp+var_B], 20h ; ' '
		push	68h ; 'h'
		call	_uprv_malloc_56
		add	esp, 4
		mov	ecx, [ebp+arg_0]
		mov	[ecx+8], eax
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+8], 0
		jz	loc_532E
		mov	[ebp+var_11C], 1Ch
		mov	[ebp+var_118], 0
		mov	[ebp+var_114], 0
		mov	[ebp+var_113], 0
		xor	eax, eax
		mov	[ebp+var_112], ax
		mov	[ebp+var_110], 0
		mov	[ebp+var_10C], 0
		mov	[ebp+var_108], 0
		mov	[ebp+var_104], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		mov	[ebp+Dst], ecx
		mov	eax, [ebp+arg_4]
		mov	cl, [eax+8]
		mov	[ebp+var_114], cl
		push	68h ; 'h'       ; Size
		push	0		; Val
		mov	eax, [ebp+Dst]
		push	eax		; Dst
		call	_memset
		add	esp, 0Ch
		mov	eax, [ebp+Dst]
		mov	dword ptr [eax+2Ch], 0
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+34h], 0
		mov	eax, [ebp+arg_4]
		cmp	dword ptr [eax+18h], 0
		jz	short loc_4D8B
		push	1
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax+18h]
		push	ecx
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	esi, esp
		push	6		; Count
		mov	edx, [ebp+arg_4]
		mov	eax, [edx+18h]
		push	eax		; Source
		lea	ecx, [ebp+Dest]
		push	ecx		; Dest
		call	dword ptr ds:__imp__strncpy
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_4D8B:				; CODE XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+F9j
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax+0Ch]
		and	ecx, 0Fh
		mov	[ebp+var_134], ecx
		mov	eax, [ebp+Dst]
		mov	ecx, [ebp+var_134]
		mov	[eax+40h], ecx
		movsx	eax, [ebp+Dest]
		cmp	eax, 6Ah ; 'j'
		jnz	loc_4F8F
		movsx	eax, [ebp+var_F]
		cmp	eax, 61h ; 'a'
		jz	short loc_4DCC
		movsx	eax, [ebp+var_F]
		cmp	eax, 70h ; 'p'
		jnz	loc_4F8F

loc_4DCC:				; CODE XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+15Dj
		movsx	eax, [ebp+var_E]
		cmp	eax, 5Fh ; '_'
		jz	short loc_4DE1
		movsx	eax, [ebp+var_E]
		test	eax, eax
		jnz	loc_4F8F

loc_4DE1:				; CODE XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+173j
		cmp	[ebp+var_134], 4
		jbe	short loc_4DF8
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 2
		jmp	loc_5337
; ---------------------------------------------------------------------------

loc_4DF8:				; CODE XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+188j
		mov	eax, [ebp+var_134]
		movzx	ecx, ds:_jpCharsetMasks[eax*2]
		and	ecx, 4
		jz	short loc_4E33
		mov	eax, [ebp+arg_8]
		push	eax
		lea	ecx, [ebp+var_11C]
		push	ecx
		lea	edx, [ebp+var_F8]
		push	edx
		push	offset ??_C@_09KFBIDBIA@ISO8859_7?$AA@ ; "ISO8859_7"
		call	_ucnv_loadSharedData_56
		add	esp, 10h
		mov	ecx, [ebp+Dst]
		mov	[ecx+8], eax

loc_4E33:				; CODE XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+1A9j
		mov	eax, [ebp+arg_8]
		push	eax
		lea	ecx, [ebp+var_11C]
		push	ecx
		lea	edx, [ebp+var_F8]
		push	edx
		push	offset ??_C@_09DNLJOPNC@Shift?9JIS?$AA@	; "Shift-JIS"
		call	_ucnv_loadSharedData_56
		add	esp, 10h
		mov	ecx, [ebp+Dst]
		mov	[ecx+10h], eax
		mov	eax, [ebp+var_134]
		movzx	ecx, ds:_jpCharsetMasks[eax*2]
		and	ecx, 20h
		jz	short loc_4E96
		mov	eax, [ebp+arg_8]
		push	eax
		lea	ecx, [ebp+var_11C]
		push	ecx
		lea	edx, [ebp+var_F8]
		push	edx
		push	offset ??_C@_08IOEEBOKI@jisx?9212?$AA@ ; "jisx-212"
		call	_ucnv_loadSharedData_56
		add	esp, 10h
		mov	ecx, [ebp+Dst]
		mov	[ecx+14h], eax

loc_4E96:				; CODE XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+20Cj
		mov	eax, [ebp+var_134]
		movzx	ecx, ds:_jpCharsetMasks[eax*2]
		and	ecx, 40h
		jz	short loc_4ED1
		mov	eax, [ebp+arg_8]
		push	eax
		lea	ecx, [ebp+var_11C]
		push	ecx
		lea	edx, [ebp+var_F8]
		push	edx
		push	offset ??_C@_08KJIFHEL@ibm?95478?$AA@ ;	"ibm-5478"
		call	_ucnv_loadSharedData_56
		add	esp, 10h
		mov	ecx, [ebp+Dst]
		mov	[ecx+18h], eax

loc_4ED1:				; CODE XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+247j
		mov	eax, [ebp+var_134]
		movzx	ecx, ds:_jpCharsetMasks[eax*2]
		and	ecx, 80h
		jz	short loc_4F0F
		mov	eax, [ebp+arg_8]
		push	eax
		lea	ecx, [ebp+var_11C]
		push	ecx
		lea	edx, [ebp+var_F8]
		push	edx
		push	offset ??_C@_08PMCOPMKI@ksc_5601?$AA@ ;	"ksc_5601"
		call	_ucnv_loadSharedData_56
		add	esp, 10h
		mov	ecx, [ebp+Dst]
		mov	[ecx+1Ch], eax

loc_4F0F:				; CODE XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+285j
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+18h], offset ?_ISO2022JPData@?A0x5ec8f556@@3UUConverterSharedData@@B ; UConverterSharedData const `anonymous namespace'::_ISO2022JPData
		push	offset ??_C@_02DJBIDCPN@ja?$AA@	; "ja"
		mov	eax, [ebp+Dst]
		add	eax, 63h ; 'c'
		push	eax		; Dest
		call	_strcpy
		add	esp, 8
		push	offset ??_C@_0BM@OKNPDGBE@ISO_2022?0locale?$DNja?0version?$DN?$AA@ ; "ISO_2022,locale=ja,version="
		mov	eax, [ebp+Dst]
		add	eax, 45h ; 'E'
		push	eax		; Dest
		call	_strcpy
		add	esp, 8
		mov	eax, [ebp+Dst]
		add	eax, 45h ; 'E'
		push	eax		; Str
		call	_strlen
		add	esp, 4
		mov	[ebp+var_140], eax
		mov	eax, [ebp+Dst]
		mov	ecx, [eax+40h]
		add	ecx, 30h ; '0'
		mov	edx, [ebp+Dst]
		add	edx, [ebp+var_140]
		mov	[edx+45h], cl
		mov	eax, [ebp+Dst]
		add	eax, [ebp+var_140]
		mov	byte ptr [eax+46h], 0
		jmp	loc_52EE
; ---------------------------------------------------------------------------

loc_4F8F:				; CODE XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+150j
					; _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+166j ...
		movsx	eax, [ebp+Dest]
		cmp	eax, 6Bh ; 'k'
		jnz	loc_5165
		movsx	eax, [ebp+var_F]
		cmp	eax, 6Fh ; 'o'
		jz	short loc_4FB2
		movsx	eax, [ebp+var_F]
		cmp	eax, 72h ; 'r'
		jnz	loc_5165

loc_4FB2:				; CODE XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+343j
		movsx	eax, [ebp+var_E]
		cmp	eax, 5Fh ; '_'
		jz	short loc_4FC7
		movsx	eax, [ebp+var_E]
		test	eax, eax
		jnz	loc_5165

loc_4FC7:				; CODE XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+359j
		cmp	[ebp+var_134], 1
		jbe	short loc_4FDE
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 2
		jmp	loc_5337
; ---------------------------------------------------------------------------

loc_4FDE:				; CODE XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+36Ej
		cmp	[ebp+var_134], 1
		jnz	short loc_4FF3
		mov	[ebp+var_14C], offset ??_C@_0BD@OMACFIPD@icu?9internal?925546?$AA@ ; "icu-internal-25546"
		jmp	short loc_5016
; ---------------------------------------------------------------------------

loc_4FF3:				; CODE XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+385j
		mov	[ebp+var_14C], offset ??_C@_07GEKOEGCG@ibm?9949?$AA@ ; "ibm-949"
		mov	[ebp+var_134], 0
		mov	eax, [ebp+Dst]
		mov	ecx, [ebp+var_134]
		mov	[eax+40h], ecx

loc_5016:				; CODE XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+391j
		mov	eax, [ebp+arg_4]
		movsx	ecx, byte ptr [eax+8]
		test	ecx, ecx
		jz	short loc_5057
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+var_14C]
		push	ecx
		call	_ucnv_canCreateConverter_56
		add	esp, 8
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		push	ecx
		call	_uprv_free_56
		add	esp, 4
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+8], 0
		jmp	loc_5337
; ---------------------------------------------------------------------------
		jmp	loc_5160
; ---------------------------------------------------------------------------

loc_5057:				; CODE XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+3BFj
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+var_14C]
		push	ecx
		call	_ucnv_open_56
		add	esp, 8
		mov	edx, [ebp+Dst]
		mov	[edx+28h], eax
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_5099
		mov	eax, [ebp+arg_0]
		push	eax
		call	?_ISO2022Close@@YAXPAUUConverter@@@Z ; _ISO2022Close(UConverter	*)
		add	esp, 4
		jmp	loc_5337
; ---------------------------------------------------------------------------

loc_5099:				; CODE XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+426j
		cmp	[ebp+var_134], 1
		jnz	short loc_5102
		push	offset ??_C@_0BN@OIMKAGGC@ISO_2022?0locale?$DNko?0version?$DN1?$AA@ ; "ISO_2022,locale=ko,version=1"
		mov	eax, [ebp+Dst]
		add	eax, 45h ; 'E'
		push	eax		; Dest
		call	_strcpy
		add	esp, 8
		push	1
		mov	eax, [ebp+Dst]
		mov	ecx, [eax+28h]
		mov	edx, [ecx+14h]
		push	edx
		call	_uprv_checkValidMemory
		add	esp, 8
		push	4		; Size
		mov	eax, [ebp+Dst]
		mov	ecx, [eax+28h]
		mov	edx, [ecx+14h]
		push	edx		; Src
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+14h]
		push	ecx		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	eax, [ebp+Dst]
		mov	ecx, [eax+28h]
		mov	edx, [ebp+arg_0]
		mov	al, [ecx+3Dh]
		mov	[edx+3Dh], al
		jmp	short loc_5119
; ---------------------------------------------------------------------------

loc_5102:				; CODE XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+440j
		push	offset ??_C@_0BN@PBNBDHCD@ISO_2022?0locale?$DNko?0version?$DN0?$AA@ ; "ISO_2022,locale=ko,version=0"
		mov	eax, [ebp+Dst]
		add	eax, 45h ; 'E'
		push	eax		; Dest
		call	_strcpy
		add	esp, 8

loc_5119:				; CODE XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+4A0j
		mov	eax, [ebp+Dst]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?setInitialStateToUnicodeKR@@YAXPAUUConverter@@PAUUConverterDataISO2022@@@Z ; setInitialStateToUnicodeKR(UConverter *,UConverterDataISO2022 *)
		add	esp, 8
		mov	eax, [ebp+Dst]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?setInitialStateFromUnicodeKR@@YAXPAUUConverter@@PAUUConverterDataISO2022@@@Z ;	setInitialStateFromUnicodeKR(UConverter	*,UConverterDataISO2022	*)
		add	esp, 8
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+18h], offset ?_ISO2022KRData@?A0x5ec8f556@@3UUConverterSharedData@@B ; UConverterSharedData const `anonymous namespace'::_ISO2022KRData
		push	offset ??_C@_02KGFJHFEE@ko?$AA@	; "ko"
		mov	eax, [ebp+Dst]
		add	eax, 63h ; 'c'
		push	eax		; Dest
		call	_strcpy
		add	esp, 8

loc_5160:				; CODE XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+3F2j
		jmp	loc_52EE
; ---------------------------------------------------------------------------

loc_5165:				; CODE XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+336j
					; _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+34Cj ...
		movsx	eax, [ebp+Dest]
		cmp	eax, 7Ah ; 'z'
		jnz	short loc_5177
		movsx	eax, [ebp+var_F]
		cmp	eax, 68h ; 'h'
		jz	short loc_5191

loc_5177:				; CODE XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+50Cj
		movsx	eax, [ebp+Dest]
		cmp	eax, 63h ; 'c'
		jnz	loc_52E3
		movsx	eax, [ebp+var_F]
		cmp	eax, 6Eh ; 'n'
		jnz	loc_52E3

loc_5191:				; CODE XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+515j
		movsx	eax, [ebp+var_E]
		cmp	eax, 5Fh ; '_'
		jz	short loc_51A6
		movsx	eax, [ebp+var_E]
		test	eax, eax
		jnz	loc_52E3

loc_51A6:				; CODE XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+538j
		cmp	[ebp+var_134], 2
		jbe	short loc_51BD
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 2
		jmp	loc_5337
; ---------------------------------------------------------------------------

loc_51BD:				; CODE XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+54Dj
		mov	eax, [ebp+arg_8]
		push	eax
		lea	ecx, [ebp+var_11C]
		push	ecx
		lea	edx, [ebp+var_F8]
		push	edx
		push	offset ??_C@_08KJIFHEL@ibm?95478?$AA@ ;	"ibm-5478"
		call	_ucnv_loadSharedData_56
		add	esp, 10h
		mov	ecx, [ebp+Dst]
		mov	[ecx+4], eax
		cmp	[ebp+var_134], 1
		jnz	short loc_5216
		mov	eax, [ebp+arg_8]
		push	eax
		lea	ecx, [ebp+var_11C]
		push	ecx
		lea	edx, [ebp+var_F8]
		push	edx
		push	offset ??_C@_0L@OIODGLNO@iso?9ir?9165?$AA@ ; "iso-ir-165"
		call	_ucnv_loadSharedData_56
		add	esp, 10h
		mov	ecx, [ebp+Dst]
		mov	[ecx+8], eax

loc_5216:				; CODE XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+58Cj
		mov	eax, [ebp+arg_8]
		push	eax
		lea	ecx, [ebp+var_11C]
		push	ecx
		lea	edx, [ebp+var_F8]
		push	edx
		push	offset ??_C@_0P@HKOBFPCG@cns?911643?91992?$AA@ ; "cns-11643-1992"
		call	_ucnv_loadSharedData_56
		add	esp, 10h
		mov	ecx, [ebp+Dst]
		mov	[ecx+0Ch], eax
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+18h], offset ?_ISO2022CNData@?A0x5ec8f556@@3UUConverterSharedData@@B ; UConverterSharedData const `anonymous namespace'::_ISO2022CNData
		push	offset ??_C@_02LBFBBFLN@cn?$AA@	; "cn"
		mov	eax, [ebp+Dst]
		add	eax, 63h ; 'c'
		push	eax		; Dest
		call	_strcpy
		add	esp, 8
		cmp	[ebp+var_134], 0
		jnz	short loc_528E
		mov	eax, [ebp+Dst]
		mov	dword ptr [eax+40h], 0
		push	offset ??_C@_0BN@OMNIKBPD@ISO_2022?0locale?$DNzh?0version?$DN0?$AA@ ; "ISO_2022,locale=zh,version=0"
		mov	eax, [ebp+Dst]
		add	eax, 45h ; 'E'
		push	eax		; Dest
		call	_strcpy
		add	esp, 8
		jmp	short loc_52E1
; ---------------------------------------------------------------------------

loc_528E:				; CODE XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+606j
		cmp	[ebp+var_134], 1
		jnz	short loc_52BD
		mov	eax, [ebp+Dst]
		mov	dword ptr [eax+40h], 1
		push	offset ??_C@_0BN@PFMDJALC@ISO_2022?0locale?$DNzh?0version?$DN1?$AA@ ; "ISO_2022,locale=zh,version=1"
		mov	eax, [ebp+Dst]
		add	eax, 45h ; 'E'
		push	eax		; Dest
		call	_strcpy
		add	esp, 8
		jmp	short loc_52E1
; ---------------------------------------------------------------------------

loc_52BD:				; CODE XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+635j
		mov	eax, [ebp+Dst]
		mov	dword ptr [eax+40h], 2
		push	offset ??_C@_0BN@NOOOMDHB@ISO_2022?0locale?$DNzh?0version?$DN2?$AA@ ; "ISO_2022,locale=zh,version=2"
		mov	eax, [ebp+Dst]
		add	eax, 45h ; 'E'
		push	eax		; Dest
		call	_strcpy
		add	esp, 8

loc_52E1:				; CODE XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+62Cj
					; _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+65Bj
		jmp	short loc_52EE
; ---------------------------------------------------------------------------

loc_52E3:				; CODE XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+51Ej
					; _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+52Bj ...
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 2
		jmp	short loc_5337
; ---------------------------------------------------------------------------

loc_52EE:				; CODE XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+32Aj
					; _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *):loc_5160j ...
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+18h]
		mov	edx, [ecx+0Ch]
		mov	eax, [ebp+arg_0]
		mov	cl, [edx+47h]
		mov	[eax+3Ch], cl
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jnz	short loc_5320
		mov	eax, [ebp+arg_4]
		movsx	ecx, byte ptr [eax+8]
		test	ecx, ecx
		jz	short loc_532C

loc_5320:				; CODE XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+6B3j
		mov	eax, [ebp+arg_0]
		push	eax
		call	?_ISO2022Close@@YAXPAUUConverter@@@Z ; _ISO2022Close(UConverter	*)
		add	esp, 4

loc_532C:				; CODE XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+6BEj
		jmp	short loc_5337
; ---------------------------------------------------------------------------

loc_532E:				; CODE XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+57j
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 7

loc_5337:				; CODE XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+193j
					; _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+379j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN44
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 210h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?_ISO2022Open@@YAXPAUUConverter@@PAUUConverterLoadArgs@@PAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN44		dd 3			; DATA XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+6DBo
		dd offset $LN43
$LN43		dd 0FFFFFFF0h, 6	; DATA XREF: .text:0000536Co
		dd offset $LN40		; "myLocale"
		db 8, 0FFh
		dw 0FFFFh
		dd offset ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B ;	std::_Iosb<int>::_Openmode const std::_Iosb<int>::_Nocreate
		dd offset $LN41		; "stackPieces"
		dd 0FFFFFEE4h, 1Ch
		dd offset $LN42		; "stackArgs"
$LN42		db 'stackArgs',0        ; DATA XREF: .text:00005390o
$LN41		db 'stackPieces',0      ; DATA XREF: .text:00005384o
$LN40		db 'myLocale',0         ; DATA XREF: .text:00005378o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 53B4h
		public ??_C@_0BN@NOOOMDHB@ISO_2022?0locale?$DNzh?0version?$DN2?$AA@
; char `string'[]
??_C@_0BN@NOOOMDHB@ISO_2022?0locale?$DNzh?0version?$DN2?$AA@ db	'ISO_2022,locale=zh,version=2',0
					; DATA XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+66Ao
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 53D4h
		public ??_C@_0BN@PFMDJALC@ISO_2022?0locale?$DNzh?0version?$DN1?$AA@
; char `string'[]
??_C@_0BN@PFMDJALC@ISO_2022?0locale?$DNzh?0version?$DN1?$AA@ db	'ISO_2022,locale=zh,version=1',0
					; DATA XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+644o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 53F4h
		public ??_C@_0BN@OMNIKBPD@ISO_2022?0locale?$DNzh?0version?$DN0?$AA@
; char `string'[]
??_C@_0BN@OMNIKBPD@ISO_2022?0locale?$DNzh?0version?$DN0?$AA@ db	'ISO_2022,locale=zh,version=0',0
					; DATA XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+615o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5414h
		public ??_C@_02LBFBBFLN@cn?$AA@
; char `string'[3]
??_C@_02LBFBBFLN@cn?$AA@ db 'cn',0      ; DATA XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+5E8o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5418h
		public ??_C@_0P@HKOBFPCG@cns?911643?91992?$AA@
; `string'
??_C@_0P@HKOBFPCG@cns?911643?91992?$AA@	db 'cns-11643-1992',0
					; DATA XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+5C8o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5428h
		public ??_C@_0L@OIODGLNO@iso?9ir?9165?$AA@
; `string'
??_C@_0L@OIODGLNO@iso?9ir?9165?$AA@ db 'iso-ir-165',0
					; DATA XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+5A0o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5434h
		public ??_C@_02KGFJHFEE@ko?$AA@
; char `string'[3]
??_C@_02KGFJHFEE@ko?$AA@ db 'ko',0      ; DATA XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+4E9o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5438h
		public ??_C@_0BN@PBNBDHCD@ISO_2022?0locale?$DNko?0version?$DN0?$AA@
; char `string'[]
??_C@_0BN@PBNBDHCD@ISO_2022?0locale?$DNko?0version?$DN0?$AA@ db	'ISO_2022,locale=ko,version=0',0
					; DATA XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *):loc_5102o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5458h
		public ??_C@_0BN@OIMKAGGC@ISO_2022?0locale?$DNko?0version?$DN1?$AA@
; char `string'[]
??_C@_0BN@OIMKAGGC@ISO_2022?0locale?$DNko?0version?$DN1?$AA@ db	'ISO_2022,locale=ko,version=1',0
					; DATA XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+442o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5478h
		public ??_C@_07GEKOEGCG@ibm?9949?$AA@
; `string'
??_C@_07GEKOEGCG@ibm?9949?$AA@ db 'ibm-949',0
					; DATA XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *):loc_4FF3o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5480h
		public ??_C@_0BD@OMACFIPD@icu?9internal?925546?$AA@
; `string'
??_C@_0BD@OMACFIPD@icu?9internal?925546?$AA@ db	'icu-internal-25546',0
					; DATA XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+387o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5494h
		public ??_C@_0BM@OKNPDGBE@ISO_2022?0locale?$DNja?0version?$DN?$AA@
; char `string'[]
??_C@_0BM@OKNPDGBE@ISO_2022?0locale?$DNja?0version?$DN?$AA@ db 'ISO_2022,locale=ja,version=',0
					; DATA XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+2D0o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 54B0h
		public ??_C@_02DJBIDCPN@ja?$AA@
; char `string'[]
??_C@_02DJBIDCPN@ja?$AA@ db 'ja',0      ; DATA XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+2B9o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 54B4h
		public ??_C@_08PMCOPMKI@ksc_5601?$AA@
; `string'
??_C@_08PMCOPMKI@ksc_5601?$AA@ db 'ksc_5601',0
					; DATA XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+299o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 54C0h
		public ??_C@_08KJIFHEL@ibm?95478?$AA@
; `string'
??_C@_08KJIFHEL@ibm?95478?$AA@ db 'ibm-5478',0
					; DATA XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+25Bo
					; _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+56Fo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 54CCh
		public ??_C@_08IOEEBOKI@jisx?9212?$AA@
; `string'
??_C@_08IOEEBOKI@jisx?9212?$AA@	db 'jisx-212',0
					; DATA XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+220o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 54D8h
		public ??_C@_09DNLJOPNC@Shift?9JIS?$AA@
; `string'
??_C@_09DNLJOPNC@Shift?9JIS?$AA@ db 'Shift-JIS',0
					; DATA XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+1E5o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 54E4h
		public ??_C@_09KFBIDBIA@ISO8859_7?$AA@
; `string'
??_C@_09KFBIDBIA@ISO8859_7?$AA@	db 'ISO8859_7',0
					; DATA XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+1BDo
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 54F0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl U_FAILURE(enum  UErrorCode)
?U_FAILURE@@YACW4UErrorCode@@@Z	proc near
					; CODE XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+419p
					; _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+6A6p ...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		setnle	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?U_FAILURE@@YACW4UErrorCode@@@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 551Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl setInitialStateToUnicodeKR(struct UConverter *, struct UConverterDataISO2022 *)
?setInitialStateToUnicodeKR@@YAXPAUUConverter@@PAUUConverterDataISO2022@@@Z proc near
					; CODE XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+4C4p
					; _ISO2022Reset(UConverter *,UConverterResetChoice)+84p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		cmp	dword ptr [eax+40h], 1
		jnz	short loc_5567
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax+28h]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+2Ch], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+30h], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+24h], 0

loc_5567:				; CODE XREF: setInitialStateToUnicodeKR(UConverter *,UConverterDataISO2022 *)+25j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?setInitialStateToUnicodeKR@@YAXPAUUConverter@@PAUUConverterDataISO2022@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5570h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl setInitialStateFromUnicodeKR(struct UConverter *, struct	UConverterDataISO2022 *)
?setInitialStateFromUnicodeKR@@YAXPAUUConverter@@PAUUConverterDataISO2022@@@Z proc near
					; CODE XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+4D7p
					; _ISO2022Reset(UConverter *,UConverterResetChoice)+9Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		movsx	ecx, byte ptr [eax+3Fh]
		test	ecx, ecx
		jnz	short loc_55BC
		mov	eax, [ebp+arg_0]
		mov	byte ptr [eax+3Fh], 4
		mov	eax, [ebp+arg_0]
		mov	byte ptr [eax+4Ch], 1Bh
		mov	eax, [ebp+arg_0]
		mov	byte ptr [eax+4Dh], 24h	; '$'
		mov	eax, [ebp+arg_0]
		mov	byte ptr [eax+4Eh], 29h	; ')'
		mov	eax, [ebp+arg_0]
		mov	byte ptr [eax+4Fh], 43h	; 'C'

loc_55BC:				; CODE XREF: setInitialStateFromUnicodeKR(UConverter *,UConverterDataISO2022 *)+27j
		mov	eax, [ebp+arg_4]
		cmp	dword ptr [eax+40h], 1
		jnz	short loc_55E2
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax+28h]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+38h], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+34h], 1

loc_55E2:				; CODE XREF: setInitialStateFromUnicodeKR(UConverter *,UConverterDataISO2022 *)+53j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?setInitialStateFromUnicodeKR@@YAXPAUUConverter@@PAUUConverterDataISO2022@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 55ECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl _ISO2022Close(struct UConverter *)
?_ISO2022Close@@YAXPAUUConverter@@@Z proc near
					; CODE XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+42Cp
					; _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+6C4p
					; DATA XREF: ...

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+8], 0
		jz	short loc_568D
		mov	[ebp+var_20], 0
		jmp	short loc_5634
; ---------------------------------------------------------------------------

loc_562B:				; CODE XREF: _ISO2022Close(UConverter *):loc_5658j
		mov	eax, [ebp+var_20]
		add	eax, 1
		mov	[ebp+var_20], eax

loc_5634:				; CODE XREF: _ISO2022Close(UConverter *)+3Dj
		cmp	[ebp+var_20], 0Ah
		jge	short loc_565A
		mov	eax, [ebp+var_20]
		mov	ecx, [ebp+var_14]
		cmp	dword ptr [ecx+eax*4], 0
		jz	short loc_5658
		mov	eax, [ebp+var_20]
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+eax*4]
		push	edx
		call	_ucnv_unloadSharedDataIfReady_56
		add	esp, 4

loc_5658:				; CODE XREF: _ISO2022Close(UConverter *)+58j
		jmp	short loc_562B
; ---------------------------------------------------------------------------

loc_565A:				; CODE XREF: _ISO2022Close(UConverter *)+4Cj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+28h]
		push	ecx
		call	_ucnv_close_56
		add	esp, 4
		mov	eax, [ebp+arg_0]
		movsx	ecx, byte ptr [eax+22h]
		test	ecx, ecx
		jnz	short loc_568D
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		push	ecx
		call	_uprv_free_56
		add	esp, 4
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+8], 0

loc_568D:				; CODE XREF: _ISO2022Close(UConverter *)+34j
					; _ISO2022Close(UConverter *)+86j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?_ISO2022Close@@YAXPAUUConverter@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 56A4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl _ISO2022Reset(struct UConverter *, enum	UConverterResetChoice)
?_ISO2022Reset@@YAXPAUUConverter@@W4UConverterResetChoice@@@Z proc near
					; DATA XREF: .rdata:0000058Co
					; .rdata:00000724o ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_4], 1
		jg	short loc_56F5
		push	6		; Size
		push	0		; Val
		mov	eax, [ebp+var_8]
		add	eax, 30h ; '0'
		push	eax		; Dst
		call	_memset
		add	esp, 0Ch
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+3Ch], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+44h], 0

loc_56F5:				; CODE XREF: _ISO2022Reset(UConverter *,UConverterResetChoice)+2Bj
		cmp	[ebp+arg_4], 1
		jz	short loc_570E
		push	6		; Size
		push	0		; Val
		mov	eax, [ebp+var_8]
		add	eax, 36h ; '6'
		push	eax		; Dst
		call	_memset
		add	esp, 0Ch

loc_570E:				; CODE XREF: _ISO2022Reset(UConverter *,UConverterResetChoice)+55j
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+63h]
		cmp	ecx, 6Bh ; 'k'
		jnz	short loc_5746
		cmp	[ebp+arg_4], 1
		jg	short loc_5730
		mov	eax, [ebp+var_8]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?setInitialStateToUnicodeKR@@YAXPAUUConverter@@PAUUConverterDataISO2022@@@Z ; setInitialStateToUnicodeKR(UConverter *,UConverterDataISO2022 *)
		add	esp, 8

loc_5730:				; CODE XREF: _ISO2022Reset(UConverter *,UConverterResetChoice)+7Aj
		cmp	[ebp+arg_4], 1
		jz	short loc_5746
		mov	eax, [ebp+var_8]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?setInitialStateFromUnicodeKR@@YAXPAUUConverter@@PAUUConverterDataISO2022@@@Z ;	setInitialStateFromUnicodeKR(UConverter	*,UConverterDataISO2022	*)
		add	esp, 8

loc_5746:				; CODE XREF: _ISO2022Reset(UConverter *,UConverterResetChoice)+74j
					; _ISO2022Reset(UConverter *,UConverterResetChoice)+90j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?_ISO2022Reset@@YAXPAUUConverter@@W4UConverterResetChoice@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 575Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; char const * __cdecl _ISO2022getName(struct UConverter const *)
?_ISO2022getName@@YAPBDPBUUConverter@@@Z proc near ; DATA XREF:	.rdata:000005A8o
					; .rdata:00000740o ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+8], 0
		jz	short loc_5794
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		add	eax, 45h ; 'E'
		jmp	short loc_5796
; ---------------------------------------------------------------------------

loc_5794:				; CODE XREF: _ISO2022getName(UConverter	const *)+25j
		xor	eax, eax

loc_5796:				; CODE XREF: _ISO2022getName(UConverter	const *)+36j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?_ISO2022getName@@YAPBDPBUUConverter@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 57A0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(struct UConverterFromUnicodeArgs *, enum  UErrorCode *)
?UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC@@YAXPAUUConverterFromUnicodeArgs@@PAW4UErrorCode@@@Z proc near
					; DATA XREF: .rdata:00000730o
					; .rdata:00000734o

var_224		= dword	ptr -224h
var_15C		= dword	ptr -15Ch
var_150		= dword	ptr -150h
var_144		= dword	ptr -144h
Size		= dword	ptr -138h
var_129		= byte ptr -129h
var_120		= dword	ptr -120h
var_114		= dword	ptr -114h
var_108		= word ptr -108h
var_FC		= word ptr -0FCh
var_ED		= byte ptr -0EDh
var_E1		= byte ptr -0E1h
var_D8		= dword	ptr -0D8h
var_C9		= byte ptr -0C9h
var_C0		= dword	ptr -0C0h
var_B4		= dword	ptr -0B4h
var_A8		= byte ptr -0A8h
var_94		= dword	ptr -94h
var_88		= dword	ptr -88h
Dst		= byte ptr -7Ch
var_7B		= byte ptr -7Bh
var_6C		= dword	ptr -6Ch
var_60		= dword	ptr -60h
var_54		= dword	ptr -54h
var_48		= dword	ptr -48h
var_3C		= dword	ptr -3Ch
var_30		= dword	ptr -30h
var_24		= dword	ptr -24h
var_18		= dword	ptr -18h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 224h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_224]
		mov	ecx, 89h ; ''
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	[ebp+var_C], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		mov	[ebp+var_30], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+14h]
		mov	[ebp+var_3C], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		mov	[ebp+var_48], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+0Ch]
		mov	[ebp+var_54], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+18h]
		mov	[ebp+var_60], ecx
		mov	[ebp+var_C0], 0
		mov	eax, [ebp+var_C]
		mov	ecx, [eax+8]
		mov	[ebp+var_18], ecx
		mov	eax, [ebp+var_18]
		add	eax, 36h ; '6'
		mov	[ebp+var_24], eax
		mov	[ebp+var_B4], 0
		mov	eax, [ebp+var_C]
		mov	ecx, [eax+38h]
		mov	[ebp+var_6C], ecx
		cmp	[ebp+var_6C], 0
		jz	short loc_583F
		mov	eax, [ebp+var_30]
		cmp	eax, [ebp+var_3C]
		jnb	short loc_583F
		jmp	short $getTrail$37772
; ---------------------------------------------------------------------------
		jmp	short $getTrail$37772
; ---------------------------------------------------------------------------

loc_583F:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+91j
					; UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)+99j ...
		mov	eax, [ebp+var_48]
		cmp	eax, [ebp+var_54]
		jnb	loc_62A5
		mov	eax, [ebp+var_30]
		cmp	eax, [ebp+var_3C]
		jnb	loc_6295
		mov	eax, [ebp+var_48]
		movzx	ecx, word ptr [eax]
		mov	[ebp+var_6C], ecx
		mov	edx, [ebp+var_48]
		add	edx, 2
		mov	[ebp+var_48], edx
		mov	eax, [ebp+var_6C]
		and	eax, 0FFFFF800h
		cmp	eax, 0D800h
		jnz	loc_591A
		mov	eax, [ebp+var_6C]
		and	eax, 400h
		jnz	short loc_5903

$getTrail$37772:			; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+9Bj
					; UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)+9Dj
		mov	eax, [ebp+var_48]
		cmp	eax, [ebp+var_54]
		jnb	short loc_58F3
		mov	eax, [ebp+var_48]
		mov	cx, [eax]
		mov	[ebp+var_FC], cx
		movzx	eax, [ebp+var_FC]
		and	eax, 0FFFFFC00h
		cmp	eax, 0DC00h
		jnz	short loc_58DA
		mov	eax, [ebp+var_48]
		add	eax, 2
		mov	[ebp+var_48], eax
		mov	eax, [ebp+var_6C]
		shl	eax, 0Ah
		movzx	ecx, [ebp+var_FC]
		lea	edx, [eax+ecx-35FDC00h]
		mov	[ebp+var_6C], edx
		mov	eax, [ebp+var_C]
		mov	dword ptr [eax+38h], 0
		jmp	short loc_58F1
; ---------------------------------------------------------------------------

loc_58DA:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+10Cj
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Ch
		mov	eax, [ebp+var_C]
		mov	ecx, [ebp+var_6C]
		mov	[eax+38h], ecx
		jmp	loc_62A5
; ---------------------------------------------------------------------------

loc_58F1:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+138j
		jmp	short loc_5901
; ---------------------------------------------------------------------------

loc_58F3:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+ECj
		mov	eax, [ebp+var_C]
		mov	ecx, [ebp+var_6C]
		mov	[eax+38h], ecx
		jmp	loc_62A5
; ---------------------------------------------------------------------------

loc_5901:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *):loc_58F1j
		jmp	short loc_591A
; ---------------------------------------------------------------------------

loc_5903:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+E4j
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Ch
		mov	eax, [ebp+var_C]
		mov	ecx, [ebp+var_6C]
		mov	[eax+38h], ecx
		jmp	loc_62A5
; ---------------------------------------------------------------------------

loc_591A:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+D6j
					; UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *):loc_5901j
		cmp	[ebp+var_6C], 20h ; ' '
		jge	short loc_5948
		mov	eax, 1
		mov	ecx, [ebp+var_6C]
		shl	eax, cl
		and	eax, 800C000h
		jz	short loc_5948
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Ch
		mov	eax, [ebp+var_C]
		mov	ecx, [ebp+var_6C]
		mov	[eax+38h], ecx
		jmp	loc_62A5
; ---------------------------------------------------------------------------

loc_5948:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+17Ej
					; UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)+18Fj
		cmp	[ebp+var_B4], 0
		jnz	loc_5AF3
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+40h]
		mov	dx, ds:_jpCharsetMasks[ecx*2]
		mov	[ebp+var_108], dx
		mov	[ebp+var_B4], 0
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+40h], 3
		jz	short loc_5986
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+40h], 4
		jnz	short loc_59A3

loc_5986:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+1DBj
		mov	eax, [ebp+var_B4]
		mov	[ebp+eax+var_A8], 8
		mov	ecx, [ebp+var_B4]
		add	ecx, 1
		mov	[ebp+var_B4], ecx

loc_59A3:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+1E4j
		movzx	eax, [ebp+var_108]
		and	eax, 0FFFFFEFFh
		mov	[ebp+var_108], ax
		mov	eax, [ebp+var_24]
		mov	cl, [eax]
		mov	[ebp+var_E1], cl
		mov	edx, [ebp+var_B4]
		mov	al, [ebp+var_E1]
		mov	[ebp+edx+var_A8], al
		mov	ecx, [ebp+var_B4]
		add	ecx, 1
		mov	[ebp+var_B4], ecx
		movsx	ecx, [ebp+var_E1]
		mov	eax, 1
		shl	eax, cl
		not	eax
		movzx	ecx, [ebp+var_108]
		and	ecx, eax
		mov	[ebp+var_108], cx
		mov	eax, [ebp+var_24]
		mov	cl, [eax+2]
		mov	[ebp+var_E1], cl
		movsx	edx, [ebp+var_E1]
		test	edx, edx
		jz	short loc_5A5C
		mov	eax, [ebp+var_B4]
		mov	cl, [ebp+var_E1]
		mov	[ebp+eax+var_A8], cl
		mov	edx, [ebp+var_B4]
		add	edx, 1
		mov	[ebp+var_B4], edx
		movsx	ecx, [ebp+var_E1]
		mov	eax, 1
		shl	eax, cl
		not	eax
		movzx	ecx, [ebp+var_108]
		and	ecx, eax
		mov	[ebp+var_108], cx

loc_5A5C:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+278j
		mov	[ebp+var_D8], 0
		jmp	short loc_5A77
; ---------------------------------------------------------------------------

loc_5A68:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *):loc_5AEEj
		mov	eax, [ebp+var_D8]
		add	eax, 1
		mov	[ebp+var_D8], eax

loc_5A77:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+2C6j
		cmp	[ebp+var_D8], 9
		jge	short loc_5AF3
		mov	eax, [ebp+var_D8]
		mov	cl, ds:_jpCharsetPref[eax*4]
		mov	[ebp+var_E1], cl
		movsx	ecx, [ebp+var_E1]
		mov	eax, 1
		shl	eax, cl
		movzx	ecx, [ebp+var_108]
		and	eax, ecx
		jz	short loc_5AEE
		mov	eax, [ebp+var_B4]
		mov	cl, [ebp+var_E1]
		mov	[ebp+eax+var_A8], cl
		mov	edx, [ebp+var_B4]
		add	edx, 1
		mov	[ebp+var_B4], edx
		movsx	ecx, [ebp+var_E1]
		mov	eax, 1
		shl	eax, cl
		not	eax
		movzx	ecx, [ebp+var_108]
		and	ecx, eax
		mov	[ebp+var_108], cx

loc_5AEE:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+30Aj
		jmp	loc_5A68
; ---------------------------------------------------------------------------

loc_5AF3:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+1AFj
					; UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)+2DEj
		mov	[ebp+var_ED], 0
		mov	al, [ebp+var_ED]
		mov	[ebp+var_E1], al
		mov	[ebp+var_88], 0
		mov	eax, [ebp+var_C]
		mov	cl, [eax+23h]
		mov	[ebp+var_C9], cl
		mov	[ebp+var_D8], 0
		jmp	short loc_5B37
; ---------------------------------------------------------------------------

loc_5B28:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *):loc_5F3Ej
		mov	eax, [ebp+var_D8]
		add	eax, 1
		mov	[ebp+var_D8], eax

loc_5B37:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+386j
		mov	eax, [ebp+var_D8]
		cmp	eax, [ebp+var_B4]
		jge	loc_5F43
		cmp	[ebp+var_88], 0
		jg	loc_5F43
		mov	eax, [ebp+var_D8]
		mov	cl, [ebp+eax+var_A8]
		mov	[ebp+var_129], cl
		movsx	eax, [ebp+var_129]
		mov	[ebp+var_224], eax
		cmp	[ebp+var_224], 8 ; switch 9 cases
		ja	$LN35		; jumptable 00005B89 default case
		mov	ecx, [ebp+var_224]
		jmp	ds:$LN92[ecx*4]	; switch jump
; ---------------------------------------------------------------------------

$LN56:					; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+3E9j
					; DATA XREF: .text:$LN92o
		cmp	[ebp+var_6C], 7Fh ; '' ; jumptable 00005B89 case 0
		jg	short loc_5BBC
		mov	eax, [ebp+var_6C]
		mov	[ebp+var_C0], eax
		mov	[ebp+var_88], 1
		mov	al, [ebp+var_129]
		mov	[ebp+var_E1], al
		mov	[ebp+var_ED], 0

loc_5BBC:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+3F4j
		jmp	loc_5F3E
; ---------------------------------------------------------------------------

$LN54:					; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+3E9j
					; DATA XREF: .text:$LN92o
		cmp	[ebp+var_6C], 0A0h ; '' ; jumptable 00005B89 case 1
		jl	short loc_5BFE
		cmp	[ebp+var_6C], 0FFh
		jg	short loc_5BFE
		mov	eax, [ebp+var_6C]
		sub	eax, 80h ; ''
		mov	[ebp+var_C0], eax
		mov	[ebp+var_88], 1
		mov	al, [ebp+var_129]
		mov	[ebp+var_E1], al
		mov	[ebp+var_ED], 2

loc_5BFE:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+428j
					; UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)+431j
		jmp	loc_5F3E
; ---------------------------------------------------------------------------

$LN52:					; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+3E9j
					; DATA XREF: .text:$LN92o
		mov	eax, [ebp+var_6C] ; jumptable 00005B89 case 8
		sub	eax, 0FF61h
		cmp	eax, 3Eh ; '>'
		ja	loc_5CA8
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+40h], 3
		jnz	short loc_5C56
		mov	eax, [ebp+var_6C]
		sub	eax, 0FF40h
		mov	[ebp+var_C0], eax
		mov	[ebp+var_88], 1
		mov	al, [ebp+var_129]
		mov	[ebp+var_E1], al
		mov	ecx, [ebp+var_24]
		mov	dl, [ebp+var_E1]
		mov	[ecx+1], dl
		mov	[ebp+var_ED], 1
		jmp	short loc_5CA8
; ---------------------------------------------------------------------------

loc_5C56:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+47Bj
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+40h], 4
		jnz	short loc_5CA8
		mov	eax, [ebp+var_6C]
		sub	eax, 0FEC0h
		mov	[ebp+var_C0], eax
		mov	[ebp+var_88], 1
		mov	eax, [ebp+var_24]
		mov	cl, [eax]
		mov	[ebp+var_E1], cl
		movsx	eax, [ebp+var_E1]
		cmp	eax, 4
		jl	short loc_5CA1
		movsx	eax, [ebp+var_E1]
		cmp	eax, 7
		jg	short loc_5CA1
		mov	[ebp+var_E1], 3

loc_5CA1:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+4ECj
					; UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)+4F8j
		mov	[ebp+var_ED], 0

loc_5CA8:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+46Ej
					; UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)+4B4j ...
		jmp	loc_5F3E
; ---------------------------------------------------------------------------

$LN46:					; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+3E9j
					; DATA XREF: .text:$LN92o
		mov	eax, [ebp+var_6C] ; jumptable 00005B89 case 3
		push	eax
		call	?jisx201FromU@@YAII@Z ;	jisx201FromU(uint)
		add	esp, 4
		mov	[ebp+var_114], eax
		cmp	[ebp+var_114], 7Fh ; ''
		ja	short loc_5CF8
		mov	eax, [ebp+var_114]
		mov	[ebp+var_C0], eax
		mov	[ebp+var_88], 1
		mov	al, [ebp+var_129]
		mov	[ebp+var_E1], al
		mov	[ebp+var_ED], 0
		mov	[ebp+var_C9], 0

loc_5CF8:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+526j
		jmp	loc_5F3E
; ---------------------------------------------------------------------------

$LN44_0:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+3E9j
					; DATA XREF: .text:$LN92o
		push	1		; jumptable 00005B89 case 4
		movzx	eax, [ebp+var_C9]
		push	eax
		lea	ecx, [ebp+var_114]
		push	ecx
		mov	edx, [ebp+var_6C]
		push	edx
		movsx	eax, [ebp+var_129]
		mov	ecx, [ebp+var_18]
		mov	edx, [ecx+eax*4]
		push	edx
		call	?MBCS_FROM_UCHAR32_ISO2022@@YAHPAUUConverterSharedData@@HPAICH@Z ; MBCS_FROM_UCHAR32_ISO2022(UConverterSharedData *,int,uint *,signed char,int)
		add	esp, 14h
		mov	[ebp+var_120], eax
		cmp	[ebp+var_120], 2
		jz	short loc_5D49
		cmp	[ebp+var_120], 0FFFFFFFEh
		jnz	short loc_5D9B
		cmp	[ebp+var_88], 0
		jnz	short loc_5D9B

loc_5D49:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+595j
		mov	eax, [ebp+var_114]
		push	eax
		call	?_2022FromSJIS@@YAII@Z ; _2022FromSJIS(uint)
		add	esp, 4
		mov	[ebp+var_114], eax
		cmp	[ebp+var_114], 0
		jz	short loc_5D99
		mov	eax, [ebp+var_114]
		mov	[ebp+var_C0], eax
		mov	eax, [ebp+var_120]
		mov	[ebp+var_88], eax
		mov	al, [ebp+var_129]
		mov	[ebp+var_E1], al
		mov	[ebp+var_ED], 0
		mov	[ebp+var_C9], 0

loc_5D99:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+5C5j
		jmp	short loc_5DF1
; ---------------------------------------------------------------------------

loc_5D9B:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+59Ej
					; UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)+5A7j
		cmp	[ebp+var_88], 0
		jnz	short loc_5DF1
		movsx	eax, [ebp+var_C9]
		test	eax, eax
		jz	short loc_5DF1
		mov	eax, [ebp+var_6C]
		sub	eax, 0FF61h
		cmp	eax, 3Eh ; '>'
		ja	short loc_5DF1
		mov	eax, [ebp+var_6C]
		movzx	ecx, word ptr (byte_BD3-2060Dh)[eax*2]
		mov	[ebp+var_C0], ecx
		mov	[ebp+var_88], 0FFFFFFFEh
		mov	al, [ebp+var_129]
		mov	[ebp+var_E1], al
		mov	[ebp+var_ED], 0
		mov	[ebp+var_C9], 0

loc_5DF1:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *):loc_5D99j
					; UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)+602j ...
		jmp	loc_5F3E
; ---------------------------------------------------------------------------

$LN38:					; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+3E9j
					; DATA XREF: .text:$LN92o
		movzx	eax, [ebp+var_C9] ; jumptable 00005B89 case 2
		push	eax
		lea	ecx, [ebp+var_114]
		push	ecx
		mov	edx, [ebp+var_6C]
		push	edx
		movsx	eax, [ebp+var_129]
		mov	ecx, [ebp+var_18]
		mov	edx, [ecx+eax*4]
		push	edx
		call	?MBCS_SINGLE_FROM_UCHAR32@@YAHPAUUConverterSharedData@@HPAIC@Z ; MBCS_SINGLE_FROM_UCHAR32(UConverterSharedData *,int,uint *,signed char)
		add	esp, 10h
		mov	[ebp+var_120], eax
		cmp	[ebp+var_120], 0
		jz	short loc_5E8F
		cmp	[ebp+var_120], 0
		jge	short loc_5E40
		cmp	[ebp+var_88], 0
		jnz	short loc_5E8F

loc_5E40:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+695j
		cmp	[ebp+var_114], 0A0h ; ''
		jb	short loc_5E8F
		cmp	[ebp+var_114], 0FFh
		ja	short loc_5E8F
		mov	eax, [ebp+var_114]
		sub	eax, 80h ; ''
		mov	[ebp+var_C0], eax
		mov	eax, [ebp+var_120]
		mov	[ebp+var_88], eax
		mov	al, [ebp+var_129]
		mov	[ebp+var_E1], al
		mov	[ebp+var_ED], 2
		mov	[ebp+var_C9], 0

loc_5E8F:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+68Cj
					; UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)+69Ej ...
		jmp	loc_5F3E
; ---------------------------------------------------------------------------

$LN35:					; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+3DDj
					; UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)+3E9j
					; DATA XREF: ...
		push	1		; jumptable 00005B89 default case
		movzx	eax, [ebp+var_C9]
		push	eax
		lea	ecx, [ebp+var_114]
		push	ecx
		mov	edx, [ebp+var_6C]
		push	edx
		movsx	eax, [ebp+var_129]
		mov	ecx, [ebp+var_18]
		mov	edx, [ecx+eax*4]
		push	edx
		call	?MBCS_FROM_UCHAR32_ISO2022@@YAHPAUUConverterSharedData@@HPAICH@Z ; MBCS_FROM_UCHAR32_ISO2022(UConverterSharedData *,int,uint *,signed char,int)
		add	esp, 14h
		mov	[ebp+var_120], eax
		cmp	[ebp+var_120], 2
		jz	short loc_5EE0
		cmp	[ebp+var_120], 0FFFFFFFEh
		jnz	short loc_5F3E
		cmp	[ebp+var_88], 0
		jnz	short loc_5F3E

loc_5EE0:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+72Cj
		movsx	eax, [ebp+var_129]
		cmp	eax, 7
		jnz	short loc_5F0C
		mov	eax, [ebp+var_114]
		push	eax
		call	?_2022FromGR94DBCS@@YAII@Z ; _2022FromGR94DBCS(uint)
		add	esp, 4
		mov	[ebp+var_114], eax
		cmp	[ebp+var_114], 0
		jnz	short loc_5F0C
		jmp	short loc_5F3E
; ---------------------------------------------------------------------------

loc_5F0C:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+74Aj
					; UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)+768j
		mov	eax, [ebp+var_114]
		mov	[ebp+var_C0], eax
		mov	eax, [ebp+var_120]
		mov	[ebp+var_88], eax
		mov	al, [ebp+var_129]
		mov	[ebp+var_E1], al
		mov	[ebp+var_ED], 0
		mov	[ebp+var_C9], 0

loc_5F3E:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *):loc_5BBCj
					; UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *):loc_5BFEj	...
		jmp	loc_5B28
; ---------------------------------------------------------------------------

loc_5F43:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+3A3j
					; UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)+3B0j
		cmp	[ebp+var_88], 0
		jz	loc_613B
		cmp	[ebp+var_88], 0
		jge	short loc_5F67
		mov	eax, [ebp+var_88]
		neg	eax
		mov	[ebp+var_88], eax

loc_5F67:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+7B7j
		mov	[ebp+var_94], 0
		mov	eax, [ebp+var_24]
		movsx	ecx, byte ptr [eax+4]
		cmp	ecx, 1
		jnz	short loc_5FA9
		movsx	eax, [ebp+var_ED]
		test	eax, eax
		jnz	short loc_5FA9
		mov	eax, [ebp+var_94]
		mov	[ebp+eax+Dst], 0Fh
		mov	ecx, [ebp+var_94]
		add	ecx, 1
		mov	[ebp+var_94], ecx
		mov	eax, [ebp+var_24]
		mov	byte ptr [eax+4], 0

loc_5FA9:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+7DBj
					; UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)+7E6j
		movsx	eax, [ebp+var_E1]
		movsx	ecx, [ebp+var_ED]
		mov	edx, [ebp+var_24]
		movsx	ecx, byte ptr [edx+ecx]
		cmp	eax, ecx
		jz	loc_604E
		movsx	eax, [ebp+var_E1]
		movsx	ecx, ds:_escSeqCharsLen[eax]
		mov	[ebp+Size], ecx
		push	1
		movsx	eax, [ebp+var_E1]
		imul	eax, 6
		add	eax, offset _escSeqChars
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	ecx, [ebp+Size]
		push	ecx		; Size
		movsx	edx, [ebp+var_E1]
		imul	edx, 6
		add	edx, offset _escSeqChars
		push	edx		; Src
		mov	eax, [ebp+var_94]
		lea	ecx, [ebp+eax+Dst]
		push	ecx		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	eax, [ebp+var_94]
		add	eax, [ebp+Size]
		mov	[ebp+var_94], eax
		movsx	eax, [ebp+var_ED]
		mov	ecx, [ebp+var_24]
		mov	dl, [ebp+var_E1]
		mov	[ecx+eax], dl
		mov	[ebp+var_B4], 0

loc_604E:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+820j
		movsx	eax, [ebp+var_ED]
		mov	ecx, [ebp+var_24]
		movsx	edx, byte ptr [ecx+4]
		cmp	eax, edx
		jz	short loc_60CE
		mov	al, [ebp+var_ED]
		mov	byte ptr [ebp+var_224],	al
		cmp	byte ptr [ebp+var_224],	1
		jz	short loc_6077
		jmp	short loc_609A
; ---------------------------------------------------------------------------

loc_6077:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+8D3j
		mov	eax, [ebp+var_94]
		mov	[ebp+eax+Dst], 0Eh
		mov	ecx, [ebp+var_94]
		add	ecx, 1
		mov	[ebp+var_94], ecx
		mov	eax, [ebp+var_24]
		mov	byte ptr [eax+4], 1
		jmp	short loc_60CE
; ---------------------------------------------------------------------------

loc_609A:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+8D5j
		mov	eax, [ebp+var_94]
		mov	[ebp+eax+Dst], 1Bh
		mov	ecx, [ebp+var_94]
		add	ecx, 1
		mov	[ebp+var_94], ecx
		mov	eax, [ebp+var_94]
		mov	[ebp+eax+Dst], 4Eh ; 'N'
		mov	ecx, [ebp+var_94]
		add	ecx, 1
		mov	[ebp+var_94], ecx

loc_60CE:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+8BEj
					; UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)+8F8j
		cmp	[ebp+var_88], 1
		jnz	short loc_60F8
		mov	eax, [ebp+var_94]
		mov	cl, byte ptr [ebp+var_C0]
		mov	[ebp+eax+Dst], cl
		mov	edx, [ebp+var_94]
		add	edx, 1
		mov	[ebp+var_94], edx
		jmp	short loc_6139
; ---------------------------------------------------------------------------

loc_60F8:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+935j
		mov	eax, [ebp+var_C0]
		shr	eax, 8
		mov	ecx, [ebp+var_94]
		mov	[ebp+ecx+Dst], al
		mov	edx, [ebp+var_94]
		add	edx, 1
		mov	[ebp+var_94], edx
		mov	eax, [ebp+var_94]
		mov	cl, byte ptr [ebp+var_C0]
		mov	[ebp+eax+Dst], cl
		mov	edx, [ebp+var_94]
		add	edx, 1
		mov	[ebp+var_94], edx

loc_6139:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+956j
		jmp	short loc_6152
; ---------------------------------------------------------------------------

loc_613B:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+7AAj
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Ah
		mov	eax, [ebp+var_C]
		mov	ecx, [ebp+var_6C]
		mov	[eax+38h], ecx
		jmp	loc_62A5
; ---------------------------------------------------------------------------

loc_6152:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *):loc_6139j
		cmp	[ebp+var_6C], 0Dh
		jz	short loc_615E
		cmp	[ebp+var_6C], 0Ah
		jnz	short loc_616F

loc_615E:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+9B6j
		mov	eax, [ebp+var_24]
		mov	byte ptr [eax+2], 0
		mov	[ebp+var_B4], 0

loc_616F:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+9BCj
		cmp	[ebp+var_94], 1
		jnz	short loc_61B0
		mov	eax, [ebp+var_30]
		mov	cl, [ebp+Dst]
		mov	[eax], cl
		mov	edx, [ebp+var_30]
		add	edx, 1
		mov	[ebp+var_30], edx
		cmp	[ebp+var_60], 0
		jz	short loc_61AB
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_48]
		sub	ecx, [eax+8]
		sar	ecx, 1
		sub	ecx, 1
		mov	edx, [ebp+var_60]
		mov	[edx], ecx
		mov	eax, [ebp+var_60]
		add	eax, 4
		mov	[ebp+var_60], eax

loc_61AB:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+9EDj
		jmp	loc_6293
; ---------------------------------------------------------------------------

loc_61B0:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+9D6j
		cmp	[ebp+var_94], 2
		jnz	short loc_6238
		mov	eax, [ebp+var_30]
		add	eax, 2
		cmp	eax, [ebp+var_3C]
		ja	short loc_6238
		mov	eax, [ebp+var_30]
		mov	cl, [ebp+Dst]
		mov	[eax], cl
		mov	edx, [ebp+var_30]
		add	edx, 1
		mov	[ebp+var_30], edx
		mov	eax, [ebp+var_30]
		mov	cl, [ebp+var_7B]
		mov	[eax], cl
		mov	edx, [ebp+var_30]
		add	edx, 1
		mov	[ebp+var_30], edx
		cmp	[ebp+var_60], 0
		jz	short loc_6236
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_48]
		sub	ecx, [eax+8]
		sar	ecx, 1
		mov	edx, 0FFFFh
		cmp	edx, [ebp+var_6C]
		sbb	eax, eax
		neg	eax
		add	eax, 1
		sub	ecx, eax
		mov	[ebp+var_144], ecx
		mov	eax, [ebp+var_60]
		mov	ecx, [ebp+var_144]
		mov	[eax], ecx
		mov	edx, [ebp+var_60]
		add	edx, 4
		mov	[ebp+var_60], edx
		mov	eax, [ebp+var_60]
		mov	ecx, [ebp+var_144]
		mov	[eax], ecx
		mov	edx, [ebp+var_60]
		add	edx, 4
		mov	[ebp+var_60], edx

loc_6236:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+A4Aj
		jmp	short loc_6293
; ---------------------------------------------------------------------------

loc_6238:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+A17j
					; UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)+A22j
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ebp+var_48]
		sub	edx, [ecx+8]
		sar	edx, 1
		mov	eax, 0FFFFh
		cmp	eax, [ebp+var_6C]
		sbb	ecx, ecx
		neg	ecx
		add	ecx, 1
		sub	edx, ecx
		push	edx
		lea	edx, [ebp+var_60]
		push	edx
		mov	eax, [ebp+var_3C]
		push	eax
		lea	ecx, [ebp+var_30]
		push	ecx
		mov	edx, [ebp+var_94]
		push	edx
		lea	eax, [ebp+Dst]
		push	eax
		mov	ecx, [ebp+var_C]
		push	ecx
		call	?fromUWriteUInt8@@YAXPAUUConverter@@PBDHPAPAE1PAPAHHPAW4UErrorCode@@@Z ; fromUWriteUInt8(UConverter *,char const *,int,uchar * *,char const *,int * *,int,UErrorCode *)
		add	esp, 20h
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_6293
		jmp	short loc_62A5
; ---------------------------------------------------------------------------

loc_6293:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *):loc_61ABj
					; UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *):loc_6236j	...
		jmp	short loc_62A0
; ---------------------------------------------------------------------------

loc_6295:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+B1j
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Fh
		jmp	short loc_62A5
; ---------------------------------------------------------------------------

loc_62A0:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *):loc_6293j
		jmp	loc_583F
; ---------------------------------------------------------------------------

loc_62A5:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+A5j
					; UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)+14Cj ...
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	loc_6446
		mov	eax, [ebp+var_24]
		movsx	ecx, byte ptr [eax+4]
		test	ecx, ecx
		jnz	short loc_62D7
		mov	eax, [ebp+var_24]
		movsx	ecx, byte ptr [eax]
		test	ecx, ecx
		jz	loc_6446

loc_62D7:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+B27j
		mov	eax, [ebp+arg_0]
		movsx	ecx, byte ptr [eax+2]
		test	ecx, ecx
		jz	loc_6446
		mov	eax, [ebp+var_48]
		cmp	eax, [ebp+var_54]
		jb	loc_6446
		mov	eax, [ebp+var_C]
		cmp	dword ptr [eax+38h], 0
		jnz	loc_6446
		mov	[ebp+var_94], 0
		mov	eax, [ebp+var_24]
		movsx	ecx, byte ptr [eax+4]
		test	ecx, ecx
		jz	short loc_6335
		mov	eax, [ebp+var_94]
		mov	[ebp+eax+Dst], 0Fh
		mov	ecx, [ebp+var_94]
		add	ecx, 1
		mov	[ebp+var_94], ecx
		mov	eax, [ebp+var_24]
		mov	byte ptr [eax+4], 0

loc_6335:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+B72j
		mov	eax, [ebp+var_24]
		movsx	ecx, byte ptr [eax]
		test	ecx, ecx
		jz	short loc_6392
		movsx	eax, ds:_escSeqCharsLen
		mov	[ebp+var_15C], eax
		push	1
		push	offset _escSeqChars
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	eax, [ebp+var_15C]
		push	eax		; Size
		push	offset _escSeqChars ; Src
		mov	ecx, [ebp+var_94]
		lea	edx, [ebp+ecx+Dst]
		push	edx		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	eax, [ebp+var_94]
		add	eax, [ebp+var_15C]
		mov	[ebp+var_94], eax
		mov	eax, [ebp+var_24]
		mov	byte ptr [eax],	0

loc_6392:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+B9Dj
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_48]
		sub	ecx, [eax+8]
		sar	ecx, 1
		mov	[ebp+var_150], ecx
		cmp	[ebp+var_150], 0
		jle	short loc_640E
		mov	eax, [ebp+var_150]
		sub	eax, 1
		mov	[ebp+var_150], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		mov	edx, [ebp+var_150]
		movzx	eax, word ptr [ecx+edx*2]
		and	eax, 0FFFFFC00h
		cmp	eax, 0DC00h
		jnz	short loc_640C
		cmp	[ebp+var_150], 0
		jz	short loc_63FD
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		mov	edx, [ebp+var_150]
		movzx	eax, word ptr [ecx+edx*2-2]
		and	eax, 0FFFFFC00h
		cmp	eax, 0D800h
		jnz	short loc_640C

loc_63FD:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+C3Ej
		mov	eax, [ebp+var_150]
		sub	eax, 1
		mov	[ebp+var_150], eax

loc_640C:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+C35j
					; UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)+C5Bj
		jmp	short loc_6418
; ---------------------------------------------------------------------------

loc_640E:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+C0Aj
		mov	[ebp+var_150], 0FFFFFFFFh

loc_6418:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *):loc_640Cj
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_150]
		push	ecx
		lea	edx, [ebp+var_60]
		push	edx
		mov	eax, [ebp+var_3C]
		push	eax
		lea	ecx, [ebp+var_30]
		push	ecx
		mov	edx, [ebp+var_94]
		push	edx
		lea	eax, [ebp+Dst]
		push	eax
		mov	ecx, [ebp+var_C]
		push	ecx
		call	?fromUWriteUInt8@@YAXPAUUConverter@@PBDHPAPAE1PAPAHHPAW4UErrorCode@@@Z ; fromUWriteUInt8(UConverter *,char const *,int,uchar * *,char const *,int * *,int,UErrorCode *)
		add	esp, 20h

loc_6446:				; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+B18j
					; UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)+B31j ...
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_48]
		mov	[eax+8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_30]
		mov	[eax+10h], ecx
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN91
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 224h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC@@YAXPAUUConverterFromUnicodeArgs@@PAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN91		dd 5			; DATA XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+CBCo
		dd offset $LN90
$LN90		dd 0FFFFFFD0h, 4	; DATA XREF: .text:0000648Co
		dd offset $LN85		; "target"
		dd 0FFFFFFA0h, 4
		dd offset $LN86		; "offsets"
		dd 0FFFFFF84h, 8
		dd offset $LN87		; "buffer"
		dd 0FFFFFF58h, 0Ah
		dd offset $LN88		; "choices"
		dd 0FFFFFEECh, 4
		dd offset $LN89		; "value"
$LN89		db 'value',0            ; DATA XREF: .text:000064C8o
$LN88		db 'choices',0          ; DATA XREF: .text:000064BCo
$LN87		db 'buffer',0           ; DATA XREF: .text:000064B0o
$LN86		db 'offsets',0          ; DATA XREF: .text:000064A4o
$LN85		db 'target',0           ; DATA XREF: .text:00006498o
$LN92		dd offset $LN56		; DATA XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+3E9r
		dd offset $LN54		; jump table for switch	statement
		dd offset $LN38
		dd offset $LN46
		dd offset $LN44_0
		dd offset $LN35
		dd offset $LN35
		dd offset $LN35
		dd offset $LN52
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6514h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl U_SUCCESS(enum  UErrorCode)
?U_SUCCESS@@YACW4UErrorCode@@@Z	proc near
					; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+B0Bp
					; UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+1DDp ...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		setle	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?U_SUCCESS@@YACW4UErrorCode@@@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6540h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl fromUWriteUInt8(struct UConverter *, char const *, int, unsigned	char * *, char const *,	int * *, int, enum  UErrorCode *)
?fromUWriteUInt8@@YAXPAUUConverter@@PBDHPAPAE1PAPAHHPAW4UErrorCode@@@Z proc near
					; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+AD4p
					; UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)+C9Ep ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h
arg_1C		= dword	ptr  24h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_1C]
		push	eax
		mov	ecx, [ebp+arg_18]
		push	ecx
		mov	edx, [ebp+arg_14]
		push	edx
		mov	eax, [ebp+arg_10]
		push	eax
		lea	ecx, [ebp+var_8]
		push	ecx
		mov	edx, [ebp+arg_8]
		push	edx
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	_ucnv_fromUWriteBytes_56
		add	esp, 20h
		mov	eax, [ebp+arg_C]
		mov	ecx, [ebp+var_8]
		mov	[eax], ecx
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN5
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?fromUWriteUInt8@@YAXPAUUConverter@@PBDHPAPAE1PAPAHHPAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN5		dd 1			; DATA XREF: fromUWriteUInt8(UConverter	*,char const *,int,uchar * *,char const	*,int *	*,int,UErrorCode *)+5Ao
		dd offset $LN4
$LN4		dd 0FFFFFFF8h, 4	; DATA XREF: .text:000065C0o
		dd offset $LN3		; "targetChars"
$LN3		db 'targetChars',0      ; DATA XREF: .text:000065CCo
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 65DCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl MBCS_FROM_UCHAR32_ISO2022(struct UConverterSharedData *, int, unsigned int *, signed char, int)
?MBCS_FROM_UCHAR32_ISO2022@@YAHPAUUConverterSharedData@@HPAICH@Z proc near
					; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+580p
					; UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)+717p ...

var_108		= byte ptr -108h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= byte ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 108h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_108]
		mov	ecx, 42h ; 'B'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_4], 10000h
		jl	short loc_6616
		mov	eax, [ebp+arg_0]
		movzx	ecx, byte ptr [eax+0C9h]
		and	ecx, 1
		jz	loc_6749

loc_6616:				; CODE XREF: MBCS_FROM_UCHAR32_ISO2022(UConverterSharedData *,int,uint *,signed	char,int)+25j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+34h]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_4]
		sar	eax, 0Ah
		mov	ecx, [ebp+var_14]
		movzx	edx, word ptr [ecx+eax*2]
		mov	eax, [ebp+arg_4]
		sar	eax, 4
		and	eax, 3Fh
		add	edx, eax
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+edx*4]
		mov	[ebp+var_20], edx
		cmp	[ebp+arg_10], 1
		jnz	short loc_6680
		movzx	eax, word ptr [ebp+var_20]
		shl	eax, 4
		mov	ecx, [ebp+arg_4]
		and	ecx, 0Fh
		add	eax, ecx
		mov	edx, [ebp+arg_0]
		mov	ecx, [edx+0BCh]
		movzx	edx, word ptr [ecx+eax*2]
		mov	[ebp+var_2C], edx
		cmp	[ebp+var_2C], 0FFh
		ja	short loc_6677
		mov	[ebp+var_38], 1
		jmp	short loc_667E
; ---------------------------------------------------------------------------

loc_6677:				; CODE XREF: MBCS_FROM_UCHAR32_ISO2022(UConverterSharedData *,int,uint *,signed	char,int)+90j
		mov	[ebp+var_38], 2

loc_667E:				; CODE XREF: MBCS_FROM_UCHAR32_ISO2022(UConverterSharedData *,int,uint *,signed	char,int)+99j
		jmp	short loc_66EA
; ---------------------------------------------------------------------------

loc_6680:				; CODE XREF: MBCS_FROM_UCHAR32_ISO2022(UConverterSharedData *,int,uint *,signed	char,int)+68j
		movzx	eax, word ptr [ebp+var_20]
		shl	eax, 4
		mov	ecx, [ebp+arg_4]
		and	ecx, 0Fh
		add	eax, ecx
		imul	eax, 3
		mov	edx, [ebp+arg_0]
		add	eax, [edx+0BCh]
		mov	[ebp+var_44], eax
		mov	eax, [ebp+var_44]
		movzx	ecx, byte ptr [eax]
		shl	ecx, 10h
		mov	edx, [ebp+var_44]
		movzx	eax, byte ptr [edx+1]
		shl	eax, 8
		or	ecx, eax
		mov	edx, [ebp+var_44]
		movzx	eax, byte ptr [edx+2]
		or	ecx, eax
		mov	[ebp+var_2C], ecx
		cmp	[ebp+var_2C], 0FFh
		ja	short loc_66D1
		mov	[ebp+var_38], 1
		jmp	short loc_66EA
; ---------------------------------------------------------------------------

loc_66D1:				; CODE XREF: MBCS_FROM_UCHAR32_ISO2022(UConverterSharedData *,int,uint *,signed	char,int)+EAj
		cmp	[ebp+var_2C], 0FFFFh
		ja	short loc_66E3
		mov	[ebp+var_38], 2
		jmp	short loc_66EA
; ---------------------------------------------------------------------------

loc_66E3:				; CODE XREF: MBCS_FROM_UCHAR32_ISO2022(UConverterSharedData *,int,uint *,signed	char,int)+FCj
		mov	[ebp+var_38], 3

loc_66EA:				; CODE XREF: MBCS_FROM_UCHAR32_ISO2022(UConverterSharedData *,int,uint *,signed	char,int):loc_667Ej
					; MBCS_FROM_UCHAR32_ISO2022(UConverterSharedData *,int,uint *,signed char,int)+F3j ...
		mov	ecx, [ebp+arg_4]
		and	ecx, 0Fh
		add	ecx, 10h
		mov	eax, 1
		shl	eax, cl
		and	eax, [ebp+var_20]
		jz	short loc_670E
		mov	eax, [ebp+arg_8]
		mov	ecx, [ebp+var_2C]
		mov	[eax], ecx
		mov	eax, [ebp+var_38]
		jmp	short loc_6778
; ---------------------------------------------------------------------------
		jmp	short loc_6749
; ---------------------------------------------------------------------------

loc_670E:				; CODE XREF: MBCS_FROM_UCHAR32_ISO2022(UConverterSharedData *,int,uint *,signed	char,int)+121j
		movsx	eax, [ebp+arg_C]
		test	eax, eax
		jnz	short loc_6734
		mov	eax, [ebp+arg_4]
		sub	eax, 0E000h
		cmp	eax, 1900h
		jb	short loc_6734
		mov	eax, [ebp+arg_4]
		sub	eax, 0F0000h
		cmp	eax, 20000h
		jnb	short loc_6749

loc_6734:				; CODE XREF: MBCS_FROM_UCHAR32_ISO2022(UConverterSharedData *,int,uint *,signed	char,int)+138j
					; MBCS_FROM_UCHAR32_ISO2022(UConverterSharedData *,int,uint *,signed char,int)+147j
		cmp	[ebp+var_2C], 0
		jz	short loc_6749
		mov	eax, [ebp+arg_8]
		mov	ecx, [ebp+var_2C]
		mov	[eax], ecx
		mov	eax, [ebp+var_38]
		neg	eax
		jmp	short loc_6778
; ---------------------------------------------------------------------------

loc_6749:				; CODE XREF: MBCS_FROM_UCHAR32_ISO2022(UConverterSharedData *,int,uint *,signed	char,int)+34j
					; MBCS_FROM_UCHAR32_ISO2022(UConverterSharedData *,int,uint *,signed char,int)+130j ...
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+0E0h]
		mov	[ebp+var_8], ecx
		cmp	[ebp+var_8], 0
		jz	short loc_6776
		movzx	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+var_8]
		push	eax
		call	_ucnv_extSimpleMatchFromU_56
		add	esp, 10h
		jmp	short loc_6778
; ---------------------------------------------------------------------------

loc_6776:				; CODE XREF: MBCS_FROM_UCHAR32_ISO2022(UConverterSharedData *,int,uint *,signed	char,int)+17Dj
		xor	eax, eax

loc_6778:				; CODE XREF: MBCS_FROM_UCHAR32_ISO2022(UConverterSharedData *,int,uint *,signed	char,int)+12Ej
					; MBCS_FROM_UCHAR32_ISO2022(UConverterSharedData *,int,uint *,signed char,int)+16Bj ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 108h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?MBCS_FROM_UCHAR32_ISO2022@@YAHPAUUConverterSharedData@@HPAICH@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 678Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl MBCS_SINGLE_FROM_UCHAR32(struct UConverterSharedData *, int, unsigned int	*, signed char)
?MBCS_SINGLE_FROM_UCHAR32@@YAHPAUUConverterSharedData@@HPAIC@Z proc near
					; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+677p

var_DC		= dword	ptr -0DCh
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= byte ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0DCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_DC]
		mov	ecx, 37h ; '7'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_4], 10000h
		jl	short loc_67C9
		mov	eax, [ebp+arg_0]
		movzx	ecx, byte ptr [eax+0C9h]
		and	ecx, 1
		jnz	short loc_67C9
		xor	eax, eax
		jmp	loc_6868
; ---------------------------------------------------------------------------

loc_67C9:				; CODE XREF: MBCS_SINGLE_FROM_UCHAR32(UConverterSharedData *,int,uint *,signed char)+25j
					; MBCS_SINGLE_FROM_UCHAR32(UConverterSharedData	*,int,uint *,signed char)+34j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+34h]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		sar	eax, 0Ah
		mov	ecx, [ebp+var_8]
		movzx	edx, word ptr [ecx+eax*2]
		mov	eax, [ebp+arg_4]
		sar	eax, 4
		and	eax, 3Fh
		add	edx, eax
		mov	ecx, [ebp+var_8]
		movzx	edx, word ptr [ecx+edx*2]
		mov	eax, [ebp+arg_4]
		and	eax, 0Fh
		add	edx, eax
		mov	ecx, [ebp+arg_0]
		mov	eax, [ecx+0BCh]
		movzx	ecx, word ptr [eax+edx*2]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_14]
		and	eax, 0FFh
		mov	ecx, [ebp+arg_8]
		mov	[ecx], eax
		cmp	[ebp+var_14], 0F00h
		jl	short loc_6828
		mov	eax, 1
		jmp	short loc_6868
; ---------------------------------------------------------------------------
		jmp	short loc_6868
; ---------------------------------------------------------------------------

loc_6828:				; CODE XREF: MBCS_SINGLE_FROM_UCHAR32(UConverterSharedData *,int,uint *,signed char)+91j
		movsx	eax, [ebp+arg_C]
		test	eax, eax
		jz	short loc_6844
		xor	ecx, ecx
		cmp	[ebp+var_14], 800h
		setnl	cl
		mov	[ebp+var_DC], ecx
		jmp	short loc_6856
; ---------------------------------------------------------------------------

loc_6844:				; CODE XREF: MBCS_SINGLE_FROM_UCHAR32(UConverterSharedData *,int,uint *,signed char)+A2j
		xor	edx, edx
		cmp	[ebp+var_14], 0C00h
		setnl	dl
		mov	[ebp+var_DC], edx

loc_6856:				; CODE XREF: MBCS_SINGLE_FROM_UCHAR32(UConverterSharedData *,int,uint *,signed char)+B6j
		cmp	[ebp+var_DC], 0
		jz	short loc_6866
		or	eax, 0FFFFFFFFh
		jmp	short loc_6868
; ---------------------------------------------------------------------------
		jmp	short loc_6868
; ---------------------------------------------------------------------------

loc_6866:				; CODE XREF: MBCS_SINGLE_FROM_UCHAR32(UConverterSharedData *,int,uint *,signed char)+D1j
		xor	eax, eax

loc_6868:				; CODE XREF: MBCS_SINGLE_FROM_UCHAR32(UConverterSharedData *,int,uint *,signed char)+38j
					; MBCS_SINGLE_FROM_UCHAR32(UConverterSharedData	*,int,uint *,signed char)+98j ...
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?MBCS_SINGLE_FROM_UCHAR32@@YAHPAUUConverterSharedData@@HPAIC@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6870h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; unsigned int __cdecl _2022FromGR94DBCS(unsigned int)
?_2022FromGR94DBCS@@YAII@Z proc	near	; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+753p

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		sub	eax, 0A1A1h
		movzx	ecx, ax
		cmp	ecx, 5D5Dh
		jg	short loc_68BD
		mov	eax, [ebp+arg_0]
		sub	eax, 0A1h ; ''
		movzx	ecx, al
		cmp	ecx, 5Dh ; ']'
		jg	short loc_68BD
		mov	eax, [ebp+arg_0]
		sub	eax, 8080h
		jmp	short loc_68BF
; ---------------------------------------------------------------------------
		jmp	short loc_68BF
; ---------------------------------------------------------------------------

loc_68BD:				; CODE XREF: _2022FromGR94DBCS(uint)+2Fj
					; _2022FromGR94DBCS(uint)+3Fj
		xor	eax, eax

loc_68BF:				; CODE XREF: _2022FromGR94DBCS(uint)+49j
					; _2022FromGR94DBCS(uint)+4Bj
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?_2022FromGR94DBCS@@YAII@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 68C8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; unsigned int __cdecl jisx201FromU(unsigned int)
?jisx201FromU@@YAII@Z proc near		; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+511p

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 7Fh ; ''
		ja	short loc_68FF
		cmp	[ebp+arg_0], 5Ch ; '\'
		jz	short loc_68FD
		cmp	[ebp+arg_0], 7Eh ; '~'
		jz	short loc_68FD
		mov	eax, [ebp+arg_0]
		jmp	short loc_6926
; ---------------------------------------------------------------------------

loc_68FD:				; CODE XREF: jisx201FromU(uint)+28j
					; jisx201FromU(uint)+2Ej
		jmp	short loc_6921
; ---------------------------------------------------------------------------

loc_68FF:				; CODE XREF: jisx201FromU(uint)+22j
		cmp	[ebp+arg_0], 0A5h ; ''
		jnz	short loc_6911
		mov	eax, 5Ch ; '\'
		jmp	short loc_6926
; ---------------------------------------------------------------------------
		jmp	short loc_6921
; ---------------------------------------------------------------------------

loc_6911:				; CODE XREF: jisx201FromU(uint)+3Ej
		cmp	[ebp+arg_0], 203Eh
		jnz	short loc_6921
		mov	eax, 7Eh ; '~'
		jmp	short loc_6926
; ---------------------------------------------------------------------------

loc_6921:				; CODE XREF: jisx201FromU(uint):loc_68FDj
					; jisx201FromU(uint)+47j ...
		mov	eax, 0FFFEh

loc_6926:				; CODE XREF: jisx201FromU(uint)+33j
					; jisx201FromU(uint)+45j ...
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?jisx201FromU@@YAII@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6930h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; unsigned int __cdecl _2022FromSJIS(unsigned int)
?_2022FromSJIS@@YAII@Z proc near	; CODE XREF: UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+5B0p

var_CC		= byte ptr -0CCh
var_5		= byte ptr -5
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0EFFCh
		jbe	short loc_695E
		xor	eax, eax
		jmp	loc_69E5
; ---------------------------------------------------------------------------

loc_695E:				; CODE XREF: _2022FromSJIS(uint)+25j
		mov	al, byte ptr [ebp+arg_0]
		mov	[ebp+var_5], al
		mov	eax, [ebp+arg_0]
		and	eax, 0FF00h
		mov	[ebp+arg_0], eax
		cmp	[ebp+arg_0], 9F00h
		ja	short loc_6985
		mov	eax, [ebp+arg_0]
		sub	eax, 7000h
		mov	[ebp+arg_0], eax
		jmp	short loc_6990
; ---------------------------------------------------------------------------

loc_6985:				; CODE XREF: _2022FromSJIS(uint)+46j
		mov	eax, [ebp+arg_0]
		sub	eax, 0B000h
		mov	[ebp+arg_0], eax

loc_6990:				; CODE XREF: _2022FromSJIS(uint)+53j
		mov	eax, [ebp+arg_0]
		shl	eax, 1
		mov	[ebp+arg_0], eax
		movzx	eax, [ebp+var_5]
		cmp	eax, 9Eh ; ''
		jg	short loc_69D5
		mov	eax, [ebp+arg_0]
		sub	eax, 100h
		mov	[ebp+arg_0], eax
		movzx	eax, [ebp+var_5]
		cmp	eax, 7Eh ; '~'
		jg	short loc_69C6
		movzx	eax, [ebp+var_5]
		sub	eax, 1Fh
		or	eax, [ebp+arg_0]
		mov	[ebp+arg_0], eax
		jmp	short loc_69D3
; ---------------------------------------------------------------------------

loc_69C6:				; CODE XREF: _2022FromSJIS(uint)+85j
		movzx	eax, [ebp+var_5]
		sub	eax, 20h ; ' '
		or	eax, [ebp+arg_0]
		mov	[ebp+arg_0], eax

loc_69D3:				; CODE XREF: _2022FromSJIS(uint)+94j
		jmp	short loc_69E2
; ---------------------------------------------------------------------------

loc_69D5:				; CODE XREF: _2022FromSJIS(uint)+71j
		movzx	eax, [ebp+var_5]
		sub	eax, 7Eh ; '~'
		or	eax, [ebp+arg_0]
		mov	[ebp+arg_0], eax

loc_69E2:				; CODE XREF: _2022FromSJIS(uint):loc_69D3j
		mov	eax, [ebp+arg_0]

loc_69E5:				; CODE XREF: _2022FromSJIS(uint)+29j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?_2022FromSJIS@@YAII@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 69ECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(struct UConverterToUnicodeArgs *,	enum  UErrorCode *)
?UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC@@YAXPAUUConverterToUnicodeArgs@@PAW4UErrorCode@@@Z proc	near
					; DATA XREF: .rdata:00000728o
					; .rdata:0000072Co

var_178		= dword	ptr -178h
var_AD		= byte ptr -0ADh
var_A4		= dword	ptr -0A4h
var_98		= dword	ptr -98h
var_89		= byte ptr -89h
var_80		= dword	ptr -80h
var_74		= dword	ptr -74h
var_68		= dword	ptr -68h
var_5C		= dword	ptr -5Ch
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= byte ptr -8
var_7		= byte ptr -7
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 178h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_178]
		mov	ecx, 5Eh ; '^'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		mov	[ebp+var_20], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+0Ch]
		mov	[ebp+var_2C], ecx
		mov	[ebp+var_38], 0
		mov	[ebp+var_44], 0
		mov	[ebp+var_50], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	edx, [ecx+8]
		mov	[ebp+var_5C], edx
		mov	eax, [ebp+var_5C]
		add	eax, 30h ; '0'
		mov	[ebp+var_68], eax
		mov	eax, [ebp+var_5C]
		cmp	dword ptr [eax+3Ch], 0
		jz	short loc_6A64
		jmp	$escape$37917
; ---------------------------------------------------------------------------
		jmp	$escape$37917
; ---------------------------------------------------------------------------
		jmp	short loc_6ABF
; ---------------------------------------------------------------------------

loc_6A64:				; CODE XREF: UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+6Aj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		movsx	edx, byte ptr [ecx+24h]
		cmp	edx, 1
		jnz	short loc_6ABF
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_2C]
		jnb	short loc_6ABF
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_20]
		cmp	ecx, [eax+14h]
		jnb	short loc_6ABF
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		movzx	edx, byte ptr [ecx+25h]
		mov	[ebp+var_44], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	byte ptr [ecx+24h], 0
		mov	eax, [ebp+var_68]
		movsx	ecx, byte ptr [eax+4]
		mov	edx, [ebp+var_68]
		movsx	eax, byte ptr [edx+ecx]
		mov	[ebp+var_74], eax
		mov	[ebp+var_38], 0FFFFh
		jmp	$getTrailByte$37922
; ---------------------------------------------------------------------------
		jmp	$getTrailByte$37922
; ---------------------------------------------------------------------------

loc_6ABF:				; CODE XREF: UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+76j
					; UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+85j ...
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_2C]
		jnb	$endloop$37998
		mov	[ebp+var_38], 0FFFFh
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_20]
		cmp	ecx, [eax+14h]
		jnb	loc_7088
		mov	eax, [ebp+var_14]
		movzx	ecx, byte ptr [eax]
		mov	[ebp+var_44], ecx
		mov	edx, [ebp+var_14]
		add	edx, 1
		mov	[ebp+var_14], edx
		mov	eax, [ebp+var_44]
		mov	[ebp+var_178], eax
		mov	ecx, [ebp+var_178]
		sub	ecx, 0Ah
		mov	[ebp+var_178], ecx
		cmp	[ebp+var_178], 11h ; switch 18 cases
		ja	$LN38_0		; jumptable 00006B25 default case
		mov	edx, [ebp+var_178]
		movzx	eax, ds:$LN64[edx]
		jmp	ds:$LN69[eax*4]	; switch jump
; ---------------------------------------------------------------------------

$LN50:					; CODE XREF: UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+139j
					; DATA XREF: .text:$LN69o
		mov	eax, [ebp+var_5C] ; jumptable 00006B25 case 5
		cmp	dword ptr [eax+40h], 3
		jnz	short loc_6B40
		mov	eax, [ebp+var_68]
		mov	byte ptr [eax+4], 0
		jmp	short loc_6ABF
; ---------------------------------------------------------------------------
		jmp	short $LN47	; jumptable 00006B25 case 4
; ---------------------------------------------------------------------------

loc_6B40:				; CODE XREF: UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+147j
		mov	eax, [ebp+var_5C]
		mov	byte ptr [eax+44h], 0
		jmp	loc_6F03
; ---------------------------------------------------------------------------

$LN47:					; CODE XREF: UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+139j
					; UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+152j
					; DATA XREF: ...
		mov	eax, [ebp+var_5C] ; jumptable 00006B25 case 4
		cmp	dword ptr [eax+40h], 3
		jnz	short loc_6B6A
		mov	eax, [ebp+var_68]
		mov	byte ptr [eax+1], 8
		mov	eax, [ebp+var_68]
		mov	byte ptr [eax+4], 1
		jmp	loc_6ABF
; ---------------------------------------------------------------------------
		jmp	short $LN44_1	; jumptable 00006B25 case 17
; ---------------------------------------------------------------------------

loc_6B6A:				; CODE XREF: UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+167j
		mov	eax, [ebp+var_5C]
		mov	byte ptr [eax+44h], 0
		jmp	loc_6F03
; ---------------------------------------------------------------------------

$LN44_1:				; CODE XREF: UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+139j
					; UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+17Cj
					; DATA XREF: ...
		mov	eax, [ebp+var_14] ; jumptable 00006B25 case 17
		sub	eax, 1
		mov	[ebp+var_14], eax

$escape$37917:				; CODE XREF: UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+6Cj
					; UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+71j
		mov	eax, [ebp+var_14]
		mov	[ebp+var_80], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	dl, [ecx+24h]
		mov	[ebp+var_89], dl
		mov	eax, [ebp+arg_4]
		push	eax
		push	1
		mov	ecx, [ebp+var_2C]
		push	ecx
		lea	edx, [ebp+var_14]
		push	edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		push	ecx
		call	?changeState_2022@@YAXPAUUConverter@@PAPBDPBDW4Variant2022@@PAW4UErrorCode@@@Z ; changeState_2022(UConverter *,char const * *,char const *,Variant2022,UErrorCode *)
		add	esp, 14h
		mov	eax, [ebp+var_5C]
		cmp	dword ptr [eax+40h], 0
		jnz	short loc_6C14
		mov	eax, [ebp+var_5C]
		cmp	dword ptr [eax+3Ch], 0
		jnz	short loc_6C14
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_6C14
		mov	eax, [ebp+var_5C]
		movsx	ecx, byte ptr [eax+44h]
		test	ecx, ecx
		jz	short loc_6C14
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 12h
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	dword ptr [ecx+100h], 2
		movsx	eax, [ebp+var_89]
		mov	ecx, [ebp+var_14]
		sub	ecx, [ebp+var_80]
		add	eax, ecx
		mov	edx, [ebp+arg_0]
		mov	ecx, [edx+4]
		mov	[ecx+24h], al

loc_6C14:				; CODE XREF: UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+1CCj
					; UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+1D5j ...
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_6C47
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_20]
		mov	[eax+10h], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		mov	[eax+8], ecx
		mov	eax, [ebp+var_5C]
		mov	byte ptr [eax+44h], 0
		jmp	loc_70AA
; ---------------------------------------------------------------------------

loc_6C47:				; CODE XREF: UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+23Bj
		mov	eax, [ebp+var_5C]
		cmp	dword ptr [eax+3Ch], 0
		jnz	short loc_6C57
		mov	eax, [ebp+var_5C]
		mov	byte ptr [eax+44h], 1

loc_6C57:				; CODE XREF: UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+262j
		jmp	loc_6ABF
; ---------------------------------------------------------------------------

$LN40_0:				; CODE XREF: UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+139j
					; DATA XREF: .text:$LN69o
		mov	eax, [ebp+var_68] ; jumptable 00006B25 cases 0,3
		movsx	ecx, byte ptr [eax]
		test	ecx, ecx
		jz	short loc_6C77
		mov	eax, [ebp+var_68]
		movsx	ecx, byte ptr [eax]
		cmp	ecx, 3
		jz	short loc_6C77
		mov	eax, [ebp+var_68]
		mov	byte ptr [eax],	0

loc_6C77:				; CODE XREF: UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+278j
					; UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+283j
		mov	eax, [ebp+var_68]
		mov	byte ptr [eax+2], 0
		mov	eax, [ebp+var_68]
		mov	byte ptr [eax+4], 0

$LN38_0:				; CODE XREF: UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+126j
					; UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+139j
					; DATA XREF: ...
		mov	eax, [ebp+var_5C] ; jumptable 00006B25 default case
		mov	byte ptr [eax+44h], 0
		mov	eax, [ebp+var_68]
		movsx	ecx, byte ptr [eax+4]
		mov	edx, [ebp+var_68]
		movsx	eax, byte ptr [edx+ecx]
		mov	[ebp+var_74], eax
		mov	eax, [ebp+var_44]
		sub	eax, 0A1h ; ''
		movzx	ecx, al
		cmp	ecx, 3Eh ; '>'
		jg	short loc_6CEA
		mov	eax, [ebp+var_5C]
		cmp	dword ptr [eax+40h], 4
		jnz	short loc_6CEA
		cmp	[ebp+var_74], 4
		jl	short loc_6CC2
		cmp	[ebp+var_74], 7
		jle	short loc_6CEA

loc_6CC2:				; CODE XREF: UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+2CEj
		mov	eax, [ebp+var_44]
		add	eax, 0FEC0h
		mov	[ebp+var_38], eax
		mov	eax, [ebp+var_68]
		movsx	ecx, byte ptr [eax+4]
		cmp	ecx, 2
		jl	short loc_6CE5
		mov	eax, [ebp+var_68]
		mov	ecx, [ebp+var_68]
		mov	dl, [ecx+5]
		mov	[eax+4], dl

loc_6CE5:				; CODE XREF: UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+2EBj
		jmp	loc_6F03
; ---------------------------------------------------------------------------

loc_6CEA:				; CODE XREF: UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+2BFj
					; UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+2C8j ...
		mov	eax, [ebp+var_74]
		mov	[ebp+var_178], eax
		cmp	[ebp+var_178], 8 ; switch 9 cases
		ja	$LN21		; jumptable 00006D06 default case
		mov	ecx, [ebp+var_178]
		jmp	ds:$LN70[ecx*4]	; switch jump
; ---------------------------------------------------------------------------

$LN31:					; CODE XREF: UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+31Aj
					; DATA XREF: .text:$LN70o
		cmp	[ebp+var_44], 7Fh ; '' ; jumptable 00006D06 case 0
		ja	short loc_6D19
		mov	eax, [ebp+var_44]
		mov	[ebp+var_38], eax

loc_6D19:				; CODE XREF: UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+325j
		jmp	loc_6F03
; ---------------------------------------------------------------------------

$LN29:					; CODE XREF: UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+31Aj
					; DATA XREF: .text:$LN70o
		cmp	[ebp+var_44], 7Fh ; '' ; jumptable 00006D06 case 1
		ja	short loc_6D2F
		mov	eax, [ebp+var_44]
		add	eax, 80h ; ''
		mov	[ebp+var_38], eax

loc_6D2F:				; CODE XREF: UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+336j
		mov	eax, [ebp+var_68]
		mov	ecx, [ebp+var_68]
		mov	dl, [ecx+5]
		mov	[eax+4], dl
		jmp	loc_6F03
; ---------------------------------------------------------------------------

$LN27:					; CODE XREF: UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+31Aj
					; DATA XREF: .text:$LN70o
		cmp	[ebp+var_44], 7Fh ; '' ; jumptable 00006D06 case 2
		ja	short loc_6D64
		mov	eax, [ebp+var_74]
		mov	ecx, [ebp+var_5C]
		mov	edx, [ecx+eax*4]
		mov	eax, [ebp+var_44]
		add	eax, 80h ; ''
		movzx	ecx, al
		mov	edx, [edx+24h]
		movzx	eax, word ptr [edx+ecx*4]
		mov	[ebp+var_38], eax

loc_6D64:				; CODE XREF: UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+358j
		mov	eax, [ebp+var_68]
		mov	ecx, [ebp+var_68]
		mov	dl, [ecx+5]
		mov	[eax+4], dl
		jmp	loc_6F03
; ---------------------------------------------------------------------------

$LN25:					; CODE XREF: UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+31Aj
					; DATA XREF: .text:$LN70o
		cmp	[ebp+var_44], 7Fh ; '' ; jumptable 00006D06 case 3
		ja	short loc_6D8A
		mov	eax, [ebp+var_44]
		push	eax
		call	?jisx201ToU@@YAII@Z ; jisx201ToU(uint)
		add	esp, 4
		mov	[ebp+var_38], eax

loc_6D8A:				; CODE XREF: UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+38Dj
		jmp	loc_6F03
; ---------------------------------------------------------------------------

$LN23:					; CODE XREF: UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+31Aj
					; DATA XREF: .text:$LN70o
		mov	eax, [ebp+var_44] ; jumptable 00006D06 case 8
		sub	eax, 21h ; '!'
		movzx	ecx, al
		cmp	ecx, 3Eh ; '>'
		jg	short loc_6DA8
		mov	eax, [ebp+var_44]
		add	eax, 0FF40h
		mov	[ebp+var_38], eax

loc_6DA8:				; CODE XREF: UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+3AFj
		jmp	loc_6F03
; ---------------------------------------------------------------------------

$LN21:					; CODE XREF: UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+30Ej
					; UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+31Aj
					; DATA XREF: ...
		mov	eax, [ebp+var_14] ; jumptable 00006D06 default case
		cmp	eax, [ebp+var_2C]
		jnb	loc_6EE3

$getTrailByte$37922:			; CODE XREF: UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+C9j
					; UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+CEj
		mov	eax, [ebp+var_14]
		mov	cl, [eax]
		mov	[ebp+var_AD], cl
		mov	eax, [ebp+var_44]
		sub	eax, 21h ; '!'
		movzx	ecx, al
		xor	edx, edx
		cmp	ecx, 5Dh ; ']'
		setle	dl
		mov	[ebp+var_98], edx
		movzx	eax, [ebp+var_AD]
		sub	eax, 21h ; '!'
		movzx	ecx, al
		xor	edx, edx
		cmp	ecx, 5Dh ; ']'
		setle	dl
		mov	[ebp+var_A4], edx
		cmp	[ebp+var_98], 0
		jz	loc_6E97
		cmp	[ebp+var_A4], 0
		jz	loc_6E97
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_44]
		shl	eax, 8
		movzx	ecx, [ebp+var_AD]
		or	eax, ecx
		mov	[ebp+var_50], eax
		cmp	[ebp+var_74], 4
		jnz	short loc_6E52
		lea	eax, [ebp+var_8]
		push	eax
		movzx	ecx, [ebp+var_AD]
		push	ecx
		movzx	edx, byte ptr [ebp+var_44]
		push	edx
		call	?_2022ToSJIS@@YAXEEQAD@Z ; _2022ToSJIS(uchar,uchar,char	* const)
		add	esp, 0Ch
		mov	eax, [ebp+var_50]
		mov	[ebp+var_44], eax
		jmp	short loc_6E78
; ---------------------------------------------------------------------------

loc_6E52:				; CODE XREF: UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+443j
		mov	eax, [ebp+var_50]
		mov	[ebp+var_44], eax
		cmp	[ebp+var_74], 7
		jnz	short loc_6E69
		mov	eax, [ebp+var_50]
		add	eax, 8080h
		mov	[ebp+var_50], eax

loc_6E69:				; CODE XREF: UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+470j
		mov	eax, [ebp+var_50]
		shr	eax, 8
		mov	[ebp+var_8], al
		mov	al, byte ptr [ebp+var_50]
		mov	[ebp+var_7], al

loc_6E78:				; CODE XREF: UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+464j
		push	0
		push	2
		lea	eax, [ebp+var_8]
		push	eax
		mov	ecx, [ebp+var_74]
		mov	edx, [ebp+var_5C]
		mov	eax, [edx+ecx*4]
		push	eax
		call	_ucnv_MBCSSimpleGetNextUChar_56
		add	esp, 10h
		mov	[ebp+var_38], eax
		jmp	short loc_6EE1
; ---------------------------------------------------------------------------

loc_6E97:				; CODE XREF: UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+411j
					; UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+41Ej
		cmp	[ebp+var_A4], 0
		jnz	short loc_6EE1
		movzx	eax, [ebp+var_AD]
		cmp	eax, 20h ; ' '
		jge	short loc_6EC1
		movzx	ecx, [ebp+var_AD]
		mov	eax, 1
		shl	eax, cl
		and	eax, 800C000h
		jnz	short loc_6EE1

loc_6EC1:				; CODE XREF: UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+4BEj
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_44]
		shl	eax, 8
		or	eax, 10000h
		movzx	ecx, [ebp+var_AD]
		or	eax, ecx
		mov	[ebp+var_44], eax

loc_6EE1:				; CODE XREF: UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+4A9j
					; UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+4B2j ...
		jmp	short loc_6F03
; ---------------------------------------------------------------------------

loc_6EE3:				; CODE XREF: UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+3C7j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	dl, byte ptr [ebp+var_44]
		mov	[ecx+25h], dl
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	byte ptr [ecx+24h], 1
		jmp	$endloop$37998
; ---------------------------------------------------------------------------
		jmp	$endloop$37998
; ---------------------------------------------------------------------------

loc_6F03:				; CODE XREF: UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+15Bj
					; UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+185j ...
		cmp	[ebp+var_38], 0FFFEh
		jnb	short loc_6F5B
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+18h], 0
		jz	short loc_6F43
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		sub	ecx, [eax+8]
		mov	edx, 0FFh
		cmp	edx, [ebp+var_44]
		sbb	eax, eax
		neg	eax
		add	eax, 1
		sub	ecx, eax
		mov	edx, [ebp+arg_0]
		mov	eax, [ebp+var_20]
		sub	eax, [edx+10h]
		sar	eax, 1
		mov	edx, [ebp+arg_0]
		mov	edx, [edx+18h]
		mov	[edx+eax*4], ecx

loc_6F43:				; CODE XREF: UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+527j
		mov	eax, [ebp+var_20]
		mov	cx, word ptr [ebp+var_38]
		mov	[eax], cx
		mov	edx, [ebp+var_20]
		add	edx, 2
		mov	[ebp+var_20], edx
		jmp	loc_7086
; ---------------------------------------------------------------------------

loc_6F5B:				; CODE XREF: UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+51Ej
		cmp	[ebp+var_38], 0FFFFh
		jbe	loc_7069
		mov	eax, [ebp+var_38]
		sub	eax, 10000h
		mov	[ebp+var_38], eax
		mov	eax, [ebp+var_38]
		shr	eax, 0Ah
		movzx	ecx, ax
		add	ecx, 0D800h
		mov	edx, [ebp+var_20]
		mov	[edx], cx
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+18h], 0
		jz	short loc_6FBF
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		sub	ecx, [eax+8]
		mov	edx, 0FFh
		cmp	edx, [ebp+var_44]
		sbb	eax, eax
		neg	eax
		add	eax, 1
		sub	ecx, eax
		mov	edx, [ebp+arg_0]
		mov	eax, [ebp+var_20]
		sub	eax, [edx+10h]
		sar	eax, 1
		mov	edx, [ebp+arg_0]
		mov	edx, [edx+18h]
		mov	[edx+eax*4], ecx

loc_6FBF:				; CODE XREF: UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+5A3j
		mov	eax, [ebp+var_20]
		add	eax, 2
		mov	[ebp+var_20], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_20]
		cmp	ecx, [eax+14h]
		jnb	short loc_702C
		mov	eax, [ebp+var_38]
		and	eax, 3FFh
		movzx	ecx, ax
		add	ecx, 0DC00h
		mov	edx, [ebp+var_20]
		mov	[edx], cx
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+18h], 0
		jz	short loc_7021
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		sub	ecx, [eax+8]
		mov	edx, 0FFh
		cmp	edx, [ebp+var_44]
		sbb	eax, eax
		neg	eax
		add	eax, 1
		sub	ecx, eax
		mov	edx, [ebp+arg_0]
		mov	eax, [ebp+var_20]
		sub	eax, [edx+10h]
		sar	eax, 1
		mov	edx, [ebp+arg_0]
		mov	edx, [edx+18h]
		mov	[edx+eax*4], ecx

loc_7021:				; CODE XREF: UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+605j
		mov	eax, [ebp+var_20]
		add	eax, 2
		mov	[ebp+var_20], eax
		jmp	short loc_7067
; ---------------------------------------------------------------------------

loc_702C:				; CODE XREF: UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+5E5j
		mov	eax, [ebp+var_38]
		and	eax, 3FFh
		movzx	ecx, ax
		add	ecx, 0DC00h
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+4]
		mov	edx, [ebp+arg_0]
		mov	edx, [edx+4]
		movsx	edx, byte ptr [edx+41h]
		mov	[eax+edx*2+74h], cx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	dl, [ecx+41h]
		add	dl, 1
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	[ecx+41h], dl

loc_7067:				; CODE XREF: UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+63Ej
		jmp	short loc_7086
; ---------------------------------------------------------------------------

loc_7069:				; CODE XREF: UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+576j
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_38]
		push	ecx
		mov	edx, [ebp+var_44]
		push	edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		push	ecx
		call	?toUnicodeCallback@@YAXPAUUConverter@@IIPAW4UErrorCode@@@Z ; toUnicodeCallback(UConverter *,uint,uint,UErrorCode *)
		add	esp, 10h
		jmp	short $endloop$37998
; ---------------------------------------------------------------------------

loc_7086:				; CODE XREF: UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+56Aj
					; UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *):loc_7067j
		jmp	short loc_7093
; ---------------------------------------------------------------------------

loc_7088:				; CODE XREF: UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+EFj
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Fh
		jmp	short $endloop$37998
; ---------------------------------------------------------------------------

loc_7093:				; CODE XREF: UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *):loc_7086j
		jmp	loc_6ABF
; ---------------------------------------------------------------------------

$endloop$37998:				; CODE XREF: UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+D9j
					; UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+50Dj ...
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_20]
		mov	[eax+10h], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		mov	[eax+8], ecx

loc_70AA:				; CODE XREF: UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+256j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN68
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 178h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC@@YAXPAUUConverterToUnicodeArgs@@PAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
$LN68		dd 2			; DATA XREF: UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+6C2o
		dd offset $LN67
$LN67		dd 0FFFFFFF8h, 2	; DATA XREF: .text:000070D4o
		dd offset $LN65		; "tempBuf"
		dd 0FFFFFFECh, 4
		dd offset $LN66		; "mySource"
$LN66		db 'mySource',0         ; DATA XREF: .text:000070ECo
$LN65		db 'tempBuf',0          ; DATA XREF: .text:000070E0o
		align 4
$LN69		dd offset $LN40_0	; DATA XREF: UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+139r
		dd offset $LN47		; jump table for switch	statement
		dd offset $LN50
		dd offset $LN44_1
		dd offset $LN38_0
$LN64		db	0,     4,     4,     0
					; DATA XREF: UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+132r
		db	1,     2,     4,     4 ; indirect table	for switch statement
		db	4,     4,     4,     4
		db	4,     4,     4,     4
		db	4,     3
		align 4
$LN70		dd offset $LN31		; DATA XREF: UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+31Ar
		dd offset $LN29		; jump table for switch	statement
		dd offset $LN27
		dd offset $LN25
		dd offset $LN21
		dd offset $LN21
		dd offset $LN21
		dd offset $LN21
		dd offset $LN23
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7150h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl changeState_2022(struct UConverter *, char const	* *, char const	*, enum	 Variant2022, enum  UErrorCode *)
?changeState_2022@@YAXPAUUConverter@@PAPBDPBDW4Variant2022@@PAW4UErrorCode@@@Z proc near
					; CODE XREF: UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+1BDp
					; UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+1CFp ...

var_13C		= dword	ptr -13Ch
var_71		= byte ptr -71h
var_65		= byte ptr -65h
var_5C		= dword	ptr -5Ch
var_50		= dword	ptr -50h
var_41		= byte ptr -41h
var_35		= byte ptr -35h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 13Ch
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_13C]
		mov	ecx, 4Fh ; 'O'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+3Ch]
		mov	[ebp+var_20], ecx
		mov	[ebp+var_2C], 0
		mov	eax, [ebp+arg_0]
		mov	cl, [eax+24h]
		mov	[ebp+var_35], cl
		mov	[ebp+var_8], 0

loc_7197:				; CODE XREF: changeState_2022(UConverter *,char	const *	*,char const *,Variant2022,UErrorCode *):loc_723Dj
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		cmp	ecx, [ebp+arg_8]
		jnb	$DONE$37531
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		mov	dl, [ecx]
		mov	[ebp+var_41], dl
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		add	ecx, 1
		mov	edx, [ebp+arg_4]
		mov	[edx], ecx
		mov	eax, [ebp+arg_0]
		movsx	ecx, byte ptr [eax+24h]
		mov	edx, [ebp+arg_0]
		mov	al, [ebp+var_41]
		mov	[edx+ecx+25h], al
		mov	ecx, [ebp+arg_0]
		mov	dl, [ecx+24h]
		add	dl, 1
		mov	eax, [ebp+arg_0]
		mov	[eax+24h], dl
		lea	eax, [ebp+var_2C]
		push	eax
		lea	ecx, [ebp+var_20]
		push	ecx
		movzx	edx, [ebp+var_41]
		push	edx
		call	?getKey_2022@@YA?AW4UCNV_TableStates_2022@@DPAH0@Z ; getKey_2022(char,int *,int	*)
		add	esp, 0Ch
		mov	[ebp+var_8], eax
		mov	eax, [ebp+var_8]
		mov	[ebp+var_13C], eax
		cmp	[ebp+var_13C], 0FFFFFFFFh
		jz	short loc_7227
		cmp	[ebp+var_13C], 1
		jz	short loc_721C
		cmp	[ebp+var_13C], 2
		jz	short loc_722B
		jmp	short loc_723D
; ---------------------------------------------------------------------------
		jmp	short loc_723D
; ---------------------------------------------------------------------------

loc_721C:				; CODE XREF: changeState_2022(UConverter *,char	const *	*,char const *,Variant2022,UErrorCode *)+BDj
		mov	[ebp+var_20], 0
		jmp	short $DONE$37531
; ---------------------------------------------------------------------------
		jmp	short $DONE$37531
; ---------------------------------------------------------------------------

loc_7227:				; CODE XREF: changeState_2022(UConverter *,char	const *	*,char const *,Variant2022,UErrorCode *)+B4j
		jmp	short $DONE$37531
; ---------------------------------------------------------------------------
		jmp	short $DONE$37531
; ---------------------------------------------------------------------------

loc_722B:				; CODE XREF: changeState_2022(UConverter *,char	const *	*,char const *,Variant2022,UErrorCode *)+C6j
		mov	[ebp+var_8], 1
		mov	[ebp+var_20], 0
		jmp	short $DONE$37531
; ---------------------------------------------------------------------------
		jmp	short $DONE$37531
; ---------------------------------------------------------------------------

loc_723D:				; CODE XREF: changeState_2022(UConverter *,char	const *	*,char const *,Variant2022,UErrorCode *)+C8j
					; changeState_2022(UConverter *,char const * *,char const *,Variant2022,UErrorCode *)+CAj
		jmp	loc_7197
; ---------------------------------------------------------------------------

$DONE$37531:				; CODE XREF: changeState_2022(UConverter *,char	const *	*,char const *,Variant2022,UErrorCode *)+4Fj
					; changeState_2022(UConverter *,char const * *,char const *,Variant2022,UErrorCode *)+D3j ...
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_20]
		mov	[eax+3Ch], ecx
		cmp	[ebp+var_8], 0
		jnz	short loc_725B
		jmp	loc_75A9
; ---------------------------------------------------------------------------
		jmp	loc_74B9
; ---------------------------------------------------------------------------

loc_725B:				; CODE XREF: changeState_2022(UConverter *,char	const *	*,char const *,Variant2022,UErrorCode *)+FFj
		cmp	[ebp+var_8], 0FFFFFFFFh
		jnz	short loc_726F
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 12h
		jmp	loc_74B9
; ---------------------------------------------------------------------------

loc_726F:				; CODE XREF: changeState_2022(UConverter *,char	const *	*,char const *,Variant2022,UErrorCode *)+10Fj
		mov	eax, [ebp+arg_C]
		mov	[ebp+var_13C], eax
		cmp	[ebp+var_13C], 1
		jz	short loc_72A0
		cmp	[ebp+var_13C], 2
		jz	loc_749D
		cmp	[ebp+var_13C], 3
		jz	loc_7392
		jmp	loc_74B0
; ---------------------------------------------------------------------------

loc_72A0:				; CODE XREF: changeState_2022(UConverter *,char	const *	*,char const *,Variant2022,UErrorCode *)+12Fj
		mov	eax, [ebp+var_2C]
		movsx	ecx, ds:_nextStateToUnicodeJP[eax]
		mov	[ebp+var_50], ecx
		mov	eax, [ebp+var_50]
		mov	[ebp+var_13C], eax
		mov	ecx, [ebp+var_13C]
		add	ecx, 1
		mov	[ebp+var_13C], ecx
		cmp	[ebp+var_13C], 11h ; switch 18 cases
		ja	$LN34		; jumptable 000072DF default case
		mov	edx, [ebp+var_13C]
		movzx	eax, ds:$LN65_0[edx]
		jmp	ds:$LN71[eax*4]	; switch jump
; ---------------------------------------------------------------------------

$LN42_0:				; CODE XREF: changeState_2022(UConverter *,char	const *	*,char const *,Variant2022,UErrorCode *)+18Fj
					; DATA XREF: .text:$LN71o
		mov	eax, [ebp+arg_10] ; jumptable 000072DF case 0
		mov	dword ptr [eax], 13h
		jmp	loc_738D
; ---------------------------------------------------------------------------

$LN41_0:				; CODE XREF: changeState_2022(UConverter *,char	const *	*,char const *,Variant2022,UErrorCode *)+18Fj
					; DATA XREF: .text:$LN71o
		mov	eax, [ebp+var_14] ; jumptable 000072DF case 17
		movsx	ecx, byte ptr [eax+32h]
		test	ecx, ecx
		jz	short loc_7320
		mov	eax, [ebp+var_14]
		movsx	ecx, byte ptr [eax+34h]
		cmp	ecx, 2
		jge	short loc_7317
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_14]
		mov	dl, [ecx+34h]
		mov	[eax+35h], dl

loc_7317:				; CODE XREF: changeState_2022(UConverter *,char	const *	*,char const *,Variant2022,UErrorCode *)+1B9j
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+34h], 2
		jmp	short loc_7329
; ---------------------------------------------------------------------------

loc_7320:				; CODE XREF: changeState_2022(UConverter *,char	const *	*,char const *,Variant2022,UErrorCode *)+1ADj
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 12h

loc_7329:				; CODE XREF: changeState_2022(UConverter *,char	const *	*,char const *,Variant2022,UErrorCode *)+1CEj
		jmp	short loc_738D
; ---------------------------------------------------------------------------

$LN37:					; CODE XREF: changeState_2022(UConverter *,char	const *	*,char const *,Variant2022,UErrorCode *)+18Fj
					; DATA XREF: .text:$LN71o
		mov	eax, [ebp+var_14] ; jumptable 000072DF cases 2,3
		mov	ecx, [eax+40h]
		movzx	edx, ds:_jpCharsetMasks[ecx*2]
		mov	eax, 1
		mov	ecx, [ebp+var_50]
		shl	eax, cl
		and	edx, eax
		jnz	short loc_7352
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 13h
		jmp	short loc_735B
; ---------------------------------------------------------------------------

loc_7352:				; CODE XREF: changeState_2022(UConverter *,char	const *	*,char const *,Variant2022,UErrorCode *)+1F5j
		mov	eax, [ebp+var_14]
		mov	cl, byte ptr [ebp+var_50]
		mov	[eax+32h], cl

loc_735B:				; CODE XREF: changeState_2022(UConverter *,char	const *	*,char const *,Variant2022,UErrorCode *)+200j
		jmp	short loc_738D
; ---------------------------------------------------------------------------

$LN34:					; CODE XREF: changeState_2022(UConverter *,char	const *	*,char const *,Variant2022,UErrorCode *)+17Cj
					; changeState_2022(UConverter *,char const * *,char const *,Variant2022,UErrorCode *)+18Fj
					; DATA XREF: ...
		mov	eax, [ebp+var_14] ; jumptable 000072DF default case
		mov	ecx, [eax+40h]
		movzx	edx, ds:_jpCharsetMasks[ecx*2]
		mov	eax, 1
		mov	ecx, [ebp+var_50]
		shl	eax, cl
		and	edx, eax
		jnz	short loc_7384
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 13h
		jmp	short loc_738D
; ---------------------------------------------------------------------------

loc_7384:				; CODE XREF: changeState_2022(UConverter *,char	const *	*,char const *,Variant2022,UErrorCode *)+227j
		mov	eax, [ebp+var_14]
		mov	cl, byte ptr [ebp+var_50]
		mov	[eax+30h], cl

loc_738D:				; CODE XREF: changeState_2022(UConverter *,char	const *	*,char const *,Variant2022,UErrorCode *)+19Fj
					; changeState_2022(UConverter *,char const * *,char const *,Variant2022,UErrorCode *):loc_7329j ...
		jmp	loc_74B9
; ---------------------------------------------------------------------------

loc_7392:				; CODE XREF: changeState_2022(UConverter *,char	const *	*,char const *,Variant2022,UErrorCode *)+145j
		mov	eax, [ebp+var_2C]
		movsx	ecx, ds:_nextStateToUnicodeCN[eax]
		mov	[ebp+var_5C], ecx
		mov	eax, [ebp+var_5C]
		mov	[ebp+var_13C], eax
		mov	ecx, [ebp+var_13C]
		add	ecx, 1
		mov	[ebp+var_13C], ecx
		cmp	[ebp+var_13C], 23h ; '#' ; switch 36 cases
		ja	$LN15		; jumptable 000073D1 default case
		mov	edx, [ebp+var_13C]
		movzx	eax, ds:$LN66_0[edx]
		jmp	ds:$LN72[eax*4]	; switch jump
; ---------------------------------------------------------------------------

$LN28:					; CODE XREF: changeState_2022(UConverter *,char	const *	*,char const *,Variant2022,UErrorCode *)+281j
					; DATA XREF: .text:$LN72o
		mov	eax, [ebp+arg_10] ; jumptable 000073D1 case 0
		mov	dword ptr [eax], 13h
		jmp	loc_749B
; ---------------------------------------------------------------------------

$LN27_0:				; CODE XREF: changeState_2022(UConverter *,char	const *	*,char const *,Variant2022,UErrorCode *)+281j
					; DATA XREF: .text:$LN72o
		mov	eax, [ebp+var_14] ; jumptable 000073D1 case 17
		movsx	ecx, byte ptr [eax+32h]
		test	ecx, ecx
		jz	short loc_7412
		mov	eax, [ebp+var_14]
		movsx	ecx, byte ptr [eax+34h]
		cmp	ecx, 2
		jge	short loc_7409
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_14]
		mov	dl, [ecx+34h]
		mov	[eax+35h], dl

loc_7409:				; CODE XREF: changeState_2022(UConverter *,char	const *	*,char const *,Variant2022,UErrorCode *)+2ABj
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+34h], 2
		jmp	short loc_741B
; ---------------------------------------------------------------------------

loc_7412:				; CODE XREF: changeState_2022(UConverter *,char	const *	*,char const *,Variant2022,UErrorCode *)+29Fj
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 12h

loc_741B:				; CODE XREF: changeState_2022(UConverter *,char	const *	*,char const *,Variant2022,UErrorCode *)+2C0j
		jmp	short loc_749B
; ---------------------------------------------------------------------------

$LN23_0:				; CODE XREF: changeState_2022(UConverter *,char	const *	*,char const *,Variant2022,UErrorCode *)+281j
					; DATA XREF: .text:$LN72o
		mov	eax, [ebp+var_14] ; jumptable 000073D1 case 18
		movsx	ecx, byte ptr [eax+33h]
		test	ecx, ecx
		jz	short loc_7449
		mov	eax, [ebp+var_14]
		movsx	ecx, byte ptr [eax+34h]
		cmp	ecx, 2
		jge	short loc_7440
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_14]
		mov	dl, [ecx+34h]
		mov	[eax+35h], dl

loc_7440:				; CODE XREF: changeState_2022(UConverter *,char	const *	*,char const *,Variant2022,UErrorCode *)+2E2j
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+34h], 3
		jmp	short loc_7452
; ---------------------------------------------------------------------------

loc_7449:				; CODE XREF: changeState_2022(UConverter *,char	const *	*,char const *,Variant2022,UErrorCode *)+2D6j
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 12h

loc_7452:				; CODE XREF: changeState_2022(UConverter *,char	const *	*,char const *,Variant2022,UErrorCode *)+2F7j
		jmp	short loc_749B
; ---------------------------------------------------------------------------

$LN19:					; CODE XREF: changeState_2022(UConverter *,char	const *	*,char const *,Variant2022,UErrorCode *)+281j
					; DATA XREF: .text:$LN72o
		mov	eax, [ebp+var_14] ; jumptable 000073D1 case 3
		cmp	dword ptr [eax+40h], 0
		jnz	short $LN17	; jumptable 000073D1 cases 2,34
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 13h
		jmp	short loc_749B
; ---------------------------------------------------------------------------

$LN17:					; CODE XREF: changeState_2022(UConverter *,char	const *	*,char const *,Variant2022,UErrorCode *)+281j
					; changeState_2022(UConverter *,char const * *,char const *,Variant2022,UErrorCode *)+30Bj
					; DATA XREF: ...
		mov	eax, [ebp+var_14] ; jumptable 000073D1 cases 2,34
		mov	cl, byte ptr [ebp+var_5C]
		mov	[eax+31h], cl
		jmp	short loc_749B
; ---------------------------------------------------------------------------

$LN16:					; CODE XREF: changeState_2022(UConverter *,char	const *	*,char const *,Variant2022,UErrorCode *)+281j
					; DATA XREF: .text:$LN72o
		mov	eax, [ebp+var_14] ; jumptable 000073D1 case 35
		mov	cl, byte ptr [ebp+var_5C]
		mov	[eax+32h], cl
		jmp	short loc_749B
; ---------------------------------------------------------------------------

$LN15:					; CODE XREF: changeState_2022(UConverter *,char	const *	*,char const *,Variant2022,UErrorCode *)+26Ej
					; changeState_2022(UConverter *,char const * *,char const *,Variant2022,UErrorCode *)+281j
					; DATA XREF: ...
		mov	eax, [ebp+var_14] ; jumptable 000073D1 default case
		cmp	dword ptr [eax+40h], 0
		jnz	short loc_7492
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 13h
		jmp	short loc_749B
; ---------------------------------------------------------------------------

loc_7492:				; CODE XREF: changeState_2022(UConverter *,char	const *	*,char const *,Variant2022,UErrorCode *)+335j
		mov	eax, [ebp+var_14]
		mov	cl, byte ptr [ebp+var_5C]
		mov	[eax+33h], cl

loc_749B:				; CODE XREF: changeState_2022(UConverter *,char	const *	*,char const *,Variant2022,UErrorCode *)+291j
					; changeState_2022(UConverter *,char const * *,char const *,Variant2022,UErrorCode *):loc_741Bj ...
		jmp	short loc_74B9
; ---------------------------------------------------------------------------

loc_749D:				; CODE XREF: changeState_2022(UConverter *,char	const *	*,char const *,Variant2022,UErrorCode *)+138j
		cmp	[ebp+var_2C], 30h ; '0'
		jnz	short loc_74A5
		jmp	short loc_74AE
; ---------------------------------------------------------------------------

loc_74A5:				; CODE XREF: changeState_2022(UConverter *,char	const *	*,char const *,Variant2022,UErrorCode *)+351j
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 13h

loc_74AE:				; CODE XREF: changeState_2022(UConverter *,char	const *	*,char const *,Variant2022,UErrorCode *)+353j
		jmp	short loc_74B9
; ---------------------------------------------------------------------------

loc_74B0:				; CODE XREF: changeState_2022(UConverter *,char	const *	*,char const *,Variant2022,UErrorCode *)+14Bj
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 12h

loc_74B9:				; CODE XREF: changeState_2022(UConverter *,char	const *	*,char const *,Variant2022,UErrorCode *)+106j
					; changeState_2022(UConverter *,char const * *,char const *,Variant2022,UErrorCode *)+11Aj ...
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_74DA
		mov	eax, [ebp+arg_0]
		mov	byte ptr [eax+24h], 0
		jmp	loc_75A9
; ---------------------------------------------------------------------------

loc_74DA:				; CODE XREF: changeState_2022(UConverter *,char	const *	*,char const *,Variant2022,UErrorCode *)+37Cj
		mov	eax, [ebp+arg_10]
		cmp	dword ptr [eax], 12h
		jnz	loc_7594
		mov	eax, [ebp+arg_0]
		movsx	ecx, byte ptr [eax+24h]
		cmp	ecx, 1
		jle	loc_7592
		mov	eax, [ebp+arg_0]
		movsx	ecx, byte ptr [eax+24h]
		sub	ecx, 1
		mov	[ebp+var_65], cl
		mov	eax, [ebp+arg_0]
		movsx	ecx, byte ptr [eax+24h]
		movsx	edx, [ebp+var_35]
		sub	ecx, edx
		mov	[ebp+var_71], cl
		movsx	eax, [ebp+var_65]
		movsx	ecx, [ebp+var_71]
		cmp	eax, ecx
		jg	short loc_7531
		movsx	eax, [ebp+var_65]
		mov	ecx, [ebp+arg_4]
		mov	edx, [ecx]
		sub	edx, eax
		mov	eax, [ebp+arg_4]
		mov	[eax], edx
		jmp	short loc_758B
; ---------------------------------------------------------------------------

loc_7531:				; CODE XREF: changeState_2022(UConverter *,char	const *	*,char const *,Variant2022,UErrorCode *)+3CDj
		movsx	eax, [ebp+var_71]
		movsx	ecx, [ebp+var_65]
		sub	eax, ecx
		mov	edx, [ebp+arg_0]
		mov	[edx+0FEh], al
		push	1
		mov	eax, [ebp+arg_0]
		add	eax, 26h ; '&'
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	ecx, [ebp+arg_0]
		movsx	edx, byte ptr [ecx+0FEh]
		neg	edx
		push	edx		; Size
		mov	eax, [ebp+arg_0]
		add	eax, 26h ; '&'
		push	eax		; Src
		mov	ecx, [ebp+arg_0]
		add	ecx, 0DEh ; ''
		push	ecx		; Dst
		call	_memcpy
		add	esp, 0Ch
		movsx	eax, [ebp+var_71]
		mov	ecx, [ebp+arg_4]
		mov	edx, [ecx]
		sub	edx, eax
		mov	eax, [ebp+arg_4]
		mov	[eax], edx

loc_758B:				; CODE XREF: changeState_2022(UConverter *,char	const *	*,char const *,Variant2022,UErrorCode *)+3DFj
		mov	eax, [ebp+arg_0]
		mov	byte ptr [eax+24h], 1

loc_7592:				; CODE XREF: changeState_2022(UConverter *,char	const *	*,char const *,Variant2022,UErrorCode *)+3A0j
		jmp	short loc_75A9
; ---------------------------------------------------------------------------

loc_7594:				; CODE XREF: changeState_2022(UConverter *,char	const *	*,char const *,Variant2022,UErrorCode *)+390j
		mov	eax, [ebp+arg_10]
		cmp	dword ptr [eax], 13h
		jnz	short loc_75A9
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+100h], 0

loc_75A9:				; CODE XREF: changeState_2022(UConverter *,char	const *	*,char const *,Variant2022,UErrorCode *)+101j
					; changeState_2022(UConverter *,char const * *,char const *,Variant2022,UErrorCode *)+385j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN70_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 13Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?changeState_2022@@YAXPAUUConverter@@PAPBDPBDW4Variant2022@@PAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
$LN70_0		dd 2			; DATA XREF: changeState_2022(UConverter *,char	const *	*,char const *,Variant2022,UErrorCode *)+45Do
		dd offset $LN69_0
$LN69_0		dd 0FFFFFFE0h, 4	; DATA XREF: .text:000075D4o
		dd offset $LN67_0	; "key"
		dd 0FFFFFFD4h, 4
		dd offset $LN68_0	; "offset"
$LN68_0		db 'offset',0           ; DATA XREF: .text:000075ECo
$LN67_0		db 'key',0              ; DATA XREF: .text:000075E0o
		align 4
$LN71		dd offset $LN42_0	; DATA XREF: changeState_2022(UConverter *,char	const *	*,char const *,Variant2022,UErrorCode *)+18Fr
		dd offset $LN37		; jump table for switch	statement
		dd offset $LN41_0
		dd offset $LN34
$LN65_0		db	0,     3,     1,     1
					; DATA XREF: changeState_2022(UConverter *,char	const *	*,char const *,Variant2022,UErrorCode *)+188r
		db	3,     3,     3,     3 ; indirect table	for switch statement
		db	3,     3,     3,     3
		db	3,     3,     3,     3
		db	3,     2
		align 10h
$LN72		dd offset $LN28		; DATA XREF: changeState_2022(UConverter *,char	const *	*,char const *,Variant2022,UErrorCode *)+281r
		dd offset $LN17		; jump table for switch	statement
		dd offset $LN19
		dd offset $LN27_0
		dd offset $LN23_0
		dd offset $LN16
		dd offset $LN15
$LN66_0		db	0,     6,     1,     2
					; DATA XREF: changeState_2022(UConverter *,char	const *	*,char const *,Variant2022,UErrorCode *)+27Ar
		db	6,     6,     6,     6 ; indirect table	for switch statement
		db	6,     6,     6,     6
		db	6,     6,     6,     6
		db	6,     3,     4,     6
		db	6,     6,     6,     6
		db	6,     6,     6,     6
		db	6,     6,     6,     6
		db	6,     6,     1,     5
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7660h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; enum	UCNV_TableStates_2022 __cdecl getKey_2022(char,	int *, int *)
?getKey_2022@@YA?AW4UCNV_TableStates_2022@@DPAH0@Z proc	near
					; CODE XREF: changeState_2022(UConverter *,char	const *	*,char const *,Variant2022,UErrorCode *)+99p

var_FC		= byte ptr -0FCh
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= byte ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0FCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_FC]
		mov	ecx, 3Fh ; '?'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_14], 0
		mov	[ebp+var_20], 4Ah ; 'J'
		mov	[ebp+var_2C], 0
		movzx	eax, [ebp+arg_0]
		movsx	ecx, ds:_normalize_esq_chars_2022[eax]
		mov	[ebp+var_8], ecx
		cmp	[ebp+var_8], 0
		jnz	short loc_76C1
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 0
		or	eax, 0FFFFFFFFh
		jmp	loc_7753
; ---------------------------------------------------------------------------

loc_76C1:				; CODE XREF: getKey_2022(char,int *,int	*)+45j
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		shl	ecx, 5
		add	ecx, [ebp+var_8]
		mov	[ebp+var_8], ecx

loc_76CF:				; CODE XREF: getKey_2022(char,int *,int	*)+DCj
		mov	eax, [ebp+var_20]
		cmp	eax, [ebp+var_14]
		jz	short loc_773E
		mov	eax, [ebp+var_20]
		add	eax, [ebp+var_14]
		sar	eax, 1
		mov	[ebp+var_38], eax
		mov	eax, [ebp+var_38]
		cmp	eax, [ebp+var_2C]
		jnz	short loc_76EC
		jmp	short loc_773E
; ---------------------------------------------------------------------------

loc_76EC:				; CODE XREF: getKey_2022(char,int *,int	*)+88j
		mov	eax, [ebp+var_38]
		mov	ecx, ds:_escSeqStateTable_Key_2022[eax*4]
		cmp	ecx, [ebp+var_8]
		jle	short loc_7703
		mov	eax, [ebp+var_38]
		mov	[ebp+var_20], eax
		jmp	short loc_7736
; ---------------------------------------------------------------------------

loc_7703:				; CODE XREF: getKey_2022(char,int *,int	*)+99j
		mov	eax, [ebp+var_38]
		mov	ecx, ds:_escSeqStateTable_Key_2022[eax*4]
		cmp	ecx, [ebp+var_8]
		jge	short loc_771A
		mov	eax, [ebp+var_38]
		mov	[ebp+var_14], eax
		jmp	short loc_7736
; ---------------------------------------------------------------------------

loc_771A:				; CODE XREF: getKey_2022(char,int *,int	*)+B0j
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+var_8]
		mov	[eax], ecx
		mov	eax, [ebp+arg_8]
		mov	ecx, [ebp+var_38]
		mov	[eax], ecx
		mov	eax, [ebp+var_38]
		movsx	eax, ds:_escSeqStateTable_Value_2022[eax]
		jmp	short loc_7753
; ---------------------------------------------------------------------------

loc_7736:				; CODE XREF: getKey_2022(char,int *,int	*)+A1j
					; getKey_2022(char,int *,int *)+B8j
		mov	eax, [ebp+var_38]
		mov	[ebp+var_2C], eax
		jmp	short loc_76CF
; ---------------------------------------------------------------------------

loc_773E:				; CODE XREF: getKey_2022(char,int *,int	*)+75j
					; getKey_2022(char,int *,int *)+8Aj
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 0
		or	eax, 0FFFFFFFFh

loc_7753:				; CODE XREF: getKey_2022(char,int *,int	*)+5Cj
					; getKey_2022(char,int *,int *)+D4j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getKey_2022@@YA?AW4UCNV_TableStates_2022@@DPAH0@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 775Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl toUnicodeCallback(struct	UConverter *, unsigned int, unsigned int, enum	UErrorCode *)
?toUnicodeCallback@@YAXPAUUConverter@@IIPAW4UErrorCode@@@Z proc	near
					; CODE XREF: UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+690p
					; UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+3CDp ...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_4], 0FFh
		jbe	short loc_77A1
		mov	eax, [ebp+arg_4]
		shr	eax, 8
		mov	ecx, [ebp+arg_0]
		mov	[ecx+25h], al
		mov	eax, [ebp+arg_0]
		mov	cl, byte ptr [ebp+arg_4]
		mov	[eax+26h], cl
		mov	eax, [ebp+arg_0]
		mov	byte ptr [eax+24h], 2
		jmp	short loc_77B1
; ---------------------------------------------------------------------------

loc_77A1:				; CODE XREF: toUnicodeCallback(UConverter *,uint,uint,UErrorCode *)+25j
		mov	eax, [ebp+arg_0]
		mov	cl, byte ptr [ebp+arg_4]
		mov	[eax+25h], cl
		mov	eax, [ebp+arg_0]
		mov	byte ptr [eax+24h], 1

loc_77B1:				; CODE XREF: toUnicodeCallback(UConverter *,uint,uint,UErrorCode *)+43j
		cmp	[ebp+arg_8], 0FFFEh
		jnz	short loc_77C5
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 0Ah
		jmp	short loc_77CE
; ---------------------------------------------------------------------------

loc_77C5:				; CODE XREF: toUnicodeCallback(UConverter *,uint,uint,UErrorCode *)+5Cj
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 0Ch

loc_77CE:				; CODE XREF: toUnicodeCallback(UConverter *,uint,uint,UErrorCode *)+67j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?toUnicodeCallback@@YAXPAUUConverter@@IIPAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 77D8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; unsigned int __cdecl jisx201ToU(unsigned int)
?jisx201ToU@@YAII@Z proc near		; CODE XREF: UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+393p

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 5Ch ; '\'
		jnb	short loc_7803
		mov	eax, [ebp+arg_0]
		jmp	short loc_7824
; ---------------------------------------------------------------------------
		jmp	short loc_7824
; ---------------------------------------------------------------------------

loc_7803:				; CODE XREF: jisx201ToU(uint)+22j
		cmp	[ebp+arg_0], 5Ch ; '\'
		jnz	short loc_7812
		mov	eax, 0A5h ; ''
		jmp	short loc_7824
; ---------------------------------------------------------------------------
		jmp	short loc_7824
; ---------------------------------------------------------------------------

loc_7812:				; CODE XREF: jisx201ToU(uint)+2Fj
		cmp	[ebp+arg_0], 7Eh ; '~'
		jnz	short loc_7821
		mov	eax, 203Eh
		jmp	short loc_7824
; ---------------------------------------------------------------------------
		jmp	short loc_7824
; ---------------------------------------------------------------------------

loc_7821:				; CODE XREF: jisx201ToU(uint)+3Ej
		mov	eax, [ebp+arg_0]

loc_7824:				; CODE XREF: jisx201ToU(uint)+27j
					; jisx201ToU(uint)+29j	...
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?jisx201ToU@@YAII@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 782Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl _2022ToSJIS(unsigned char, unsigned char, char *	const)
?_2022ToSJIS@@YAXEEQAD@Z proc near	; CODE XREF: UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+456p

var_C0		= byte ptr -0C0h
arg_0		= byte ptr  8
arg_4		= byte ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		movzx	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_788B
		mov	al, [ebp+arg_0]
		add	al, 1
		mov	[ebp+arg_0], al
		movzx	eax, [ebp+arg_4]
		cmp	eax, 5Fh ; '_'
		jg	short loc_7870
		movzx	eax, [ebp+arg_4]
		add	eax, 1Fh
		mov	[ebp+arg_4], al
		jmp	short loc_7889
; ---------------------------------------------------------------------------

loc_7870:				; CODE XREF: _2022ToSJIS(uchar,uchar,char * const)+36j
		movzx	eax, [ebp+arg_4]
		cmp	eax, 7Eh ; '~'
		jg	short loc_7885
		movzx	eax, [ebp+arg_4]
		add	eax, 20h ; ' '
		mov	[ebp+arg_4], al
		jmp	short loc_7889
; ---------------------------------------------------------------------------

loc_7885:				; CODE XREF: _2022ToSJIS(uchar,uchar,char * const)+4Bj
		mov	[ebp+arg_4], 0

loc_7889:				; CODE XREF: _2022ToSJIS(uchar,uchar,char * const)+42j
					; _2022ToSJIS(uchar,uchar,char * const)+57j
		jmp	short loc_78AA
; ---------------------------------------------------------------------------

loc_788B:				; CODE XREF: _2022ToSJIS(uchar,uchar,char * const)+25j
		movzx	eax, [ebp+arg_4]
		sub	eax, 21h ; '!'
		movzx	ecx, al
		cmp	ecx, 5Dh ; ']'
		jg	short loc_78A6
		movzx	eax, [ebp+arg_4]
		add	eax, 7Eh ; '~'
		mov	[ebp+arg_4], al
		jmp	short loc_78AA
; ---------------------------------------------------------------------------

loc_78A6:				; CODE XREF: _2022ToSJIS(uchar,uchar,char * const)+6Cj
		mov	[ebp+arg_4], 0

loc_78AA:				; CODE XREF: _2022ToSJIS(uchar,uchar,char * const):loc_7889j
					; _2022ToSJIS(uchar,uchar,char * const)+78j
		mov	al, [ebp+arg_0]
		shr	al, 1
		mov	[ebp+arg_0], al
		movzx	eax, [ebp+arg_0]
		cmp	eax, 2Fh ; '/'
		jg	short loc_78C7
		movzx	eax, [ebp+arg_0]
		add	eax, 70h ; 'p'
		mov	[ebp+arg_0], al
		jmp	short loc_78E2
; ---------------------------------------------------------------------------

loc_78C7:				; CODE XREF: _2022ToSJIS(uchar,uchar,char * const)+8Dj
		movzx	eax, [ebp+arg_0]
		cmp	eax, 3Fh ; '?'
		jg	short loc_78DE
		movzx	eax, [ebp+arg_0]
		add	eax, 0B0h ; ''
		mov	[ebp+arg_0], al
		jmp	short loc_78E2
; ---------------------------------------------------------------------------

loc_78DE:				; CODE XREF: _2022ToSJIS(uchar,uchar,char * const)+A2j
		mov	[ebp+arg_0], 0

loc_78E2:				; CODE XREF: _2022ToSJIS(uchar,uchar,char * const)+99j
					; _2022ToSJIS(uchar,uchar,char * const)+B0j
		mov	eax, [ebp+arg_8]
		mov	cl, [ebp+arg_0]
		mov	[eax], cl
		mov	eax, [ebp+arg_8]
		mov	cl, [ebp+arg_4]
		mov	[eax+1], cl
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?_2022ToSJIS@@YAXEEQAD@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 78FCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC(struct UConverterFromUnicodeArgs *, enum  UErrorCode *)
?UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC@@YAXPAUUConverterFromUnicodeArgs@@PAW4UErrorCode@@@Z proc near
					; DATA XREF: .rdata:000008C8o
					; .rdata:000008CCo

var_174		= byte ptr -174h
var_B0		= dword	ptr -0B0h
var_A4		= word ptr -0A4h
var_98		= dword	ptr -98h
var_89		= byte ptr -89h
var_80		= dword	ptr -80h
var_74		= dword	ptr -74h
var_65		= byte ptr -65h
var_59		= byte ptr -59h
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 174h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_174]
		mov	ecx, 5Dh ; ']'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+0Ch]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		mov	[ebp+var_20], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+14h]
		mov	[ebp+var_2C], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+18h]
		mov	[ebp+var_38], ecx
		mov	[ebp+var_44], 0
		mov	[ebp+var_50], 0
		mov	[ebp+var_98], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	edx, [ecx+8]
		mov	[ebp+var_74], edx
		mov	eax, [ebp+var_74]
		cmp	dword ptr [eax+40h], 1
		jnz	short loc_7989
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC_IBM@@YAXPAUUConverterFromUnicodeArgs@@PAW4UErrorCode@@@Z ; UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC_IBM(UConverterFromUnicodeArgs *,UErrorCode *)
		add	esp, 8
		jmp	loc_7EE3
; ---------------------------------------------------------------------------

loc_7989:				; CODE XREF: UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+76j
		mov	eax, [ebp+var_74]
		mov	ecx, [eax+28h]
		mov	edx, [ecx+18h]
		mov	[ebp+var_80], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	dl, [ecx+23h]
		mov	[ebp+var_89], dl
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	dl, [ecx+34h]
		mov	[ebp+var_59], dl
		mov	al, [ebp+var_59]
		mov	[ebp+var_65], al
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	dl, [ecx+34h]
		mov	[ebp+var_59], dl
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	edx, [ecx+38h]
		mov	[ebp+var_50], edx
		cmp	[ebp+var_50], 0
		jz	short loc_79E6
		mov	eax, [ebp+var_20]
		cmp	eax, [ebp+var_2C]
		jnb	short loc_79E6
		jmp	$getTrail$38053
; ---------------------------------------------------------------------------
		jmp	$getTrail$38053
; ---------------------------------------------------------------------------

loc_79E6:				; CODE XREF: UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+D6j
					; UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)+DEj ...
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+var_14]
		jnb	loc_7DBD
		mov	[ebp+var_44], 0FFFFh
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_20]
		cmp	ecx, [eax+14h]
		jnb	loc_7DAD
		mov	eax, [ebp+var_8]
		movzx	ecx, word ptr [eax]
		mov	[ebp+var_50], ecx
		mov	edx, [ebp+var_8]
		add	edx, 2
		mov	[ebp+var_8], edx
		cmp	[ebp+var_50], 20h ; ' '
		jge	short loc_7A4B
		mov	eax, 1
		mov	ecx, [ebp+var_50]
		shl	eax, cl
		and	eax, 800C000h
		jz	short loc_7A4B
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Ch
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	edx, [ebp+var_50]
		mov	[ecx+38h], edx
		jmp	loc_7DBD
; ---------------------------------------------------------------------------

loc_7A4B:				; CODE XREF: UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+122j
					; UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)+133j
		push	1
		movzx	eax, [ebp+var_89]
		push	eax
		lea	ecx, [ebp+var_44]
		push	ecx
		mov	edx, [ebp+var_50]
		push	edx
		mov	eax, [ebp+var_80]
		push	eax
		call	?MBCS_FROM_UCHAR32_ISO2022@@YAHPAUUConverterSharedData@@HPAICH@Z ; MBCS_FROM_UCHAR32_ISO2022(UConverterSharedData *,int,uint *,signed char,int)
		add	esp, 14h
		mov	[ebp+var_98], eax
		cmp	[ebp+var_98], 0
		jge	short loc_7A86
		mov	eax, [ebp+var_98]
		neg	eax
		mov	[ebp+var_98], eax

loc_7A86:				; CODE XREF: UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+17Aj
		cmp	[ebp+var_98], 2
		jg	short loc_7AD3
		cmp	[ebp+var_98], 0
		jz	short loc_7AD3
		cmp	[ebp+var_98], 1
		jnz	short loc_7AA7
		cmp	[ebp+var_44], 7Fh ; ''
		ja	short loc_7AD3

loc_7AA7:				; CODE XREF: UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+1A3j
		cmp	[ebp+var_98], 2
		jnz	short loc_7ADA
		mov	eax, [ebp+var_44]
		sub	eax, 0A1A1h
		movzx	ecx, ax
		cmp	ecx, 5D5Dh
		jg	short loc_7AD3
		mov	eax, [ebp+var_44]
		sub	eax, 0A1h ; ''
		movzx	ecx, al
		cmp	ecx, 5Dh ; ']'
		jle	short loc_7ADA

loc_7AD3:				; CODE XREF: UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+191j
					; UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)+19Aj ...
		mov	[ebp+var_44], 0FFFFh

loc_7ADA:				; CODE XREF: UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+1B2j
					; UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)+1D5j
		cmp	[ebp+var_44], 0FFFFh
		jz	loc_7D07
		mov	al, [ebp+var_59]
		mov	[ebp+var_65], al
		cmp	[ebp+var_44], 0FFh
		setnbe	al
		mov	[ebp+var_59], al
		movsx	eax, [ebp+var_65]
		movsx	ecx, [ebp+var_59]
		cmp	eax, ecx
		jz	short loc_7B50
		movsx	eax, [ebp+var_59]
		test	eax, eax
		jz	short loc_7B1F
		mov	eax, [ebp+var_20]
		mov	byte ptr [eax],	0Eh
		mov	ecx, [ebp+var_20]
		add	ecx, 1
		mov	[ebp+var_20], ecx
		jmp	short loc_7B2E
; ---------------------------------------------------------------------------

loc_7B1F:				; CODE XREF: UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+210j
		mov	eax, [ebp+var_20]
		mov	byte ptr [eax],	0Fh
		mov	ecx, [ebp+var_20]
		add	ecx, 1
		mov	[ebp+var_20], ecx

loc_7B2E:				; CODE XREF: UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+221j
		cmp	[ebp+var_38], 0
		jz	short loc_7B50
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_8]
		sub	ecx, [eax+8]
		sar	ecx, 1
		sub	ecx, 1
		mov	edx, [ebp+var_38]
		mov	[edx], ecx
		mov	eax, [ebp+var_38]
		add	eax, 4
		mov	[ebp+var_38], eax

loc_7B50:				; CODE XREF: UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+208j
					; UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)+236j
		cmp	[ebp+var_44], 0FFh
		ja	short loc_7BCF
		mov	eax, [ebp+var_20]
		cmp	eax, [ebp+var_2C]
		jnb	short loc_7B96
		mov	eax, [ebp+var_20]
		mov	cl, byte ptr [ebp+var_44]
		mov	[eax], cl
		mov	edx, [ebp+var_20]
		add	edx, 1
		mov	[ebp+var_20], edx
		cmp	[ebp+var_38], 0
		jz	short loc_7B94
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_8]
		sub	ecx, [eax+8]
		sar	ecx, 1
		sub	ecx, 1
		mov	edx, [ebp+var_38]
		mov	[edx], ecx
		mov	eax, [ebp+var_38]
		add	eax, 4
		mov	[ebp+var_38], eax

loc_7B94:				; CODE XREF: UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+27Aj
		jmp	short loc_7BCA
; ---------------------------------------------------------------------------

loc_7B96:				; CODE XREF: UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+263j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+4]
		movsx	edx, byte ptr [eax+3Fh]
		mov	al, byte ptr [ebp+var_44]
		mov	[ecx+edx+4Ch], al
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	al, [edx+3Fh]
		add	al, 1
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	[edx+3Fh], al
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Fh

loc_7BCA:				; CODE XREF: UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *):loc_7B94j
		jmp	loc_7D02
; ---------------------------------------------------------------------------

loc_7BCF:				; CODE XREF: UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+25Bj
		mov	eax, [ebp+var_20]
		cmp	eax, [ebp+var_2C]
		jnb	loc_7C94
		mov	eax, [ebp+var_44]
		shr	eax, 8
		sub	eax, 80h ; ''
		mov	ecx, [ebp+var_20]
		mov	[ecx], al
		mov	edx, [ebp+var_20]
		add	edx, 1
		mov	[ebp+var_20], edx
		cmp	[ebp+var_38], 0
		jz	short loc_7C16
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_8]
		sub	ecx, [eax+8]
		sar	ecx, 1
		sub	ecx, 1
		mov	edx, [ebp+var_38]
		mov	[edx], ecx
		mov	eax, [ebp+var_38]
		add	eax, 4
		mov	[ebp+var_38], eax

loc_7C16:				; CODE XREF: UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+2FCj
		mov	eax, [ebp+var_20]
		cmp	eax, [ebp+var_2C]
		jnb	short loc_7C58
		mov	eax, [ebp+var_44]
		sub	eax, 80h ; ''
		mov	ecx, [ebp+var_20]
		mov	[ecx], al
		mov	edx, [ebp+var_20]
		add	edx, 1
		mov	[ebp+var_20], edx
		cmp	[ebp+var_38], 0
		jz	short loc_7C56
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_8]
		sub	ecx, [eax+8]
		sar	ecx, 1
		sub	ecx, 1
		mov	edx, [ebp+var_38]
		mov	[edx], ecx
		mov	eax, [ebp+var_38]
		add	eax, 4
		mov	[ebp+var_38], eax

loc_7C56:				; CODE XREF: UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+33Cj
		jmp	short loc_7C92
; ---------------------------------------------------------------------------

loc_7C58:				; CODE XREF: UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+320j
		mov	eax, [ebp+var_44]
		sub	eax, 80h ; ''
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	ecx, [ebp+arg_0]
		mov	ecx, [ecx+4]
		movsx	ecx, byte ptr [ecx+3Fh]
		mov	[edx+ecx+4Ch], al
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+4]
		mov	cl, [eax+3Fh]
		add	cl, 1
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+4]
		mov	[eax+3Fh], cl
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Fh

loc_7C92:				; CODE XREF: UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *):loc_7C56j
		jmp	short loc_7D02
; ---------------------------------------------------------------------------

loc_7C94:				; CODE XREF: UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+2D9j
		mov	eax, [ebp+var_44]
		shr	eax, 8
		sub	eax, 80h ; ''
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	ecx, [ebp+arg_0]
		mov	ecx, [ecx+4]
		movsx	ecx, byte ptr [ecx+3Fh]
		mov	[edx+ecx+4Ch], al
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+4]
		mov	cl, [eax+3Fh]
		add	cl, 1
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+4]
		mov	[eax+3Fh], cl
		mov	eax, [ebp+var_44]
		sub	eax, 80h ; ''
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	ecx, [ebp+arg_0]
		mov	ecx, [ecx+4]
		movsx	ecx, byte ptr [ecx+3Fh]
		mov	[edx+ecx+4Ch], al
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+4]
		mov	cl, [eax+3Fh]
		add	cl, 1
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+4]
		mov	[eax+3Fh], cl
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Fh

loc_7D02:				; CODE XREF: UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *):loc_7BCAj
					; UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *):loc_7C92j
		jmp	loc_7DAB
; ---------------------------------------------------------------------------

loc_7D07:				; CODE XREF: UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+1E5j
		mov	eax, [ebp+var_50]
		and	eax, 0FFFFF800h
		cmp	eax, 0D800h
		jnz	short loc_7D94
		mov	eax, [ebp+var_50]
		and	eax, 400h
		jnz	short loc_7D89

$getTrail$38053:			; CODE XREF: UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+E0j
					; UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)+E5j
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+var_14]
		jnb	short loc_7D7E
		mov	eax, [ebp+var_8]
		mov	cx, [eax]
		mov	[ebp+var_A4], cx
		movzx	eax, [ebp+var_A4]
		and	eax, 0FFFFFC00h
		cmp	eax, 0DC00h
		jnz	short loc_7D73
		mov	eax, [ebp+var_8]
		add	eax, 2
		mov	[ebp+var_8], eax
		mov	eax, [ebp+var_50]
		shl	eax, 0Ah
		movzx	ecx, [ebp+var_A4]
		lea	edx, [eax+ecx-35FDC00h]
		mov	[ebp+var_50], edx
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Ah
		jmp	short loc_7D7C
; ---------------------------------------------------------------------------

loc_7D73:				; CODE XREF: UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+44Aj
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Ch

loc_7D7C:				; CODE XREF: UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+475j
		jmp	short loc_7D87
; ---------------------------------------------------------------------------

loc_7D7E:				; CODE XREF: UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+42Aj
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0

loc_7D87:				; CODE XREF: UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *):loc_7D7Cj
		jmp	short loc_7D92
; ---------------------------------------------------------------------------

loc_7D89:				; CODE XREF: UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+422j
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Ch

loc_7D92:				; CODE XREF: UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *):loc_7D87j
		jmp	short loc_7D9D
; ---------------------------------------------------------------------------

loc_7D94:				; CODE XREF: UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+418j
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Ah

loc_7D9D:				; CODE XREF: UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *):loc_7D92j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	edx, [ebp+var_50]
		mov	[ecx+38h], edx
		jmp	short loc_7DBD
; ---------------------------------------------------------------------------

loc_7DAB:				; CODE XREF: UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *):loc_7D02j
		jmp	short loc_7DB8
; ---------------------------------------------------------------------------

loc_7DAD:				; CODE XREF: UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+106j
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Fh
		jmp	short loc_7DBD
; ---------------------------------------------------------------------------

loc_7DB8:				; CODE XREF: UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *):loc_7DABj
		jmp	loc_79E6
; ---------------------------------------------------------------------------

loc_7DBD:				; CODE XREF: UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+F0j
					; UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)+14Aj ...
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	loc_7EC4
		movsx	eax, [ebp+var_59]
		test	eax, eax
		jz	loc_7EC4
		mov	eax, [ebp+arg_0]
		movsx	ecx, byte ptr [eax+2]
		test	ecx, ecx
		jz	loc_7EC4
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+var_14]
		jb	loc_7EC4
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		cmp	dword ptr [ecx+38h], 0
		jnz	loc_7EC4
		mov	[ebp+var_59], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_8]
		sub	ecx, [eax+8]
		sar	ecx, 1
		mov	[ebp+var_B0], ecx
		cmp	[ebp+var_B0], 0
		jle	short loc_7E8D
		mov	eax, [ebp+var_B0]
		sub	eax, 1
		mov	[ebp+var_B0], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		mov	edx, [ebp+var_B0]
		movzx	eax, word ptr [ecx+edx*2]
		and	eax, 0FFFFFC00h
		cmp	eax, 0DC00h
		jnz	short loc_7E8B
		cmp	[ebp+var_B0], 0
		jz	short loc_7E7C
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		mov	edx, [ebp+var_B0]
		movzx	eax, word ptr [ecx+edx*2-2]
		and	eax, 0FFFFFC00h
		cmp	eax, 0D800h
		jnz	short loc_7E8B

loc_7E7C:				; CODE XREF: UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+561j
		mov	eax, [ebp+var_B0]
		sub	eax, 1
		mov	[ebp+var_B0], eax

loc_7E8B:				; CODE XREF: UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+558j
					; UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)+57Ej
		jmp	short loc_7E97
; ---------------------------------------------------------------------------

loc_7E8D:				; CODE XREF: UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+52Dj
		mov	[ebp+var_B0], 0FFFFFFFFh

loc_7E97:				; CODE XREF: UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *):loc_7E8Bj
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_B0]
		push	ecx
		lea	edx, [ebp+var_38]
		push	edx
		mov	eax, [ebp+var_2C]
		push	eax
		lea	ecx, [ebp+var_20]
		push	ecx
		push	1
		push	offset _SHIFT_IN_STR
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+4]
		push	eax
		call	?fromUWriteUInt8@@YAXPAUUConverter@@PBDHPAPAE1PAPAHHPAW4UErrorCode@@@Z ; fromUWriteUInt8(UConverter *,char const *,int,uchar * *,char const *,int * *,int,UErrorCode *)
		add	esp, 20h

loc_7EC4:				; CODE XREF: UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+4D4j
					; UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)+4E0j ...
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_8]
		mov	[eax+8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_20]
		mov	[eax+10h], ecx
		movsx	eax, [ebp+var_59]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	[edx+34h], eax

loc_7EE3:				; CODE XREF: UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+88j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN50_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 174h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC@@YAXPAUUConverterFromUnicodeArgs@@PAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
$LN50_0		dd 3			; DATA XREF: UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+5EBo
		dd offset $LN49
$LN49		dd 0FFFFFFE0h, 4	; DATA XREF: .text:00007F0Co
		dd offset $LN46_0	; "target"
		dd 0FFFFFFC8h, 4
		dd offset $LN47_0	; "offsets"
		dd 0FFFFFFBCh, 4
		dd offset $LN48		; "targetByteUnit"
$LN48		db 'targetByteUnit',0   ; DATA XREF: .text:00007F30o
$LN47_0		db 'offsets',0          ; DATA XREF: .text:00007F24o
$LN46_0		db 'target',0           ; DATA XREF: .text:00007F18o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7F54h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC_IBM(struct UConverterFromUnicodeArgs *,	enum  UErrorCode *)
?UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC_IBM@@YAXPAUUConverterFromUnicodeArgs@@PAW4UErrorCode@@@Z proc	near
					; CODE XREF: UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+80p

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+28h]
		mov	[eax+4], edx
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+28h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+38h]
		mov	[ecx+38h], eax
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	_ucnv_MBCSFromUnicodeWithOffsets_56
		add	esp, 8
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+28h]
		mov	edx, [ebp+var_8]
		mov	eax, [ecx+38h]
		mov	[edx+38h], eax
		mov	eax, [ebp+arg_4]
		cmp	dword ptr [eax], 0Fh
		jnz	short loc_8025
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+28h]
		movsx	edx, byte ptr [ecx+3Fh]
		test	edx, edx
		jle	short loc_800C
		push	1
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+28h]
		add	ecx, 4Ch ; 'L'
		push	ecx
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	edx, [ebp+var_14]
		mov	eax, [edx+28h]
		movsx	ecx, byte ptr [eax+3Fh]
		push	ecx		; Size
		mov	edx, [ebp+var_14]
		mov	eax, [edx+28h]
		add	eax, 4Ch ; 'L'
		push	eax		; Src
		mov	ecx, [ebp+var_8]

loc_8000:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::_Stdioo
		add	ecx, 4Ch ; 'L'
		push	ecx		; Dst
		call	_memcpy
		add	esp, 0Ch

loc_800C:				; CODE XREF: UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC_IBM(UConverterFromUnicodeArgs *,UErrorCode *)+7Ej
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+28h]
		mov	edx, [ebp+var_8]
		mov	al, [ecx+3Fh]
		mov	[edx+3Fh], al
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+28h]
		mov	byte ptr [ecx+3Fh], 0

loc_8025:				; CODE XREF: UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC_IBM(UConverterFromUnicodeArgs *,UErrorCode *)+70j
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_8]
		mov	[eax+4], ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC_IBM@@YAXPAUUConverterFromUnicodeArgs@@PAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8044h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC(void *Src,	int)
?UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC@@YAXPAUUConverterToUnicodeArgs@@PAW4UErrorCode@@@Z proc	near
					; DATA XREF: .rdata:000008C0o
					; .rdata:000008C4o

var_150		= byte ptr -150h
var_89		= byte ptr -89h
var_80		= dword	ptr -80h
var_74		= dword	ptr -74h
var_65		= byte ptr -65h
var_5C		= dword	ptr -5Ch
var_50		= dword	ptr -50h
var_44		= word ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= byte ptr -8
var_7		= byte ptr -7
Src		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 150h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_150]
		mov	ecx, 54h ; 'T'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+Src]
		mov	ecx, [eax+8]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+Src]
		mov	ecx, [eax+10h]
		mov	[ebp+var_20], ecx
		mov	eax, [ebp+Src]
		mov	ecx, [eax+0Ch]
		mov	[ebp+var_2C], ecx
		mov	[ebp+var_38], 0
		xor	eax, eax
		mov	[ebp+var_44], ax
		mov	eax, [ebp+Src]
		mov	ecx, [eax+4]
		mov	edx, [ecx+8]
		mov	[ebp+var_50], edx
		mov	eax, [ebp+var_50]
		cmp	dword ptr [eax+40h], 1
		jnz	short loc_80B4
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+Src]
		push	ecx		; Src
		call	?UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC_IBM@@YAXPAUUConverterToUnicodeArgs@@PAW4UErrorCode@@@Z ; UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC_IBM(UConverterToUnicodeArgs *,UErrorCode *)
		add	esp, 8
		jmp	loc_843F
; ---------------------------------------------------------------------------

loc_80B4:				; CODE XREF: UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+59j
		mov	eax, [ebp+var_50]
		mov	ecx, [eax+28h]
		mov	edx, [ecx+18h]
		mov	[ebp+var_5C], edx
		mov	eax, [ebp+Src]
		mov	ecx, [eax+4]
		mov	dl, [ecx+23h]
		mov	[ebp+var_65], dl
		mov	eax, [ebp+var_50]
		cmp	dword ptr [eax+3Ch], 0
		jz	short loc_80E1
		jmp	$escape$38175
; ---------------------------------------------------------------------------
		jmp	$escape$38175
; ---------------------------------------------------------------------------
		jmp	short loc_8126
; ---------------------------------------------------------------------------

loc_80E1:				; CODE XREF: UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+8Fj
		mov	eax, [ebp+Src]
		mov	ecx, [eax+4]
		movsx	edx, byte ptr [ecx+24h]
		cmp	edx, 1
		jnz	short loc_8126
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_2C]
		jnb	short loc_8126
		mov	eax, [ebp+Src]
		mov	ecx, [ebp+var_20]
		cmp	ecx, [eax+14h]
		jnb	short loc_8126
		mov	eax, [ebp+Src]
		mov	ecx, [eax+4]
		movzx	dx, byte ptr [ecx+25h]
		mov	[ebp+var_44], dx
		mov	eax, [ebp+Src]
		mov	ecx, [eax+4]
		mov	byte ptr [ecx+24h], 0
		jmp	$getTrailByte$38179
; ---------------------------------------------------------------------------
		jmp	$getTrailByte$38179
; ---------------------------------------------------------------------------

loc_8126:				; CODE XREF: UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+9Bj
					; UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+AAj ...
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_2C]
		jnb	loc_842D
		mov	eax, [ebp+Src]
		mov	ecx, [ebp+var_20]
		cmp	ecx, [eax+14h]
		jnb	loc_841D
		mov	eax, [ebp+var_14]
		movzx	cx, byte ptr [eax]
		mov	[ebp+var_44], cx
		mov	edx, [ebp+var_14]
		add	edx, 1
		mov	[ebp+var_14], edx
		movzx	eax, [ebp+var_44]
		cmp	eax, 0Fh
		jnz	short loc_81C7
		mov	eax, [ebp+var_50]
		mov	byte ptr [eax+34h], 0
		mov	eax, [ebp+var_50]
		movsx	ecx, byte ptr [eax+44h]
		test	ecx, ecx
		jz	short loc_81BD
		mov	eax, [ebp+var_50]
		mov	byte ptr [eax+44h], 0
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 12h
		mov	eax, [ebp+Src]
		mov	ecx, [eax+4]
		mov	dword ptr [ecx+100h], 2
		mov	eax, [ebp+Src]
		mov	ecx, [eax+4]
		mov	dl, byte ptr [ebp+var_44]
		mov	[ecx+25h], dl
		mov	eax, [ebp+Src]
		mov	ecx, [eax+4]
		mov	byte ptr [ecx+24h], 1
		mov	eax, [ebp+Src]
		mov	ecx, [ebp+var_20]
		mov	[eax+10h], ecx
		mov	eax, [ebp+Src]
		mov	ecx, [ebp+var_14]
		mov	[eax+8], ecx
		jmp	loc_843F
; ---------------------------------------------------------------------------

loc_81BD:				; CODE XREF: UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+12Aj
		jmp	loc_8126
; ---------------------------------------------------------------------------
		jmp	loc_824C
; ---------------------------------------------------------------------------

loc_81C7:				; CODE XREF: UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+118j
		movzx	eax, [ebp+var_44]
		cmp	eax, 0Eh
		jnz	short loc_81E5
		mov	eax, [ebp+var_50]
		mov	byte ptr [eax+34h], 1
		mov	eax, [ebp+var_50]
		mov	byte ptr [eax+44h], 1
		jmp	loc_8126
; ---------------------------------------------------------------------------
		jmp	short loc_824C
; ---------------------------------------------------------------------------

loc_81E5:				; CODE XREF: UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+18Aj
		movzx	eax, [ebp+var_44]
		cmp	eax, 1Bh
		jnz	short loc_824C
		mov	eax, [ebp+var_14]
		sub	eax, 1
		mov	[ebp+var_14], eax

$escape$38175:				; CODE XREF: UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+91j
					; UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+96j
		mov	eax, [ebp+var_50]
		mov	byte ptr [eax+44h], 0
		mov	eax, [ebp+arg_4]
		push	eax
		push	2
		mov	ecx, [ebp+var_2C]
		push	ecx
		lea	edx, [ebp+var_14]
		push	edx
		mov	eax, [ebp+Src]
		mov	ecx, [eax+4]
		push	ecx
		call	?changeState_2022@@YAXPAUUConverter@@PAPBDPBDW4Variant2022@@PAW4UErrorCode@@@Z ; changeState_2022(UConverter *,char const * *,char const *,Variant2022,UErrorCode *)
		add	esp, 14h
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_8247
		mov	eax, [ebp+Src]
		mov	ecx, [ebp+var_20]
		mov	[eax+10h], ecx
		mov	eax, [ebp+Src]
		mov	ecx, [ebp+var_14]
		mov	[eax+8], ecx
		jmp	loc_843F
; ---------------------------------------------------------------------------

loc_8247:				; CODE XREF: UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+1EAj
		jmp	loc_8126
; ---------------------------------------------------------------------------

loc_824C:				; CODE XREF: UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+17Ej
					; UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+19Fj ...
		mov	eax, [ebp+var_50]
		mov	byte ptr [eax+44h], 0
		mov	eax, [ebp+var_50]
		movsx	ecx, byte ptr [eax+34h]
		cmp	ecx, 1
		jnz	loc_8376
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_2C]
		jnb	loc_8359

$getTrailByte$38179:			; CODE XREF: UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+D8j
					; UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+DDj
		mov	[ebp+var_38], 0FFFFh
		mov	eax, [ebp+var_14]
		mov	cl, [eax]
		mov	[ebp+var_89], cl
		movzx	eax, [ebp+var_44]
		sub	eax, 21h ; '!'
		movzx	ecx, al
		xor	edx, edx
		cmp	ecx, 5Dh ; ']'
		setle	dl
		mov	[ebp+var_74], edx
		movzx	eax, [ebp+var_89]
		sub	eax, 21h ; '!'
		movzx	ecx, al
		xor	edx, edx
		cmp	ecx, 5Dh ; ']'
		setle	dl
		mov	[ebp+var_80], edx
		cmp	[ebp+var_74], 0
		jz	short loc_830E
		cmp	[ebp+var_80], 0
		jz	short loc_830E
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax
		movzx	eax, [ebp+var_44]
		add	eax, 80h ; ''
		mov	[ebp+var_8], al
		movzx	eax, [ebp+var_89]
		add	eax, 80h ; ''
		mov	[ebp+var_7], al
		movzx	eax, [ebp+var_65]
		push	eax
		push	2
		lea	ecx, [ebp+var_8]
		push	ecx
		mov	edx, [ebp+var_5C]
		push	edx
		call	_ucnv_MBCSSimpleGetNextUChar_56
		add	esp, 10h
		mov	[ebp+var_38], eax
		movzx	eax, [ebp+var_44]
		shl	eax, 8
		movzx	ecx, [ebp+var_89]
		or	eax, ecx
		mov	[ebp+var_44], ax
		jmp	short loc_8357
; ---------------------------------------------------------------------------

loc_830E:				; CODE XREF: UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+26Ej
					; UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+274j
		cmp	[ebp+var_80], 0
		jnz	short loc_8357
		movzx	eax, [ebp+var_89]
		cmp	eax, 20h ; ' '
		jge	short loc_8335
		movzx	ecx, [ebp+var_89]
		mov	eax, 1
		shl	eax, cl
		and	eax, 800C000h
		jnz	short loc_8357

loc_8335:				; CODE XREF: UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+2DAj
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax
		movzx	eax, [ebp+var_44]
		shl	eax, 8
		or	eax, 10000h
		movzx	ecx, [ebp+var_89]
		or	eax, ecx
		mov	[ebp+var_44], ax

loc_8357:				; CODE XREF: UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+2C8j
					; UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+2CEj ...
		jmp	short loc_8374
; ---------------------------------------------------------------------------

loc_8359:				; CODE XREF: UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+225j
		mov	eax, [ebp+Src]
		mov	ecx, [eax+4]
		mov	dl, byte ptr [ebp+var_44]
		mov	[ecx+25h], dl
		mov	eax, [ebp+Src]
		mov	ecx, [eax+4]
		mov	byte ptr [ecx+24h], 1
		jmp	loc_842D
; ---------------------------------------------------------------------------

loc_8374:				; CODE XREF: UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *):loc_8357j
		jmp	short loc_83A5
; ---------------------------------------------------------------------------

loc_8376:				; CODE XREF: UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+219j
		movzx	eax, [ebp+var_44]
		cmp	eax, 7Fh ; ''
		jg	short loc_839E
		movzx	eax, [ebp+var_65]
		push	eax
		push	1
		mov	ecx, [ebp+var_14]
		sub	ecx, 1
		push	ecx
		mov	edx, [ebp+var_5C]
		push	edx
		call	_ucnv_MBCSSimpleGetNextUChar_56
		add	esp, 10h
		mov	[ebp+var_38], eax
		jmp	short loc_83A5
; ---------------------------------------------------------------------------

loc_839E:				; CODE XREF: UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+339j
		mov	[ebp+var_38], 0FFFFh

loc_83A5:				; CODE XREF: UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *):loc_8374j
					; UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+358j
		cmp	[ebp+var_38], 0FFFEh
		jge	short loc_83FD
		mov	eax, [ebp+Src]
		cmp	dword ptr [eax+18h], 0
		jz	short loc_83E8
		mov	eax, [ebp+Src]
		mov	ecx, [ebp+var_14]
		sub	ecx, [eax+8]
		movzx	edx, [ebp+var_44]
		xor	eax, eax
		cmp	edx, 0FFh
		setnle	al
		add	eax, 1
		sub	ecx, eax
		mov	edx, [ebp+Src]
		mov	eax, [ebp+var_20]
		sub	eax, [edx+10h]
		sar	eax, 1
		mov	edx, [ebp+Src]
		mov	edx, [edx+18h]
		mov	[edx+eax*4], ecx

loc_83E8:				; CODE XREF: UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+371j
		mov	eax, [ebp+var_20]
		mov	cx, word ptr [ebp+var_38]
		mov	[eax], cx
		mov	edx, [ebp+var_20]
		add	edx, 2
		mov	[ebp+var_20], edx
		jmp	short loc_841B
; ---------------------------------------------------------------------------

loc_83FD:				; CODE XREF: UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+368j
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_38]
		push	ecx
		movzx	edx, [ebp+var_44]
		push	edx
		mov	eax, [ebp+Src]
		mov	ecx, [eax+4]
		push	ecx
		call	?toUnicodeCallback@@YAXPAUUConverter@@IIPAW4UErrorCode@@@Z ; toUnicodeCallback(UConverter *,uint,uint,UErrorCode *)
		add	esp, 10h
		jmp	short loc_842D
; ---------------------------------------------------------------------------

loc_841B:				; CODE XREF: UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+3B7j
		jmp	short loc_8428
; ---------------------------------------------------------------------------

loc_841D:				; CODE XREF: UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+F7j
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Fh
		jmp	short loc_842D
; ---------------------------------------------------------------------------

loc_8428:				; CODE XREF: UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *):loc_841Bj
		jmp	loc_8126
; ---------------------------------------------------------------------------

loc_842D:				; CODE XREF: UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+E8j
					; UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+32Bj ...
		mov	eax, [ebp+Src]
		mov	ecx, [ebp+var_20]
		mov	[eax+10h], ecx
		mov	eax, [ebp+Src]
		mov	ecx, [ebp+var_14]
		mov	[eax+8], ecx

loc_843F:				; CODE XREF: UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+6Bj
					; UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+174j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN37_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 150h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC@@YAXPAUUConverterToUnicodeArgs@@PAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
$LN37_0		dd 2			; DATA XREF: UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+3FFo
		dd offset $LN36
$LN36		dd 0FFFFFFF8h, 2	; DATA XREF: .text:00008468o
		dd offset $LN34_0	; "tempBuf"
		dd 0FFFFFFECh, 4
		dd offset $LN35_0	; "mySource"
$LN35_0		db 'mySource',0         ; DATA XREF: .text:00008480o
$LN34_0		db 'tempBuf',0          ; DATA XREF: .text:00008474o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8498h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC_IBM(void *Src, int)
?UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC_IBM@@YAXPAUUConverterToUnicodeArgs@@PAW4UErrorCode@@@Z proc near
					; CODE XREF: UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+63p

var_12C		= byte ptr -12Ch
var_68		= dword	ptr -68h
var_5C		= dword	ptr -5Ch
var_50		= dword	ptr -50h
Size		= dword	ptr -44h
Dst		= word ptr -38h
var_34		= dword	ptr -34h
var_30		= dword	ptr -30h
var_2C		= dword	ptr -2Ch
var_28		= dword	ptr -28h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
Src		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 12Ch
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_12C]
		mov	ecx, 4Bh ; 'K'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+Src]
		mov	ecx, [eax+4]
		mov	edx, [ecx+8]
		mov	[ebp+var_14], edx
		mov	eax, [ebp+Src]
		movzx	ecx, word ptr [eax]
		cmp	ecx, 1Ch
		jnb	short loc_84D8
		mov	eax, [ebp+Src]
		movzx	ecx, word ptr [eax]
		mov	[ebp+Size], ecx
		jmp	short loc_84DF
; ---------------------------------------------------------------------------

loc_84D8:				; CODE XREF: UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC_IBM(UConverterToUnicodeArgs	*,UErrorCode *)+33j
		mov	[ebp+Size], 1Ch

loc_84DF:				; CODE XREF: UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC_IBM(UConverterToUnicodeArgs	*,UErrorCode *)+3Ej
		push	1
		mov	eax, [ebp+Src]
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	ecx, [ebp+Size]
		push	ecx		; Size
		mov	edx, [ebp+Src]
		push	edx		; Src
		lea	eax, [ebp+Dst]
		push	eax		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	ax, word ptr [ebp+Size]
		mov	[ebp+Dst], ax
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+28h]
		mov	[ebp+var_34], ecx
		mov	eax, [ebp+Src]
		mov	ecx, [eax+8]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+3Ch], 0
		jz	short loc_852E
		jmp	$escape$38137
; ---------------------------------------------------------------------------
		jmp	$escape$38137
; ---------------------------------------------------------------------------

loc_852E:				; CODE XREF: UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC_IBM(UConverterToUnicodeArgs	*,UErrorCode *)+8Aj
					; UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC_IBM(UConverterToUnicodeArgs *,UErrorCode *)+2C9j
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	loc_8766
		mov	eax, [ebp+Src]
		mov	ecx, [ebp+Src]
		mov	edx, [eax+8]
		cmp	edx, [ecx+0Ch]
		jnb	loc_8766
		mov	eax, [ebp+Src]
		mov	ecx, [eax+8]
		mov	[ebp+var_30], ecx
		mov	eax, [ebp+Src]
		movzx	ecx, byte ptr [eax+2]
		push	ecx
		mov	edx, [ebp+Src]
		mov	eax, [edx+0Ch]
		push	eax
		mov	ecx, [ebp+Src]
		add	ecx, 8
		push	ecx
		call	?getEndOfBuffer_2022@@YAPBDPAPBDPBDC@Z ; getEndOfBuffer_2022(char const	* *,char const *,signed	char)
		add	esp, 0Ch
		mov	[ebp+var_2C], eax
		mov	eax, [ebp+var_30]
		cmp	eax, [ebp+var_2C]
		jz	loc_8719
		mov	eax, [ebp+Src]
		mov	ecx, [eax+4]
		movsx	edx, byte ptr [ecx+24h]
		test	edx, edx
		jle	short loc_85D5
		push	1
		mov	eax, [ebp+Src]
		mov	ecx, [eax+4]
		add	ecx, 25h ; '%'
		push	ecx
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	edx, [ebp+Src]
		mov	eax, [edx+4]
		movsx	ecx, byte ptr [eax+24h]
		push	ecx		; Size
		mov	edx, [ebp+Src]
		mov	eax, [edx+4]
		add	eax, 25h ; '%'
		push	eax		; Src
		mov	ecx, [ebp+var_34]
		add	ecx, 25h ; '%'
		push	ecx		; Dst
		call	_memcpy
		add	esp, 0Ch

loc_85D5:				; CODE XREF: UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC_IBM(UConverterToUnicodeArgs	*,UErrorCode *)+103j
		mov	eax, [ebp+Src]
		mov	ecx, [eax+4]
		mov	edx, [ebp+var_34]
		mov	al, [ecx+24h]
		mov	[edx+24h], al
		mov	eax, [ebp+arg_4]
		push	eax
		lea	ecx, [ebp+Dst]
		push	ecx
		call	_ucnv_MBCSToUnicodeWithOffsets_56
		add	esp, 8
		mov	eax, [ebp+Src]
		cmp	dword ptr [eax+18h], 0
		jz	short loc_8657
		mov	eax, [ebp+Src]
		mov	ecx, [ebp+var_8]
		cmp	ecx, [eax+8]
		jz	short loc_8657
		mov	eax, [ebp+Src]
		mov	ecx, [eax+18h]
		mov	[ebp+var_50], ecx
		mov	eax, [ebp+Src]
		mov	ecx, [eax+10h]
		mov	[ebp+var_5C], ecx
		mov	eax, [ebp+Src]
		mov	ecx, [eax+8]
		sub	ecx, [ebp+var_8]
		mov	[ebp+var_68], ecx

loc_8626:				; CODE XREF: UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC_IBM(UConverterToUnicodeArgs	*,UErrorCode *)+1BDj
		mov	eax, [ebp+var_5C]
		cmp	eax, [ebp+var_28]
		jnb	short loc_8657
		mov	eax, [ebp+var_50]
		cmp	dword ptr [eax], 0
		jl	short loc_8643
		mov	eax, [ebp+var_50]
		mov	ecx, [eax]
		add	ecx, [ebp+var_68]
		mov	edx, [ebp+var_50]
		mov	[edx], ecx

loc_8643:				; CODE XREF: UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC_IBM(UConverterToUnicodeArgs	*,UErrorCode *)+19Cj
		mov	eax, [ebp+var_50]
		add	eax, 4
		mov	[ebp+var_50], eax
		mov	eax, [ebp+var_5C]
		add	eax, 2
		mov	[ebp+var_5C], eax
		jmp	short loc_8626
; ---------------------------------------------------------------------------

loc_8657:				; CODE XREF: UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC_IBM(UConverterToUnicodeArgs	*,UErrorCode *)+163j
					; UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC_IBM(UConverterToUnicodeArgs *,UErrorCode *)+16Ej ...
		mov	eax, [ebp+Src]
		mov	ecx, [ebp+var_30]
		mov	[eax+8], ecx
		mov	eax, [ebp+Src]
		mov	ecx, [ebp+var_28]
		mov	[eax+10h], ecx
		mov	eax, [ebp+Src]
		mov	ecx, [ebp+var_20]
		mov	[eax+18h], ecx
		mov	eax, [ebp+var_34]
		movsx	ecx, byte ptr [eax+24h]
		test	ecx, ecx
		jle	short loc_86AF
		push	1
		mov	eax, [ebp+var_34]
		add	eax, 25h ; '%'
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	ecx, [ebp+var_34]
		movsx	edx, byte ptr [ecx+24h]
		push	edx		; Size
		mov	eax, [ebp+var_34]
		add	eax, 25h ; '%'
		push	eax		; Src
		mov	ecx, [ebp+Src]
		mov	edx, [ecx+4]
		add	edx, 25h ; '%'
		push	edx		; Dst
		call	_memcpy
		add	esp, 0Ch

loc_86AF:				; CODE XREF: UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC_IBM(UConverterToUnicodeArgs	*,UErrorCode *)+1E3j
		mov	eax, [ebp+Src]
		mov	ecx, [eax+4]
		mov	edx, [ebp+var_34]
		mov	al, [edx+24h]
		mov	[ecx+24h], al
		mov	eax, [ebp+arg_4]
		cmp	dword ptr [eax], 0Fh
		jnz	short loc_8719
		mov	eax, [ebp+var_34]
		movsx	ecx, byte ptr [eax+41h]
		test	ecx, ecx
		jle	short loc_8703
		push	1
		mov	eax, [ebp+var_34]
		add	eax, 74h ; 't'
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	ecx, [ebp+var_34]
		movsx	edx, byte ptr [ecx+41h]
		push	edx		; Size
		mov	eax, [ebp+var_34]
		add	eax, 74h ; 't'
		push	eax		; Src
		mov	ecx, [ebp+Src]
		mov	edx, [ecx+4]
		add	edx, 74h ; 't'
		push	edx		; Dst
		call	_memcpy
		add	esp, 0Ch

loc_8703:				; CODE XREF: UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC_IBM(UConverterToUnicodeArgs	*,UErrorCode *)+237j
		mov	eax, [ebp+Src]
		mov	ecx, [eax+4]
		mov	edx, [ebp+var_34]
		mov	al, [edx+41h]
		mov	[ecx+41h], al
		mov	eax, [ebp+var_34]
		mov	byte ptr [eax+41h], 0

loc_8719:				; CODE XREF: UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC_IBM(UConverterToUnicodeArgs	*,UErrorCode *)+F1j
					; UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC_IBM(UConverterToUnicodeArgs *,UErrorCode *)+22Cj
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jnz	short loc_873C
		mov	eax, [ebp+Src]
		mov	ecx, [ebp+Src]
		mov	edx, [eax+8]
		cmp	edx, [ecx+0Ch]
		jnz	short $escape$38137

loc_873C:				; CODE XREF: UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC_IBM(UConverterToUnicodeArgs	*,UErrorCode *)+294j
		jmp	short loc_8766
; ---------------------------------------------------------------------------

$escape$38137:				; CODE XREF: UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC_IBM(UConverterToUnicodeArgs	*,UErrorCode *)+8Cj
					; UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC_IBM(UConverterToUnicodeArgs *,UErrorCode *)+91j ...
		mov	eax, [ebp+arg_4]
		push	eax
		push	2
		mov	ecx, [ebp+Src]
		mov	edx, [ecx+0Ch]
		push	edx
		mov	eax, [ebp+Src]
		add	eax, 8
		push	eax
		mov	ecx, [ebp+Src]
		mov	edx, [ecx+4]
		push	edx
		call	?changeState_2022@@YAXPAUUConverter@@PAPBDPBDW4Variant2022@@PAW4UErrorCode@@@Z ; changeState_2022(UConverter *,char const * *,char const *,Variant2022,UErrorCode *)
		add	esp, 14h
		jmp	loc_852E
; ---------------------------------------------------------------------------

loc_8766:				; CODE XREF: UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC_IBM(UConverterToUnicodeArgs	*,UErrorCode *)+A9j
					; UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC_IBM(UConverterToUnicodeArgs *,UErrorCode *)+BBj ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN22
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 12Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC_IBM@@YAXPAUUConverterToUnicodeArgs@@PAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN22		dd 1			; DATA XREF: UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC_IBM(UConverterToUnicodeArgs	*,UErrorCode *)+2D2o
		dd offset $LN21_0
$LN21_0		dd 0FFFFFFC8h, 1Ch	; DATA XREF: .text:00008790o
		dd offset $LN20		; "subArgs"
$LN20		db 'subArgs',0          ; DATA XREF: .text:0000879Co
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 87A8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; char const * __cdecl getEndOfBuffer_2022(char	const *	*, char	const *, signed	char)
?getEndOfBuffer_2022@@YAPBDPAPBDPBDC@Z proc near
					; CODE XREF: UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC_IBM(UConverterToUnicodeArgs	*,UErrorCode *)+E0p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	[ebp+var_8], ecx

loc_87CE:				; CODE XREF: getEndOfBuffer_2022(char const * *,char const *,signed char)+42j
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+arg_4]
		jnb	short loc_87EC
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax]
		cmp	ecx, 1Bh
		jz	short loc_87EC
		mov	eax, [ebp+var_8]
		add	eax, 1
		mov	[ebp+var_8], eax
		jmp	short loc_87CE
; ---------------------------------------------------------------------------

loc_87EC:				; CODE XREF: getEndOfBuffer_2022(char const * *,char const *,signed char)+2Cj
					; getEndOfBuffer_2022(char const * *,char const	*,signed char)+37j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getEndOfBuffer_2022@@YAPBDPAPBDPBDC@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 87F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(struct UConverterFromUnicodeArgs *, enum  UErrorCode *)
?UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC@@YAXPAUUConverterFromUnicodeArgs@@PAW4UErrorCode@@@Z proc near
					; DATA XREF: .rdata:00000A60o
					; .rdata:00000A64o

var_1F8		= byte ptr -1F8h
var_1ED		= byte ptr -1EDh
var_124		= dword	ptr -124h
var_118		= dword	ptr -118h
var_10C		= dword	ptr -10Ch
var_100		= dword	ptr -100h
var_F1		= byte ptr -0F1h
var_E5		= byte ptr -0E5h
var_D9		= byte ptr -0D9h
var_D0		= dword	ptr -0D0h
var_C4		= word ptr -0C4h
var_B5		= byte ptr -0B5h
var_AC		= dword	ptr -0ACh
var_A0		= dword	ptr -0A0h
var_94		= byte ptr -94h
var_93		= byte ptr -93h
var_92		= byte ptr -92h
var_88		= dword	ptr -88h
var_7C		= byte ptr -7Ch
var_7B		= byte ptr -7Bh
var_6C		= dword	ptr -6Ch
var_60		= dword	ptr -60h
var_54		= dword	ptr -54h
var_48		= dword	ptr -48h
var_3C		= dword	ptr -3Ch
var_30		= dword	ptr -30h
Dst		= dword	ptr -24h
var_18		= dword	ptr -18h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 1F8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_1F8]
		mov	ecx, 7Eh ; '~'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	[ebp+var_1ED], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	[ebp+var_C], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		mov	[ebp+var_30], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+14h]
		mov	[ebp+var_3C], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		mov	[ebp+var_48], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+0Ch]
		mov	[ebp+var_54], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+18h]
		mov	[ebp+var_60], ecx
		mov	[ebp+var_AC], 0
		mov	eax, [ebp+var_C]
		mov	ecx, [eax+8]
		mov	[ebp+var_18], ecx
		mov	eax, [ebp+var_18]
		add	eax, 36h ; '6'
		mov	[ebp+Dst], eax
		mov	[ebp+var_A0], 0
		mov	eax, [ebp+var_C]
		mov	ecx, [eax+38h]
		mov	[ebp+var_6C], ecx
		cmp	[ebp+var_6C], 0
		jz	short loc_889E
		mov	eax, [ebp+var_30]
		cmp	eax, [ebp+var_3C]
		jnb	short loc_889E
		jmp	short $getTrail$38253
; ---------------------------------------------------------------------------
		jmp	short $getTrail$38253
; ---------------------------------------------------------------------------

loc_889E:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+98j
					; UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)+A0j ...
		mov	eax, [ebp+var_48]
		cmp	eax, [ebp+var_54]
		jnb	loc_90EB
		mov	eax, [ebp+var_30]
		cmp	eax, [ebp+var_3C]
		jnb	loc_90DB
		mov	eax, [ebp+var_48]
		movzx	ecx, word ptr [eax]
		mov	[ebp+var_6C], ecx
		mov	edx, [ebp+var_48]
		add	edx, 2
		mov	[ebp+var_48], edx
		mov	eax, [ebp+var_6C]
		and	eax, 0FFFFF800h
		cmp	eax, 0D800h
		jnz	loc_8979
		mov	eax, [ebp+var_6C]
		and	eax, 400h
		jnz	short loc_8962

$getTrail$38253:			; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+A2j
					; UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)+A4j
		mov	eax, [ebp+var_48]
		cmp	eax, [ebp+var_54]
		jnb	short loc_8952
		mov	eax, [ebp+var_48]
		mov	cx, [eax]
		mov	[ebp+var_C4], cx
		movzx	eax, [ebp+var_C4]
		and	eax, 0FFFFFC00h
		cmp	eax, 0DC00h
		jnz	short loc_8939
		mov	eax, [ebp+var_48]
		add	eax, 2
		mov	[ebp+var_48], eax
		mov	eax, [ebp+var_6C]
		shl	eax, 0Ah

loc_891C:				; DATA XREF: .rdata:0000028Co
		movzx	ecx, [ebp+var_C4]
		lea	edx, [eax+ecx-35FDC00h]
		mov	[ebp+var_6C], edx
		mov	eax, [ebp+var_C]
		mov	dword ptr [eax+38h], 0
		jmp	short loc_8950
; ---------------------------------------------------------------------------

loc_8939:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+113j
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Ch
		mov	eax, [ebp+var_C]
		mov	ecx, [ebp+var_6C]
		mov	[eax+38h], ecx
		jmp	loc_90EB
; ---------------------------------------------------------------------------

loc_8950:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+13Fj
		jmp	short loc_8960
; ---------------------------------------------------------------------------

loc_8952:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+F3j
		mov	eax, [ebp+var_C]
		mov	ecx, [ebp+var_6C]
		mov	[eax+38h], ecx
		jmp	loc_90EB
; ---------------------------------------------------------------------------

loc_8960:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *):loc_8950j
		jmp	short loc_8979
; ---------------------------------------------------------------------------

loc_8962:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+EBj
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Ch
		mov	eax, [ebp+var_C]
		mov	ecx, [ebp+var_6C]
		mov	[eax+38h], ecx
		jmp	loc_90EB
; ---------------------------------------------------------------------------

loc_8979:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+DDj
					; UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *):loc_8960j
		cmp	[ebp+var_6C], 7Fh ; ''
		jg	loc_8A25
		cmp	[ebp+var_6C], 20h ; ' '
		jge	short loc_89B1
		mov	eax, 1
		mov	ecx, [ebp+var_6C]
		shl	eax, cl
		and	eax, 800C000h
		jz	short loc_89B1
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Ch
		mov	eax, [ebp+var_C]
		mov	ecx, [ebp+var_6C]
		mov	[eax+38h], ecx
		jmp	loc_90EB
; ---------------------------------------------------------------------------

loc_89B1:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+18Fj
					; UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)+1A0j
		mov	eax, [ebp+Dst]
		movsx	ecx, byte ptr [eax+4]
		test	ecx, ecx
		jnz	short loc_89CE
		mov	al, byte ptr [ebp+var_6C]
		mov	[ebp+var_7C], al
		mov	[ebp+var_88], 1
		jmp	short loc_89FA
; ---------------------------------------------------------------------------

loc_89CE:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+1C2j
		mov	[ebp+var_7C], 0Fh
		mov	[ebp+var_1ED], 1
		mov	al, byte ptr [ebp+var_6C]
		mov	[ebp+var_7B], al
		mov	[ebp+var_88], 2
		mov	eax, [ebp+Dst]
		mov	byte ptr [eax+4], 0
		mov	[ebp+var_A0], 0

loc_89FA:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+1D4j
		cmp	[ebp+var_6C], 0Dh
		jz	short loc_8A06
		cmp	[ebp+var_6C], 0Ah
		jnz	short loc_8A20

loc_8A06:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+206j
		push	6		; Size
		push	0		; Val
		mov	eax, [ebp+Dst]
		push	eax		; Dst
		call	_memset
		add	esp, 0Ch
		mov	[ebp+var_A0], 0

loc_8A20:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+20Cj
		jmp	loc_8F90
; ---------------------------------------------------------------------------

loc_8A25:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+185j
		cmp	[ebp+var_A0], 0
		jnz	loc_8AF2
		mov	eax, [ebp+Dst]
		mov	cl, [eax+1]
		mov	[ebp+var_94], cl
		movsx	eax, [ebp+var_94]
		test	eax, eax
		jnz	short loc_8A50
		mov	[ebp+var_94], 1

loc_8A50:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+24Fj
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+40h], 0
		jnz	short loc_8A81
		movsx	eax, [ebp+var_94]
		cmp	eax, 1
		jnz	short loc_8A6E
		mov	[ebp+var_93], 21h ; '!'
		jmp	short loc_8A75
; ---------------------------------------------------------------------------

loc_8A6E:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+26Bj
		mov	[ebp+var_93], 1

loc_8A75:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+274j
		mov	[ebp+var_A0], 2
		jmp	short loc_8AF2
; ---------------------------------------------------------------------------

loc_8A81:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+25Fj
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+40h], 1
		jnz	short loc_8AE4
		mov	al, [ebp+var_94]
		mov	[ebp+var_1F8], al
		cmp	[ebp+var_1F8], 1
		jz	short loc_8AAA
		cmp	[ebp+var_1F8], 2
		jz	short loc_8ABA
		jmp	short loc_8ACA
; ---------------------------------------------------------------------------

loc_8AAA:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+2A5j
		mov	[ebp+var_93], 21h ; '!'
		mov	[ebp+var_92], 2
		jmp	short loc_8AD8
; ---------------------------------------------------------------------------

loc_8ABA:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+2AEj
		mov	[ebp+var_93], 1
		mov	[ebp+var_92], 21h ; '!'
		jmp	short loc_8AD8
; ---------------------------------------------------------------------------

loc_8ACA:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+2B0j
		mov	[ebp+var_93], 1
		mov	[ebp+var_92], 2

loc_8AD8:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+2C0j
					; UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)+2D0j
		mov	[ebp+var_A0], 3
		jmp	short loc_8AF2
; ---------------------------------------------------------------------------

loc_8AE4:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+290j
		mov	[ebp+var_94], 21h ; '!'
		mov	[ebp+var_93], 1

loc_8AF2:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+234j
					; UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)+287j ...
		mov	[ebp+var_E5], 0
		mov	al, [ebp+var_E5]
		mov	[ebp+var_D9], al
		mov	[ebp+var_88], 0
		mov	eax, [ebp+var_C]
		mov	cl, [eax+23h]
		mov	[ebp+var_B5], cl
		mov	[ebp+var_D0], 0
		jmp	short loc_8B36
; ---------------------------------------------------------------------------

loc_8B27:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *):loc_8D16j
		mov	eax, [ebp+var_D0]
		add	eax, 1
		mov	[ebp+var_D0], eax

loc_8B36:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+32Dj
		mov	eax, [ebp+var_D0]
		cmp	eax, [ebp+var_A0]
		jge	loc_8D1B
		cmp	[ebp+var_88], 0
		jg	loc_8D1B
		mov	eax, [ebp+var_D0]
		mov	cl, [ebp+eax+var_94]
		mov	[ebp+var_F1], cl
		movsx	eax, [ebp+var_F1]
		test	eax, eax
		jle	loc_8D16
		movsx	eax, [ebp+var_F1]
		cmp	eax, 20h ; ' '
		jl	loc_8C63
		push	2
		movzx	eax, [ebp+var_B5]
		push	eax
		lea	ecx, [ebp+var_100]
		push	ecx
		mov	edx, [ebp+var_6C]
		push	edx
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+0Ch]
		push	ecx
		call	?MBCS_FROM_UCHAR32_ISO2022@@YAHPAUUConverterSharedData@@HPAICH@Z ; MBCS_FROM_UCHAR32_ISO2022(UConverterSharedData *,int,uint *,signed char,int)
		add	esp, 14h
		mov	[ebp+var_10C], eax
		cmp	[ebp+var_10C], 3
		jz	short loc_8BD4
		cmp	[ebp+var_10C], 0FFFFFFFDh
		jnz	loc_8C5E
		cmp	[ebp+var_88], 0
		jnz	loc_8C5E

loc_8BD4:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+3C0j
		mov	eax, [ebp+var_100]
		mov	[ebp+var_AC], eax
		mov	eax, [ebp+var_100]
		shr	eax, 10h
		sub	eax, 60h ; '`'
		mov	[ebp+var_D9], al
		cmp	[ebp+var_10C], 0
		jl	short loc_8C07
		mov	[ebp+var_88], 2
		jmp	short loc_8C18
; ---------------------------------------------------------------------------

loc_8C07:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+401j
		mov	[ebp+var_88], 0FFFFFFFEh
		mov	[ebp+var_B5], 0

loc_8C18:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+40Dj
		movsx	eax, [ebp+var_D9]
		cmp	eax, 21h ; '!'
		jnz	short loc_8C2D
		mov	[ebp+var_E5], 1
		jmp	short loc_8C5E
; ---------------------------------------------------------------------------

loc_8C2D:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+42Aj
		movsx	eax, [ebp+var_D9]
		cmp	eax, 22h ; '"'
		jnz	short loc_8C42
		mov	[ebp+var_E5], 2
		jmp	short loc_8C5E
; ---------------------------------------------------------------------------

loc_8C42:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+43Fj
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+40h], 1
		jnz	short loc_8C54
		mov	[ebp+var_E5], 3
		jmp	short loc_8C5E
; ---------------------------------------------------------------------------

loc_8C54:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+451j
		mov	[ebp+var_88], 0

loc_8C5E:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+3C9j
					; UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)+3D6j ...
		jmp	loc_8D16
; ---------------------------------------------------------------------------

loc_8C63:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+389j
		movsx	eax, [ebp+var_F1]
		cmp	eax, 0Ah
		jl	short loc_8C98
		mov	ecx, ds:?__LINE__Var@?1??UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC@@YAXPAUUConverterFromUnicodeArgs@@PAW4UErrorCode@@@Z@4JA@d3633fb2
		add	ecx, 0C2h ; ''
		mov	esi, esp
		push	ecx		; Line
		push	offset ??_C@_1FO@NKNFLGG@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@ ; "d:\\mozilla\\intl\\icu\\source\\common\"...
		push	offset ??_C@_1O@ILAJHGN@?$AAc?$AAs?$AA0?$AA?$DM?$AA1?$AA0?$AA?$AA@ ; "cs0<10"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_8C98:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+475j
		push	1
		movzx	eax, [ebp+var_B5]
		push	eax
		lea	ecx, [ebp+var_100]
		push	ecx
		mov	edx, [ebp+var_6C]
		push	edx
		movsx	eax, [ebp+var_F1]
		mov	ecx, [ebp+var_18]
		mov	edx, [ecx+eax*4]
		push	edx
		call	?MBCS_FROM_UCHAR32_ISO2022@@YAHPAUUConverterSharedData@@HPAICH@Z ; MBCS_FROM_UCHAR32_ISO2022(UConverterSharedData *,int,uint *,signed char,int)
		add	esp, 14h
		mov	[ebp+var_10C], eax
		cmp	[ebp+var_10C], 2
		jz	short loc_8CE4
		cmp	[ebp+var_10C], 0FFFFFFFEh
		jnz	short loc_8D16
		cmp	[ebp+var_88], 0
		jnz	short loc_8D16

loc_8CE4:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+4D8j
		mov	eax, [ebp+var_100]
		mov	[ebp+var_AC], eax
		mov	eax, [ebp+var_10C]
		mov	[ebp+var_88], eax
		mov	al, [ebp+var_F1]
		mov	[ebp+var_D9], al
		mov	[ebp+var_E5], 1
		mov	[ebp+var_B5], 0

loc_8D16:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+379j
					; UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *):loc_8C5Ej	...
		jmp	loc_8B27
; ---------------------------------------------------------------------------

loc_8D1B:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+34Aj
					; UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)+357j
		cmp	[ebp+var_88], 0
		jz	loc_8F79
		mov	[ebp+var_88], 0
		movsx	eax, [ebp+var_D9]
		movsx	ecx, [ebp+var_E5]
		mov	edx, [ebp+Dst]
		movsx	ecx, byte ptr [edx+ecx]
		cmp	eax, ecx
		jz	loc_8E3F
		movsx	eax, [ebp+var_D9]
		cmp	eax, 3
		jge	short loc_8D9A
		push	1
		movsx	eax, [ebp+var_D9]
		mov	ecx, ds:_escSeqCharsCN[eax*4]
		push	ecx
		call	_uprv_checkValidMemory
		add	esp, 8
		push	4		; Size
		movsx	edx, [ebp+var_D9]
		mov	eax, ds:_escSeqCharsCN[edx*4]
		push	eax		; Src
		mov	[ebp+var_1ED], 1
		lea	ecx, [ebp+var_7C]
		push	ecx		; Dst
		call	_memcpy
		add	esp, 0Ch
		jmp	short loc_8E0C
; ---------------------------------------------------------------------------

loc_8D9A:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+561j
		movsx	eax, [ebp+var_D9]
		cmp	eax, 21h ; '!'
		jge	short loc_8DCF
		mov	ecx, ds:?__LINE__Var@?1??UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC@@YAXPAUUConverterFromUnicodeArgs@@PAW4UErrorCode@@@Z@4JA@d3633fb2
		add	ecx, 0DCh ; ''
		mov	esi, esp
		push	ecx		; Line
		push	offset ??_C@_1FO@NKNFLGG@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@ ; "d:\\mozilla\\intl\\icu\\source\\common\"...
		push	offset ??_C@_1CE@NGCDFDBE@?$AAc?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAC?$AAN?$AAS?$AA_?$AA1?$AA1?$AA6?$AA4?$AA3?$AA_?$AA1?$AA?$AA@ ; "cs >= CNS_11643_1"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_8DCF:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+5ACj
		push	1
		movsx	eax, [ebp+var_D9]
		mov	ecx, ds:Src[eax*4]
		push	ecx
		call	_uprv_checkValidMemory
		add	esp, 8
		push	4		; Size
		movsx	edx, [ebp+var_D9]
		mov	eax, ds:Src[edx*4]
		push	eax		; Src
		mov	[ebp+var_1ED], 1
		lea	ecx, [ebp+var_7C]
		push	ecx		; Dst
		call	_memcpy
		add	esp, 0Ch

loc_8E0C:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+5A0j
		mov	[ebp+var_88], 4
		movsx	eax, [ebp+var_E5]
		mov	ecx, [ebp+Dst]
		mov	dl, [ebp+var_D9]
		mov	[ecx+eax], dl
		movsx	eax, [ebp+var_E5]
		cmp	eax, 1
		jnz	short loc_8E3F
		mov	[ebp+var_A0], 0

loc_8E3F:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+551j
					; UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)+63Bj
		movsx	eax, [ebp+var_E5]
		mov	ecx, [ebp+Dst]
		movsx	edx, byte ptr [ecx+4]
		cmp	eax, edx
		jz	loc_8F28
		mov	al, [ebp+var_E5]
		mov	[ebp+var_1F8], al
		cmp	[ebp+var_1F8], 1
		jz	short loc_8E75
		cmp	[ebp+var_1F8], 2
		jz	short loc_8EA2
		jmp	short loc_8EE6
; ---------------------------------------------------------------------------

loc_8E75:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+670j
		mov	[ebp+var_1ED], 1
		mov	eax, [ebp+var_88]
		mov	[ebp+eax+var_7C], 0Eh
		mov	ecx, [ebp+var_88]
		add	ecx, 1
		mov	[ebp+var_88], ecx
		mov	eax, [ebp+Dst]
		mov	byte ptr [eax+4], 1
		jmp	loc_8F28
; ---------------------------------------------------------------------------

loc_8EA2:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+679j
		mov	[ebp+var_1ED], 1
		mov	eax, [ebp+var_88]
		mov	[ebp+eax+var_7C], 1Bh
		mov	ecx, [ebp+var_88]
		add	ecx, 1
		mov	[ebp+var_88], ecx
		mov	[ebp+var_1ED], 1
		mov	eax, [ebp+var_88]
		mov	[ebp+eax+var_7C], 4Eh ;	'N'
		mov	ecx, [ebp+var_88]
		add	ecx, 1
		mov	[ebp+var_88], ecx
		jmp	short loc_8F28
; ---------------------------------------------------------------------------

loc_8EE6:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+67Bj
		mov	[ebp+var_1ED], 1
		mov	eax, [ebp+var_88]
		mov	[ebp+eax+var_7C], 1Bh
		mov	ecx, [ebp+var_88]
		add	ecx, 1
		mov	[ebp+var_88], ecx
		mov	[ebp+var_1ED], 1
		mov	eax, [ebp+var_88]
		mov	[ebp+eax+var_7C], 4Fh ;	'O'
		mov	ecx, [ebp+var_88]
		add	ecx, 1
		mov	[ebp+var_88], ecx

loc_8F28:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+657j
					; UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)+6A5j ...
		mov	eax, [ebp+var_AC]
		shr	eax, 8
		mov	[ebp+var_1ED], 1
		mov	ecx, [ebp+var_88]
		mov	[ebp+ecx+var_7C], al
		mov	edx, [ebp+var_88]
		add	edx, 1
		mov	[ebp+var_88], edx
		mov	[ebp+var_1ED], 1
		mov	eax, [ebp+var_88]
		mov	cl, byte ptr [ebp+var_AC]
		mov	[ebp+eax+var_7C], cl
		mov	edx, [ebp+var_88]
		add	edx, 1
		mov	[ebp+var_88], edx
		jmp	short loc_8F90
; ---------------------------------------------------------------------------

loc_8F79:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+52Aj
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Ah
		mov	eax, [ebp+var_C]
		mov	ecx, [ebp+var_6C]
		mov	[eax+38h], ecx
		jmp	loc_90EB
; ---------------------------------------------------------------------------

loc_8F90:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *):loc_8A20j
					; UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)+77Fj
		cmp	[ebp+var_88], 1
		jnz	short loc_8FD1
		mov	eax, [ebp+var_30]
		mov	cl, [ebp+var_7C]
		mov	[eax], cl
		mov	edx, [ebp+var_30]
		add	edx, 1
		mov	[ebp+var_30], edx
		cmp	[ebp+var_60], 0
		jz	short loc_8FCC
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_48]
		sub	ecx, [eax+8]
		sar	ecx, 1
		sub	ecx, 1
		mov	edx, [ebp+var_60]
		mov	[edx], ecx
		mov	eax, [ebp+var_60]
		add	eax, 4
		mov	[ebp+var_60], eax

loc_8FCC:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+7B6j
		jmp	loc_90D9
; ---------------------------------------------------------------------------

loc_8FD1:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+79Fj
		cmp	[ebp+var_88], 2
		jnz	loc_9077
		mov	eax, [ebp+var_30]
		add	eax, 2
		cmp	eax, [ebp+var_3C]
		ja	loc_9077
		mov	eax, [ebp+var_30]
		mov	cl, [ebp+var_7C]
		mov	[eax], cl
		mov	edx, [ebp+var_30]
		add	edx, 1
		mov	[ebp+var_30], edx
		cmp	[ebp+var_1ED], 0
		jnz	short loc_9014
		push	offset $LN81	; "buffer"
		call	__RTC_UninitUse
		add	esp, 4

loc_9014:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+80Dj
		mov	eax, [ebp+var_30]
		mov	cl, [ebp+var_7B]
		mov	[eax], cl
		mov	edx, [ebp+var_30]
		add	edx, 1
		mov	[ebp+var_30], edx
		cmp	[ebp+var_60], 0
		jz	short loc_9075
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_48]
		sub	ecx, [eax+8]
		sar	ecx, 1
		mov	edx, 0FFFFh
		cmp	edx, [ebp+var_6C]
		sbb	eax, eax
		neg	eax
		add	eax, 1

loc_9045:				; DATA XREF: .rdata:00000290o
		sub	ecx, eax

loc_9047:				; DATA XREF: .rdata:00000294o
					; .rdata:00000298o ...
		mov	[ebp+var_118], ecx

loc_904D:				; DATA XREF: .rdata:000002A8o
					; .rdata:000002ACo
		mov	eax, [ebp+var_60]

loc_9050:				; DATA XREF: .rdata:000002B0o
					; .rdata:000002B4o ...
		mov	ecx, [ebp+var_118]
		mov	[eax], ecx
		mov	edx, [ebp+var_60]
		add	edx, 4
		mov	[ebp+var_60], edx
		mov	eax, [ebp+var_60]
		mov	ecx, [ebp+var_118]
		mov	[eax], ecx
		mov	edx, [ebp+var_60]
		add	edx, 4
		mov	[ebp+var_60], edx

loc_9075:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+831j
		jmp	short loc_90D9
; ---------------------------------------------------------------------------

loc_9077:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+7E0j
					; UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)+7EFj
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ebp+var_48]
		sub	edx, [ecx+8]
		sar	edx, 1
		mov	eax, 0FFFFh
		cmp	eax, [ebp+var_6C]
		sbb	ecx, ecx
		neg	ecx
		add	ecx, 1
		sub	edx, ecx
		push	edx
		lea	edx, [ebp+var_60]
		push	edx
		mov	eax, [ebp+var_3C]
		push	eax
		lea	ecx, [ebp+var_30]
		push	ecx
		mov	edx, [ebp+var_88]
		push	edx
		mov	[ebp+var_1ED], 1
		lea	eax, [ebp+var_7C]
		push	eax
		mov	ecx, [ebp+var_C]
		push	ecx
		call	?fromUWriteUInt8@@YAXPAUUConverter@@PBDHPAPAE1PAPAHHPAW4UErrorCode@@@Z ; fromUWriteUInt8(UConverter *,char const *,int,uchar * *,char const *,int * *,int,UErrorCode *)
		add	esp, 20h
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_90D9
		jmp	short loc_90EB
; ---------------------------------------------------------------------------

loc_90D9:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *):loc_8FCCj
					; UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *):loc_9075j	...
		jmp	short loc_90E6
; ---------------------------------------------------------------------------

loc_90DB:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+B8j
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Fh
		jmp	short loc_90EB
; ---------------------------------------------------------------------------

loc_90E6:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *):loc_90D9j
		jmp	loc_889E
; ---------------------------------------------------------------------------

loc_90EB:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+ACj
					; UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)+153j ...
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	loc_91F2
		mov	eax, [ebp+Dst]
		movsx	ecx, byte ptr [eax+4]
		test	ecx, ecx
		jz	loc_91F2
		mov	eax, [ebp+arg_0]
		movsx	ecx, byte ptr [eax+2]
		test	ecx, ecx
		jz	loc_91F2
		mov	eax, [ebp+var_48]
		cmp	eax, [ebp+var_54]
		jb	loc_91F2
		mov	eax, [ebp+var_C]
		cmp	dword ptr [eax+38h], 0
		jnz	loc_91F2
		mov	eax, [ebp+Dst]
		mov	byte ptr [eax+4], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_48]
		sub	ecx, [eax+8]
		sar	ecx, 1
		mov	[ebp+var_124], ecx
		cmp	[ebp+var_124], 0
		jle	short loc_91BE
		mov	eax, [ebp+var_124]
		sub	eax, 1
		mov	[ebp+var_124], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		mov	edx, [ebp+var_124]
		movzx	eax, word ptr [ecx+edx*2]
		and	eax, 0FFFFFC00h
		cmp	eax, 0DC00h
		jnz	short loc_91BC
		cmp	[ebp+var_124], 0
		jz	short loc_91AD
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		mov	edx, [ebp+var_124]
		movzx	eax, word ptr [ecx+edx*2-2]
		and	eax, 0FFFFFC00h
		cmp	eax, 0D800h
		jnz	short loc_91BC

loc_91AD:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+996j
		mov	eax, [ebp+var_124]
		sub	eax, 1
		mov	[ebp+var_124], eax

loc_91BC:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+98Dj
					; UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)+9B3j
		jmp	short loc_91C8
; ---------------------------------------------------------------------------

loc_91BE:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+962j
		mov	[ebp+var_124], 0FFFFFFFFh

loc_91C8:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *):loc_91BCj
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_124]
		push	ecx
		lea	edx, [ebp+var_60]
		push	edx
		mov	eax, [ebp+var_3C]
		push	eax
		lea	ecx, [ebp+var_30]
		push	ecx
		push	1
		push	offset _SHIFT_IN_STR
		mov	edx, [ebp+var_C]
		push	edx
		call	?fromUWriteUInt8@@YAXPAUUConverter@@PBDHPAPAE1PAPAHHPAW4UErrorCode@@@Z ; fromUWriteUInt8(UConverter *,char const *,int,uchar * *,char const *,int * *,int,UErrorCode *)
		add	esp, 20h

loc_91F2:				; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+906j
					; UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)+915j ...
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_48]
		mov	[eax+8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_30]
		mov	[eax+10h], ecx
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN87_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 1F8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC@@YAXPAUUConverterFromUnicodeArgs@@PAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN87_0		dd 5			; DATA XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+A10o
		dd offset $LN86_0
$LN86_0		dd 0FFFFFF84h, 8	; DATA XREF: .text:00009238o
		dd offset $LN81		; "buffer"
		dd 0FFFFFFD0h, 4
		dd offset $LN82		; "target"
		dd 0FFFFFFA0h, 4
		dd offset $LN83		; "offsets"
		dd 0FFFFFF6Ch, 3
		dd offset $LN84		; "choices"
		dd 0FFFFFF00h, 4
		dd offset $LN85_0	; "value"
$LN85_0		db 'value',0            ; DATA XREF: .text:00009274o
$LN84		db 'choices',0          ; DATA XREF: .text:00009268o
$LN83		db 'offsets',0          ; DATA XREF: .text:0000925Co
$LN82		db 'target',0           ; DATA XREF: .text:00009250o
$LN81		db 'buffer',0           ; DATA XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)+80Fo
					; .text:00009244o
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 929Ch
		public ??_C@_1CE@NGCDFDBE@?$AAc?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAC?$AAN?$AAS?$AA_?$AA1?$AA1?$AA6?$AA4?$AA3?$AA_?$AA1?$AA?$AA@
; wchar_t `string'
??_C@_1CE@NGCDFDBE@?$AAc?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAC?$AAN?$AAS?$AA_?$AA1?$AA1?$AA6?$AA4?$AA3?$AA_?$AA1?$AA?$AA@:
					; DATA XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+5C2o
		unicode	0, <cs >
		dw 3Eh
		unicode	0, <= CNS_11643_1>,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 92C0h
		public ??_C@_1O@ILAJHGN@?$AAc?$AAs?$AA0?$AA?$DM?$AA1?$AA0?$AA?$AA@
; wchar_t `string'
??_C@_1O@ILAJHGN@?$AAc?$AAs?$AA0?$AA?$DM?$AA1?$AA0?$AA?$AA@:
					; DATA XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+48Bo
		unicode	0, <cs0>
		dw 3Ch
		unicode	0, <10>,0
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 92D0h
		public ??_C@_1FO@NKNFLGG@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@
; wchar_t `string'
??_C@_1FO@NKNFLGG@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@:
					; DATA XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+486o
					; UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)+5BDo ...
		unicode	0, <d:\mozilla\intl\icu\source\common\ucnv2022.cpp>,0
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 9330h
		public ?__LINE__Var@?1??UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC@@YAXPAUUConverterFromUnicodeArgs@@PAW4UErrorCode@@@Z@4JA@d3633fb2
?__LINE__Var@?1??UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC@@YAXPAUUConverterFromUnicodeArgs@@PAW4UErrorCode@@@Z@4JA@d3633fb2 dd offset word_B5A
					; DATA XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+477r
					; UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)+5AEr
_data		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9334h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(struct UConverterToUnicodeArgs *,	enum  UErrorCode *)
?UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC@@YAXPAUUConverterToUnicodeArgs@@PAW4UErrorCode@@@Z proc	near
					; DATA XREF: .rdata:00000A58o
					; .rdata:00000A5Co

var_184		= dword	ptr -184h
var_B9		= byte ptr -0B9h
var_B0		= dword	ptr -0B0h
var_A4		= dword	ptr -0A4h
var_98		= dword	ptr -98h
var_8C		= dword	ptr -8Ch
var_80		= dword	ptr -80h
var_71		= byte ptr -71h
var_68		= dword	ptr -68h
Dst		= dword	ptr -5Ch
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= byte ptr -8
var_7		= byte ptr -7
var_6		= byte ptr -6
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 184h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_184]
		mov	ecx, 61h ; 'a'

loc_934B:				; DATA XREF: .rdata:000002D4o
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		mov	[ebp+var_20], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+0Ch]
		mov	[ebp+var_2C], ecx

loc_936D:				; DATA XREF: .rdata:000002D8o
					; .rdata:000002DCo ...
		mov	[ebp+var_38], 0

loc_9374:				; DATA XREF: .rdata:000002E8o
		mov	[ebp+var_44], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	edx, [ecx+8]
		mov	[ebp+var_50], edx
		mov	eax, [ebp+var_50]
		add	eax, 30h ; '0'
		mov	[ebp+Dst], eax
		mov	eax, [ebp+var_50]
		cmp	dword ptr [eax+3Ch], 0
		jz	short loc_93A5
		jmp	$escape$38392
; ---------------------------------------------------------------------------
		jmp	$escape$38392
; ---------------------------------------------------------------------------
		jmp	short loc_93EF
; ---------------------------------------------------------------------------

loc_93A5:				; CODE XREF: UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+63j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		movsx	edx, byte ptr [ecx+24h]
		cmp	edx, 1
		jnz	short loc_93EF
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_2C]
		jnb	short loc_93EF
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_20]
		cmp	ecx, [eax+14h]
		jnb	short loc_93EF
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		movzx	edx, byte ptr [ecx+25h]
		mov	[ebp+var_44], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	byte ptr [ecx+24h], 0
		mov	[ebp+var_38], 0FFFFh
		jmp	$getTrailByte$38396
; ---------------------------------------------------------------------------
		jmp	$getTrailByte$38396
; ---------------------------------------------------------------------------

loc_93EF:				; CODE XREF: UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+6Fj
					; UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+7Ej ...
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_2C]
		jnb	$endloop$38451
		mov	[ebp+var_38], 0FFFFh
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_20]
		cmp	ecx, [eax+14h]
		jnb	loc_9930
		mov	eax, [ebp+var_14]
		movzx	ecx, byte ptr [eax]
		mov	[ebp+var_44], ecx
		mov	edx, [ebp+var_14]
		add	edx, 1
		mov	[ebp+var_14], edx
		mov	eax, [ebp+var_44]
		mov	[ebp+var_184], eax
		mov	ecx, [ebp+var_184]
		sub	ecx, 0Ah
		mov	[ebp+var_184], ecx
		cmp	[ebp+var_184], 11h ; switch 18 cases
		ja	$LN24		; jumptable 00009455 default case
		mov	edx, [ebp+var_184]
		movzx	eax, ds:$LN48_0[edx]
		jmp	ds:$LN53[eax*4]	; switch jump
; ---------------------------------------------------------------------------

$LN33:					; CODE XREF: UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+121j
					; DATA XREF: .text:$LN53o
		mov	eax, [ebp+Dst]	; jumptable 00009455 case 5
		mov	byte ptr [eax+4], 0
		mov	eax, [ebp+var_50]
		movsx	ecx, byte ptr [eax+44h]
		test	ecx, ecx
		jz	short loc_94BB
		mov	eax, [ebp+var_50]
		mov	byte ptr [eax+44h], 0
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 12h
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	dword ptr [ecx+100h], 2
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	dl, byte ptr [ebp+var_44]
		mov	[ecx+25h], dl
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	byte ptr [ecx+24h], 1
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_20]
		mov	[eax+10h], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		mov	[eax+8], ecx
		jmp	loc_9952
; ---------------------------------------------------------------------------

loc_94BB:				; CODE XREF: UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+138j
		jmp	loc_93EF
; ---------------------------------------------------------------------------

$LN31_0:				; CODE XREF: UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+121j
					; DATA XREF: .text:$LN53o
		mov	eax, [ebp+Dst]	; jumptable 00009455 case 4
		movsx	ecx, byte ptr [eax+1]
		test	ecx, ecx
		jz	short loc_94E0
		mov	eax, [ebp+Dst]
		mov	byte ptr [eax+4], 1
		mov	eax, [ebp+var_50]
		mov	byte ptr [eax+44h], 1
		jmp	loc_93EF
; ---------------------------------------------------------------------------
		jmp	short $LN28_0	; jumptable 00009455 case 17
; ---------------------------------------------------------------------------

loc_94E0:				; CODE XREF: UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+195j
		mov	eax, [ebp+var_50]
		mov	byte ptr [eax+44h], 0
		jmp	loc_97AB
; ---------------------------------------------------------------------------

$LN28_0:				; CODE XREF: UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+121j
					; UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+1AAj
					; DATA XREF: ...
		mov	eax, [ebp+var_14] ; jumptable 00009455 case 17
		sub	eax, 1
		mov	[ebp+var_14], eax

$escape$38392:				; CODE XREF: UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+65j
					; UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+6Aj
		mov	eax, [ebp+var_14]
		mov	[ebp+var_68], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	dl, [ecx+24h]
		mov	[ebp+var_71], dl
		mov	eax, [ebp+arg_4]
		push	eax
		push	3
		mov	ecx, [ebp+var_2C]
		push	ecx
		lea	edx, [ebp+var_14]
		push	edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		push	ecx
		call	?changeState_2022@@YAXPAUUConverter@@PAPBDPBDW4Variant2022@@PAW4UErrorCode@@@Z ; changeState_2022(UConverter *,char const * *,char const *,Variant2022,UErrorCode *)
		add	esp, 14h
		mov	eax, [ebp+var_50]
		cmp	dword ptr [eax+3Ch], 0
		jnz	short loc_957B
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_957B
		mov	eax, [ebp+var_50]
		movsx	ecx, byte ptr [eax+44h]
		test	ecx, ecx
		jz	short loc_957B
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 12h
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	dword ptr [ecx+100h], 2
		movsx	eax, [ebp+var_71]
		mov	ecx, [ebp+var_14]
		sub	ecx, [ebp+var_68]
		add	eax, ecx
		mov	edx, [ebp+arg_0]
		mov	ecx, [edx+4]
		mov	[ecx+24h], al

loc_957B:				; CODE XREF: UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+1F7j
					; UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+20Cj ...
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_95AE
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_20]
		mov	[eax+10h], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		mov	[eax+8], ecx
		mov	eax, [ebp+var_50]
		mov	byte ptr [eax+44h], 0
		jmp	loc_9952
; ---------------------------------------------------------------------------

loc_95AE:				; CODE XREF: UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+25Aj
		jmp	loc_93EF
; ---------------------------------------------------------------------------

$LN25_0:				; CODE XREF: UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+121j
					; DATA XREF: .text:$LN53o
		push	6		; jumptable 00009455 cases 0,3
		push	0		; Val
		mov	eax, [ebp+Dst]
		push	eax		; Dst
		call	_memset
		add	esp, 0Ch

$LN24:					; CODE XREF: UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+10Ej
					; UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+121j
					; DATA XREF: ...
		mov	eax, [ebp+var_50] ; jumptable 00009455 default case
		mov	byte ptr [eax+44h], 0
		mov	eax, [ebp+Dst]
		movsx	ecx, byte ptr [eax+4]
		test	ecx, ecx
		jz	loc_979E
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_2C]
		jnb	loc_977C

$getTrailByte$38396:			; CODE XREF: UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+B1j
					; UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+B6j
		mov	eax, [ebp+var_14]
		mov	cl, [eax]
		mov	[ebp+var_B9], cl
		mov	eax, [ebp+var_44]
		sub	eax, 21h ; '!'
		movzx	ecx, al
		xor	edx, edx
		cmp	ecx, 5Dh ; ']'
		setle	dl
		mov	[ebp+var_A4], edx
		movzx	eax, [ebp+var_B9]
		sub	eax, 21h ; '!'
		movzx	ecx, al
		xor	edx, edx
		cmp	ecx, 5Dh ; ']'
		setle	dl
		mov	[ebp+var_B0], edx
		cmp	[ebp+var_A4], 0
		jz	loc_9718
		cmp	[ebp+var_B0], 0
		jz	loc_9718
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax
		mov	eax, [ebp+Dst]
		movsx	ecx, byte ptr [eax+4]
		mov	edx, [ebp+Dst]
		movsx	eax, byte ptr [edx+ecx]
		mov	[ebp+var_8C], eax
		cmp	[ebp+var_8C], 20h ; ' '
		jl	short loc_9692
		mov	eax, [ebp+var_50]
		mov	ecx, [eax+0Ch]
		mov	[ebp+var_80], ecx
		mov	eax, [ebp+var_8C]
		add	eax, 60h ; '`'
		mov	[ebp+var_8], al
		mov	al, byte ptr [ebp+var_44]
		mov	[ebp+var_7], al
		mov	al, [ebp+var_B9]
		mov	[ebp+var_6], al
		mov	[ebp+var_98], 3
		jmp	short loc_96E8
; ---------------------------------------------------------------------------

loc_9692:				; CODE XREF: UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+32Cj
		cmp	[ebp+var_8C], 0Ah
		jl	short loc_96C0
		mov	eax, ds:?__LINE__Var@?1??UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC@@YAXPAUUConverterToUnicodeArgs@@PAW4UErrorCode@@@Z@4JA@d3633fb2
		add	eax, 7Fh ; ''
		mov	esi, esp
		push	eax		; Line
		push	offset ??_C@_1FO@NKNFLGG@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@ ; "d:\\mozilla\\intl\\icu\\source\\common\"...
		push	offset ??_C@_1BK@ENOKOAEN@?$AAt?$AAe?$AAm?$AAp?$AAS?$AAt?$AAa?$AAt?$AAe?$AA?$DM?$AA1?$AA0?$AA?$AA@ ; "tempState<10"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_96C0:				; CODE XREF: UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+365j
		mov	eax, [ebp+var_8C]
		mov	ecx, [ebp+var_50]
		mov	edx, [ecx+eax*4]
		mov	[ebp+var_80], edx
		mov	al, byte ptr [ebp+var_44]
		mov	[ebp+var_8], al
		mov	al, [ebp+var_B9]
		mov	[ebp+var_7], al
		mov	[ebp+var_98], 2

loc_96E8:				; CODE XREF: UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+35Cj
		push	0
		mov	eax, [ebp+var_98]
		push	eax
		lea	ecx, [ebp+var_8]
		push	ecx
		mov	edx, [ebp+var_80]
		push	edx
		call	_ucnv_MBCSSimpleGetNextUChar_56
		add	esp, 10h
		mov	[ebp+var_38], eax
		mov	eax, [ebp+var_44]
		shl	eax, 8
		movzx	ecx, [ebp+var_B9]
		or	eax, ecx
		mov	[ebp+var_44], eax
		jmp	short loc_9762
; ---------------------------------------------------------------------------

loc_9718:				; CODE XREF: UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+2F5j
					; UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+302j
		cmp	[ebp+var_B0], 0
		jnz	short loc_9762
		movzx	eax, [ebp+var_B9]
		cmp	eax, 20h ; ' '
		jge	short loc_9742
		movzx	ecx, [ebp+var_B9]
		mov	eax, 1
		shl	eax, cl
		and	eax, 800C000h
		jnz	short loc_9762

loc_9742:				; CODE XREF: UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+3F7j
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_44]
		shl	eax, 8
		or	eax, 10000h
		movzx	ecx, [ebp+var_B9]
		or	eax, ecx
		mov	[ebp+var_44], eax

loc_9762:				; CODE XREF: UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+3E2j
					; UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+3EBj ...
		mov	eax, [ebp+Dst]
		movsx	ecx, byte ptr [eax+4]
		cmp	ecx, 2
		jl	short loc_977A
		mov	eax, [ebp+Dst]
		mov	ecx, [ebp+Dst]
		mov	dl, [ecx+5]
		mov	[eax+4], dl

loc_977A:				; CODE XREF: UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+438j
		jmp	short loc_979C
; ---------------------------------------------------------------------------

loc_977C:				; CODE XREF: UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+2ABj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	dl, byte ptr [ebp+var_44]
		mov	[ecx+25h], dl
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	byte ptr [ecx+24h], 1
		jmp	$endloop$38451
; ---------------------------------------------------------------------------
		jmp	$endloop$38451
; ---------------------------------------------------------------------------

loc_979C:				; CODE XREF: UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *):loc_977Aj
		jmp	short loc_97AB
; ---------------------------------------------------------------------------

loc_979E:				; CODE XREF: UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+29Fj
		cmp	[ebp+var_44], 7Fh ; ''
		ja	short loc_97AB
		movzx	eax, word ptr [ebp+var_44]
		mov	[ebp+var_38], eax

loc_97AB:				; CODE XREF: UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+1B3j
					; UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *):loc_979Cj ...
		cmp	[ebp+var_38], 0FFFEh
		jnb	short loc_9803
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+18h], 0
		jz	short loc_97EB
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		sub	ecx, [eax+8]
		mov	edx, 0FFh
		cmp	edx, [ebp+var_44]
		sbb	eax, eax
		neg	eax
		add	eax, 1
		sub	ecx, eax
		mov	edx, [ebp+arg_0]
		mov	eax, [ebp+var_20]
		sub	eax, [edx+10h]
		sar	eax, 1
		mov	edx, [ebp+arg_0]
		mov	edx, [edx+18h]
		mov	[edx+eax*4], ecx

loc_97EB:				; CODE XREF: UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+487j
		mov	eax, [ebp+var_20]
		mov	cx, word ptr [ebp+var_38]
		mov	[eax], cx
		mov	edx, [ebp+var_20]
		add	edx, 2
		mov	[ebp+var_20], edx
		jmp	loc_992E
; ---------------------------------------------------------------------------

loc_9803:				; CODE XREF: UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+47Ej
		cmp	[ebp+var_38], 0FFFFh
		jbe	loc_9911
		mov	eax, [ebp+var_38]
		sub	eax, 10000h
		mov	[ebp+var_38], eax
		mov	eax, [ebp+var_38]
		shr	eax, 0Ah
		movzx	ecx, ax
		add	ecx, 0D800h
		mov	edx, [ebp+var_20]
		mov	[edx], cx
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+18h], 0
		jz	short loc_9867
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		sub	ecx, [eax+8]
		mov	edx, 0FFh
		cmp	edx, [ebp+var_44]
		sbb	eax, eax
		neg	eax
		add	eax, 1
		sub	ecx, eax
		mov	edx, [ebp+arg_0]
		mov	eax, [ebp+var_20]
		sub	eax, [edx+10h]
		sar	eax, 1
		mov	edx, [ebp+arg_0]
		mov	edx, [edx+18h]
		mov	[edx+eax*4], ecx

loc_9867:				; CODE XREF: UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+503j
		mov	eax, [ebp+var_20]
		add	eax, 2
		mov	[ebp+var_20], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_20]
		cmp	ecx, [eax+14h]
		jnb	short loc_98D4
		mov	eax, [ebp+var_38]
		and	eax, 3FFh
		movzx	ecx, ax
		add	ecx, 0DC00h
		mov	edx, [ebp+var_20]
		mov	[edx], cx
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+18h], 0
		jz	short loc_98C9
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		sub	ecx, [eax+8]
		mov	edx, 0FFh
		cmp	edx, [ebp+var_44]
		sbb	eax, eax
		neg	eax
		add	eax, 1
		sub	ecx, eax
		mov	edx, [ebp+arg_0]
		mov	eax, [ebp+var_20]
		sub	eax, [edx+10h]
		sar	eax, 1
		mov	edx, [ebp+arg_0]
		mov	edx, [edx+18h]
		mov	[edx+eax*4], ecx

loc_98C9:				; CODE XREF: UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+565j
		mov	eax, [ebp+var_20]
		add	eax, 2
		mov	[ebp+var_20], eax
		jmp	short loc_990F
; ---------------------------------------------------------------------------

loc_98D4:				; CODE XREF: UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+545j
		mov	eax, [ebp+var_38]
		and	eax, 3FFh
		movzx	ecx, ax
		add	ecx, 0DC00h
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+4]
		mov	edx, [ebp+arg_0]
		mov	edx, [edx+4]
		movsx	edx, byte ptr [edx+41h]
		mov	[eax+edx*2+74h], cx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	dl, [ecx+41h]
		add	dl, 1
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	[ecx+41h], dl

loc_990F:				; CODE XREF: UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+59Ej
		jmp	short loc_992E
; ---------------------------------------------------------------------------

loc_9911:				; CODE XREF: UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+4D6j
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_38]
		push	ecx
		mov	edx, [ebp+var_44]
		push	edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		push	ecx
		call	?toUnicodeCallback@@YAXPAUUConverter@@IIPAW4UErrorCode@@@Z ; toUnicodeCallback(UConverter *,uint,uint,UErrorCode *)
		add	esp, 10h
		jmp	short $endloop$38451
; ---------------------------------------------------------------------------

loc_992E:				; CODE XREF: UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+4CAj
					; UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *):loc_990Fj
		jmp	short loc_993B
; ---------------------------------------------------------------------------

loc_9930:				; CODE XREF: UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+D7j
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Fh
		jmp	short $endloop$38451
; ---------------------------------------------------------------------------

loc_993B:				; CODE XREF: UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *):loc_992Ej
		jmp	loc_93EF
; ---------------------------------------------------------------------------

$endloop$38451:				; CODE XREF: UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+C1j
					; UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+45Ej ...
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_20]
		mov	[eax+10h], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		mov	[eax+8], ecx

loc_9952:				; CODE XREF: UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+182j
					; UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+275j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN52_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 184h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC@@YAXPAUUConverterToUnicodeArgs@@PAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN52_0		dd 2			; DATA XREF: UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+622o
		dd offset $LN51
$LN51		dd 0FFFFFFF8h, 3	; DATA XREF: .text:0000997Co
		dd offset $LN49_0	; "tempBuf"
		dd 0FFFFFFECh, 4
		dd offset $LN50_1	; "mySource"
$LN50_1		db 'mySource',0         ; DATA XREF: .text:00009994o
$LN49_0		db 'tempBuf',0          ; DATA XREF: .text:00009988o
		align 4
$LN53		dd offset $LN25_0	; DATA XREF: UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+121r
		dd offset $LN31_0	; jump table for switch	statement
		dd offset $LN33
		dd offset $LN28_0
		dd offset $LN24
$LN48_0		db	0,     4,     4,     0
					; DATA XREF: UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+11Ar
		db	1,     2,     4,     4 ; indirect table	for switch statement
		db	4,     4,     4,     4
		db	4,     4,     4,     4
		db	4,     3
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 99D4h
		public ??_C@_1BK@ENOKOAEN@?$AAt?$AAe?$AAm?$AAp?$AAS?$AAt?$AAa?$AAt?$AAe?$AA?$DM?$AA1?$AA0?$AA?$AA@
; wchar_t `string'
??_C@_1BK@ENOKOAEN@?$AAt?$AAe?$AAm?$AAp?$AAS?$AAt?$AAa?$AAt?$AAe?$AA?$DM?$AA1?$AA0?$AA?$AA@:
					; DATA XREF: UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+377o
		unicode	0, <tempState>
		dw 3Ch
		unicode	0, <10>,0
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 99F0h
		public ?__LINE__Var@?1??UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC@@YAXPAUUConverterToUnicodeArgs@@PAW4UErrorCode@@@Z@4JA@d3633fb2
?__LINE__Var@?1??UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC@@YAXPAUUConverterToUnicodeArgs@@PAW4UErrorCode@@@Z@4JA@d3633fb2	dd 0CBAh
					; DATA XREF: UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+367r
_data		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 99F4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl _ISO_2022_WriteSub(struct UConverterFromUnicodeArgs *, int, enum	 UErrorCode *)
?_ISO_2022_WriteSub@@YAXPAUUConverterFromUnicodeArgs@@HPAW4UErrorCode@@@Z proc near
					; DATA XREF: .rdata:000005ACo
					; .rdata:00000744o ...

var_144		= byte ptr -144h
var_79		= byte ptr -79h
var_70		= dword	ptr -70h
var_61		= byte ptr -61h
var_58		= dword	ptr -58h
var_4C		= byte ptr -4Ch
var_3C		= dword	ptr -3Ch
var_30		= dword	ptr -30h
var_24		= dword	ptr -24h
var_18		= dword	ptr -18h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 144h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_144]
		mov	ecx, 51h ; 'Q'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	[ebp+var_C], ecx
		mov	eax, [ebp+var_C]
		mov	ecx, [eax+8]
		mov	[ebp+var_18], ecx
		mov	eax, [ebp+var_18]
		add	eax, 36h ; '6'
		mov	[ebp+var_24], eax
		mov	eax, [ebp+var_C]
		mov	ecx, [eax+14h]
		mov	[ebp+var_3C], ecx
		mov	eax, [ebp+var_C]
		movsx	ecx, byte ptr [eax+3Dh]
		mov	[ebp+var_58], ecx
		lea	eax, [ebp+var_4C]
		mov	[ebp+var_30], eax
		mov	eax, [ebp+var_18]
		mov	cl, [eax+63h]
		mov	[ebp+var_144], cl
		cmp	[ebp+var_144], 63h ; 'c'
		jz	loc_9B0A
		cmp	[ebp+var_144], 6Ah ; 'j'
		jz	short loc_9A84
		cmp	[ebp+var_144], 6Bh ; 'k'
		jz	loc_9B43
		jmp	loc_9CE6
; ---------------------------------------------------------------------------

loc_9A84:				; CODE XREF: _ISO_2022_WriteSub(UConverterFromUnicodeArgs *,int,UErrorCode *)+7Cj
		mov	eax, [ebp+var_24]
		movsx	ecx, byte ptr [eax+4]
		cmp	ecx, 1
		jnz	short loc_9AA6
		mov	eax, [ebp+var_24]
		mov	byte ptr [eax+4], 0
		mov	eax, [ebp+var_30]
		mov	byte ptr [eax],	0Fh
		mov	ecx, [ebp+var_30]
		add	ecx, 1
		mov	[ebp+var_30], ecx

loc_9AA6:				; CODE XREF: _ISO_2022_WriteSub(UConverterFromUnicodeArgs *,int,UErrorCode *)+9Aj
		mov	eax, [ebp+var_24]
		mov	cl, [eax]
		mov	[ebp+var_61], cl
		movsx	eax, [ebp+var_61]
		test	eax, eax
		jz	short loc_9AF2
		movsx	eax, [ebp+var_61]
		cmp	eax, 3
		jz	short loc_9AF2
		mov	eax, [ebp+var_24]
		mov	byte ptr [eax],	0
		mov	eax, [ebp+var_30]
		mov	byte ptr [eax],	1Bh
		mov	ecx, [ebp+var_30]
		add	ecx, 1
		mov	[ebp+var_30], ecx
		mov	eax, [ebp+var_30]
		mov	byte ptr [eax],	28h ; '('
		mov	ecx, [ebp+var_30]
		add	ecx, 1
		mov	[ebp+var_30], ecx
		mov	eax, [ebp+var_30]
		mov	byte ptr [eax],	42h ; 'B'
		mov	ecx, [ebp+var_30]
		add	ecx, 1
		mov	[ebp+var_30], ecx

loc_9AF2:				; CODE XREF: _ISO_2022_WriteSub(UConverterFromUnicodeArgs *,int,UErrorCode *)+C0j
					; _ISO_2022_WriteSub(UConverterFromUnicodeArgs *,int,UErrorCode	*)+C9j
		mov	eax, [ebp+var_30]
		mov	ecx, [ebp+var_3C]
		mov	dl, [ecx]
		mov	[eax], dl
		mov	eax, [ebp+var_30]
		add	eax, 1
		mov	[ebp+var_30], eax
		jmp	loc_9CE6
; ---------------------------------------------------------------------------

loc_9B0A:				; CODE XREF: _ISO_2022_WriteSub(UConverterFromUnicodeArgs *,int,UErrorCode *)+6Fj
		mov	eax, [ebp+var_24]
		movsx	ecx, byte ptr [eax+4]
		test	ecx, ecx
		jz	short loc_9B2B
		mov	eax, [ebp+var_24]
		mov	byte ptr [eax+4], 0
		mov	eax, [ebp+var_30]
		mov	byte ptr [eax],	0Fh
		mov	ecx, [ebp+var_30]
		add	ecx, 1
		mov	[ebp+var_30], ecx

loc_9B2B:				; CODE XREF: _ISO_2022_WriteSub(UConverterFromUnicodeArgs *,int,UErrorCode *)+11Fj
		mov	eax, [ebp+var_30]
		mov	ecx, [ebp+var_3C]
		mov	dl, [ecx]
		mov	[eax], dl
		mov	eax, [ebp+var_30]
		add	eax, 1
		mov	[ebp+var_30], eax
		jmp	loc_9CE6
; ---------------------------------------------------------------------------

loc_9B43:				; CODE XREF: _ISO_2022_WriteSub(UConverterFromUnicodeArgs *,int,UErrorCode *)+85j
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+40h], 0
		jnz	loc_9BF0
		cmp	[ebp+var_58], 1
		jnz	short loc_9B95
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		movsx	edx, byte ptr [ecx+34h]
		test	edx, edx
		jz	short loc_9B80
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	dword ptr [ecx+34h], 0
		mov	eax, [ebp+var_30]
		mov	byte ptr [eax],	0Fh
		mov	ecx, [ebp+var_30]
		add	ecx, 1
		mov	[ebp+var_30], ecx

loc_9B80:				; CODE XREF: _ISO_2022_WriteSub(UConverterFromUnicodeArgs *,int,UErrorCode *)+16Ej
		mov	eax, [ebp+var_30]
		mov	ecx, [ebp+var_3C]
		mov	dl, [ecx]
		mov	[eax], dl
		mov	eax, [ebp+var_30]
		add	eax, 1
		mov	[ebp+var_30], eax
		jmp	short loc_9BE6
; ---------------------------------------------------------------------------

loc_9B95:				; CODE XREF: _ISO_2022_WriteSub(UConverterFromUnicodeArgs *,int,UErrorCode *)+160j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		movsx	edx, byte ptr [ecx+34h]
		test	edx, edx
		jnz	short loc_9BBF
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	dword ptr [ecx+34h], 1
		mov	eax, [ebp+var_30]
		mov	byte ptr [eax],	0Eh
		mov	ecx, [ebp+var_30]
		add	ecx, 1
		mov	[ebp+var_30], ecx

loc_9BBF:				; CODE XREF: _ISO_2022_WriteSub(UConverterFromUnicodeArgs *,int,UErrorCode *)+1ADj
		mov	eax, [ebp+var_30]
		mov	ecx, [ebp+var_3C]
		mov	dl, [ecx]
		mov	[eax], dl
		mov	eax, [ebp+var_30]
		add	eax, 1
		mov	[ebp+var_30], eax
		mov	eax, [ebp+var_30]
		mov	ecx, [ebp+var_3C]
		mov	dl, [ecx+1]
		mov	[eax], dl
		mov	eax, [ebp+var_30]
		add	eax, 1
		mov	[ebp+var_30], eax

loc_9BE6:				; CODE XREF: _ISO_2022_WriteSub(UConverterFromUnicodeArgs *,int,UErrorCode *)+19Fj
		jmp	loc_9CE6
; ---------------------------------------------------------------------------
		jmp	loc_9CE6
; ---------------------------------------------------------------------------

loc_9BF0:				; CODE XREF: _ISO_2022_WriteSub(UConverterFromUnicodeArgs *,int,UErrorCode *)+156j
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+28h]
		mov	edx, [ecx+14h]
		mov	[ebp+var_70], edx
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+28h]
		mov	dl, [ecx+3Dh]
		mov	[ebp+var_79], dl
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+28h]
		mov	edx, [ebp+var_3C]
		mov	[ecx+14h], edx
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+28h]
		mov	dl, byte ptr [ebp+var_58]
		mov	[ecx+3Dh], dl
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_18]
		mov	edx, [ecx+28h]
		mov	[eax+4], edx
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+28h]
		mov	edx, [ebp+var_C]
		mov	eax, [edx+38h]
		mov	[ecx+38h], eax
		mov	eax, [ebp+arg_8]
		push	eax
		push	0
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	_ucnv_cbFromUWriteSub_56
		add	esp, 0Ch
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+28h]
		mov	edx, [ebp+var_C]
		mov	eax, [ecx+38h]
		mov	[edx+38h], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_C]
		mov	[eax+4], ecx
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+28h]
		mov	edx, [ebp+var_70]
		mov	[ecx+14h], edx
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+28h]
		mov	dl, [ebp+var_79]
		mov	[ecx+3Dh], dl
		mov	eax, [ebp+arg_8]
		cmp	dword ptr [eax], 0Fh
		jnz	short loc_9CE4
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+28h]
		movsx	edx, byte ptr [ecx+3Fh]
		test	edx, edx
		jle	short loc_9CCB
		push	1
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+28h]
		add	ecx, 4Ch ; 'L'
		push	ecx
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	edx, [ebp+var_18]
		mov	eax, [edx+28h]
		movsx	ecx, byte ptr [eax+3Fh]
		push	ecx		; Size
		mov	edx, [ebp+var_18]
		mov	eax, [edx+28h]
		add	eax, 4Ch ; 'L'
		push	eax		; Src
		mov	ecx, [ebp+var_C]
		add	ecx, 4Ch ; 'L'
		push	ecx		; Dst

loc_9CC3:				; DATA XREF: .rdata:000002ECo
		call	_memcpy

loc_9CC8:				; DATA XREF: .rdata:000002F0o
					; .rdata:000002F4o
		add	esp, 0Ch

loc_9CCB:				; CODE XREF: _ISO_2022_WriteSub(UConverterFromUnicodeArgs *,int,UErrorCode *)+29Dj
					; DATA XREF: .rdata:000002F8o ...
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+28h]
		mov	edx, [ebp+var_C]
		mov	al, [ecx+3Fh]
		mov	[edx+3Fh], al
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+28h]
		mov	byte ptr [ecx+3Fh], 0

loc_9CE4:				; CODE XREF: _ISO_2022_WriteSub(UConverterFromUnicodeArgs *,int,UErrorCode *)+28Fj
		jmp	short loc_9D07
; ---------------------------------------------------------------------------

loc_9CE6:				; CODE XREF: _ISO_2022_WriteSub(UConverterFromUnicodeArgs *,int,UErrorCode *)+8Bj
					; _ISO_2022_WriteSub(UConverterFromUnicodeArgs *,int,UErrorCode	*)+111j ...
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+var_30]
		lea	eax, [ebp+var_4C]
		sub	edx, eax
		push	edx
		lea	ecx, [ebp+var_4C]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	_ucnv_cbFromUWriteBytes_56
		add	esp, 14h

loc_9D07:				; CODE XREF: _ISO_2022_WriteSub(UConverterFromUnicodeArgs *,int,UErrorCode *):loc_9CE4j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN22_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 144h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?_ISO_2022_WriteSub@@YAXPAUUConverterFromUnicodeArgs@@HPAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN22_0		dd 1			; DATA XREF: _ISO_2022_WriteSub(UConverterFromUnicodeArgs *,int,UErrorCode *)+317o
		dd offset $LN21_1
$LN21_1		dd 0FFFFFFB4h, 8	; DATA XREF: .text:00009D3Co
		dd offset $LN20_0	; "buffer"
$LN20_0		db 'buffer',0           ; DATA XREF: .text:00009D48o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9D54h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct UConverter * __cdecl _ISO_2022_SafeClone(struct UConverter const *, void *, int *, enum  UErrorCode *)
?_ISO_2022_SafeClone@@YAPAUUConverter@@PBU1@PAXPAHPAW4UErrorCode@@@Z proc near
					; DATA XREF: .rdata:000005B0o
					; .rdata:00000748o ...

var_F0		= byte ptr -0F0h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
Src		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0F0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_F0]
		mov	ecx, 3Ch ; '<'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_8]
		cmp	dword ptr [eax], 0
		jnz	short loc_9D8A
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 278h
		xor	eax, eax
		jmp	loc_9E62
; ---------------------------------------------------------------------------

loc_9D8A:				; CODE XREF: _ISO_2022_SafeClone(UConverter const *,void *,int *,UErrorCode *)+24j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		mov	[ebp+Src], ecx
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_8], eax
		push	1
		mov	eax, [ebp+Src]
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		push	68h ; 'h'       ; Size
		mov	ecx, [ebp+Src]
		push	ecx		; Src
		mov	edx, [ebp+var_8]
		add	edx, 210h
		push	edx		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	eax, [ebp+var_8]
		add	eax, 210h
		mov	ecx, [ebp+var_8]
		mov	[ecx+8], eax
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+22h], 1
		mov	eax, [ebp+Src]
		cmp	dword ptr [eax+28h], 0
		jz	short loc_9E27
		mov	[ebp+var_2C], 10Ch
		mov	eax, [ebp+arg_C]
		push	eax
		lea	ecx, [ebp+var_2C]
		push	ecx
		mov	edx, [ebp+var_8]
		add	edx, 104h
		push	edx
		mov	eax, [ebp+Src]
		mov	ecx, [eax+28h]
		push	ecx
		call	_ucnv_safeClone_56
		add	esp, 10h
		mov	edx, [ebp+var_8]
		mov	[edx+238h], eax
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_9E27
		xor	eax, eax
		jmp	short loc_9E62
; ---------------------------------------------------------------------------

loc_9E27:				; CODE XREF: _ISO_2022_SafeClone(UConverter const *,void *,int *,UErrorCode *)+87j
					; _ISO_2022_SafeClone(UConverter const *,void *,int *,UErrorCode *)+CDj
		mov	[ebp+var_20], 0
		jmp	short loc_9E39
; ---------------------------------------------------------------------------

loc_9E30:				; CODE XREF: _ISO_2022_SafeClone(UConverter const *,void *,int *,UErrorCode *):loc_9E5Dj
		mov	eax, [ebp+var_20]
		add	eax, 1
		mov	[ebp+var_20], eax

loc_9E39:				; CODE XREF: _ISO_2022_SafeClone(UConverter const *,void *,int *,UErrorCode *)+DAj
		cmp	[ebp+var_20], 0Ah
		jge	short loc_9E5F
		mov	eax, [ebp+var_20]
		mov	ecx, [ebp+Src]
		cmp	dword ptr [ecx+eax*4], 0
		jz	short loc_9E5D
		mov	eax, [ebp+var_20]
		mov	ecx, [ebp+Src]
		mov	edx, [ecx+eax*4]
		push	edx
		call	_ucnv_incrementRefCount_56
		add	esp, 4

loc_9E5D:				; CODE XREF: _ISO_2022_SafeClone(UConverter const *,void *,int *,UErrorCode *)+F5j
		jmp	short loc_9E30
; ---------------------------------------------------------------------------

loc_9E5F:				; CODE XREF: _ISO_2022_SafeClone(UConverter const *,void *,int *,UErrorCode *)+E9j
		mov	eax, [ebp+var_8]

loc_9E62:				; CODE XREF: _ISO_2022_SafeClone(UConverter const *,void *,int *,UErrorCode *)+31j
					; _ISO_2022_SafeClone(UConverter const *,void *,int *,UErrorCode *)+D1j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN12
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?_ISO_2022_SafeClone@@YAPAUUConverter@@PBU1@PAXPAHPAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN12		dd 1			; DATA XREF: _ISO_2022_SafeClone(UConverter const *,void *,int *,UErrorCode *)+112o
		dd offset $LN11
$LN11		dd 0FFFFFFD4h, 4	; DATA XREF: .text:00009E8Co
		dd offset $LN10		; "size"
$LN10		db 'size',0             ; DATA XREF: .text:00009E98o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9EA4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl _ISO_2022_GetUnicodeSet(struct UConverter const *, struct USetAdder const *, enum  UConverterUnicodeSet,	enum  UErrorCode *)
?_ISO_2022_GetUnicodeSet@@YAXPBUUConverter@@PBUUSetAdder@@W4UConverterUnicodeSet@@PAW4UErrorCode@@@Z proc near
					; DATA XREF: .rdata:000005B4o
					; .rdata:0000074Co ...

var_E8		= dword	ptr -0E8h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_E8]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_9EDC
		jmp	loc_A16E
; ---------------------------------------------------------------------------

loc_9EDC:				; CODE XREF: _ISO_2022_GetUnicodeSet(UConverter	const *,USetAdder const	*,UConverterUnicodeSet,UErrorCode *)+31j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_14]
		movsx	ecx, byte ptr [eax+63h]
		mov	[ebp+var_E8], ecx
		mov	edx, [ebp+var_E8]
		sub	edx, 63h ; 'c'
		mov	[ebp+var_E8], edx
		cmp	[ebp+var_E8], 17h ; switch 24 cases
		ja	$LN20_1		; jumptable 00009F1B default case
		mov	eax, [ebp+var_E8]
		movzx	ecx, ds:$LN25_1[eax]
		jmp	ds:$LN26[ecx*4]	; switch jump
; ---------------------------------------------------------------------------

$LN19_0:				; CODE XREF: _ISO_2022_GetUnicodeSet(UConverter	const *,USetAdder const	*,UConverterUnicodeSet,UErrorCode *)+77j
					; DATA XREF: .text:$LN26o
		mov	esi, esp	; jumptable 00009F1B case 7
		push	0A5h ; ''
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		mov	edx, [ebp+arg_4]
		mov	eax, [edx+4]
		call	eax
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		push	203Eh
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		mov	edx, [ebp+arg_4]
		mov	eax, [edx+4]
		call	eax
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+40h]
		movzx	edx, ds:_jpCharsetMasks[ecx*2]
		and	edx, 2
		jz	short loc_9F96
		mov	esi, esp
		push	0FFh
		push	0
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		mov	edx, [ebp+arg_4]
		mov	eax, [edx+8]
		call	eax
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_9FB4
; ---------------------------------------------------------------------------

loc_9F96:				; CODE XREF: _ISO_2022_GetUnicodeSet(UConverter	const *,USetAdder const	*,UConverterUnicodeSet,UErrorCode *)+CDj
		mov	esi, esp
		push	7Fh ; ''
		push	0
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		mov	edx, [ebp+arg_4]
		mov	eax, [edx+8]
		call	eax
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_9FB4:				; CODE XREF: _ISO_2022_GetUnicodeSet(UConverter	const *,USetAdder const	*,UConverterUnicodeSet,UErrorCode *)+F0j
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+40h], 3
		jz	short loc_9FCC
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+40h], 4
		jz	short loc_9FCC
		cmp	[ebp+arg_8], 1
		jnz	short loc_9FF0

loc_9FCC:				; CODE XREF: _ISO_2022_GetUnicodeSet(UConverter	const *,USetAdder const	*,UConverterUnicodeSet,UErrorCode *)+117j
					; _ISO_2022_GetUnicodeSet(UConverter const *,USetAdder const *,UConverterUnicodeSet,UErrorCode *)+120j
		mov	esi, esp
		push	0FF9Fh
		push	0FF61h
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		mov	edx, [ebp+arg_4]
		mov	eax, [edx+8]
		call	eax
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_9FF0:				; CODE XREF: _ISO_2022_GetUnicodeSet(UConverter	const *,USetAdder const	*,UConverterUnicodeSet,UErrorCode *)+126j
		jmp	short $LN20_1	; jumptable 00009F1B default case
; ---------------------------------------------------------------------------

$LN14:					; CODE XREF: _ISO_2022_GetUnicodeSet(UConverter	const *,USetAdder const	*,UConverterUnicodeSet,UErrorCode *)+77j
					; DATA XREF: .text:$LN26o
		mov	esi, esp	; jumptable 00009F1B cases 0,23
		push	7Fh ; ''
		push	0
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		mov	edx, [ebp+arg_4]
		mov	eax, [edx+8]
		call	eax
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short $LN20_1	; jumptable 00009F1B default case
; ---------------------------------------------------------------------------

$LN13:					; CODE XREF: _ISO_2022_GetUnicodeSet(UConverter	const *,USetAdder const	*,UConverterUnicodeSet,UErrorCode *)+77j
					; DATA XREF: .text:$LN26o
		mov	esi, esp	; jumptable 00009F1B case 8
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+28h]
		push	ecx
		mov	edx, [ebp+var_14]
		mov	eax, [edx+28h]
		mov	ecx, [eax+18h]
		mov	edx, [ecx+14h]
		mov	eax, [edx+3Ch]
		call	eax
		add	esp, 10h
		cmp	esi, esp
		call	__RTC_CheckEsp

$LN20_1:				; CODE XREF: _ISO_2022_GetUnicodeSet(UConverter	const *,USetAdder const	*,UConverterUnicodeSet,UErrorCode *)+64j
					; _ISO_2022_GetUnicodeSet(UConverter const *,USetAdder const *,UConverterUnicodeSet,UErrorCode *)+77j ...
		mov	[ebp+var_8], 0	; jumptable 00009F1B default case
		jmp	short loc_A054
; ---------------------------------------------------------------------------

loc_A04B:				; CODE XREF: _ISO_2022_GetUnicodeSet(UConverter	const *,USetAdder const	*,UConverterUnicodeSet,UErrorCode *):loc_A0F1j
		mov	eax, [ebp+var_8]
		add	eax, 1
		mov	[ebp+var_8], eax

loc_A054:				; CODE XREF: _ISO_2022_GetUnicodeSet(UConverter	const *,USetAdder const	*,UConverterUnicodeSet,UErrorCode *)+1A5j
		cmp	[ebp+var_8], 0Ah
		jge	loc_A0F6
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		cmp	dword ptr [ecx+eax*4], 0
		jz	loc_A0F1
		mov	eax, [ebp+var_14]
		movsx	ecx, byte ptr [eax+63h]
		cmp	ecx, 6Ah ; 'j'
		jnz	short loc_A089
		cmp	[ebp+var_8], 4
		jnz	short loc_A089
		mov	[ebp+var_20], 3
		jmp	short loc_A0CF
; ---------------------------------------------------------------------------

loc_A089:				; CODE XREF: _ISO_2022_GetUnicodeSet(UConverter	const *,USetAdder const	*,UConverterUnicodeSet,UErrorCode *)+1D4j
					; _ISO_2022_GetUnicodeSet(UConverter const *,USetAdder const *,UConverterUnicodeSet,UErrorCode *)+1DAj
		mov	eax, [ebp+var_14]
		movsx	ecx, byte ptr [eax+63h]
		cmp	ecx, 63h ; 'c'
		jz	short loc_A0A1
		mov	eax, [ebp+var_14]
		movsx	ecx, byte ptr [eax+63h]
		cmp	ecx, 7Ah ; 'z'
		jnz	short loc_A0B9

loc_A0A1:				; CODE XREF: _ISO_2022_GetUnicodeSet(UConverter	const *,USetAdder const	*,UConverterUnicodeSet,UErrorCode *)+1EFj
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+40h], 0
		jnz	short loc_A0B9
		cmp	[ebp+var_8], 3
		jnz	short loc_A0B9
		mov	[ebp+var_20], 2
		jmp	short loc_A0CF
; ---------------------------------------------------------------------------

loc_A0B9:				; CODE XREF: _ISO_2022_GetUnicodeSet(UConverter	const *,USetAdder const	*,UConverterUnicodeSet,UErrorCode *)+1FBj
					; _ISO_2022_GetUnicodeSet(UConverter const *,USetAdder const *,UConverterUnicodeSet,UErrorCode *)+204j	...
		cmp	[ebp+var_8], 7
		jnz	short loc_A0C8
		mov	[ebp+var_20], 4
		jmp	short loc_A0CF
; ---------------------------------------------------------------------------

loc_A0C8:				; CODE XREF: _ISO_2022_GetUnicodeSet(UConverter	const *,USetAdder const	*,UConverterUnicodeSet,UErrorCode *)+219j
		mov	[ebp+var_20], 0

loc_A0CF:				; CODE XREF: _ISO_2022_GetUnicodeSet(UConverter	const *,USetAdder const	*,UConverterUnicodeSet,UErrorCode *)+1E3j
					; _ISO_2022_GetUnicodeSet(UConverter const *,USetAdder const *,UConverterUnicodeSet,UErrorCode *)+213j	...
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+var_20]
		push	ecx
		mov	edx, [ebp+arg_8]
		push	edx
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ebp+var_14]
		mov	eax, [edx+ecx*4]
		push	eax
		call	_ucnv_MBCSGetFilteredUnicodeSetForUnicode_56
		add	esp, 14h

loc_A0F1:				; CODE XREF: _ISO_2022_GetUnicodeSet(UConverter	const *,USetAdder const	*,UConverterUnicodeSet,UErrorCode *)+1C4j
		jmp	loc_A04B
; ---------------------------------------------------------------------------

loc_A0F6:				; CODE XREF: _ISO_2022_GetUnicodeSet(UConverter	const *,USetAdder const	*,UConverterUnicodeSet,UErrorCode *)+1B4j
		mov	esi, esp
		push	0Eh
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		mov	edx, [ebp+arg_4]
		mov	eax, [edx+10h]
		call	eax
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		push	0Fh
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		mov	edx, [ebp+arg_4]
		mov	eax, [edx+10h]
		call	eax
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		push	1Bh
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		mov	edx, [ebp+arg_4]
		mov	eax, [edx+10h]
		call	eax
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		push	9Fh ; ''
		push	80h ; ''
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		mov	edx, [ebp+arg_4]
		mov	eax, [edx+14h]
		call	eax
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_A16E:				; CODE XREF: _ISO_2022_GetUnicodeSet(UConverter	const *,USetAdder const	*,UConverterUnicodeSet,UErrorCode *)+33j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?_ISO_2022_GetUnicodeSet@@YAXPBUUConverter@@PBUUSetAdder@@W4UConverterUnicodeSet@@PAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN26		dd offset $LN14		; DATA XREF: _ISO_2022_GetUnicodeSet(UConverter	const *,USetAdder const	*,UConverterUnicodeSet,UErrorCode *)+77r
		dd offset $LN19_0	; jump table for switch	statement
		dd offset $LN13
		dd offset $LN20_1
$LN25_1		db	0,     3,     3,     3
					; DATA XREF: _ISO_2022_GetUnicodeSet(UConverter	const *,USetAdder const	*,UConverterUnicodeSet,UErrorCode *)+70r
		db	3,     3,     3,     1 ; indirect table	for switch statement
		db	2,     3,     3,     3
		db	3,     3,     3,     3
		db	3,     3,     3,     3
		db	3,     3,     3,     0
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A1ACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char const * __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::data(void)const
		public ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ proc near
					; CODE XREF: icu_56::StringPiece::StringPiece(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::c_str(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A1ECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char const * __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::c_str(void)const
		public ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::data(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ;	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Myptr(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A22Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
		public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
					; CODE XREF: icu_56::StringPiece::StringPiece(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&)+33p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+14h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A25Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char const * __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Myptr(void)const
		public ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::c_str(void)+26p

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+18h], 10h
		jb	short loc_A296
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+4]
		mov	[ebp+var_D0], edx
		jmp	short loc_A2A2
; ---------------------------------------------------------------------------

loc_A296:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Myptr(void)+2Aj
		mov	eax, [ebp+var_8]
		add	eax, 4
		mov	[ebp+var_D0], eax

loc_A2A2:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Myptr(void)+38j
		mov	eax, [ebp+var_D0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ endp

_text		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn __RTC_Shutdown:near ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
		extrn __RTC_InitBase:near ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
; const	type_info::`vftable'
		extrn ??_7type_info@@6B@:near
					; DATA XREF: .data:icu_56::UObject `RTTI Type Descriptor'o
					; .data:icu_56::UMemory	`RTTI Type Descriptor'o ...
; public: virtual void * __thiscall icu_56::UObject::getDynamicClassID(void)const
		extrn ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ:near
					; DATA XREF: .rdata:00000D08o
					; .rdata:00000FBCo ...
; void __cdecl icu_56::UMemory::operator delete(void *)
		extrn ??3UMemory@icu_56@@SAXPAX@Z:near
					; CODE XREF: icu_56::UObject::`scalar deleting destructor'(uint)+37p
					; icu_56::UObject::`vector deleting destructor'(uint)+75p ...
; _DWORD __thiscall icu_56::UObject::~UObject(icu_56::UObject *__hidden	this)
		extrn ??1UObject@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::UObject::`scalar deleting destructor'(uint)+26p
					; icu_56::UObject::`vector deleting destructor'(uint)+64p ...
		extrn __RTC_CheckEsp:near
					; CODE XREF: icu_56::UObject::`scalar deleting destructor'(uint)+4Dp
					; icu_56::UObject::`vector deleting destructor'(uint)+8Bp ...
; void __cdecl icu_56::UMemory::operator delete[](void *)
		extrn ??_VUMemory@icu_56@@SAXPAX@Z:near
					; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+51p
					; icu_56::Replaceable::`vector deleting	destructor'(uint)+51p ...
; void __stdcall `eh vector destructor iterator'(void *, unsigned int, int, void (__thiscall *)(void *))
		extrn ??_M@YGXPAXIHP6EX0@Z@Z:near
					; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+3Dp
					; icu_56::Replaceable::`vector deleting	destructor'(uint)+3Dp ...
		extrn __purecall:near	; DATA XREF: .rdata:00000FC0o
					; .rdata:00000FC4o ...
; public: virtual signed char __thiscall icu_56::Replaceable::hasMetaData(void)const
		extrn ?hasMetaData@Replaceable@icu_56@@UBECXZ:near
					; DATA XREF: .rdata:00000FCCo
; public: virtual class	icu_56::Replaceable * __thiscall icu_56::Replaceable::clone(void)const
		extrn ?clone@Replaceable@icu_56@@UBEPAV12@XZ:near
					; DATA XREF: .rdata:00000FD0o
; _DWORD __thiscall icu_56::Replaceable::~Replaceable(icu_56::Replaceable *__hidden this)
		extrn ??1Replaceable@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::Replaceable::`scalar deleting destructor'(uint)+26p
					; icu_56::Replaceable::`vector deleting	destructor'(uint)+64p
					; DATA XREF: ...
; _DWORD __thiscall icu_56::StringPiece::StringPiece(icu_56::StringPiece *__hidden this, const struct icu_56::StringPiece *, int, int)
		extrn ??0StringPiece@icu_56@@QAE@ABV01@HH@Z:near
					; CODE XREF: icu_56::StringPiece::substr(int,int)+32p
; public: virtual char * __thiscall icu_56::ByteSink::GetAppendBuffer(int, int,	char *,	int, int *)
		extrn ?GetAppendBuffer@ByteSink@icu_56@@UAEPADHHPADHPAH@Z:near
					; DATA XREF: .rdata:0000167Co
; public: virtual void __thiscall icu_56::ByteSink::Flush(void)
		extrn ?Flush@ByteSink@icu_56@@UAEXXZ:near ; DATA XREF: .rdata:00001680o
; _DWORD __thiscall icu_56::ByteSink::~ByteSink(icu_56::ByteSink *__hidden this)
		extrn ??1ByteSink@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::ByteSink::`scalar deleting	destructor'(uint)+26p
					; icu_56::ByteSink::`vector deleting destructor'(uint)+64p
					; DATA XREF: ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::moveFrom(icu_56::UnicodeString *__hidden this, struct	icu_56::UnicodeString *)
		extrn ?moveFrom@UnicodeString@icu_56@@QAEAAV12@AAV12@@Z:near
					; CODE XREF: icu_56::UnicodeString::operator=(icu_56::UnicodeString &&)+2Ap
; void __thiscall icu_56::UnicodeString::swap(icu_56::UnicodeString *__hidden this, struct icu_56::UnicodeString *)
		extrn ?swap@UnicodeString@icu_56@@QAEXAAV12@@Z:near
					; CODE XREF: icu_56::swap(icu_56::UnicodeString	&,icu_56::UnicodeString	&)+25p
; _DWORD __thiscall icu_56::UnicodeString::~UnicodeString(icu_56::UnicodeString	*__hidden this)
		extrn ??1UnicodeString@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::UnicodeString::`scalar deleting destructor'(uint)+26p
					; icu_56::UnicodeString::`vector deleting destructor'(uint)+64p
					; DATA XREF: ...
; public: virtual void * __thiscall icu_56::UnicodeString::getDynamicClassID(void)const
		extrn ?getDynamicClassID@UnicodeString@icu_56@@UBEPAXXZ:near
					; DATA XREF: .rdata:00001BF8o
; public: virtual void __thiscall icu_56::UnicodeString::extractBetween(int, int, class	icu_56::UnicodeString &)const
		extrn ?extractBetween@UnicodeString@icu_56@@UBEXHHAAV12@@Z:near
					; DATA XREF: .rdata:00001BFCo
; public: virtual void __thiscall icu_56::UnicodeString::handleReplaceBetween(int, int,	class icu_56::UnicodeString const &)
		extrn ?handleReplaceBetween@UnicodeString@icu_56@@UAEXHHABV12@@Z:near
					; DATA XREF: .rdata:00001C00o
; public: virtual void __thiscall icu_56::UnicodeString::copy(int, int,	int)
		extrn ?copy@UnicodeString@icu_56@@UAEXHHH@Z:near
					; DATA XREF: .rdata:00001C04o
; public: virtual signed char __thiscall icu_56::UnicodeString::hasMetaData(void)const
		extrn ?hasMetaData@UnicodeString@icu_56@@UBECXZ:near
					; DATA XREF: .rdata:00001C08o
; public: virtual class	icu_56::Replaceable * __thiscall icu_56::UnicodeString::clone(void)const
		extrn ?clone@UnicodeString@icu_56@@UBEPAVReplaceable@2@XZ:near
					; DATA XREF: .rdata:00001C0Co
; protected: virtual int __thiscall icu_56::UnicodeString::getLength(void)const
		extrn ?getLength@UnicodeString@icu_56@@MBEHXZ:near
					; DATA XREF: .rdata:00001C10o
; protected: virtual wchar_t __thiscall	icu_56::UnicodeString::getCharAt(int)const
		extrn ?getCharAt@UnicodeString@icu_56@@MBE_WH@Z:near
					; DATA XREF: .rdata:00001C14o
; protected: virtual int __thiscall icu_56::UnicodeString::getChar32At(int)const
		extrn ?getChar32At@UnicodeString@icu_56@@MBEHH@Z:near
					; DATA XREF: .rdata:00001C18o
; int __thiscall icu_56::UnicodeString::doHashCode(icu_56::UnicodeString *__hidden this)
		extrn ?doHashCode@UnicodeString@icu_56@@ABEHXZ:near
					; CODE XREF: icu_56::UnicodeString::hashCode(void)+26p
; int __thiscall icu_56::UnicodeString::refCount(icu_56::UnicodeString *__hidden this)
		extrn ?refCount@UnicodeString@icu_56@@ABEHXZ:near
					; CODE XREF: icu_56::UnicodeString::isBufferWritable(void)+3Ep
; signed __int8	__thiscall icu_56::UnicodeString::doCompare(icu_56::UnicodeString *__hidden this, int, int, const wchar_t *, int, int)
		extrn ?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z:near
					; CODE XREF: icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+72p
					; icu_56::UnicodeString::compare(wchar_t const *,int)+3Bp ...
; signed __int8	__thiscall icu_56::UnicodeString::doEquals(icu_56::UnicodeString *__hidden this, const struct icu_56::UnicodeString *, int)
		extrn ?doEquals@UnicodeString@icu_56@@ABECABV12@H@Z:near
					; CODE XREF: icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)+76p
; signed __int8	__thiscall icu_56::UnicodeString::doCompareCodePointOrder(icu_56::UnicodeString	*__hidden this,	int, int, const	wchar_t	*, int,	int)
		extrn ?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHPB_WHH@Z:near
					; CODE XREF: icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const	&,int,int)+72p
					; icu_56::UnicodeString::compareCodePointOrder(wchar_t const *,int)+3Bp ...
; signed __int8	__thiscall icu_56::UnicodeString::doCaseCompare(icu_56::UnicodeString *__hidden	this, int, int,	const wchar_t *, int, int, unsigned int)
		extrn ?doCaseCompare@UnicodeString@icu_56@@ABECHHPB_WHHI@Z:near
					; CODE XREF: icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString	const &,int,int,uint)+76p
					; icu_56::UnicodeString::caseCompare(wchar_t const *,int,uint)+3Fp ...
; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *__hidden	this, const wchar_t *, int, int, int, int)
		extrn ?indexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z:near
					; CODE XREF: icu_56::UnicodeString::indexOf(icu_56::UnicodeString const	&,int,int,int,int)+64p
					; icu_56::UnicodeString::indexOf(wchar_t const *,int,int)+4Cp ...
; int __thiscall icu_56::UnicodeString::doIndexOf(icu_56::UnicodeString	*__hidden this,	wchar_t, int, int)
		extrn ?doIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z:near
					; CODE XREF: icu_56::UnicodeString::indexOf(wchar_t,int,int)+33p
					; icu_56::UnicodeString::indexOf(wchar_t)+36p ...
; int __thiscall icu_56::UnicodeString::doIndexOf(icu_56::UnicodeString	*__hidden this,	int, int, int)
		extrn ?doIndexOf@UnicodeString@icu_56@@ABEHHHH@Z:near
					; CODE XREF: icu_56::UnicodeString::indexOf(int,int,int)+32p
; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *__hidden this, const	wchar_t	*, int,	int, int, int)
		extrn ?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z:near
					; CODE XREF: icu_56::UnicodeString::lastIndexOf(wchar_t	const *,int,int,int)+38p
					; icu_56::UnicodeString::lastIndexOf(wchar_t const *,int,int)+4Cp ...
; int __thiscall icu_56::UnicodeString::doLastIndexOf(icu_56::UnicodeString *__hidden this, wchar_t, int, int)
		extrn ?doLastIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z:near
					; CODE XREF: icu_56::UnicodeString::lastIndexOf(wchar_t,int,int)+33p
					; icu_56::UnicodeString::lastIndexOf(wchar_t)+36p ...
; int __thiscall icu_56::UnicodeString::doLastIndexOf(icu_56::UnicodeString *__hidden this, int, int, int)
		extrn ?doLastIndexOf@UnicodeString@icu_56@@ABEHHHH@Z:near
					; CODE XREF: icu_56::UnicodeString::lastIndexOf(int,int,int)+32p
		extrn _u_strlen_56:near	; CODE XREF: icu_56::UnicodeString::startsWith(wchar_t const *,int)+2Dp
					; icu_56::UnicodeString::startsWith(wchar_t const *,int,int)+2Dp ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::doReplace(icu_56::UnicodeString *__hidden this, int, int, const struct icu_56::UnicodeString *, int, int)
		extrn ?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z:near
					; CODE XREF: icu_56::UnicodeString::replace(int,int,icu_56::UnicodeString const	&)+3Dp
					; icu_56::UnicodeString::replace(int,int,icu_56::UnicodeString const &,int,int)+3Ap ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::doReplace(icu_56::UnicodeString *__hidden this, int, int, const wchar_t *, int, int)
		extrn ?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z:near
					; CODE XREF: icu_56::UnicodeString::replace(int,int,wchar_t const *,int)+38p
					; icu_56::UnicodeString::replace(int,int,wchar_t const *,int,int)+3Ap ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::findAndReplace(icu_56::UnicodeString *__hidden this, int, int, const struct icu_56::UnicodeString *, int, int, const struct icu_56::UnicodeString *, int, int)
		extrn ?findAndReplace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH0HH@Z:near
					; CODE XREF: icu_56::UnicodeString::findAndReplace(icu_56::UnicodeString const &,icu_56::UnicodeString const &)+4Fp
					; icu_56::UnicodeString::findAndReplace(int,int,icu_56::UnicodeString const &,icu_56::UnicodeString const &)+4Cp
; void __thiscall icu_56::UnicodeString::doExtract(icu_56::UnicodeString *__hidden this, int, int, wchar_t *, int)
		extrn ?doExtract@UnicodeString@icu_56@@ABEXHHPA_WH@Z:near
					; CODE XREF: icu_56::UnicodeString::extract(int,int,wchar_t *,int)+36p
					; icu_56::UnicodeString::extractBetween(int,int,wchar_t	*,int)+51p
; int __thiscall icu_56::UnicodeString::extract(icu_56::UnicodeString *__hidden	this, int, int,	char *,	unsigned int, const char *)
		extrn ?extract@UnicodeString@icu_56@@QBEHHHPADIPBD@Z:near
					; CODE XREF: icu_56::UnicodeString::extract(int,int,char *,char	const *)+3Ep
; struct icu_56::UnicodeString __thiscall __high icu_56::UnicodeString::tempSubString(int, int)
		extrn ?tempSubString@UnicodeString@icu_56@@QBE?AV12@HH@Z:near
					; CODE XREF: icu_56::UnicodeString::tempSubStringBetween(int,int)+3Fp
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replace(icu_56::UnicodeString	*__hidden this,	int, int, int)
		extrn ?replace@UnicodeString@icu_56@@QAEAAV12@HHH@Z:near
					; CODE XREF: icu_56::UnicodeString::operator=(int)+35p
					; icu_56::UnicodeString::setTo(int)+3Dp ...
; void __thiscall icu_56::UnicodeString::unBogus(icu_56::UnicodeString *__hidden this)
		extrn ?unBogus@UnicodeString@icu_56@@AAEXXZ:near
					; CODE XREF: icu_56::UnicodeString::setTo(icu_56::UnicodeString	const &,int,int)+26p
					; icu_56::UnicodeString::setTo(icu_56::UnicodeString const &,int)+26p ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::copyFrom(icu_56::UnicodeString *__hidden this, const struct icu_56::UnicodeString *, signed __int8)
		extrn ?copyFrom@UnicodeString@icu_56@@AAEAAV12@ABV12@C@Z:near
					; CODE XREF: icu_56::UnicodeString::setTo(icu_56::UnicodeString	const &)+2Cp
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::doAppend(icu_56::UnicodeString *__hidden this, const struct icu_56::UnicodeString *, int, int)
		extrn ?doAppend@UnicodeString@icu_56@@AAEAAV12@ABV12@HH@Z:near
					; CODE XREF: icu_56::UnicodeString::append(icu_56::UnicodeString const &,int,int)+32p
					; icu_56::UnicodeString::append(icu_56::UnicodeString const &)+35p ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::doAppend(icu_56::UnicodeString *__hidden this, const wchar_t *, int, int)
		extrn ?doAppend@UnicodeString@icu_56@@AAEAAV12@PB_WHH@Z:near
					; CODE XREF: icu_56::UnicodeString::append(wchar_t const *,int,int)+32p
					; icu_56::UnicodeString::append(wchar_t	const *,int)+30p ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *__hidden this, int)
		extrn ?append@UnicodeString@icu_56@@QAEAAV12@H@Z:near
					; CODE XREF: icu_56::UnicodeString::operator+=(int)+2Ap
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::doReverse(icu_56::UnicodeString *__hidden this, int, int)
		extrn ?doReverse@UnicodeString@icu_56@@AAEAAV12@HH@Z:near
					; CODE XREF: icu_56::UnicodeString::reverse(void)+31p
					; icu_56::UnicodeString::reverse(int,int)+2Ep
; _DWORD __thiscall icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString *__hidden this, const struct icu_56::UnicodeString *)
		extrn ??0UnicodeString@icu_56@@QAE@ABV01@@Z:near
					; CODE XREF: icu_56::StringEnumeration::StringEnumeration(icu_56::StringEnumeration const &)+6Bp
		extrn ___security_cookie:near
					; DATA XREF: icu_56::StringEnumeration::StringEnumeration(icu_56::StringEnumeration const &)+2Er
					; _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+1Er ...
		extrn ___CxxFrameHandler3:near
					; CODE XREF: __ehhandler$??0StringEnumeration@icu_56@@QAE@ABV01@@Z+19j
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near
					; CODE XREF: __ehhandler$??0StringEnumeration@icu_56@@QAE@ABV01@@Z+Fp
					; _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+6F0p ...
; public: virtual class	icu_56::StringEnumeration * __thiscall icu_56::StringEnumeration::clone(void)const
		extrn ?clone@StringEnumeration@icu_56@@UBEPAV12@XZ:near
					; DATA XREF: .rdata:00004A0Co
; public: virtual char const * __thiscall icu_56::StringEnumeration::next(int *, enum  UErrorCode &)
		extrn ?next@StringEnumeration@icu_56@@UAEPBDPAHAAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:00004A14o
; public: virtual wchar_t const	* __thiscall icu_56::StringEnumeration::unext(int *, enum  UErrorCode &)
		extrn ?unext@StringEnumeration@icu_56@@UAEPB_WPAHAAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:00004A18o
; public: virtual class	icu_56::UnicodeString const * __thiscall icu_56::StringEnumeration::snext(enum	UErrorCode &)
		extrn ?snext@StringEnumeration@icu_56@@UAEPBVUnicodeString@2@AAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:00004A1Co
; public: virtual signed char __thiscall icu_56::StringEnumeration::operator==(class icu_56::StringEnumeration const &)const
		extrn ??8StringEnumeration@icu_56@@UBECABV01@@Z:near
					; DATA XREF: .rdata:00004A24o
; public: virtual signed char __thiscall icu_56::StringEnumeration::operator!=(class icu_56::StringEnumeration const &)const
		extrn ??9StringEnumeration@icu_56@@UBECABV01@@Z:near
					; DATA XREF: .rdata:00004A28o
; public: class	icu_56::UnicodeString &	__thiscall icu_56::UnicodeString::operator=(class icu_56::UnicodeString	const &)
		extrn ??4UnicodeString@icu_56@@QAEAAV01@ABV01@@Z:near
					; CODE XREF: icu_56::StringEnumeration::operator=(icu_56::StringEnumeration const &)+3Cp
; _DWORD __thiscall icu_56::StringEnumeration::~StringEnumeration(icu_56::StringEnumeration *__hidden this)
		extrn ??1StringEnumeration@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::StringEnumeration::`scalar	deleting destructor'(uint)+26p
					; icu_56::StringEnumeration::`vector deleting destructor'(uint)+64p
					; DATA XREF: ...
; void *__cdecl	memcpy(void *Dst, const	void *Src, size_t Size)
		extrn _memcpy:near	; CODE XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+486p
					; UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)+877p ...
		extrn _ucnv_open_56:near
					; CODE XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+402p
		extrn _uprv_free_56:near
					; CODE XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+3DBp
					; _ISO2022Close(UConverter *)+8Fp
		extrn _ucnv_canCreateConverter_56:near
					; CODE XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+3CCp
; size_t __cdecl strlen(const char *Str)
		extrn _strlen:near	; CODE XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+2F1p
; char *__cdecl	strcpy(char *Dest, const char *Source)
		extrn _strcpy:near	; CODE XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+2C8p
					; _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+2DFp ...
		extrn _ucnv_loadSharedData_56:near
					; CODE XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+1C2p
					; _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+1EAp ...
; char *__cdecl	_strncpy(char *Dest, const char	*Source, size_t	Count)
		extrn __imp__strncpy:near
					; CODE XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+11Bp
					; DATA XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+11Br
		extrn _uprv_checkValidMemory:near
					; CODE XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+104p
					; _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+468p ...
; void *__cdecl	memset(void *Dst, int Val, size_t Size)
		extrn _memset:near	; CODE XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+D3p
					; _ISO2022Reset(UConverter *,UConverterResetChoice)+38p ...
		extrn _uprv_malloc_56:near
					; CODE XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+42p
; __fastcall _RTC_CheckStackVars(x, x)
		extrn @_RTC_CheckStackVars@8:near
					; CODE XREF: _ISO2022Open(UConverter *,UConverterLoadArgs *,UErrorCode *)+6E1p
					; UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)+CC2p ...
		extrn _ucnv_close_56:near ; CODE XREF: _ISO2022Close(UConverter	*)+75p
		extrn _ucnv_unloadSharedDataIfReady_56:near
					; CODE XREF: _ISO2022Close(UConverter *)+64p
		extrn _ucnv_fromUWriteBytes_56:near
					; CODE XREF: fromUWriteUInt8(UConverter	*,char const *,int,uchar * *,char const	*,int *	*,int,UErrorCode *)+46p
		extrn _ucnv_extSimpleMatchFromU_56:near
					; CODE XREF: MBCS_FROM_UCHAR32_ISO2022(UConverterSharedData *,int,uint *,signed	char,int)+190p
		extrn _ucnv_MBCSSimpleGetNextUChar_56:near
					; CODE XREF: UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+49Ep
					; UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterToUnicodeArgs *,UErrorCode *)+2A9p ...
		extrn _ucnv_MBCSFromUnicodeWithOffsets_56:near
					; CODE XREF: UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC_IBM(UConverterFromUnicodeArgs *,UErrorCode *)+53p
		extrn _ucnv_MBCSToUnicodeWithOffsets_56:near
					; CODE XREF: UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC_IBM(UConverterToUnicodeArgs	*,UErrorCode *)+154p
; void __cdecl __wassert(const wchar_t *Message, const wchar_t *File, unsigned int Line)
		extrn __imp___wassert:near
					; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+490p
					; UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs *,UErrorCode *)+5C7p ...
		extrn __RTC_UninitUse:near
					; CODE XREF: UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs	*,UErrorCode *)+814p
		extrn _ucnv_cbFromUWriteBytes_56:near
					; CODE XREF: _ISO_2022_WriteSub(UConverterFromUnicodeArgs *,int,UErrorCode *)+30Bp
		extrn _ucnv_cbFromUWriteSub_56:near
					; CODE XREF: _ISO_2022_WriteSub(UConverterFromUnicodeArgs *,int,UErrorCode *)+251p
		extrn _ucnv_incrementRefCount_56:near
					; CODE XREF: _ISO_2022_SafeClone(UConverter const *,void *,int *,UErrorCode *)+101p
		extrn _ucnv_safeClone_56:near
					; CODE XREF: _ISO_2022_SafeClone(UConverter const *,void *,int *,UErrorCode *)+A9p
		extrn _ucnv_MBCSGetFilteredUnicodeSetForUnicode_56:near
					; CODE XREF: _ISO_2022_GetUnicodeSet(UConverter	const *,USetAdder const	*,UConverterUnicodeSet,UErrorCode *)+245p


		end
