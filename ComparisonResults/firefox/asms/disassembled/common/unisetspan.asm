;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	3C8D63550E6BC792572CAEF80C51B1FC
; Input	CRC32 :	D3E4B8A8

; File Name   :	D:\compspace\objfiles\firefox\common\unisetspan.obj
; Format      :	COFF (X386MAGIC)
; includelib "msvcprtd"
; includelib "MSVCRTD"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		public ?value@?$integral_constant@_N$0A@@tr1@std@@2_NB
; public: static bool const std::tr1::integral_constant<bool, 0>::value
?value@?$integral_constant@_N$0A@@tr1@std@@2_NB	db 0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		;org 4
		public ?value@?$integral_constant@_N$00@tr1@std@@2_NB
; public: static bool const std::tr1::integral_constant<bool, 1>::value
?value@?$integral_constant@_N$00@tr1@std@@2_NB db 1
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8
		public ?value@?$integral_constant@I$0A@@tr1@std@@2IB
; public: static unsigned int const std::tr1::integral_constant<unsigned int, 0>::value
?value@?$integral_constant@I$0A@@tr1@std@@2IB dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0Ch
		public ?_Rank@?$_Arithmetic_traits@_N@std@@2HB
; public: static int const std::_Arithmetic_traits<bool>::_Rank
?_Rank@?$_Arithmetic_traits@_N@std@@2HB	dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 10h
		public ?_Rank@?$_Arithmetic_traits@D@std@@2HB
; public: static int const std::_Arithmetic_traits<char>::_Rank
?_Rank@?$_Arithmetic_traits@D@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 14h
		public ?_Rank@?$_Arithmetic_traits@C@std@@2HB
; public: static int const std::_Arithmetic_traits<signed char>::_Rank
?_Rank@?$_Arithmetic_traits@C@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 18h
		public ?_Rank@?$_Arithmetic_traits@E@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned char>::_Rank
?_Rank@?$_Arithmetic_traits@E@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1Ch
		public ?_Rank@?$_Arithmetic_traits@F@std@@2HB
; public: static int const std::_Arithmetic_traits<short>::_Rank
?_Rank@?$_Arithmetic_traits@F@std@@2HB dd 3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 20h
		public ?_Rank@?$_Arithmetic_traits@G@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned short>::_Rank
?_Rank@?$_Arithmetic_traits@G@std@@2HB dd 3
					; DATA XREF: .rdata:int	const std::_Locbase<int>::messageso
					; .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::showposo ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 24h
		public ?_Rank@?$_Arithmetic_traits@H@std@@2HB
; public: static int const std::_Arithmetic_traits<int>::_Rank
?_Rank@?$_Arithmetic_traits@H@std@@2HB dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 28h
		public ?_Rank@?$_Arithmetic_traits@I@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned int>::_Rank
?_Rank@?$_Arithmetic_traits@I@std@@2HB dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2Ch
		public ?_Rank@?$_Arithmetic_traits@J@std@@2HB
; public: static int const std::_Arithmetic_traits<long>::_Rank
?_Rank@?$_Arithmetic_traits@J@std@@2HB dd 5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 30h
		public ?_Rank@?$_Arithmetic_traits@K@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned long>::_Rank
?_Rank@?$_Arithmetic_traits@K@std@@2HB dd 5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 34h
		public ?_Rank@?$_Arithmetic_traits@_J@std@@2HB
; public: static int const std::_Arithmetic_traits<__int64>::_Rank
?_Rank@?$_Arithmetic_traits@_J@std@@2HB	dd 6
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 38h
		public ?_Rank@?$_Arithmetic_traits@_K@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned __int64>::_Rank
?_Rank@?$_Arithmetic_traits@_K@std@@2HB	dd 6
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3Ch
		public ?_Rank@?$_Arithmetic_traits@M@std@@2HB
; public: static int const std::_Arithmetic_traits<float>::_Rank
?_Rank@?$_Arithmetic_traits@M@std@@2HB dd 7
					; DATA XREF: .rdata:int	const std::_Locbase<int>::allo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 40h
		public ?_Rank@?$_Arithmetic_traits@N@std@@2HB
; public: static int const std::_Arithmetic_traits<double>::_Rank
?_Rank@?$_Arithmetic_traits@N@std@@2HB dd 8
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::lefto
					; .rdata:std::_Iosb<int>::_Openmode const std::_Iosb<int>::_Nocreateo ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 44h
		public ?_Rank@?$_Arithmetic_traits@O@std@@2HB
; public: static int const std::_Arithmetic_traits<long	double>::_Rank
?_Rank@?$_Arithmetic_traits@O@std@@2HB dd 9
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 48h
		public ?collate@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::collate
?collate@?$_Locbase@H@std@@2HB dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4Ch
		public ?ctype@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::ctype
?ctype@?$_Locbase@H@std@@2HB dd	2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 50h
		public ?monetary@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::monetary
?monetary@?$_Locbase@H@std@@2HB	dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 54h
		public ?numeric@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::numeric
?numeric@?$_Locbase@H@std@@2HB dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 58h
		public ?time@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::time
?time@?$_Locbase@H@std@@2HB dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5Ch
		public ?messages@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::messages
?messages@?$_Locbase@H@std@@2HB	dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 60h
		public ?all@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::all
?all@?$_Locbase@H@std@@2HB dd offset ?_Rank@?$_Arithmetic_traits@M@std@@2HB+3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 64h
		public ?none@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::none
?none@?$_Locbase@H@std@@2HB dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 68h
		public ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::skipws
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6Ch
		public ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::unitbuf
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 70h
		public ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::uppercase
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 74h
		public ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showbase
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 78h
		public ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showpoint
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 7Ch
		public ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showpos
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 80h
		public ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::left
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::righto
					; .rdata:std::_Iosb<int>::_Openmode const std::_Iosb<int>::_Noreplaceo
_rdata		ends			; int const std::_Arithmetic_traits<double>::_Rank

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 84h
		public ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::right
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B	dd offset ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B ; std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::left
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 88h
		public ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::internal
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_FB+5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8Ch
		public ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::dec
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_1FF+1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 90h
		public ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::oct
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_3FF+1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 94h
		public ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::hex
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_800
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 98h
		public ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::scientific
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd	offset loc_FFF+1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 9Ch
		public ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::fixed
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B	dd offset loc_2000
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A0h
		public ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::hexfloat
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_3000
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A4h
		public ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::boolalpha
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_3FFF+1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A8h
		public ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::_Stdio
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_7FFF+1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0ACh
		public ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::adjustfield
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_1BF+1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B0h
		public ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::basefield
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ??_EReplaceable@icu_56@@UAEPAXI@Z	; icu_56::Replaceable::`vector deleting	destructor'(uint)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B4h
		public ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::floatfield
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd	offset loc_3000
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B8h
		public ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::goodbit
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0BCh
		public ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::eofbit
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B	dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C0h
		public ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::failbit
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C4h
		public ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::badbit
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B	dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C8h
		public ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::_Hardfail
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0CCh
		public ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::in
?in@?$_Iosb@H@std@@2W4_Openmode@12@B dd	1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D0h
		public ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::out
?out@?$_Iosb@H@std@@2W4_Openmode@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D4h
		public ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::ate
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D8h
		public ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::app
?app@?$_Iosb@H@std@@2W4_Openmode@12@B dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0DCh
		public ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::trunc
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B	dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E0h
		public ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::_Nocreate
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E4h
		public ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::_Noreplace
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B dd	offset ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B ;	std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::left
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E8h
		public ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::binary
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int	const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0ECh
		public ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::beg
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F0h
		public ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::cur
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F4h
		public ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::end
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	2
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	operator new(unsigned int)
		public ??2@YAPAXI@Z
??2@YAPAXI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp

loc_FB:					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::internalo
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??2@YAPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$TMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$TMZ
		;org 130h
__RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
_rtc$TMZ	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$IMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$IMZ
		;org 134h
__RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
_rtc$IMZ	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 138h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl operator	delete(void *)
		public ??3@YAXPAX@Z
??3@YAXPAX@Z	proc near		; CODE XREF: icu_56::UnicodeMatcher::`scalar deleting destructor'(uint)+37p
					; icu_56::UnicodeMatcher::`vector deleting destructor'(uint)+75p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??3@YAXPAX@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 16Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	icu_56::UMemory::operator new(unsigned int, void *)
		public ??2UMemory@icu_56@@SAPAXIPAX@Z
??2UMemory@icu_56@@SAPAXIPAX@Z proc near

var_C0		= byte ptr -0C0h
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??2UMemory@icu_56@@SAPAXIPAX@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 194h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl icu_56::UMemory::operator delete(void *)
		public ??3UMemory@icu_56@@SAXPAX0@Z
??3UMemory@icu_56@@SAXPAX0@Z proc near

var_C0		= byte ptr -0C0h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??3UMemory@icu_56@@SAXPAX0@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1BCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UMemory	& __thiscall icu_56::UMemory::operator=(class icu_56::UMemory const &)
		public ??4UMemory@icu_56@@QAEAAV01@ABV01@@Z
??4UMemory@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp

loc_1BF:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::adjustfieldo
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4UMemory@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1ECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UObject::UObject(icu_56::UObject *__hidden this)
		public ??0UObject@icu_56@@QAE@XZ
??0UObject@icu_56@@QAE@XZ proc near	; CODE XREF: icu_56::UnicodeFunctor::UnicodeFunctor(void)+26p
					; icu_56::Replaceable::Replaceable(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]

loc_1FF:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::deco
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UObject@icu_56@@6B@	; const	icu_56::UObject::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0UObject@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 224h
		dd offset ??_R4UObject@icu_56@@6B@ ; const icu_56::UObject::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7UObject@icu_56@@6B@
; const	icu_56::UObject::`vftable'
??_7UObject@icu_56@@6B@	dd offset ??_EUObject@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::UObject::UObject(void)+26o
					; icu_56::UObject::UObject(icu_56::UObject const &)+44o
					; icu_56::UObject::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ ;	icu_56::UObject::getDynamicClassID(void)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 230h
		public ??_R4UObject@icu_56@@6B@
; const	icu_56::UObject::`RTTI Complete	Object Locator'
??_R4UObject@icu_56@@6B@ dd 3 dup(0)	; DATA XREF: .rdata:00000224o
		dd offset ??_R0?AVUObject@icu_56@@@8 ; icu_56::UObject `RTTI Type Descriptor'
		dd offset ??_R3UObject@icu_56@@8 ; icu_56::UObject::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 244h
		public ??_R0?AVUObject@icu_56@@@8
; class	icu_56::UObject	`RTTI Type Descriptor'
??_R0?AVUObject@icu_56@@@8 dd offset ??_7type_info@@6B@	; DATA XREF: .rdata$r:0000023Co
					; .rdata$r:icu_56::UObject::`RTTI Base Class Descriptor	at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avuobject@ic	db '.?AVUObject@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 264h
		public ??_R3UObject@icu_56@@8
; icu_56::UObject::`RTTI Class Hierarchy Descriptor'
??_R3UObject@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:00000240o
					; .rdata$r:00000298o
		dd 2
		dd offset ??_R2UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 274h
		public ??_R2UObject@icu_56@@8
; icu_56::UObject::`RTTI Base Class Array'
??_R2UObject@icu_56@@8 dd offset ??_R1A@?0A@EA@UObject@icu_56@@8
					; DATA XREF: .rdata$r:00000270o
					; icu_56::UObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 280h
		public ??_R1A@?0A@EA@UObject@icu_56@@8
; icu_56::UObject::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UObject@icu_56@@8	dd offset ??_R0?AVUObject@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UObject::`RTTI Base Class	Array'o
					; .rdata$r:00000538o ...
					; icu_56::UObject `RTTI	Type Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UObject@icu_56@@8 ; icu_56::UObject::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 29Ch
		public ??_R13?0A@EA@UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Descriptor at (4, -1, 0, 64)'
??_R13?0A@EA@UMemory@icu_56@@8 dd offset ??_R0?AVUMemory@icu_56@@@8
					; DATA XREF: .rdata$r:00000278o
					; .rdata$r:0000053Co ...
					; icu_56::UMemory `RTTI	Type Descriptor'
		dd 0
		dd 4, 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 2B8h
		public ??_R0?AVUMemory@icu_56@@@8
; class	icu_56::UMemory	`RTTI Type Descriptor'
??_R0?AVUMemory@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::UMemory::`RTTI Base Class	Descriptor at (4,-1,0,64)'o
					; .rdata$r:icu_56::UMemory::`RTTI Base Class Descriptor	at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 10h
a_?avumemory@ic	db '.?AVUMemory@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 2D8h
		public ??_R3UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Class Hierarchy Descriptor'
??_R3UMemory@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:000002B4o
					; .rdata$r:00000308o
		dd 1
		dd offset ??_R2UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 2E8h
		public ??_R2UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Array'
??_R2UMemory@icu_56@@8 dd offset ??_R1A@?0A@EA@UMemory@icu_56@@8
					; DATA XREF: .rdata$r:000002E4o
					; icu_56::UMemory::`RTTI Base Class Descriptor at (0,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 2F0h
		public ??_R1A@?0A@EA@UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UMemory@icu_56@@8	dd offset ??_R0?AVUMemory@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UMemory::`RTTI Base Class	Array'o
					; icu_56::UMemory `RTTI	Type Descriptor'
		dd 2 dup(0)
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 30Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UObject::UObject(icu_56::UObject *this, const struct icu_56::UObject *)
		public ??0UObject@icu_56@@QAE@ABV01@@Z
??0UObject@icu_56@@QAE@ABV01@@Z	proc near
					; CODE XREF: icu_56::UnicodeFunctor::UnicodeFunctor(icu_56::UnicodeFunctor const &)+2Ap
					; icu_56::Replaceable::Replaceable(icu_56::Replaceable const &)+2Ap

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jz	short loc_343
		mov	eax, [ebp+arg_0]
		add	eax, 4
		mov	[ebp+var_D0], eax
		jmp	short loc_34D
; ---------------------------------------------------------------------------

loc_343:				; CODE XREF: icu_56::UObject::UObject(icu_56::UObject const &)+27j
		mov	[ebp+var_D0], 0

loc_34D:				; CODE XREF: icu_56::UObject::UObject(icu_56::UObject const &)+35j
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UObject@icu_56@@6B@	; const	icu_56::UObject::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??0UObject@icu_56@@QAE@ABV01@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 364h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UObject	& __thiscall icu_56::UObject::operator=(class icu_56::UObject const &)
		public ??4UObject@icu_56@@QAEAAV01@ABV01@@Z
??4UObject@icu_56@@QAEAAV01@ABV01@@Z proc near
					; CODE XREF: icu_56::UnicodeFunctor::operator=(icu_56::UnicodeFunctor const &)+2Ap
					; icu_56::Replaceable::operator=(icu_56::Replaceable const &)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4UObject@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 394h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UObject::`scalar deleting destructor'(unsigned int)
		public ??_GUObject@icu_56@@UAEPAXI@Z
??_GUObject@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_3D3
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_3D3:				; CODE XREF: icu_56::UObject::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GUObject@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3ECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UObject::`vector deleting destructor'(unsigned int)
		public ??_EUObject@icu_56@@UAEPAXI@Z
??_EUObject@icu_56@@UAEPAXI@Z proc near	; DATA XREF: .rdata:const icu_56::UObject::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]

loc_3FF:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::octo
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_44D
		push	offset ??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	4
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_445
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_445:				; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_46C
; ---------------------------------------------------------------------------

loc_44D:				; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_469
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_469:				; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_46C:				; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EUObject@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 484h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UnicodeFunctor::UnicodeFunctor(icu_56::UnicodeFunctor *__hidden this)
		public ??0UnicodeFunctor@icu_56@@QAE@XZ
??0UnicodeFunctor@icu_56@@QAE@XZ proc near
					; CODE XREF: icu_56::UnicodeFilter::UnicodeFilter(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UnicodeFunctor@icu_56@@6B@ ; const icu_56::UnicodeFunctor::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0UnicodeFunctor@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4D0h
		dd offset ??_R4UnicodeFunctor@icu_56@@6B@ ; const icu_56::UnicodeFunctor::`RTTI	Complete Object	Locator'
;
; Exported entry
;
		public ??_7UnicodeFunctor@icu_56@@6B@
; const	icu_56::UnicodeFunctor::`vftable'
??_7UnicodeFunctor@icu_56@@6B@ dd offset ??_EUnicodeFunctor@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::UnicodeFunctor::UnicodeFunctor(void)+2Eo
					; icu_56::UnicodeFunctor::UnicodeFunctor(icu_56::UnicodeFunctor	const &)+32o
					; icu_56::UnicodeFunctor::`vector deleting destructor'(uint)
		dd offset __purecall
		dd offset __purecall
		dd offset ?toMatcher@UnicodeFunctor@icu_56@@UBEPAVUnicodeMatcher@2@XZ ;	icu_56::UnicodeFunctor::toMatcher(void)
		dd offset ?toReplacer@UnicodeFunctor@icu_56@@UBEPAVUnicodeReplacer@2@XZ	; icu_56::UnicodeFunctor::toReplacer(void)
		dd offset __purecall
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 4ECh
		public ??_R4UnicodeFunctor@icu_56@@6B@
; const	icu_56::UnicodeFunctor::`RTTI Complete Object Locator'
??_R4UnicodeFunctor@icu_56@@6B@	dd 3 dup(0) ; DATA XREF: .rdata:000004D0o
		dd offset ??_R0?AVUnicodeFunctor@icu_56@@@8 ; icu_56::UnicodeFunctor `RTTI Type	Descriptor'
		dd offset ??_R3UnicodeFunctor@icu_56@@8	; icu_56::UnicodeFunctor::`RTTI	Class Hierarchy	Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 500h
		public ??_R0?AVUnicodeFunctor@icu_56@@@8
; class	icu_56::UnicodeFunctor `RTTI Type Descriptor'
??_R0?AVUnicodeFunctor@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:000004F8o
					; .rdata$r:icu_56::UnicodeFunctor::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 8
a_?avunicodefun	db '.?AVUnicodeFunctor@icu_56@@',0
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 524h
		public ??_R3UnicodeFunctor@icu_56@@8
; icu_56::UnicodeFunctor::`RTTI	Class Hierarchy	Descriptor'
??_R3UnicodeFunctor@icu_56@@8 dd 2 dup(0) ; DATA XREF: .rdata$r:000004FCo
					; .rdata$r:0000055Co
		dd 3
		dd offset ??_R2UnicodeFunctor@icu_56@@8	; icu_56::UnicodeFunctor::`RTTI	Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 534h
		public ??_R2UnicodeFunctor@icu_56@@8
; icu_56::UnicodeFunctor::`RTTI	Base Class Array'
??_R2UnicodeFunctor@icu_56@@8 dd offset	??_R1A@?0A@EA@UnicodeFunctor@icu_56@@8
					; DATA XREF: .rdata$r:00000530o
					; icu_56::UnicodeFunctor::`RTTI	Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 544h
		public ??_R1A@?0A@EA@UnicodeFunctor@icu_56@@8
; icu_56::UnicodeFunctor::`RTTI	Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UnicodeFunctor@icu_56@@8 dd offset ??_R0?AVUnicodeFunctor@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UnicodeFunctor::`RTTI Base Class Array'o
					; .rdata$r:00000A18o
					; icu_56::UnicodeFunctor `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UnicodeFunctor@icu_56@@8	; icu_56::UnicodeFunctor::`RTTI	Class Hierarchy	Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 560h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UnicodeFunctor::UnicodeFunctor(icu_56::UnicodeFunctor *this, const struct icu_56::UnicodeFunctor *)
		public ??0UnicodeFunctor@icu_56@@QAE@ABV01@@Z
??0UnicodeFunctor@icu_56@@QAE@ABV01@@Z proc near
					; CODE XREF: icu_56::UnicodeFilter::UnicodeFilter(icu_56::UnicodeFilter	const &)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UObject *
		mov	ecx, [ebp+var_8] ; this
		call	??0UObject@icu_56@@QAE@ABV01@@Z	; icu_56::UObject::UObject(icu_56::UObject const &)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UnicodeFunctor@icu_56@@6B@ ; const icu_56::UnicodeFunctor::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0UnicodeFunctor@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5B4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeFunctor & __thiscall icu_56::UnicodeFunctor::operator=(class icu_56::UnicodeFunctor const &)
		public ??4UnicodeFunctor@icu_56@@QAEAAV01@ABV01@@Z
??4UnicodeFunctor@icu_56@@QAEAAV01@ABV01@@Z proc near
					; CODE XREF: icu_56::UnicodeFilter::operator=(icu_56::UnicodeFilter const &)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??4UObject@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::UObject::operator=(icu_56::UObject const	&)
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4UnicodeFunctor@icu_56@@QAEAAV01@ABV01@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5FCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UnicodeFunctor::`scalar deleting destructor'(unsigned int)
		public ??_GUnicodeFunctor@icu_56@@UAEPAXI@Z
??_GUnicodeFunctor@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1UnicodeFunctor@icu_56@@UAE@XZ ; icu_56::UnicodeFunctor::~UnicodeFunctor(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_63B
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_63B:				; CODE XREF: icu_56::UnicodeFunctor::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GUnicodeFunctor@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 654h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UnicodeFunctor::`vector deleting destructor'(unsigned int)
		public ??_EUnicodeFunctor@icu_56@@UAEPAXI@Z
??_EUnicodeFunctor@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::UnicodeFunctor::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_6B5
		push	offset ??1UnicodeFunctor@icu_56@@UAE@XZ	; icu_56::UnicodeFunctor::~UnicodeFunctor(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	4
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_6AD
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_6AD:				; CODE XREF: icu_56::UnicodeFunctor::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_6D4
; ---------------------------------------------------------------------------

loc_6B5:				; CODE XREF: icu_56::UnicodeFunctor::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1UnicodeFunctor@icu_56@@UAE@XZ ; icu_56::UnicodeFunctor::~UnicodeFunctor(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_6D1
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_6D1:				; CODE XREF: icu_56::UnicodeFunctor::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_6D4:				; CODE XREF: icu_56::UnicodeFunctor::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EUnicodeFunctor@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6ECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UnicodeMatcher::UnicodeMatcher(icu_56::UnicodeMatcher *__hidden this)
		public ??0UnicodeMatcher@icu_56@@QAE@XZ
??0UnicodeMatcher@icu_56@@QAE@XZ proc near
					; CODE XREF: icu_56::UnicodeFilter::UnicodeFilter(void)+31p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UnicodeMatcher@icu_56@@6B@ ; const icu_56::UnicodeMatcher::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0UnicodeMatcher@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 724h
		dd offset ??_R4UnicodeMatcher@icu_56@@6B@ ; const icu_56::UnicodeMatcher::`RTTI	Complete Object	Locator'
;
; Exported entry
;
		public ??_7UnicodeMatcher@icu_56@@6B@
; const	icu_56::UnicodeMatcher::`vftable'
??_7UnicodeMatcher@icu_56@@6B@ dd offset ??_EUnicodeMatcher@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::UnicodeMatcher::UnicodeMatcher(void)+26o
					; icu_56::UnicodeMatcher::UnicodeMatcher(icu_56::UnicodeMatcher	const &)+26o
					; icu_56::UnicodeMatcher::`vector deleting destructor'(uint)
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 73Ch
		public ??_R4UnicodeMatcher@icu_56@@6B@
; const	icu_56::UnicodeMatcher::`RTTI Complete Object Locator'
??_R4UnicodeMatcher@icu_56@@6B@	dd 3 dup(0) ; DATA XREF: .rdata:00000724o
		dd offset ??_R0?AVUnicodeMatcher@icu_56@@@8 ; icu_56::UnicodeMatcher `RTTI Type	Descriptor'
		dd offset ??_R3UnicodeMatcher@icu_56@@8	; icu_56::UnicodeMatcher::`RTTI	Class Hierarchy	Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 750h
		public ??_R0?AVUnicodeMatcher@icu_56@@@8
; class	icu_56::UnicodeMatcher `RTTI Type Descriptor'
??_R0?AVUnicodeMatcher@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:00000748o
					; .rdata$r:icu_56::UnicodeMatcher::`RTTI Base Class Descriptor at (0,-1,0,64)'o ...
					; const	type_info::`vftable'
		align 8
a_?avunicodemat	db '.?AVUnicodeMatcher@icu_56@@',0
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 774h
		public ??_R3UnicodeMatcher@icu_56@@8
; icu_56::UnicodeMatcher::`RTTI	Class Hierarchy	Descriptor'
??_R3UnicodeMatcher@icu_56@@8 dd 2 dup(0) ; DATA XREF: .rdata$r:0000074Co
					; .rdata$r:000007A4o ...
		dd 1
		dd offset ??_R2UnicodeMatcher@icu_56@@8	; icu_56::UnicodeMatcher::`RTTI	Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 784h
		public ??_R2UnicodeMatcher@icu_56@@8
; icu_56::UnicodeMatcher::`RTTI	Base Class Array'
??_R2UnicodeMatcher@icu_56@@8 dd offset	??_R1A@?0A@EA@UnicodeMatcher@icu_56@@8
					; DATA XREF: .rdata$r:00000780o
					; icu_56::UnicodeMatcher::`RTTI	Base Class Descriptor at (0,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 78Ch
		public ??_R1A@?0A@EA@UnicodeMatcher@icu_56@@8
; icu_56::UnicodeMatcher::`RTTI	Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UnicodeMatcher@icu_56@@8 dd offset ??_R0?AVUnicodeMatcher@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UnicodeMatcher::`RTTI Base Class Array'o
					; icu_56::UnicodeMatcher `RTTI Type Descriptor'
		dd 2 dup(0)
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UnicodeMatcher@icu_56@@8	; icu_56::UnicodeMatcher::`RTTI	Class Hierarchy	Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7A8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UnicodeMatcher::UnicodeMatcher(icu_56::UnicodeMatcher *this, const struct icu_56::UnicodeMatcher *)
		public ??0UnicodeMatcher@icu_56@@QAE@ABV01@@Z
??0UnicodeMatcher@icu_56@@QAE@ABV01@@Z proc near
					; CODE XREF: icu_56::UnicodeFilter::UnicodeFilter(icu_56::UnicodeFilter	const &)+5Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UnicodeMatcher@icu_56@@6B@ ; const icu_56::UnicodeMatcher::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??0UnicodeMatcher@icu_56@@QAE@ABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7E0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeMatcher & __thiscall icu_56::UnicodeMatcher::operator=(class icu_56::UnicodeMatcher const &)
		public ??4UnicodeMatcher@icu_56@@QAEAAV01@ABV01@@Z
??4UnicodeMatcher@icu_56@@QAEAAV01@ABV01@@Z proc near
					; CODE XREF: icu_56::UnicodeFilter::operator=(icu_56::UnicodeFilter const &)+5Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx

loc_800:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::hexo
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4UnicodeMatcher@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 810h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UnicodeMatcher::`scalar deleting destructor'(unsigned int)
		public ??_GUnicodeMatcher@icu_56@@UAEPAXI@Z
??_GUnicodeMatcher@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1UnicodeMatcher@icu_56@@UAE@XZ ; icu_56::UnicodeMatcher::~UnicodeMatcher(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_84F
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_84F:				; CODE XREF: icu_56::UnicodeMatcher::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GUnicodeMatcher@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 868h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UnicodeMatcher::`vector deleting destructor'(unsigned int)
		public ??_EUnicodeMatcher@icu_56@@UAEPAXI@Z
??_EUnicodeMatcher@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::UnicodeMatcher::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_8C9
		push	offset ??1UnicodeMatcher@icu_56@@UAE@XZ	; icu_56::UnicodeMatcher::~UnicodeMatcher(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	4
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_8C1
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_V@YAXPAX@Z	; operator delete[](void *)
		add	esp, 4

loc_8C1:				; CODE XREF: icu_56::UnicodeMatcher::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_8E8
; ---------------------------------------------------------------------------

loc_8C9:				; CODE XREF: icu_56::UnicodeMatcher::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1UnicodeMatcher@icu_56@@UAE@XZ ; icu_56::UnicodeMatcher::~UnicodeMatcher(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_8E5
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_8E5:				; CODE XREF: icu_56::UnicodeMatcher::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_8E8:				; CODE XREF: icu_56::UnicodeMatcher::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EUnicodeMatcher@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 900h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl operator	delete[](void *)
		public ??_V@YAXPAX@Z
??_V@YAXPAX@Z	proc near		; CODE XREF: icu_56::UnicodeMatcher::`vector deleting destructor'(uint)+51p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??_V@YAXPAX@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 934h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UnicodeFilter::UnicodeFilter(icu_56::UnicodeFilter *__hidden this)
		public ??0UnicodeFilter@icu_56@@QAE@XZ
??0UnicodeFilter@icu_56@@QAE@XZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??0UnicodeFunctor@icu_56@@QAE@XZ ; icu_56::UnicodeFunctor::UnicodeFunctor(void)
		mov	ecx, [ebp+var_8]
		add	ecx, 4		; this
		call	??0UnicodeMatcher@icu_56@@QAE@XZ ; icu_56::UnicodeMatcher::UnicodeMatcher(void)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UnicodeFilter@icu_56@@6BUnicodeFunctor@1@@ ; const icu_56::UnicodeFilter::`vftable'{for `icu_56::UnicodeFunctor'}
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], offset ??_7UnicodeFilter@icu_56@@6BUnicodeMatcher@1@@ ; const icu_56::UnicodeFilter::`vftable'{for `icu_56::UnicodeMatcher'}
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0UnicodeFilter@icu_56@@QAE@XZ	endp

_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 994h
		dd offset ??_R4UnicodeFilter@icu_56@@6BUnicodeMatcher@1@@ ; const icu_56::UnicodeFilter::`RTTI Complete	Object Locator'{for `icu_56::UnicodeMatcher'}
;
; Exported entry
;
		public ??_7UnicodeFilter@icu_56@@6BUnicodeMatcher@1@@
; const	icu_56::UnicodeFilter::`vftable'{for `icu_56::UnicodeMatcher'}
??_7UnicodeFilter@icu_56@@6BUnicodeMatcher@1@@ dd offset ??_EUnicodeFilter@icu_56@@W3AEPAXI@Z
					; DATA XREF: icu_56::UnicodeFilter::UnicodeFilter(void)+42o
					; icu_56::UnicodeFilter::UnicodeFilter(icu_56::UnicodeFilter const &)+6Bo
					; [thunk]:icu_56::UnicodeFilter::`vector deleting destructor'`adjustor{4}' (uint)
		dd offset ?matches@UnicodeFilter@icu_56@@UAE?AW4UMatchDegree@2@ABVReplaceable@2@AAHHC@Z	; icu_56::UnicodeFilter::matches(icu_56::Replaceable const &,int &,int,signed char)
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 9ACh
		dd offset ??_R4UnicodeFilter@icu_56@@6BUnicodeFunctor@1@@ ; const icu_56::UnicodeFilter::`RTTI Complete	Object Locator'{for `icu_56::UnicodeFunctor'}
;
; Exported entry
;
		public ??_7UnicodeFilter@icu_56@@6BUnicodeFunctor@1@@
; const	icu_56::UnicodeFilter::`vftable'{for `icu_56::UnicodeFunctor'}
??_7UnicodeFilter@icu_56@@6BUnicodeFunctor@1@@ dd offset ??_EUnicodeFilter@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::UnicodeFilter::UnicodeFilter(void)+39o
					; icu_56::UnicodeFilter::UnicodeFilter(icu_56::UnicodeFilter const &)+62o
					; icu_56::UnicodeFilter::`vector deleting destructor'(uint)
		dd offset __purecall
		dd offset __purecall
		dd offset ?toMatcher@UnicodeFilter@icu_56@@UBEPAVUnicodeMatcher@2@XZ ; icu_56::UnicodeFilter::toMatcher(void)
		dd offset ?toReplacer@UnicodeFunctor@icu_56@@UBEPAVUnicodeReplacer@2@XZ	; icu_56::UnicodeFunctor::toReplacer(void)
		dd offset ?setData@UnicodeFilter@icu_56@@UAEXPBVTransliterationRuleData@2@@Z ; icu_56::UnicodeFilter::setData(icu_56::TransliterationRuleData const *)
		dd offset __purecall
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9CCh
		public ??_R4UnicodeFilter@icu_56@@6BUnicodeFunctor@1@@
; const	icu_56::UnicodeFilter::`RTTI Complete Object Locator'{for `icu_56::UnicodeFunctor'}
??_R4UnicodeFilter@icu_56@@6BUnicodeFunctor@1@@	dd 3 dup(0) ; DATA XREF: .rdata:000009ACo
		dd offset ??_R0?AVUnicodeFilter@icu_56@@@8 ; icu_56::UnicodeFilter `RTTI Type Descriptor'
		dd offset ??_R3UnicodeFilter@icu_56@@8 ; icu_56::UnicodeFilter::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 9E0h
		public ??_R0?AVUnicodeFilter@icu_56@@@8
; class	icu_56::UnicodeFilter `RTTI Type Descriptor'
??_R0?AVUnicodeFilter@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:000009D8o
					; .rdata$r:icu_56::UnicodeFilter::`RTTI	Base Class Descriptor at (0,-1,0,64)'o ...
					; const	type_info::`vftable'
		align 8
a_?avunicodefil	db '.?AVUnicodeFilter@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0A04h
		public ??_R3UnicodeFilter@icu_56@@8
; icu_56::UnicodeFilter::`RTTI Class Hierarchy Descriptor'
??_R3UnicodeFilter@icu_56@@8 dd	0	; DATA XREF: .rdata$r:000009DCo
					; .rdata$r:00000A44o ...
		dd 1, 5
		dd offset ??_R2UnicodeFilter@icu_56@@8 ; icu_56::UnicodeFilter::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0A14h
		public ??_R2UnicodeFilter@icu_56@@8
; icu_56::UnicodeFilter::`RTTI Base Class Array'
??_R2UnicodeFilter@icu_56@@8 dd	offset ??_R1A@?0A@EA@UnicodeFilter@icu_56@@8
					; DATA XREF: .rdata$r:00000A10o
					; icu_56::UnicodeFilter::`RTTI Base Class Descriptor at	(0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UnicodeFunctor@icu_56@@8 ; icu_56::UnicodeFunctor::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		dd offset ??_R13?0A@EA@UnicodeMatcher@icu_56@@8	; icu_56::UnicodeMatcher::`RTTI	Base Class Descriptor at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0A2Ch
		public ??_R1A@?0A@EA@UnicodeFilter@icu_56@@8
; icu_56::UnicodeFilter::`RTTI Base Class Descriptor at	(0, -1,	0, 64)'
??_R1A@?0A@EA@UnicodeFilter@icu_56@@8 dd offset	??_R0?AVUnicodeFilter@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UnicodeFilter::`RTTI Base	Class Array'o
					; icu_56::UnicodeFilter	`RTTI Type Descriptor'
		dd 4, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UnicodeFilter@icu_56@@8 ; icu_56::UnicodeFilter::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0A48h
		public ??_R13?0A@EA@UnicodeMatcher@icu_56@@8
; icu_56::UnicodeMatcher::`RTTI	Base Class Descriptor at (4, -1, 0, 64)'
??_R13?0A@EA@UnicodeMatcher@icu_56@@8 dd offset	??_R0?AVUnicodeMatcher@icu_56@@@8
					; DATA XREF: .rdata$r:00000A24o
					; icu_56::UnicodeMatcher `RTTI Type Descriptor'
		align 10h
		dd 4, 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UnicodeMatcher@icu_56@@8	; icu_56::UnicodeMatcher::`RTTI	Class Hierarchy	Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0A64h
		public ??_R4UnicodeFilter@icu_56@@6BUnicodeMatcher@1@@
; const	icu_56::UnicodeFilter::`RTTI Complete Object Locator'{for `icu_56::UnicodeMatcher'}
??_R4UnicodeFilter@icu_56@@6BUnicodeMatcher@1@@	dd 0 ; DATA XREF: .rdata:00000994o
		dd 4, 0
		dd offset ??_R0?AVUnicodeFilter@icu_56@@@8 ; icu_56::UnicodeFilter `RTTI Type Descriptor'
		dd offset ??_R3UnicodeFilter@icu_56@@8 ; icu_56::UnicodeFilter::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A78h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UnicodeFilter::UnicodeFilter(icu_56::UnicodeFilter *this, const struct icu_56::UnicodeFilter *)
		public ??0UnicodeFilter@icu_56@@QAE@ABV01@@Z
??0UnicodeFilter@icu_56@@QAE@ABV01@@Z proc near

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeFunctor	*
		mov	ecx, [ebp+var_8] ; this
		call	??0UnicodeFunctor@icu_56@@QAE@ABV01@@Z ; icu_56::UnicodeFunctor::UnicodeFunctor(icu_56::UnicodeFunctor const &)
		cmp	[ebp+arg_0], 0
		jz	short loc_ABB
		mov	eax, [ebp+arg_0]
		add	eax, 4
		mov	[ebp+var_D0], eax
		jmp	short loc_AC5
; ---------------------------------------------------------------------------

loc_ABB:				; CODE XREF: icu_56::UnicodeFilter::UnicodeFilter(icu_56::UnicodeFilter	const &)+33j
		mov	[ebp+var_D0], 0

loc_AC5:				; CODE XREF: icu_56::UnicodeFilter::UnicodeFilter(icu_56::UnicodeFilter	const &)+41j
		mov	ecx, [ebp+var_D0]
		push	ecx		; struct icu_56::UnicodeMatcher	*
		mov	ecx, [ebp+var_8]
		add	ecx, 4		; this
		call	??0UnicodeMatcher@icu_56@@QAE@ABV01@@Z ; icu_56::UnicodeMatcher::UnicodeMatcher(icu_56::UnicodeMatcher const &)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UnicodeFilter@icu_56@@6BUnicodeFunctor@1@@ ; const icu_56::UnicodeFilter::`vftable'{for `icu_56::UnicodeFunctor'}
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], offset ??_7UnicodeFilter@icu_56@@6BUnicodeMatcher@1@@ ; const icu_56::UnicodeFilter::`vftable'{for `icu_56::UnicodeMatcher'}
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0UnicodeFilter@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B04h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeFilter &	__thiscall icu_56::UnicodeFilter::operator=(class icu_56::UnicodeFilter	const &)
		public ??4UnicodeFilter@icu_56@@QAEAAV01@ABV01@@Z
??4UnicodeFilter@icu_56@@QAEAAV01@ABV01@@Z proc	near

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??4UnicodeFunctor@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::UnicodeFunctor::operator=(icu_56::UnicodeFunctor const &)
		cmp	[ebp+arg_0], 0
		jz	short loc_B47
		mov	eax, [ebp+arg_0]
		add	eax, 4
		mov	[ebp+var_D0], eax
		jmp	short loc_B51
; ---------------------------------------------------------------------------

loc_B47:				; CODE XREF: icu_56::UnicodeFilter::operator=(icu_56::UnicodeFilter const &)+33j
		mov	[ebp+var_D0], 0

loc_B51:				; CODE XREF: icu_56::UnicodeFilter::operator=(icu_56::UnicodeFilter const &)+41j
		mov	ecx, [ebp+var_D0]
		push	ecx
		mov	ecx, [ebp+var_8]
		add	ecx, 4
		call	??4UnicodeMatcher@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::UnicodeMatcher::operator=(icu_56::UnicodeMatcher const &)
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4UnicodeFilter@icu_56@@QAEAAV01@ABV01@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B7Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UnicodeFilter::`scalar deleting destructor'(unsigned int)
		public ??_GUnicodeFilter@icu_56@@UAEPAXI@Z
??_GUnicodeFilter@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1UnicodeFilter@icu_56@@UAE@XZ	; icu_56::UnicodeFilter::~UnicodeFilter(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_BBB
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_BBB:				; CODE XREF: icu_56::UnicodeFilter::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GUnicodeFilter@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0BD4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UnicodeFilter::`vector deleting destructor'(unsigned int)
		public ??_EUnicodeFilter@icu_56@@UAEPAXI@Z
??_EUnicodeFilter@icu_56@@UAEPAXI@Z proc near
					; CODE XREF: [thunk]:icu_56::UnicodeFilter::`vector deleting destructor'`adjustor{4}' (uint)+3j
					; DATA XREF: .rdata:const icu_56::UnicodeFilter::`vftable'{for `icu_56::UnicodeFunctor'}o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_C35
		push	offset ??1UnicodeFilter@icu_56@@UAE@XZ ; icu_56::UnicodeFilter::~UnicodeFilter(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	8
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_C2D
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_C2D:				; CODE XREF: icu_56::UnicodeFilter::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_C54
; ---------------------------------------------------------------------------

loc_C35:				; CODE XREF: icu_56::UnicodeFilter::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1UnicodeFilter@icu_56@@UAE@XZ	; icu_56::UnicodeFilter::~UnicodeFilter(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_C51
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_C51:				; CODE XREF: icu_56::UnicodeFilter::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_C54:				; CODE XREF: icu_56::UnicodeFilter::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EUnicodeFilter@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C6Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::Replaceable::Replaceable(icu_56::Replaceable *this,	const struct icu_56::Replaceable *)
		public ??0Replaceable@icu_56@@QAE@ABV01@@Z
??0Replaceable@icu_56@@QAE@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UObject *
		mov	ecx, [ebp+var_8] ; this
		call	??0UObject@icu_56@@QAE@ABV01@@Z	; icu_56::UObject::UObject(icu_56::UObject const &)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7Replaceable@icu_56@@6B@ ; const icu_56::Replaceable::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0Replaceable@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0CC0h
		dd offset ??_R4Replaceable@icu_56@@6B@ ; const icu_56::Replaceable::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7Replaceable@icu_56@@6B@
; const	icu_56::Replaceable::`vftable'
??_7Replaceable@icu_56@@6B@ dd offset ??_EReplaceable@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::Replaceable::Replaceable(icu_56::Replaceable const	&)+32o
					; icu_56::Replaceable::Replaceable(void)+2Eo
					; icu_56::Replaceable::`vector deleting	destructor'(uint)
		dd offset ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ ;	icu_56::UObject::getDynamicClassID(void)
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
		dd offset ?hasMetaData@Replaceable@icu_56@@UBECXZ ; icu_56::Replaceable::hasMetaData(void)
		dd offset ?clone@Replaceable@icu_56@@UBEPAV12@XZ ; icu_56::Replaceable::clone(void)
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0CECh
		public ??_R4Replaceable@icu_56@@6B@
; const	icu_56::Replaceable::`RTTI Complete Object Locator'
??_R4Replaceable@icu_56@@6B@ dd	3 dup(0) ; DATA	XREF: .rdata:00000CC0o
		dd offset ??_R0?AVReplaceable@icu_56@@@8 ; icu_56::Replaceable `RTTI Type Descriptor'
		dd offset ??_R3Replaceable@icu_56@@8 ; icu_56::Replaceable::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 0D00h
		public ??_R0?AVReplaceable@icu_56@@@8
; class	icu_56::Replaceable `RTTI Type Descriptor'
??_R0?AVReplaceable@icu_56@@@8 dd offset ??_7type_info@@6B@ ; DATA XREF: .rdata$r:00000CF8o
					; .rdata$r:icu_56::Replaceable::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 8
a_?avreplaceabl	db '.?AVReplaceable@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0D24h
		public ??_R3Replaceable@icu_56@@8
; icu_56::Replaceable::`RTTI Class Hierarchy Descriptor'
??_R3Replaceable@icu_56@@8 dd 2	dup(0)	; DATA XREF: .rdata$r:00000CFCo
					; .rdata$r:00000D5Co
		dd 3
		dd offset ??_R2Replaceable@icu_56@@8 ; icu_56::Replaceable::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0D34h
		public ??_R2Replaceable@icu_56@@8
; icu_56::Replaceable::`RTTI Base Class	Array'
??_R2Replaceable@icu_56@@8 dd offset ??_R1A@?0A@EA@Replaceable@icu_56@@8
					; DATA XREF: .rdata$r:00000D30o
					; icu_56::Replaceable::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0D44h
		public ??_R1A@?0A@EA@Replaceable@icu_56@@8
; icu_56::Replaceable::`RTTI Base Class	Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@Replaceable@icu_56@@8 dd offset ??_R0?AVReplaceable@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::Replaceable::`RTTI Base Class Array'o
					; .rdata$r:00001974o
					; icu_56::Replaceable `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3Replaceable@icu_56@@8 ; icu_56::Replaceable::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D60h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::Replaceable & __thiscall icu_56::Replaceable::operator=(class icu_56::Replaceable const	&)
		public ??4Replaceable@icu_56@@QAEAAV01@ABV01@@Z
??4Replaceable@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??4UObject@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::UObject::operator=(icu_56::UObject const	&)
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4Replaceable@icu_56@@QAEAAV01@ABV01@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0DA8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::Replaceable::`scalar deleting destructor'(unsigned int)
		public ??_GReplaceable@icu_56@@UAEPAXI@Z
??_GReplaceable@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1Replaceable@icu_56@@UAE@XZ ;	icu_56::Replaceable::~Replaceable(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_DE7
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_DE7:				; CODE XREF: icu_56::Replaceable::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GReplaceable@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0E00h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::Replaceable::`vector deleting destructor'(unsigned int)
		public ??_EReplaceable@icu_56@@UAEPAXI@Z
??_EReplaceable@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::basefieldo
					; .rdata:const icu_56::Replaceable::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_E61
		push	offset ??1Replaceable@icu_56@@UAE@XZ ; icu_56::Replaceable::~Replaceable(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	4
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_E59
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_E59:				; CODE XREF: icu_56::Replaceable::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_E80
; ---------------------------------------------------------------------------

loc_E61:				; CODE XREF: icu_56::Replaceable::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1Replaceable@icu_56@@UAE@XZ ;	icu_56::Replaceable::~Replaceable(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_E7D
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_E7D:				; CODE XREF: icu_56::Replaceable::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_E80:				; CODE XREF: icu_56::Replaceable::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EReplaceable@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0E98h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::Replaceable::Replaceable(icu_56::Replaceable *__hidden this)
		public ??0Replaceable@icu_56@@IAE@XZ
??0Replaceable@icu_56@@IAE@XZ proc near	; CODE XREF: icu_56::UnicodeString::UnicodeString(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7Replaceable@icu_56@@6B@ ; const icu_56::Replaceable::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0Replaceable@icu_56@@IAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0EE4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::Replaceable::length(icu_56::Replaceable *__hidden this)
		public ?length@Replaceable@icu_56@@QBEHXZ
?length@Replaceable@icu_56@@QBEHXZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+1Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?length@Replaceable@icu_56@@QBEHXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0F34h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; wchar_t __thiscall icu_56::Replaceable::charAt(icu_56::Replaceable *this, int)
		public ?charAt@Replaceable@icu_56@@QBE_WH@Z
?charAt@Replaceable@icu_56@@QBE_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+20h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?charAt@Replaceable@icu_56@@QBE_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0F88h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::Replaceable::char32At(icu_56::Replaceable *this, int)
		public ?char32At@Replaceable@icu_56@@QBEHH@Z
?char32At@Replaceable@icu_56@@QBEHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+24h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?char32At@Replaceable@icu_56@@QBEHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0FDCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::StringPiece::StringPiece(icu_56::StringPiece *__hidden this)
		public ??0StringPiece@icu_56@@QAE@XZ
??0StringPiece@icu_56@@QAE@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx

loc_FFF:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::scientifico
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0StringPiece@icu_56@@QAE@XZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 101Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::StringPiece::StringPiece(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &)
		public ??0StringPiece@icu_56@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
??0StringPiece@icu_56@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0]
		call	?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::data(void)
		mov	ecx, [ebp+var_8]
		mov	[ecx], eax
		mov	ecx, [ebp+arg_0]
		call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
		mov	ecx, [ebp+var_8]
		mov	[ecx+4], eax
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0StringPiece@icu_56@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1074h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::StringPiece::StringPiece(icu_56::StringPiece *this,	const char *, int)
		public ??0StringPiece@icu_56@@QAE@PBDH@Z
??0StringPiece@icu_56@@QAE@PBDH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		mov	[eax+4], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	8
??0StringPiece@icu_56@@QAE@PBDH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 10B4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	char *__thiscall icu_56::StringPiece::data(icu_56::StringPiece *__hidden this)
		public ?data@StringPiece@icu_56@@QBEPBDXZ
?data@StringPiece@icu_56@@QBEPBDXZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?data@StringPiece@icu_56@@QBEPBDXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 10E4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::StringPiece::size(icu_56::StringPiece *__hidden this)
		public ?size@StringPiece@icu_56@@QBEHXZ
?size@StringPiece@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?size@StringPiece@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1114h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::StringPiece::length(icu_56::StringPiece *__hidden this)
		public ?length@StringPiece@icu_56@@QBEHXZ
?length@StringPiece@icu_56@@QBEHXZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?length@StringPiece@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1144h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::StringPiece::empty(icu_56::StringPiece *__hidden this)
		public ?empty@StringPiece@icu_56@@QBECXZ
?empty@StringPiece@icu_56@@QBECXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4], 0
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?empty@StringPiece@icu_56@@QBECXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1178h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::StringPiece::clear(icu_56::StringPiece *__hidden this)
		public ?clear@StringPiece@icu_56@@QAEXXZ
?clear@StringPiece@icu_56@@QAEXXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?clear@StringPiece@icu_56@@QAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 11B8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::StringPiece::set(icu_56::StringPiece *this, const char *, int)
		public ?set@StringPiece@icu_56@@QAEXPBDH@Z
?set@StringPiece@icu_56@@QAEXPBDH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		mov	[eax+4], ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	8
?set@StringPiece@icu_56@@QAEXPBDH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 11F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::StringPiece::remove_prefix(icu_56::StringPiece *this,	int)
		public ?remove_prefix@StringPiece@icu_56@@QAEXH@Z
?remove_prefix@StringPiece@icu_56@@QAEXH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jl	short loc_1251
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		cmp	ecx, [eax+4]
		jle	short loc_1235
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	[ebp+arg_0], ecx

loc_1235:				; CODE XREF: icu_56::StringPiece::remove_prefix(int)+32j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		add	ecx, [ebp+arg_0]
		mov	edx, [ebp+var_8]
		mov	[edx], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		sub	ecx, [ebp+arg_0]
		mov	edx, [ebp+var_8]
		mov	[edx+4], ecx

loc_1251:				; CODE XREF: icu_56::StringPiece::remove_prefix(int)+27j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?remove_prefix@StringPiece@icu_56@@QAEXH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 125Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::StringPiece::remove_suffix(icu_56::StringPiece *this,	int)
		public ?remove_suffix@StringPiece@icu_56@@QAEXH@Z
?remove_suffix@StringPiece@icu_56@@QAEXH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jl	short loc_12AB
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		cmp	ecx, [eax+4]
		jg	short loc_12A1
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		sub	ecx, [ebp+arg_0]
		mov	edx, [ebp+var_8]
		mov	[edx+4], ecx
		jmp	short loc_12AB
; ---------------------------------------------------------------------------

loc_12A1:				; CODE XREF: icu_56::StringPiece::remove_suffix(int)+32j
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0

loc_12AB:				; CODE XREF: icu_56::StringPiece::remove_suffix(int)+27j
					; icu_56::StringPiece::remove_suffix(int)+43j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?remove_suffix@StringPiece@icu_56@@QAEXH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 12B4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::StringPiece __thiscall icu_56::StringPiece::substr(int,	int)const
		public ?substr@StringPiece@icu_56@@QBE?AV12@HH@Z
?substr@StringPiece@icu_56@@QBE?AV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+var_8]
		push	edx		; struct icu_56::StringPiece *
		mov	ecx, [ebp+arg_0] ; this
		call	??0StringPiece@icu_56@@QAE@ABV01@HH@Z ;	icu_56::StringPiece::StringPiece(icu_56::StringPiece const &,int,int)
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?substr@StringPiece@icu_56@@QBE?AV12@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1304h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::StringPiece & __thiscall icu_56::StringPiece::operator=(class icu_56::StringPiece const	&)
		public ??4StringPiece@icu_56@@QAEAAV01@ABV01@@Z
??4StringPiece@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [eax+4]
		mov	eax, [ebp+var_8]
		mov	[eax], ecx
		mov	[eax+4], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4StringPiece@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1344h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::ByteSink::ByteSink(icu_56::ByteSink	*__hidden this)
		public ??0ByteSink@icu_56@@QAE@XZ
??0ByteSink@icu_56@@QAE@XZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7ByteSink@icu_56@@6B@ ; const icu_56::ByteSink::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0ByteSink@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 137Ch
		dd offset ??_R4ByteSink@icu_56@@6B@ ; const icu_56::ByteSink::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7ByteSink@icu_56@@6B@
; const	icu_56::ByteSink::`vftable'
??_7ByteSink@icu_56@@6B@ dd offset ??_EByteSink@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::ByteSink::ByteSink(void)+26o
					; icu_56::ByteSink::`vector deleting destructor'(uint)
		dd offset __purecall
		dd offset ?GetAppendBuffer@ByteSink@icu_56@@UAEPADHHPADHPAH@Z ;	icu_56::ByteSink::GetAppendBuffer(int,int,char *,int,int *)
		dd offset ?Flush@ByteSink@icu_56@@UAEXXZ ; icu_56::ByteSink::Flush(void)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1390h
		public ??_R4ByteSink@icu_56@@6B@
; const	icu_56::ByteSink::`RTTI	Complete Object	Locator'
??_R4ByteSink@icu_56@@6B@ dd 3 dup(0)	; DATA XREF: .rdata:0000137Co
		dd offset ??_R0?AVByteSink@icu_56@@@8 ;	icu_56::ByteSink `RTTI Type Descriptor'
		dd offset ??_R3ByteSink@icu_56@@8 ; icu_56::ByteSink::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 13A4h
		public ??_R0?AVByteSink@icu_56@@@8
; class	icu_56::ByteSink `RTTI Type Descriptor'
??_R0?AVByteSink@icu_56@@@8 dd offset ??_7type_info@@6B@ ; DATA	XREF: .rdata$r:0000139Co
					; .rdata$r:icu_56::ByteSink::`RTTI Base	Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avbytesink@i	db '.?AVByteSink@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 13C4h
		public ??_R3ByteSink@icu_56@@8
; icu_56::ByteSink::`RTTI Class	Hierarchy Descriptor'
??_R3ByteSink@icu_56@@8	dd 2 dup(0)	; DATA XREF: .rdata$r:000013A0o
					; .rdata$r:000013F8o
		dd 2
		dd offset ??_R2ByteSink@icu_56@@8 ; icu_56::ByteSink::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 13D4h
		public ??_R2ByteSink@icu_56@@8
; icu_56::ByteSink::`RTTI Base Class Array'
??_R2ByteSink@icu_56@@8	dd offset ??_R1A@?0A@EA@ByteSink@icu_56@@8
					; DATA XREF: .rdata$r:000013D0o
					; icu_56::ByteSink::`RTTI Base Class Descriptor	at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 13E0h
		public ??_R1A@?0A@EA@ByteSink@icu_56@@8
; icu_56::ByteSink::`RTTI Base Class Descriptor	at (0, -1, 0, 64)'
??_R1A@?0A@EA@ByteSink@icu_56@@8 dd offset ??_R0?AVByteSink@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::ByteSink::`RTTI Base Class Array'o
					; icu_56::ByteSink `RTTI Type Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3ByteSink@icu_56@@8 ; icu_56::ByteSink::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 13FCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::ByteSink::`scalar deleting destructor'(unsigned int)
		public ??_GByteSink@icu_56@@UAEPAXI@Z
??_GByteSink@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1ByteSink@icu_56@@UAE@XZ ; icu_56::ByteSink::~ByteSink(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_143B
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_143B:				; CODE XREF: icu_56::ByteSink::`scalar deleting	destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GByteSink@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1454h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::ByteSink::`vector deleting destructor'(unsigned int)
		public ??_EByteSink@icu_56@@UAEPAXI@Z
??_EByteSink@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::ByteSink::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_14B5
		push	offset ??1ByteSink@icu_56@@UAE@XZ ; icu_56::ByteSink::~ByteSink(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	4
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_14AD
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_14AD:				; CODE XREF: icu_56::ByteSink::`vector deleting	destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_14D4
; ---------------------------------------------------------------------------

loc_14B5:				; CODE XREF: icu_56::ByteSink::`vector deleting	destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1ByteSink@icu_56@@UAE@XZ ; icu_56::ByteSink::~ByteSink(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_14D1
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_14D1:				; CODE XREF: icu_56::ByteSink::`vector deleting	destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_14D4:				; CODE XREF: icu_56::ByteSink::`vector deleting	destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EByteSink@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 14ECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::CheckedArrayByteSink::NumberOfBytesWritten(icu_56::CheckedArrayByteSink *__hidden this)
		public ?NumberOfBytesWritten@CheckedArrayByteSink@icu_56@@QBEHXZ
?NumberOfBytesWritten@CheckedArrayByteSink@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+0Ch]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?NumberOfBytesWritten@CheckedArrayByteSink@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 151Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::CheckedArrayByteSink::Overflowed(icu_56::CheckedArrayByteSink *__hidden this)
		public ?Overflowed@CheckedArrayByteSink@icu_56@@QBECXZ
?Overflowed@CheckedArrayByteSink@icu_56@@QBECXZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	al, [eax+14h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?Overflowed@CheckedArrayByteSink@icu_56@@QBECXZ	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 154Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::CheckedArrayByteSink::NumberOfBytesAppended(icu_56::CheckedArrayByteSink *__hidden this)
		public ?NumberOfBytesAppended@CheckedArrayByteSink@icu_56@@QBEHXZ
?NumberOfBytesAppended@CheckedArrayByteSink@icu_56@@QBEHXZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+10h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?NumberOfBytesAppended@CheckedArrayByteSink@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 157Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator=(struct	icu_56::UnicodeString *)
		public ??4UnicodeString@icu_56@@QAEAAV01@$$QAV01@@Z
??4UnicodeString@icu_56@@QAEAAV01@$$QAV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?moveFrom@UnicodeString@icu_56@@QAEAAV12@AAV12@@Z ; icu_56::UnicodeString::moveFrom(icu_56::UnicodeString &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4UnicodeString@icu_56@@QAEAAV01@$$QAV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 15C4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl icu_56::swap(icu_56 *this, struct icu_56::UnicodeString *, struct icu_56::UnicodeString *)
		public ?swap@icu_56@@YAXAAVUnicodeString@1@0@Z
?swap@icu_56@@YAXAAVUnicodeString@1@0@Z	proc near

var_C0		= byte ptr -0C0h
this		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+this]	; this
		call	?swap@UnicodeString@icu_56@@QAEXAAV12@@Z ; icu_56::UnicodeString::swap(icu_56::UnicodeString &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?swap@icu_56@@YAXAAVUnicodeString@1@0@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1604h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UnicodeString::`scalar deleting destructor'(unsigned int)
		public ??_GUnicodeString@icu_56@@UAEPAXI@Z
??_GUnicodeString@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_1643
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_1643:				; CODE XREF: icu_56::UnicodeString::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GUnicodeString@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 165Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UnicodeString::`vector deleting destructor'(unsigned int)
		public ??_EUnicodeString@icu_56@@UAEPAXI@Z
??_EUnicodeString@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::UnicodeString::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_16BD
		push	offset ??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	40h ; '@'
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_16B5
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_16B5:				; CODE XREF: icu_56::UnicodeString::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_16DC
; ---------------------------------------------------------------------------

loc_16BD:				; CODE XREF: icu_56::UnicodeString::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_16D9
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_16D9:				; CODE XREF: icu_56::UnicodeString::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_16DC:				; CODE XREF: icu_56::UnicodeString::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EUnicodeString@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 16F4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::pinIndex(icu_56::UnicodeString	*this, int *)
		public ?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z
?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z proc near
					; CODE XREF: icu_56::UnicodeString::indexOf(icu_56::UnicodeString const	&,int)+2Ap
					; icu_56::UnicodeString::indexOf(wchar_t const *,int,int)+2Ap ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax], 0
		jge	short loc_172A
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 0
		jmp	short loc_1746
; ---------------------------------------------------------------------------

loc_172A:				; CODE XREF: icu_56::UnicodeString::pinIndex(int &)+29j
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	ecx, [ebp+arg_0]
		cmp	[ecx], eax
		jle	short loc_1746
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	ecx, [ebp+arg_0]
		mov	[ecx], eax

loc_1746:				; CODE XREF: icu_56::UnicodeString::pinIndex(int &)+34j
					; icu_56::UnicodeString::pinIndex(int &)+43j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 175Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::pinIndices(icu_56::UnicodeString *this, int *,	int *)
		public ?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z
?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z proc near
					; CODE XREF: icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+51p
					; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)+51p ...

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax], 0
		jge	short loc_179D
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 0
		jmp	short loc_17AF
; ---------------------------------------------------------------------------

loc_179D:				; CODE XREF: icu_56::UnicodeString::pinIndices(int &,int &)+34j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		cmp	ecx, [ebp+var_14]
		jle	short loc_17AF
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		mov	[eax], ecx

loc_17AF:				; CODE XREF: icu_56::UnicodeString::pinIndices(int &,int &)+3Fj
					; icu_56::UnicodeString::pinIndices(int	&,int &)+49j
		mov	eax, [ebp+arg_4]
		cmp	dword ptr [eax], 0
		jge	short loc_17C2
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0
		jmp	short loc_17DE
; ---------------------------------------------------------------------------

loc_17C2:				; CODE XREF: icu_56::UnicodeString::pinIndices(int &,int &)+59j
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		sub	ecx, [eax]
		mov	edx, [ebp+arg_4]
		cmp	[edx], ecx
		jle	short loc_17DE
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		sub	ecx, [eax]
		mov	edx, [ebp+arg_4]
		mov	[edx], ecx

loc_17DE:				; CODE XREF: icu_56::UnicodeString::pinIndices(int &,int &)+64j
					; icu_56::UnicodeString::pinIndices(int	&,int &)+73j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 17F4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; wchar_t *__thiscall icu_56::UnicodeString::getArrayStart(icu_56::UnicodeString *__hidden this)
		public ?getArrayStart@UnicodeString@icu_56@@AAEPA_WXZ
?getArrayStart@UnicodeString@icu_56@@AAEPA_WXZ proc near

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 2
		jz	short loc_1831
		mov	edx, [ebp+var_8]
		add	edx, 6
		mov	[ebp+var_D0], edx
		jmp	short loc_183D
; ---------------------------------------------------------------------------

loc_1831:				; CODE XREF: icu_56::UnicodeString::getArrayStart(void)+2Dj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	[ebp+var_D0], ecx

loc_183D:				; CODE XREF: icu_56::UnicodeString::getArrayStart(void)+3Bj
		mov	eax, [ebp+var_D0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getArrayStart@UnicodeString@icu_56@@AAEPA_WXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 184Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	wchar_t	*__thiscall icu_56::UnicodeString::getArrayStart(icu_56::UnicodeString *__hidden this)
		public ?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ
?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ proc near
					; CODE XREF: icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+61p
					; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)+61p ...

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 2
		jz	short loc_1889
		mov	edx, [ebp+var_8]
		add	edx, 6
		mov	[ebp+var_D0], edx
		jmp	short loc_1895
; ---------------------------------------------------------------------------

loc_1889:				; CODE XREF: icu_56::UnicodeString::getArrayStart(void)+2Dj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	[ebp+var_D0], ecx

loc_1895:				; CODE XREF: icu_56::UnicodeString::getArrayStart(void)+3Bj
		mov	eax, [ebp+var_D0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 18A4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString *__hidden this)
		public ??0UnicodeString@icu_56@@QAE@XZ
??0UnicodeString@icu_56@@QAE@XZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??0Replaceable@icu_56@@IAE@XZ ;	icu_56::Replaceable::Replaceable(void)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UnicodeString@icu_56@@6B@ ;	const icu_56::UnicodeString::`vftable'
		mov	eax, 2
		mov	ecx, [ebp+var_8]
		mov	[ecx+4], ax
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0UnicodeString@icu_56@@QAE@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 18FCh
		dd offset ??_R4UnicodeString@icu_56@@6B@ ; const icu_56::UnicodeString::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7UnicodeString@icu_56@@6B@
; const	icu_56::UnicodeString::`vftable'
??_7UnicodeString@icu_56@@6B@ dd offset	??_EUnicodeString@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::UnicodeString::UnicodeString(void)+2Eo
					; icu_56::UnicodeString::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@UnicodeString@icu_56@@UBEPAXXZ ; icu_56::UnicodeString::getDynamicClassID(void)
		dd offset ?extractBetween@UnicodeString@icu_56@@UBEXHHAAV12@@Z ; icu_56::UnicodeString::extractBetween(int,int,icu_56::UnicodeString &)
		dd offset ?handleReplaceBetween@UnicodeString@icu_56@@UAEXHHABV12@@Z ; icu_56::UnicodeString::handleReplaceBetween(int,int,icu_56::UnicodeString const &)
		dd offset ?copy@UnicodeString@icu_56@@UAEXHHH@Z	; icu_56::UnicodeString::copy(int,int,int)
		dd offset ?hasMetaData@UnicodeString@icu_56@@UBECXZ ; icu_56::UnicodeString::hasMetaData(void)
		dd offset ?clone@UnicodeString@icu_56@@UBEPAVReplaceable@2@XZ ;	icu_56::UnicodeString::clone(void)
		dd offset ?getLength@UnicodeString@icu_56@@MBEHXZ ; icu_56::UnicodeString::getLength(void)
		dd offset ?getCharAt@UnicodeString@icu_56@@MBE_WH@Z ; icu_56::UnicodeString::getCharAt(int)
		dd offset ?getChar32At@UnicodeString@icu_56@@MBEHH@Z ; icu_56::UnicodeString::getChar32At(int)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1928h
		public ??_R4UnicodeString@icu_56@@6B@
; const	icu_56::UnicodeString::`RTTI Complete Object Locator'
??_R4UnicodeString@icu_56@@6B@ dd 3 dup(0) ; DATA XREF:	.rdata:000018FCo
		dd offset ??_R0?AVUnicodeString@icu_56@@@8 ; icu_56::UnicodeString `RTTI Type Descriptor'
		dd offset ??_R3UnicodeString@icu_56@@8 ; icu_56::UnicodeString::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 193Ch
		public ??_R0?AVUnicodeString@icu_56@@@8
; class	icu_56::UnicodeString `RTTI Type Descriptor'
??_R0?AVUnicodeString@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:00001934o
					; .rdata$r:icu_56::UnicodeString::`RTTI	Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avunicodestr	db '.?AVUnicodeString@icu_56@@',0
		align 10h
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1960h
		public ??_R3UnicodeString@icu_56@@8
; icu_56::UnicodeString::`RTTI Class Hierarchy Descriptor'
??_R3UnicodeString@icu_56@@8 dd	2 dup(0) ; DATA	XREF: .rdata$r:00001938o
					; .rdata$r:0000199Co
		dd 4
		dd offset ??_R2UnicodeString@icu_56@@8 ; icu_56::UnicodeString::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1970h
		public ??_R2UnicodeString@icu_56@@8
; icu_56::UnicodeString::`RTTI Base Class Array'
??_R2UnicodeString@icu_56@@8 dd	offset ??_R1A@?0A@EA@UnicodeString@icu_56@@8
					; DATA XREF: .rdata$r:0000196Co
					; icu_56::UnicodeString::`RTTI Base Class Descriptor at	(0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@Replaceable@icu_56@@8 ;	icu_56::Replaceable::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1984h
		public ??_R1A@?0A@EA@UnicodeString@icu_56@@8
; icu_56::UnicodeString::`RTTI Base Class Descriptor at	(0, -1,	0, 64)'
??_R1A@?0A@EA@UnicodeString@icu_56@@8 dd offset	??_R0?AVUnicodeString@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UnicodeString::`RTTI Base	Class Array'o
					; icu_56::UnicodeString	`RTTI Type Descriptor'
		dd 3, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UnicodeString@icu_56@@8 ; icu_56::UnicodeString::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 19A0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::hasShortLength(icu_56::UnicodeString *__hidden this)
		public ?hasShortLength@UnicodeString@icu_56@@ABECXZ
?hasShortLength@UnicodeString@icu_56@@ABECXZ proc near
					; CODE XREF: icu_56::UnicodeString::length(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		test	ecx, ecx
		setnl	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?hasShortLength@UnicodeString@icu_56@@ABECXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 19D8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::getShortLength(icu_56::UnicodeString *__hidden this)
		public ?getShortLength@UnicodeString@icu_56@@ABEHXZ
?getShortLength@UnicodeString@icu_56@@ABEHXZ proc near
					; CODE XREF: icu_56::UnicodeString::length(void)+35p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	eax, word ptr [eax+4]
		sar	eax, 5
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getShortLength@UnicodeString@icu_56@@ABEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1A0Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::length(icu_56::UnicodeString *__hidden this)
		public ?length@UnicodeString@icu_56@@QBEHXZ
?length@UnicodeString@icu_56@@QBEHXZ proc near
					; CODE XREF: icu_56::UnicodeString::pinIndex(int &)+39p
					; icu_56::UnicodeString::pinIndex(int &)+48p ...

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?hasShortLength@UnicodeString@icu_56@@ABECXZ ; icu_56::UnicodeString::hasShortLength(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_1A4E
		mov	ecx, [ebp+var_8] ; this
		call	?getShortLength@UnicodeString@icu_56@@ABEHXZ ; icu_56::UnicodeString::getShortLength(void)
		mov	[ebp+var_D0], eax
		jmp	short loc_1A5A
; ---------------------------------------------------------------------------

loc_1A4E:				; CODE XREF: icu_56::UnicodeString::length(void)+30j
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+8]
		mov	[ebp+var_D0], edx

loc_1A5A:				; CODE XREF: icu_56::UnicodeString::length(void)+40j
		mov	eax, [ebp+var_D0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?length@UnicodeString@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1A74h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::getCapacity(icu_56::UnicodeString *__hidden this)
		public ?getCapacity@UnicodeString@icu_56@@QBEHXZ
?getCapacity@UnicodeString@icu_56@@QBEHXZ proc near

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 2
		jz	short loc_1AAF
		mov	[ebp+var_D0], 1Dh
		jmp	short loc_1ABB
; ---------------------------------------------------------------------------

loc_1AAF:				; CODE XREF: icu_56::UnicodeString::getCapacity(void)+2Dj
		mov	edx, [ebp+var_8]
		mov	eax, [edx+0Ch]
		mov	[ebp+var_D0], eax

loc_1ABB:				; CODE XREF: icu_56::UnicodeString::getCapacity(void)+39j
		mov	eax, [ebp+var_D0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getCapacity@UnicodeString@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1AC8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::hashCode(icu_56::UnicodeString *__hidden this)
		public ?hashCode@UnicodeString@icu_56@@QBEHXZ
?hashCode@UnicodeString@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?doHashCode@UnicodeString@icu_56@@ABEHXZ ; icu_56::UnicodeString::doHashCode(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?hashCode@UnicodeString@icu_56@@QBEHXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1B08h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::isBogus(icu_56::UnicodeString	*__hidden this)
		public ?isBogus@UnicodeString@icu_56@@QBECXZ
?isBogus@UnicodeString@icu_56@@QBECXZ proc near
					; CODE XREF: icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+26p
					; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+35p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	eax, word ptr [eax+4]
		and	eax, 1
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isBogus@UnicodeString@icu_56@@QBECXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1B3Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::isWritable(icu_56::UnicodeString *__hidden this)
		public ?isWritable@UnicodeString@icu_56@@ABECXZ
?isWritable@UnicodeString@icu_56@@ABECXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 11h
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isWritable@UnicodeString@icu_56@@ABECXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1B74h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::isBufferWritable(icu_56::UnicodeString *__hidden this)
		public ?isBufferWritable@UnicodeString@icu_56@@ABECXZ
?isBufferWritable@UnicodeString@icu_56@@ABECXZ proc near

var_D0		= byte ptr -0D0h
var_CD		= byte ptr -0CDh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 19h
		jnz	short loc_1BC5
		mov	edx, [ebp+var_8]
		movsx	eax, word ptr [edx+4]
		and	eax, 4
		jz	short loc_1BBC
		mov	ecx, [ebp+var_8] ; this
		call	?refCount@UnicodeString@icu_56@@ABEHXZ ; icu_56::UnicodeString::refCount(void)
		cmp	eax, 1
		jnz	short loc_1BC5

loc_1BBC:				; CODE XREF: icu_56::UnicodeString::isBufferWritable(void)+39j
		mov	[ebp+var_CD], 1
		jmp	short loc_1BCC
; ---------------------------------------------------------------------------

loc_1BC5:				; CODE XREF: icu_56::UnicodeString::isBufferWritable(void)+2Dj
					; icu_56::UnicodeString::isBufferWritable(void)+46j
		mov	[ebp+var_CD], 0

loc_1BCC:				; CODE XREF: icu_56::UnicodeString::isBufferWritable(void)+4Fj
		mov	al, [ebp+var_CD]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?isBufferWritable@UnicodeString@icu_56@@ABECXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1BE8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	wchar_t	*__thiscall icu_56::UnicodeString::getBuffer(icu_56::UnicodeString *__hidden this)
		public ?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ
?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ proc	near
					; CODE XREF: icu_56::UnicodeSet::span(icu_56::UnicodeString const &,int,USetSpanCondition)+59p
					; icu_56::UnicodeSet::spanBack(icu_56::UnicodeString const &,int,USetSpanCondition)+56p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 11h
		jz	short loc_1C1D
		xor	eax, eax
		jmp	short loc_1C39
; ---------------------------------------------------------------------------
		jmp	short loc_1C39
; ---------------------------------------------------------------------------

loc_1C1D:				; CODE XREF: icu_56::UnicodeString::getBuffer(void)+2Dj
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 2
		jz	short loc_1C33
		mov	eax, [ebp+var_8]
		add	eax, 6
		jmp	short loc_1C39
; ---------------------------------------------------------------------------
		jmp	short loc_1C39
; ---------------------------------------------------------------------------

loc_1C33:				; CODE XREF: icu_56::UnicodeString::getBuffer(void)+3Fj
		mov	eax, [ebp+var_8]
		mov	eax, [eax+10h]

loc_1C39:				; CODE XREF: icu_56::UnicodeString::getBuffer(void)+31j
					; icu_56::UnicodeString::getBuffer(void)+33j ...
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1C40h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::doCompare(icu_56::UnicodeString *this, int, int, const struct	icu_56::UnicodeString *, int, int)
		public ?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z
?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z proc near
					; CODE XREF: icu_56::UnicodeString::operator>(icu_56::UnicodeString const &)+40p
					; icu_56::UnicodeString::operator<(icu_56::UnicodeString const &)+40p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_1C86
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		setz	al
		jmp	short loc_1CB7
; ---------------------------------------------------------------------------
		jmp	short loc_1CB7
; ---------------------------------------------------------------------------

loc_1C86:				; CODE XREF: icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+30j
		lea	eax, [ebp+arg_10]
		push	eax		; int *
		lea	ecx, [ebp+arg_C]
		push	ecx		; int *
		mov	ecx, [ebp+arg_8] ; this
		call	?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z ; icu_56::UnicodeString::pinIndices(int &,int &)
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	ecx, [ebp+arg_8] ; this
		call	?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ ; icu_56::UnicodeString::getArrayStart(void)
		push	eax		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)

loc_1CB7:				; CODE XREF: icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+42j
					; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+44j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1CD0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator==(icu_56::UnicodeString	*)
		public ??8UnicodeString@icu_56@@QBECABV01@@Z
??8UnicodeString@icu_56@@QBECABV01@@Z proc near
					; CODE XREF: icu_56::UnicodeString::operator!=(icu_56::UnicodeString const &)+2Ap

var_E8		= byte ptr -0E8h
var_E5		= byte ptr -0E5h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E8]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_1D0E
		mov	ecx, [ebp+arg_0] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		jmp	short loc_1D68
; ---------------------------------------------------------------------------
		jmp	short loc_1D68
; ---------------------------------------------------------------------------

loc_1D0E:				; CODE XREF: icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)+30j
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	[ebp+var_14], eax
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	[ebp+var_20], eax
		mov	ecx, [ebp+arg_0] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_1D5B
		mov	ecx, [ebp+var_14]
		cmp	ecx, [ebp+var_20]
		jnz	short loc_1D5B
		mov	edx, [ebp+var_14]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?doEquals@UnicodeString@icu_56@@ABECABV12@H@Z ;	icu_56::UnicodeString::doEquals(icu_56::UnicodeString const &,int)
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_1D5B
		mov	[ebp+var_E5], 1
		jmp	short loc_1D62
; ---------------------------------------------------------------------------

loc_1D5B:				; CODE XREF: icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)+61j
					; icu_56::UnicodeString::operator==(icu_56::UnicodeString const	&)+69j	...
		mov	[ebp+var_E5], 0

loc_1D62:				; CODE XREF: icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)+89j
		mov	al, [ebp+var_E5]

loc_1D68:				; CODE XREF: icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)+3Aj
					; icu_56::UnicodeString::operator==(icu_56::UnicodeString const	&)+3Cj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??8UnicodeString@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1D80h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator!=(icu_56::UnicodeString	*)
		public ??9UnicodeString@icu_56@@QBECABV01@@Z
??9UnicodeString@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; icu_56::UnicodeString	*
		mov	ecx, [ebp+var_8]
		call	??8UnicodeString@icu_56@@QBECABV01@@Z ;	icu_56::UnicodeString::operator==(icu_56::UnicodeString	const &)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9UnicodeString@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1DD0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator>(icu_56::UnicodeString *)
		public ??OUnicodeString@icu_56@@QBECABV01@@Z
??OUnicodeString@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		cmp	ecx, 1
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??OUnicodeString@icu_56@@QBECABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1E34h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator<(icu_56::UnicodeString *)
		public ??MUnicodeString@icu_56@@QBECABV01@@Z
??MUnicodeString@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		cmp	ecx, 0FFFFFFFFh
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??MUnicodeString@icu_56@@QBECABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1E98h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator>=(icu_56::UnicodeString	*)
		public ??PUnicodeString@icu_56@@QBECABV01@@Z
??PUnicodeString@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		cmp	ecx, 0FFFFFFFFh
		setnz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??PUnicodeString@icu_56@@QBECABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1EFCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator<=(icu_56::UnicodeString	*)
		public ??NUnicodeString@icu_56@@QBECABV01@@Z
??NUnicodeString@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		cmp	ecx, 1
		setnz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??NUnicodeString@icu_56@@QBECABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1F60h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compare(icu_56::UnicodeString	*this, const struct icu_56::UnicodeString *)
		public ?compare@UnicodeString@icu_56@@QBECABV12@@Z
?compare@UnicodeString@icu_56@@QBECABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?compare@UnicodeString@icu_56@@QBECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1FBCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compare(icu_56::UnicodeString	*this, int, int, const struct icu_56::UnicodeString *)
		public ?compare@UnicodeString@icu_56@@QBECHHABV12@@Z
?compare@UnicodeString@icu_56@@QBECHHABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi

loc_2000:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::fixedo
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?compare@UnicodeString@icu_56@@QBECHHABV12@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2014h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compare(icu_56::UnicodeString	*this, const wchar_t *,	int)
		public ?compare@UnicodeString@icu_56@@QBECPB_WH@Z
?compare@UnicodeString@icu_56@@QBECPB_WH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?compare@UnicodeString@icu_56@@QBECPB_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 206Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compare(icu_56::UnicodeString	*this, int, int, const struct icu_56::UnicodeString *, int, int)
		public ?compare@UnicodeString@icu_56@@QBECHHABV12@HH@Z
?compare@UnicodeString@icu_56@@QBECHHABV12@HH@Z	proc near
					; CODE XREF: icu_56::UnicodeString::startsWith(icu_56::UnicodeString const &)+40p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?compare@UnicodeString@icu_56@@QBECHHABV12@HH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 20C4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compare(icu_56::UnicodeString	*this, int, int, const wchar_t *)
		public ?compare@UnicodeString@icu_56@@QBECHHPB_W@Z
?compare@UnicodeString@icu_56@@QBECHHPB_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?compare@UnicodeString@icu_56@@QBECHHPB_W@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2118h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compare(icu_56::UnicodeString	*this, int, int, const wchar_t *, int, int)
		public ?compare@UnicodeString@icu_56@@QBECHHPB_WHH@Z
?compare@UnicodeString@icu_56@@QBECHHPB_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?compare@UnicodeString@icu_56@@QBECHHPB_WHH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2170h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareBetween(icu_56::UnicodeString *this, int, int,	const struct icu_56::UnicodeString *, int, int)
		public ?compareBetween@UnicodeString@icu_56@@QBECHHABV12@HH@Z
?compareBetween@UnicodeString@icu_56@@QBECHHABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		sub	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_4]
		sub	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?compareBetween@UnicodeString@icu_56@@QBECHHABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 21CCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::doCompareCodePointOrder(icu_56::UnicodeString	*this, int, int, const struct icu_56::UnicodeString *, int, int)
		public ?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z
?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z	proc near
					; CODE XREF: icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString	const &)+40p
					; icu_56::UnicodeString::compareCodePointOrder(int,int,icu_56::UnicodeString const &)+3Dp ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_2212
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		setz	al
		jmp	short loc_2243
; ---------------------------------------------------------------------------
		jmp	short loc_2243
; ---------------------------------------------------------------------------

loc_2212:				; CODE XREF: icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const	&,int,int)+30j
		lea	eax, [ebp+arg_10]
		push	eax		; int *
		lea	ecx, [ebp+arg_C]
		push	ecx		; int *
		mov	ecx, [ebp+arg_8] ; this
		call	?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z ; icu_56::UnicodeString::pinIndices(int &,int &)
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	ecx, [ebp+arg_8] ; this
		call	?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ ; icu_56::UnicodeString::getArrayStart(void)
		push	eax		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHPB_WHH@Z ;	icu_56::UnicodeString::doCompareCodePointOrder(int,int,wchar_t const *,int,int)

loc_2243:				; CODE XREF: icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const	&,int,int)+42j
					; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)+44j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 225Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*)
		public ?compareCodePointOrder@UnicodeString@icu_56@@QBECABV12@@Z
?compareCodePointOrder@UnicodeString@icu_56@@QBECABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z	; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?compareCodePointOrder@UnicodeString@icu_56@@QBECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 22B8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString *this, int, int, const struct icu_56::UnicodeString *)
		public ?compareCodePointOrder@UnicodeString@icu_56@@QBECHHABV12@@Z
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z	; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHABV12@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2310h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString *this, const wchar_t *, int)
		public ?compareCodePointOrder@UnicodeString@icu_56@@QBECPB_WH@Z
?compareCodePointOrder@UnicodeString@icu_56@@QBECPB_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHPB_WHH@Z ;	icu_56::UnicodeString::doCompareCodePointOrder(int,int,wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?compareCodePointOrder@UnicodeString@icu_56@@QBECPB_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2368h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString *this, int, int, const struct icu_56::UnicodeString *, int, int)
		public ?compareCodePointOrder@UnicodeString@icu_56@@QBECHHABV12@HH@Z
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z	; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 23C0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString *this, int, int, const wchar_t *)
		public ?compareCodePointOrder@UnicodeString@icu_56@@QBECHHPB_W@Z
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHPB_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHPB_WHH@Z ;	icu_56::UnicodeString::doCompareCodePointOrder(int,int,wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHPB_W@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2414h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString *this, int, int, const wchar_t *,	int, int)
		public ?compareCodePointOrder@UnicodeString@icu_56@@QBECHHPB_WHH@Z
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHPB_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHPB_WHH@Z ;	icu_56::UnicodeString::doCompareCodePointOrder(int,int,wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHPB_WHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 246Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrderBetween(icu_56::UnicodeString *this, int, int, const struct icu_56::UnicodeString *, int, int)
		public ?compareCodePointOrderBetween@UnicodeString@icu_56@@QBECHHABV12@HH@Z
?compareCodePointOrderBetween@UnicodeString@icu_56@@QBECHHABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		sub	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_4]
		sub	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z	; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?compareCodePointOrderBetween@UnicodeString@icu_56@@QBECHHABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 24C8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::doCaseCompare(icu_56::UnicodeString *this, int, int, const struct icu_56::UnicodeString *, int, int, unsigned	int)
		public ?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z
?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z proc near
					; CODE XREF: icu_56::UnicodeString::caseCompare(icu_56::UnicodeString const &,uint)+44p
					; icu_56::UnicodeString::caseCompare(int,int,icu_56::UnicodeString const &,uint)+41p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_250E
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		setz	al
		jmp	short loc_2543
; ---------------------------------------------------------------------------
		jmp	short loc_2543
; ---------------------------------------------------------------------------

loc_250E:				; CODE XREF: icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString	const &,int,int,uint)+30j
		lea	eax, [ebp+arg_10]
		push	eax		; int *
		lea	ecx, [ebp+arg_C]
		push	ecx		; int *
		mov	ecx, [ebp+arg_8] ; this
		call	?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z ; icu_56::UnicodeString::pinIndices(int &,int &)
		mov	eax, [ebp+arg_14]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_10]
		push	ecx		; int
		mov	edx, [ebp+arg_C]
		push	edx		; int
		mov	ecx, [ebp+arg_8] ; this
		call	?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ ; icu_56::UnicodeString::getArrayStart(void)
		push	eax		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHPB_WHHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,wchar_t const *,int,int,uint)

loc_2543:				; CODE XREF: icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString	const &,int,int,uint)+42j
					; icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString const &,int,int,uint)+44j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	18h
?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 255Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompare(icu_56::UnicodeString *this, const struct	icu_56::UnicodeString *, unsigned int)
		public ?caseCompare@UnicodeString@icu_56@@QBECABV12@I@Z
?caseCompare@UnicodeString@icu_56@@QBECABV12@I@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString const &,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?caseCompare@UnicodeString@icu_56@@QBECABV12@I@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 25BCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompare(icu_56::UnicodeString *this, int,	int, const struct icu_56::UnicodeString	*, unsigned int)
		public ?caseCompare@UnicodeString@icu_56@@QBECHHABV12@I@Z
?caseCompare@UnicodeString@icu_56@@QBECHHABV12@I@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct icu_56::UnicodeString *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString const &,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?caseCompare@UnicodeString@icu_56@@QBECHHABV12@I@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2618h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompare(icu_56::UnicodeString *this, const wchar_t *, int, unsigned int)
		public ?caseCompare@UnicodeString@icu_56@@QBECPB_WHI@Z
?caseCompare@UnicodeString@icu_56@@QBECPB_WHI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHPB_WHHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,wchar_t const *,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?caseCompare@UnicodeString@icu_56@@QBECPB_WHI@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2674h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompare(icu_56::UnicodeString *this, int,	int, const struct icu_56::UnicodeString	*, int,	int, unsigned int)
		public ?caseCompare@UnicodeString@icu_56@@QBECHHABV12@HHI@Z
?caseCompare@UnicodeString@icu_56@@QBECHHABV12@HHI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_14]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_10]
		push	ecx		; int
		mov	edx, [ebp+arg_C]
		push	edx		; int
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString const &,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	18h
?caseCompare@UnicodeString@icu_56@@QBECHHABV12@HHI@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 26D0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompare(icu_56::UnicodeString *this, int,	int, const wchar_t *, unsigned int)
		public ?caseCompare@UnicodeString@icu_56@@QBECHHPB_WI@Z
?caseCompare@UnicodeString@icu_56@@QBECHHPB_WI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		push	0		; int
		mov	edx, [ebp+arg_8]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHPB_WHHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,wchar_t const *,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?caseCompare@UnicodeString@icu_56@@QBECHHPB_WI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2728h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompare(icu_56::UnicodeString *this, int,	int, const wchar_t *, int, int,	unsigned int)
		public ?caseCompare@UnicodeString@icu_56@@QBECHHPB_WHHI@Z
?caseCompare@UnicodeString@icu_56@@QBECHHPB_WHHI@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_14]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_10]
		push	ecx		; int
		mov	edx, [ebp+arg_C]
		push	edx		; int
		mov	eax, [ebp+arg_8]
		push	eax		; wchar_t *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHPB_WHHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,wchar_t const *,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	18h
?caseCompare@UnicodeString@icu_56@@QBECHHPB_WHHI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2784h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompareBetween(icu_56::UnicodeString *this, int, int, const struct icu_56::UnicodeString *, int, int, unsigned int)
		public ?caseCompareBetween@UnicodeString@icu_56@@QBECHHABV12@HHI@Z
?caseCompareBetween@UnicodeString@icu_56@@QBECHHABV12@HHI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_14]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_10]
		sub	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_C]
		push	edx		; int
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		sub	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString const &,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	18h
?caseCompareBetween@UnicodeString@icu_56@@QBECHHABV12@HHI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 27E4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*, int,	int, int, int)
		public ?indexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z
?indexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z	proc near
					; CODE XREF: icu_56::UnicodeString::indexOf(icu_56::UnicodeString const	&)+40p
					; icu_56::UnicodeString::indexOf(icu_56::UnicodeString const &,int)+51p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_284F
		lea	eax, [ebp+arg_8]
		push	eax		; int *
		lea	ecx, [ebp+arg_4]
		push	ecx		; int *
		mov	ecx, [ebp+arg_0] ; this
		call	?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z ; icu_56::UnicodeString::pinIndices(int &,int &)
		cmp	[ebp+arg_8], 0
		jle	short loc_284F
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ ; icu_56::UnicodeString::getArrayStart(void)
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z ;	icu_56::UnicodeString::indexOf(wchar_t const *,int,int,int,int)
		jmp	short loc_2852
; ---------------------------------------------------------------------------

loc_284F:				; CODE XREF: icu_56::UnicodeString::indexOf(icu_56::UnicodeString const	&,int,int,int,int)+30j
					; icu_56::UnicodeString::indexOf(icu_56::UnicodeString const &,int,int,int,int)+46j
		or	eax, 0FFFFFFFFh

loc_2852:				; CODE XREF: icu_56::UnicodeString::indexOf(icu_56::UnicodeString const	&,int,int,int,int)+69j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?indexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2868h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*)
		public ?indexOf@UnicodeString@icu_56@@QBEHABV12@@Z
?indexOf@UnicodeString@icu_56@@QBEHABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z	; icu_56::UnicodeString::indexOf(icu_56::UnicodeString const &,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?indexOf@UnicodeString@icu_56@@QBEHABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 28C4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*, int)
		public ?indexOf@UnicodeString@icu_56@@QBEHABV12@H@Z
?indexOf@UnicodeString@icu_56@@QBEHABV12@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z	; icu_56::UnicodeString::indexOf(icu_56::UnicodeString const &,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?indexOf@UnicodeString@icu_56@@QBEHABV12@H@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2930h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*, int,	int)
		public ?indexOf@UnicodeString@icu_56@@QBEHABV12@HH@Z
?indexOf@UnicodeString@icu_56@@QBEHABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z	; icu_56::UnicodeString::indexOf(icu_56::UnicodeString const &,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?indexOf@UnicodeString@icu_56@@QBEHABV12@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2988h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, const wchar_t *, int, int)
		public ?indexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z
?indexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_8]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_8]
		push	eax		; int
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z ;	icu_56::UnicodeString::indexOf(wchar_t const *,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?indexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 29F0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, const wchar_t *, int, int,	int)
		public ?indexOf@UnicodeString@icu_56@@QBEHPB_WHHH@Z
?indexOf@UnicodeString@icu_56@@QBEHPB_WHHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+arg_4]
		push	edx		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z ;	icu_56::UnicodeString::indexOf(wchar_t const *,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?indexOf@UnicodeString@icu_56@@QBEHPB_WHHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2A44h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, wchar_t, int, int)
		public ?indexOf@UnicodeString@icu_56@@QBEH_WHH@Z
?indexOf@UnicodeString@icu_56@@QBEH_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		movzx	edx, [ebp+arg_0]
		push	edx		; wchar_t
		mov	ecx, [ebp+var_8] ; this
		call	?doIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z ; icu_56::UnicodeString::doIndexOf(wchar_t,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?indexOf@UnicodeString@icu_56@@QBEH_WHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2A94h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, int, int, int)
		public ?indexOf@UnicodeString@icu_56@@QBEHHHH@Z
?indexOf@UnicodeString@icu_56@@QBEHHHH@Z proc near
					; CODE XREF: icu_56::UnicodeString::indexOf(int)+35p
					; icu_56::UnicodeString::indexOf(int,int)+46p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doIndexOf@UnicodeString@icu_56@@ABEHHHH@Z ; icu_56::UnicodeString::doIndexOf(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?indexOf@UnicodeString@icu_56@@QBEHHHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2AE4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, wchar_t)
		public ?indexOf@UnicodeString@icu_56@@QBEH_W@Z
?indexOf@UnicodeString@icu_56@@QBEH_W@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		movzx	eax, [ebp+arg_0]
		push	eax		; wchar_t
		mov	ecx, [ebp+var_8] ; this
		call	?doIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z ; icu_56::UnicodeString::doIndexOf(wchar_t,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?indexOf@UnicodeString@icu_56@@QBEH_W@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2B38h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, int)
		public ?indexOf@UnicodeString@icu_56@@QBEHH@Z
?indexOf@UnicodeString@icu_56@@QBEHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHHHH@Z ; icu_56::UnicodeString::indexOf(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?indexOf@UnicodeString@icu_56@@QBEHH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2B88h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, wchar_t, int)
		public ?indexOf@UnicodeString@icu_56@@QBEH_WH@Z
?indexOf@UnicodeString@icu_56@@QBEH_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		movzx	ecx, [ebp+arg_0]
		push	ecx		; wchar_t
		mov	ecx, [ebp+var_8] ; this
		call	?doIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z ; icu_56::UnicodeString::doIndexOf(wchar_t,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?indexOf@UnicodeString@icu_56@@QBEH_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2BECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, int, int)
		public ?indexOf@UnicodeString@icu_56@@QBEHHH@Z
?indexOf@UnicodeString@icu_56@@QBEHHH@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHHHH@Z ; icu_56::UnicodeString::indexOf(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?indexOf@UnicodeString@icu_56@@QBEHHH@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2C50h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, const wchar_t *, int, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+arg_4]
		push	edx		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z ; icu_56::UnicodeString::lastIndexOf(wchar_t const *,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2CA4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, const wchar_t *, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_8]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_8]
		push	eax		; int
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z ; icu_56::UnicodeString::lastIndexOf(wchar_t const *,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2D0Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *, int, int, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z proc near
					; CODE XREF: icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int)+3Dp
					; icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int)+51p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_2D77
		lea	eax, [ebp+arg_8]
		push	eax		; int *
		lea	ecx, [ebp+arg_4]
		push	ecx		; int *
		mov	ecx, [ebp+arg_0] ; this
		call	?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z ; icu_56::UnicodeString::pinIndices(int &,int &)
		cmp	[ebp+arg_8], 0
		jle	short loc_2D77
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ ; icu_56::UnicodeString::getArrayStart(void)
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z ; icu_56::UnicodeString::lastIndexOf(wchar_t const *,int,int,int,int)
		jmp	short loc_2D7A
; ---------------------------------------------------------------------------

loc_2D77:				; CODE XREF: icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int,int,int)+30j
					; icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int,int,int)+46j
		or	eax, 0FFFFFFFFh

loc_2D7A:				; CODE XREF: icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int,int,int)+69j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2D90h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z ; icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2DE8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@H@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z ; icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@H@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2E54h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z ; icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2EB0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, wchar_t, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEH_WHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEH_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		movzx	edx, [ebp+arg_0]
		push	edx		; wchar_t
		mov	ecx, [ebp+var_8] ; this
		call	?doLastIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z	; icu_56::UnicodeString::doLastIndexOf(wchar_t,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?lastIndexOf@UnicodeString@icu_56@@QBEH_WHH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2F00h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, int, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHHHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHHHH@Z proc near
					; CODE XREF: icu_56::UnicodeString::lastIndexOf(int)+35p
					; icu_56::UnicodeString::lastIndexOf(int,int)+46p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doLastIndexOf@UnicodeString@icu_56@@ABEHHHH@Z ; icu_56::UnicodeString::doLastIndexOf(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?lastIndexOf@UnicodeString@icu_56@@QBEHHHH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2F50h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, wchar_t)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEH_W@Z
?lastIndexOf@UnicodeString@icu_56@@QBEH_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		movzx	eax, [ebp+arg_0]
		push	eax		; wchar_t
		mov	ecx, [ebp+var_8] ; this
		call	?doLastIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z	; icu_56::UnicodeString::doLastIndexOf(wchar_t,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?lastIndexOf@UnicodeString@icu_56@@QBEH_W@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2FA4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHHHH@Z ; icu_56::UnicodeString::lastIndexOf(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?lastIndexOf@UnicodeString@icu_56@@QBEHH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2FF4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, wchar_t, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEH_WH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEH_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi

loc_3000:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::hexfloato
					; .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::floatfieldo
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		movzx	ecx, [ebp+arg_0]
		push	ecx		; wchar_t
		mov	ecx, [ebp+var_8] ; this
		call	?doLastIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z	; icu_56::UnicodeString::doLastIndexOf(wchar_t,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?lastIndexOf@UnicodeString@icu_56@@QBEH_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3058h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHHHH@Z ; icu_56::UnicodeString::lastIndexOf(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?lastIndexOf@UnicodeString@icu_56@@QBEHHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 30BCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::startsWith(icu_56::UnicodeString *this, const	struct icu_56::UnicodeString *)
		public ?startsWith@UnicodeString@icu_56@@QBECABV12@@Z
?startsWith@UnicodeString@icu_56@@QBECABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?compare@UnicodeString@icu_56@@QBECHHABV12@HH@Z	; icu_56::UnicodeString::compare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?startsWith@UnicodeString@icu_56@@QBECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3120h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::startsWith(icu_56::UnicodeString *this, const	struct icu_56::UnicodeString *,	int, int)
		public ?startsWith@UnicodeString@icu_56@@QBECABV12@HH@Z
?startsWith@UnicodeString@icu_56@@QBECABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_8]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?startsWith@UnicodeString@icu_56@@QBECABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 317Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::startsWith(icu_56::UnicodeString *this, const	wchar_t	*, int)
		public ?startsWith@UnicodeString@icu_56@@QBECPB_WH@Z
?startsWith@UnicodeString@icu_56@@QBECPB_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_4], 0
		jge	short loc_31B4
		mov	eax, [ebp+arg_0]
		push	eax
		call	_u_strlen_56
		add	esp, 4
		mov	[ebp+arg_4], eax

loc_31B4:				; CODE XREF: icu_56::UnicodeString::startsWith(wchar_t const *,int)+27j
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		movsx	eax, al
		test	eax, eax
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?startsWith@UnicodeString@icu_56@@QBECPB_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 31ECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::startsWith(icu_56::UnicodeString *this, const	wchar_t	*, int,	int)
		public ?startsWith@UnicodeString@icu_56@@QBECPB_WHH@Z
?startsWith@UnicodeString@icu_56@@QBECPB_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_8], 0
		jge	short loc_3224
		mov	eax, [ebp+arg_0]
		push	eax
		call	_u_strlen_56
		add	esp, 4
		mov	[ebp+arg_8], eax

loc_3224:				; CODE XREF: icu_56::UnicodeString::startsWith(wchar_t const *,int,int)+27j
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_8]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?startsWith@UnicodeString@icu_56@@QBECPB_WHH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 325Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::endsWith(icu_56::UnicodeString *this,	const struct icu_56::UnicodeString *)
		public ?endsWith@UnicodeString@icu_56@@QBECABV12@@Z
?endsWith@UnicodeString@icu_56@@QBECABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	esi, eax
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	esi, eax
		push	esi		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?endsWith@UnicodeString@icu_56@@QBECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 32D4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::endsWith(icu_56::UnicodeString *this,	const struct icu_56::UnicodeString *, int, int)
		public ?endsWith@UnicodeString@icu_56@@QBECABV12@HH@Z
?endsWith@UnicodeString@icu_56@@QBECABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_8]
		push	eax		; int *
		lea	ecx, [ebp+arg_4]
		push	ecx		; int *
		mov	ecx, [ebp+arg_0] ; this
		call	?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z ; icu_56::UnicodeString::pinIndices(int &,int &)
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?endsWith@UnicodeString@icu_56@@QBECABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 334Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::endsWith(icu_56::UnicodeString *this,	const wchar_t *, int)
		public ?endsWith@UnicodeString@icu_56@@QBECPB_WH@Z
?endsWith@UnicodeString@icu_56@@QBECPB_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_4], 0
		jge	short loc_3384
		mov	eax, [ebp+arg_0]
		push	eax
		call	_u_strlen_56
		add	esp, 4
		mov	[ebp+arg_4], eax

loc_3384:				; CODE XREF: icu_56::UnicodeString::endsWith(wchar_t const *,int)+27j
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		movsx	eax, al
		test	eax, eax
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?endsWith@UnicodeString@icu_56@@QBECPB_WH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 33C4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::endsWith(icu_56::UnicodeString *this,	const wchar_t *, int, int)
		public ?endsWith@UnicodeString@icu_56@@QBECPB_WHH@Z
?endsWith@UnicodeString@icu_56@@QBECPB_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_8], 0
		jge	short loc_3402
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+arg_0]
		lea	edx, [ecx+eax*2]
		push	edx
		call	_u_strlen_56
		add	esp, 4
		mov	[ebp+arg_8], eax

loc_3402:				; CODE XREF: icu_56::UnicodeString::endsWith(wchar_t const *,int,int)+27j
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?endsWith@UnicodeString@icu_56@@QBECPB_WHH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3444h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replace(icu_56::UnicodeString	*this, int, int, const struct icu_56::UnicodeString *)
		public ?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@@Z
?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 349Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replace(icu_56::UnicodeString	*this, int, int, const struct icu_56::UnicodeString *, int, int)
		public ?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z
?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z proc near
					; CODE XREF: icu_56::UnicodeString::doExtract(int,int,icu_56::UnicodeString &)+3Dp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 34F4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replace(icu_56::UnicodeString	*this, int, int, const wchar_t *, int)
		public ?replace@UnicodeString@icu_56@@QAEAAV12@HHPB_WH@Z
?replace@UnicodeString@icu_56@@QAEAAV12@HHPB_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?replace@UnicodeString@icu_56@@QAEAAV12@HHPB_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3548h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replace(icu_56::UnicodeString	*this, int, int, const wchar_t *, int, int)
		public ?replace@UnicodeString@icu_56@@QAEAAV12@HHPB_WHH@Z
?replace@UnicodeString@icu_56@@QAEAAV12@HHPB_WHH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?replace@UnicodeString@icu_56@@QAEAAV12@HHPB_WHH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 35A0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replace(icu_56::UnicodeString	*this, int, int, wchar_t)
		public ?replace@UnicodeString@icu_56@@QAEAAV12@HH_W@Z
?replace@UnicodeString@icu_56@@QAEAAV12@HH_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= word ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	1		; int
		push	0		; int
		lea	eax, [ebp+arg_8]
		push	eax		; wchar_t *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?replace@UnicodeString@icu_56@@QAEAAV12@HH_W@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 35F4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replaceBetween(icu_56::UnicodeString *this, int, int,	const struct icu_56::UnicodeString *)
		public ?replaceBetween@UnicodeString@icu_56@@QAEAAV12@HHABV12@@Z
?replaceBetween@UnicodeString@icu_56@@QAEAAV12@HHABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		sub	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?replaceBetween@UnicodeString@icu_56@@QAEAAV12@HHABV12@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3650h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replaceBetween(icu_56::UnicodeString *this, int, int,	const struct icu_56::UnicodeString *, int, int)
		public ?replaceBetween@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z
?replaceBetween@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		sub	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_4]
		sub	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?replaceBetween@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 36ACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::findAndReplace(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *, const struct icu_56::UnicodeString *)
		public ?findAndReplace@UnicodeString@icu_56@@QAEAAV12@ABV12@0@Z
?findAndReplace@UnicodeString@icu_56@@QAEAAV12@ABV12@0@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_4] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_4]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?findAndReplace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH0HH@Z ; icu_56::UnicodeString::findAndReplace(int,int,icu_56::UnicodeString const &,int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?findAndReplace@UnicodeString@icu_56@@QAEAAV12@ABV12@0@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3718h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::findAndReplace(icu_56::UnicodeString *this, int, int,	const struct icu_56::UnicodeString *, const struct icu_56::UnicodeString *)
		public ?findAndReplace@UnicodeString@icu_56@@QAEAAV12@HHABV12@0@Z
?findAndReplace@UnicodeString@icu_56@@QAEAAV12@HHABV12@0@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_C] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_C]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct icu_56::UnicodeString *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?findAndReplace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH0HH@Z ; icu_56::UnicodeString::findAndReplace(int,int,icu_56::UnicodeString const &,int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?findAndReplace@UnicodeString@icu_56@@QAEAAV12@HHABV12@0@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3780h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::doExtract(icu_56::UnicodeString *this,	int, int, struct icu_56::UnicodeString *)
		public ?doExtract@UnicodeString@icu_56@@ABEXHHAAV12@@Z
?doExtract@UnicodeString@icu_56@@ABEXHHAAV12@@Z	proc near
					; CODE XREF: icu_56::UnicodeString::extract(int,int,icu_56::UnicodeString &)+32p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	edx, [ebp+var_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_8] ; this
		call	?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::replace(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?doExtract@UnicodeString@icu_56@@ABEXHHAAV12@@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 37D8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::extract(icu_56::UnicodeString *this, int, int,	wchar_t	*, int)
		public ?extract@UnicodeString@icu_56@@QBEXHHPA_WH@Z
?extract@UnicodeString@icu_56@@QBEXHHPA_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doExtract@UnicodeString@icu_56@@ABEXHHPA_WH@Z ; icu_56::UnicodeString::doExtract(int,int,wchar_t *,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?extract@UnicodeString@icu_56@@QBEXHHPA_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 382Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::extract(icu_56::UnicodeString *this, int, int,	struct icu_56::UnicodeString *)
		public ?extract@UnicodeString@icu_56@@QBEXHHAAV12@@Z
?extract@UnicodeString@icu_56@@QBEXHHAAV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doExtract@UnicodeString@icu_56@@ABEXHHAAV12@@Z	; icu_56::UnicodeString::doExtract(int,int,icu_56::UnicodeString &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?extract@UnicodeString@icu_56@@QBEXHHAAV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 387Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::extract(icu_56::UnicodeString *this, int, int, char *, const char *)
		public ?extract@UnicodeString@icu_56@@QBEHHHPADPBD@Z
?extract@UnicodeString@icu_56@@QBEHHHPADPBD@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; char *
		mov	ecx, [ebp+arg_8]
		neg	ecx
		sbb	ecx, ecx
		push	ecx		; unsigned int
		mov	edx, [ebp+arg_8]
		push	edx		; char *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?extract@UnicodeString@icu_56@@QBEHHHPADIPBD@Z ; icu_56::UnicodeString::extract(int,int,char *,uint,char const *)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?extract@UnicodeString@icu_56@@QBEHHHPADPBD@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 38D8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::extractBetween(icu_56::UnicodeString *this, int, int, wchar_t *, int)
		public ?extractBetween@UnicodeString@icu_56@@QBEXHHPA_WH@Z
?extractBetween@UnicodeString@icu_56@@QBEXHHPA_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_0]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		sub	edx, [ebp+arg_0]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doExtract@UnicodeString@icu_56@@ABEXHHPA_WH@Z ; icu_56::UnicodeString::doExtract(int,int,wchar_t *,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?extractBetween@UnicodeString@icu_56@@QBEXHHPA_WH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3944h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeString __thiscall icu_56::UnicodeString::tempSubStringBetween(int, int)const
		public ?tempSubStringBetween@UnicodeString@icu_56@@QBE?AV12@HH@Z
?tempSubStringBetween@UnicodeString@icu_56@@QBE?AV12@HH@Z proc near

var_D8		= byte ptr -0D8h
var_D4		= dword	ptr -0D4h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_D4], 0
		mov	eax, [ebp+arg_8]
		sub	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		mov	ecx, [ebp+var_8]
		call	?tempSubString@UnicodeString@icu_56@@QBE?AV12@HH@Z ; icu_56::UnicodeString::tempSubString(int,int)
		mov	eax, [ebp+var_D4]
		or	eax, 1
		mov	[ebp+var_D4], eax
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?tempSubStringBetween@UnicodeString@icu_56@@QBE?AV12@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 39B0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; wchar_t __thiscall icu_56::UnicodeString::doCharAt(icu_56::UnicodeString *this, int)
		public ?doCharAt@UnicodeString@icu_56@@ABE_WH@Z
?doCharAt@UnicodeString@icu_56@@ABE_WH@Z proc near
					; CODE XREF: icu_56::UnicodeString::charAt(int)+2Ap
					; icu_56::UnicodeString::operator[](int)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		cmp	[ebp+arg_0], eax
		jnb	short loc_39F3
		mov	ecx, [ebp+var_8] ; this
		call	?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ ; icu_56::UnicodeString::getArrayStart(void)
		mov	ecx, [ebp+arg_0]
		mov	ax, [eax+ecx*2]
		jmp	short loc_39F8
; ---------------------------------------------------------------------------
		jmp	short loc_39F8
; ---------------------------------------------------------------------------

loc_39F3:				; CODE XREF: icu_56::UnicodeString::doCharAt(int)+2Ej
		mov	eax, 0FFFFh

loc_39F8:				; CODE XREF: icu_56::UnicodeString::doCharAt(int)+3Fj
					; icu_56::UnicodeString::doCharAt(int)+41j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?doCharAt@UnicodeString@icu_56@@ABE_WH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3A10h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; wchar_t __thiscall icu_56::UnicodeString::charAt(icu_56::UnicodeString *this,	int)
		public ?charAt@UnicodeString@icu_56@@QBE_WH@Z
?charAt@UnicodeString@icu_56@@QBE_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCharAt@UnicodeString@icu_56@@ABE_WH@Z ; icu_56::UnicodeString::doCharAt(int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?charAt@UnicodeString@icu_56@@QBE_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3A58h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: wchar_t __thiscall icu_56::UnicodeString::operator[](int)const
		public ??AUnicodeString@icu_56@@QBE_WH@Z
??AUnicodeString@icu_56@@QBE_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCharAt@UnicodeString@icu_56@@ABE_WH@Z ; icu_56::UnicodeString::doCharAt(int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??AUnicodeString@icu_56@@QBE_WH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3AA0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::isEmpty(icu_56::UnicodeString	*__hidden this)
		public ?isEmpty@UnicodeString@icu_56@@QBECXZ
?isEmpty@UnicodeString@icu_56@@QBECXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		sar	ecx, 5
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isEmpty@UnicodeString@icu_56@@QBECXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3ADCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::setZeroLength(icu_56::UnicodeString *__hidden this)
		public ?setZeroLength@UnicodeString@icu_56@@AAEXXZ
?setZeroLength@UnicodeString@icu_56@@AAEXXZ proc near
					; CODE XREF: icu_56::UnicodeString::remove(void)+3Fp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 1Fh
		mov	edx, [ebp+var_8]
		mov	[edx+4], cx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?setZeroLength@UnicodeString@icu_56@@AAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3B18h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::setShortLength(icu_56::UnicodeString *this, int)
		public ?setShortLength@UnicodeString@icu_56@@AAEXH@Z
?setShortLength@UnicodeString@icu_56@@AAEXH@Z proc near
					; CODE XREF: icu_56::UnicodeString::setLength(int)+33p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 1Fh
		mov	edx, [ebp+arg_0]
		shl	edx, 5
		or	ecx, edx
		mov	eax, [ebp+var_8]
		mov	[eax+4], cx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?setShortLength@UnicodeString@icu_56@@AAEXH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3B60h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::setLength(icu_56::UnicodeString *this,	int)
		public ?setLength@UnicodeString@icu_56@@AAEXH@Z
?setLength@UnicodeString@icu_56@@AAEXH@Z proc near
					; CODE XREF: icu_56::UnicodeString::setArray(wchar_t *,int,int)+2Ap
					; icu_56::UnicodeString::truncate(int)+5Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 3FFh
		jg	short loc_3B9A
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?setShortLength@UnicodeString@icu_56@@AAEXH@Z ;	icu_56::UnicodeString::setShortLength(int)
		jmp	short loc_3BB7
; ---------------------------------------------------------------------------

loc_3B9A:				; CODE XREF: icu_56::UnicodeString::setLength(int)+2Aj
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		or	ecx, 0FFE0h
		mov	edx, [ebp+var_8]
		mov	[edx+4], cx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+8], ecx

loc_3BB7:				; CODE XREF: icu_56::UnicodeString::setLength(int)+38j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setLength@UnicodeString@icu_56@@AAEXH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3BD0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::setToEmpty(icu_56::UnicodeString *__hidden this)
		public ?setToEmpty@UnicodeString@icu_56@@AAEXXZ
?setToEmpty@UnicodeString@icu_56@@AAEXXZ proc near
					; CODE XREF: icu_56::UnicodeString::remove(void)+35p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, 2
		mov	ecx, [ebp+var_8]
		mov	[ecx+4], ax
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?setToEmpty@UnicodeString@icu_56@@AAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3C08h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::setArray(icu_56::UnicodeString	*this, wchar_t *, int, int)
		public ?setArray@UnicodeString@icu_56@@AAEXPA_WHH@Z
?setArray@UnicodeString@icu_56@@AAEXPA_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?setLength@UnicodeString@icu_56@@AAEXH@Z ; icu_56::UnicodeString::setLength(int)
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+10h], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_8]
		mov	[eax+0Ch], ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?setArray@UnicodeString@icu_56@@AAEXPA_WHH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3C60h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator=(wchar_t)
		public ??4UnicodeString@icu_56@@QAEAAV01@_W@Z
??4UnicodeString@icu_56@@QAEAAV01@_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	1		; int
		push	0		; int
		lea	eax, [ebp+arg_0]
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4UnicodeString@icu_56@@QAEAAV01@_W@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3CB4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeString &	__thiscall icu_56::UnicodeString::operator=(int)
		public ??4UnicodeString@icu_56@@QAEAAV01@H@Z
??4UnicodeString@icu_56@@QAEAAV01@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?replace@UnicodeString@icu_56@@QAEAAV12@HHH@Z ;	icu_56::UnicodeString::replace(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4UnicodeString@icu_56@@QAEAAV01@H@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3D04h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*, int,	int)
		public ?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z
?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?unBogus@UnicodeString@icu_56@@AAEXXZ ;	icu_56::UnicodeString::unBogus(void)
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3D64h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*, int)
		public ?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@H@Z
?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@H@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?unBogus@UnicodeString@icu_56@@AAEXXZ ;	icu_56::UnicodeString::unBogus(void)
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+arg_0] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@H@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3DD8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*)
		public ?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z
?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	0		; signed __int8
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?copyFrom@UnicodeString@icu_56@@AAEAAV12@ABV12@C@Z ; icu_56::UnicodeString::copyFrom(icu_56::UnicodeString const &,signed char)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3E20h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *this, const wchar_t *, int)
		public ?setTo@UnicodeString@icu_56@@QAEAAV12@PB_WH@Z
?setTo@UnicodeString@icu_56@@QAEAAV12@PB_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?unBogus@UnicodeString@icu_56@@AAEXXZ ;	icu_56::UnicodeString::unBogus(void)
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?setTo@UnicodeString@icu_56@@QAEAAV12@PB_WH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3E80h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *this, wchar_t)
		public ?setTo@UnicodeString@icu_56@@QAEAAV12@_W@Z
?setTo@UnicodeString@icu_56@@QAEAAV12@_W@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?unBogus@UnicodeString@icu_56@@AAEXXZ ;	icu_56::UnicodeString::unBogus(void)
		push	1		; int
		push	0		; int
		lea	eax, [ebp+arg_0]
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setTo@UnicodeString@icu_56@@QAEAAV12@_W@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3EDCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *this, int)
		public ?setTo@UnicodeString@icu_56@@QAEAAV12@H@Z
?setTo@UnicodeString@icu_56@@QAEAAV12@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?unBogus@UnicodeString@icu_56@@AAEXXZ ;	icu_56::UnicodeString::unBogus(void)
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?replace@UnicodeString@icu_56@@QAEAAV12@HHH@Z ;	icu_56::UnicodeString::replace(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setTo@UnicodeString@icu_56@@QAEAAV12@H@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3F34h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *, int, int)
		public ?append@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z
?append@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@ABV12@HH@Z ; icu_56::UnicodeString::doAppend(icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?append@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3F84h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *)
		public ?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z
?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@ABV12@HH@Z ; icu_56::UnicodeString::doAppend(icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3FD4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *this, const wchar_t *, int, int)
		public ?append@UnicodeString@icu_56@@QAEAAV12@PB_WHH@Z
?append@UnicodeString@icu_56@@QAEAAV12@PB_WHH@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int

loc_3FFF:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::boolalphao
		mov	edx, [ebp+arg_0]
		push	edx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@PB_WHH@Z ; icu_56::UnicodeString::doAppend(wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?append@UnicodeString@icu_56@@QAEAAV12@PB_WHH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4024h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *this, const wchar_t *, int)
		public ?append@UnicodeString@icu_56@@QAEAAV12@PB_WH@Z
?append@UnicodeString@icu_56@@QAEAAV12@PB_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@PB_WHH@Z ; icu_56::UnicodeString::doAppend(wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?append@UnicodeString@icu_56@@QAEAAV12@PB_WH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4070h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *this, wchar_t)
		public ?append@UnicodeString@icu_56@@QAEAAV12@_W@Z
?append@UnicodeString@icu_56@@QAEAAV12@_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	1		; int
		push	0		; int
		lea	eax, [ebp+arg_0]
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@PB_WHH@Z ; icu_56::UnicodeString::doAppend(wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?append@UnicodeString@icu_56@@QAEAAV12@_W@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 40BCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator+=(wchar_t)
		public ??YUnicodeString@icu_56@@QAEAAV01@_W@Z
??YUnicodeString@icu_56@@QAEAAV01@_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	1		; int
		push	0		; int
		lea	eax, [ebp+arg_0]
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@PB_WHH@Z ; icu_56::UnicodeString::doAppend(wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??YUnicodeString@icu_56@@QAEAAV01@_W@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4108h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeString &	__thiscall icu_56::UnicodeString::operator+=(int)
		public ??YUnicodeString@icu_56@@QAEAAV01@H@Z
??YUnicodeString@icu_56@@QAEAAV01@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?append@UnicodeString@icu_56@@QAEAAV12@H@Z ; icu_56::UnicodeString::append(int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??YUnicodeString@icu_56@@QAEAAV01@H@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4150h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator+=(struct icu_56::UnicodeString *)
		public ??YUnicodeString@icu_56@@QAEAAV01@ABV01@@Z
??YUnicodeString@icu_56@@QAEAAV01@ABV01@@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@ABV12@HH@Z ; icu_56::UnicodeString::doAppend(icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??YUnicodeString@icu_56@@QAEAAV01@ABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 41A0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::insert(icu_56::UnicodeString *this, int, const struct	icu_56::UnicodeString *, int, int)
		public ?insert@UnicodeString@icu_56@@QAEAAV12@HABV12@HH@Z
?insert@UnicodeString@icu_56@@QAEAAV12@HABV12@HH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+arg_4]
		push	edx		; struct icu_56::UnicodeString *
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?insert@UnicodeString@icu_56@@QAEAAV12@HABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 41F4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::insert(icu_56::UnicodeString *this, int, const struct	icu_56::UnicodeString *)
		public ?insert@UnicodeString@icu_56@@QAEAAV12@HABV12@@Z
?insert@UnicodeString@icu_56@@QAEAAV12@HABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_4] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_4]
		push	eax		; struct icu_56::UnicodeString *
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?insert@UnicodeString@icu_56@@QAEAAV12@HABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 424Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::insert(icu_56::UnicodeString *this, int, const wchar_t *, int, int)
		public ?insert@UnicodeString@icu_56@@QAEAAV12@HPB_WHH@Z
?insert@UnicodeString@icu_56@@QAEAAV12@HPB_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+arg_4]
		push	edx		; wchar_t *
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?insert@UnicodeString@icu_56@@QAEAAV12@HPB_WHH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 42A0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::insert(icu_56::UnicodeString *this, int, const wchar_t *, int)
		public ?insert@UnicodeString@icu_56@@QAEAAV12@HPB_WH@Z
?insert@UnicodeString@icu_56@@QAEAAV12@HPB_WH@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; wchar_t *
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?insert@UnicodeString@icu_56@@QAEAAV12@HPB_WH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 42F4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::insert(icu_56::UnicodeString *this, int, wchar_t)
		public ?insert@UnicodeString@icu_56@@QAEAAV12@H_W@Z
?insert@UnicodeString@icu_56@@QAEAAV12@H_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= word ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	1		; int
		push	0		; int
		lea	eax, [ebp+arg_4]
		push	eax		; wchar_t *
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?insert@UnicodeString@icu_56@@QAEAAV12@H_W@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4344h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::insert(icu_56::UnicodeString *this, int, int)
		public ?insert@UnicodeString@icu_56@@QAEAAV12@HH@Z
?insert@UnicodeString@icu_56@@QAEAAV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?replace@UnicodeString@icu_56@@QAEAAV12@HHH@Z ;	icu_56::UnicodeString::replace(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?insert@UnicodeString@icu_56@@QAEAAV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4390h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::remove(icu_56::UnicodeString *__hidden this)
		public ?remove@UnicodeString@icu_56@@QAEAAV12@XZ
?remove@UnicodeString@icu_56@@QAEAAV12@XZ proc near
					; CODE XREF: icu_56::UnicodeString::remove(int,int)+35p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_43CC
		mov	ecx, [ebp+var_8] ; this
		call	?setToEmpty@UnicodeString@icu_56@@AAEXXZ ; icu_56::UnicodeString::setToEmpty(void)
		jmp	short loc_43D4
; ---------------------------------------------------------------------------

loc_43CC:				; CODE XREF: icu_56::UnicodeString::remove(void)+30j
		mov	ecx, [ebp+var_8] ; this
		call	?setZeroLength@UnicodeString@icu_56@@AAEXXZ ; icu_56::UnicodeString::setZeroLength(void)

loc_43D4:				; CODE XREF: icu_56::UnicodeString::remove(void)+3Aj
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?remove@UnicodeString@icu_56@@QAEAAV12@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 43ECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::remove(icu_56::UnicodeString *this, int, int)
		public ?remove@UnicodeString@icu_56@@QAEAAV12@HH@Z
?remove@UnicodeString@icu_56@@QAEAAV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jg	short loc_4428
		cmp	[ebp+arg_4], 7FFFFFFFh
		jnz	short loc_4428
		mov	ecx, [ebp+var_8] ; this
		call	?remove@UnicodeString@icu_56@@QAEAAV12@XZ ; icu_56::UnicodeString::remove(void)
		jmp	short loc_443E
; ---------------------------------------------------------------------------

loc_4428:				; CODE XREF: icu_56::UnicodeString::remove(int,int)+27j
					; icu_56::UnicodeString::remove(int,int)+30j
		push	0		; int
		push	0		; int
		push	0		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)

loc_443E:				; CODE XREF: icu_56::UnicodeString::remove(int,int)+3Aj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?remove@UnicodeString@icu_56@@QAEAAV12@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4454h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::removeBetween(icu_56::UnicodeString *this, int, int)
		public ?removeBetween@UnicodeString@icu_56@@QAEAAV12@HH@Z
?removeBetween@UnicodeString@icu_56@@QAEAAV12@HH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	0		; int
		push	0		; int
		push	0		; wchar_t *
		mov	eax, [ebp+arg_4]
		sub	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?removeBetween@UnicodeString@icu_56@@QAEAAV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 44A8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::retainBetween(icu_56::UnicodeString *this, int, int)
		public ?retainBetween@UnicodeString@icu_56@@QAEAAV12@HH@Z
?retainBetween@UnicodeString@icu_56@@QAEAAV12@HH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?truncate@UnicodeString@icu_56@@QAECH@Z	; icu_56::UnicodeString::truncate(int)
		push	0		; int
		push	0		; int
		push	0		; wchar_t *
		mov	eax, [ebp+arg_0]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?retainBetween@UnicodeString@icu_56@@QAEAAV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4504h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::truncate(icu_56::UnicodeString *this,	int)
		public ?truncate@UnicodeString@icu_56@@QAECH@Z
?truncate@UnicodeString@icu_56@@QAECH@Z	proc near
					; CODE XREF: icu_56::UnicodeString::retainBetween(int,int)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_454A
		cmp	[ebp+arg_0], 0
		jnz	short loc_454A
		mov	ecx, [ebp+var_8] ; this
		call	?unBogus@UnicodeString@icu_56@@AAEXXZ ;	icu_56::UnicodeString::unBogus(void)
		xor	al, al
		jmp	short loc_456B
; ---------------------------------------------------------------------------
		jmp	short loc_456B
; ---------------------------------------------------------------------------

loc_454A:				; CODE XREF: icu_56::UnicodeString::truncate(int)+30j
					; icu_56::UnicodeString::truncate(int)+36j
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		cmp	[ebp+arg_0], eax
		jnb	short loc_4569
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?setLength@UnicodeString@icu_56@@AAEXH@Z ; icu_56::UnicodeString::setLength(int)
		mov	al, 1
		jmp	short loc_456B
; ---------------------------------------------------------------------------
		jmp	short loc_456B
; ---------------------------------------------------------------------------

loc_4569:				; CODE XREF: icu_56::UnicodeString::truncate(int)+51j
		xor	al, al

loc_456B:				; CODE XREF: icu_56::UnicodeString::truncate(int)+42j
					; icu_56::UnicodeString::truncate(int)+44j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?truncate@UnicodeString@icu_56@@QAECH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4584h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::reverse(icu_56::UnicodeString	*__hidden this)
		public ?reverse@UnicodeString@icu_56@@QAEAAV12@XZ
?reverse@UnicodeString@icu_56@@QAEAAV12@XZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReverse@UnicodeString@icu_56@@AAEAAV12@HH@Z ; icu_56::UnicodeString::doReverse(int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?reverse@UnicodeString@icu_56@@QAEAAV12@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 45D0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::reverse(icu_56::UnicodeString	*this, int, int)
		public ?reverse@UnicodeString@icu_56@@QAEAAV12@HH@Z
?reverse@UnicodeString@icu_56@@QAEAAV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReverse@UnicodeString@icu_56@@AAEAAV12@HH@Z ; icu_56::UnicodeString::doReverse(int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?reverse@UnicodeString@icu_56@@QAEAAV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 461Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::UnicodeSet::operator!=(class icu_56::UnicodeSet const &)const
		public ??9UnicodeSet@icu_56@@QBECABV01@@Z
??9UnicodeSet@icu_56@@QBECABV01@@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+1Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9UnicodeSet@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4678h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeSet::isFrozen(icu_56::UnicodeSet *__hidden this)
		public ?isFrozen@UnicodeSet@icu_56@@QBECXZ
?isFrozen@UnicodeSet@icu_56@@QBECXZ proc near

var_D0		= byte ptr -0D0h
var_CD		= byte ptr -0CDh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+14h], 0
		jnz	short loc_46B6
		mov	ecx, [ebp+var_8]
		cmp	dword ptr [ecx+2Ch], 0
		jnz	short loc_46B6
		mov	[ebp+var_CD], 0
		jmp	short loc_46BD
; ---------------------------------------------------------------------------

loc_46B6:				; CODE XREF: icu_56::UnicodeSet::isFrozen(void)+2Aj
					; icu_56::UnicodeSet::isFrozen(void)+33j
		mov	[ebp+var_CD], 1

loc_46BD:				; CODE XREF: icu_56::UnicodeSet::isFrozen(void)+3Cj
		mov	al, [ebp+var_CD]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isFrozen@UnicodeSet@icu_56@@QBECXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 46CCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeSet::containsSome(icu_56::UnicodeSet *this, int, int)
		public ?containsSome@UnicodeSet@icu_56@@QBECHH@Z
?containsSome@UnicodeSet@icu_56@@QBECHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?containsNone@UnicodeSet@icu_56@@QBECHH@Z ; icu_56::UnicodeSet::containsNone(int,int)
		movsx	edx, al
		test	edx, edx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?containsSome@UnicodeSet@icu_56@@QBECHH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4720h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeSet::containsSome(icu_56::UnicodeSet *this, const struct icu_56::UnicodeSet *)
		public ?containsSome@UnicodeSet@icu_56@@QBECABV12@@Z
?containsSome@UnicodeSet@icu_56@@QBECABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeSet *
		mov	ecx, [ebp+var_8] ; this
		call	?containsNone@UnicodeSet@icu_56@@QBECABV12@@Z ;	icu_56::UnicodeSet::containsNone(icu_56::UnicodeSet const &)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?containsSome@UnicodeSet@icu_56@@QBECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4770h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeSet::containsSome(icu_56::UnicodeSet *this, const struct icu_56::UnicodeString *)
		public ?containsSome@UnicodeSet@icu_56@@QBECABVUnicodeString@2@@Z
?containsSome@UnicodeSet@icu_56@@QBECABVUnicodeString@2@@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?containsNone@UnicodeSet@icu_56@@QBECABVUnicodeString@2@@Z ; icu_56::UnicodeSet::containsNone(icu_56::UnicodeString const &)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?containsSome@UnicodeSet@icu_56@@QBECABVUnicodeString@2@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 47C0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeSet::isBogus(icu_56::UnicodeSet *__hidden this)
		public ?isBogus@UnicodeSet@icu_56@@QBECXZ
?isBogus@UnicodeSet@icu_56@@QBECXZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movzx	eax, byte ptr [eax+30h]
		and	eax, 1
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isBogus@UnicodeSet@icu_56@@QBECXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 47F4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeSet *__cdecl icu_56::UnicodeSet::fromUSet(struct USet *)
		public ?fromUSet@UnicodeSet@icu_56@@SAPAV12@PAUUSet@@@Z
?fromUSet@UnicodeSet@icu_56@@SAPAV12@PAUUSet@@@Z proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?fromUSet@UnicodeSet@icu_56@@SAPAV12@PAUUSet@@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 481Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::UnicodeSet *__cdecl icu_56::UnicodeSet::fromUSet(const struct USet *)
		public ?fromUSet@UnicodeSet@icu_56@@SAPBV12@PBUUSet@@@Z
?fromUSet@UnicodeSet@icu_56@@SAPBV12@PBUUSet@@@Z proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?fromUSet@UnicodeSet@icu_56@@SAPBV12@PBUUSet@@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4844h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct USet *__thiscall icu_56::UnicodeSet::toUSet(icu_56::UnicodeSet	*__hidden this)
		public ?toUSet@UnicodeSet@icu_56@@QAEPAUUSet@@XZ
?toUSet@UnicodeSet@icu_56@@QAEPAUUSet@@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?toUSet@UnicodeSet@icu_56@@QAEPAUUSet@@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4874h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct USet *__thiscall	icu_56::UnicodeSet::toUSet(icu_56::UnicodeSet *__hidden	this)
		public ?toUSet@UnicodeSet@icu_56@@QBEPBUUSet@@XZ
?toUSet@UnicodeSet@icu_56@@QBEPBUUSet@@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?toUSet@UnicodeSet@icu_56@@QBEPBUUSet@@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 48A4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: int __thiscall icu_56::UnicodeSet::span(class	icu_56::UnicodeString const &, int, enum  USetSpanCondition)const
		public ?span@UnicodeSet@icu_56@@QBEHABVUnicodeString@2@HW4USetSpanCondition@@@Z
?span@UnicodeSet@icu_56@@QBEHABVUnicodeString@2@HW4USetSpanCondition@@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	[ebp+var_14], eax
		cmp	[ebp+arg_4], 0
		jge	short loc_48E1
		mov	[ebp+arg_4], 0
		jmp	short loc_48EF
; ---------------------------------------------------------------------------

loc_48E1:				; CODE XREF: icu_56::UnicodeSet::span(icu_56::UnicodeString const &,int,USetSpanCondition)+32j
		mov	eax, [ebp+arg_4]
		cmp	eax, [ebp+var_14]
		jle	short loc_48EF
		mov	eax, [ebp+var_14]
		mov	[ebp+arg_4], eax

loc_48EF:				; CODE XREF: icu_56::UnicodeSet::span(icu_56::UnicodeString const &,int,USetSpanCondition)+3Bj
					; icu_56::UnicodeSet::span(icu_56::UnicodeString const &,int,USetSpanCondition)+43j
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+var_14]
		sub	ecx, [ebp+arg_4]
		push	ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ ; icu_56::UnicodeString::getBuffer(void)
		mov	edx, [ebp+arg_4]
		lea	eax, [eax+edx*2]
		push	eax
		mov	ecx, [ebp+var_8]
		call	?span@UnicodeSet@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z ; icu_56::UnicodeSet::span(wchar_t const *,int,USetSpanCondition)
		add	eax, [ebp+arg_4]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?span@UnicodeSet@icu_56@@QBEHABVUnicodeString@2@HW4USetSpanCondition@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 492Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: int __thiscall icu_56::UnicodeSet::spanBack(class icu_56::UnicodeString const	&, int,	enum  USetSpanCondition)const
		public ?spanBack@UnicodeSet@icu_56@@QBEHABVUnicodeString@2@HW4USetSpanCondition@@@Z
?spanBack@UnicodeSet@icu_56@@QBEHABVUnicodeString@2@HW4USetSpanCondition@@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	[ebp+var_14], eax
		cmp	[ebp+arg_4], 0
		jge	short loc_4969
		mov	[ebp+arg_4], 0
		jmp	short loc_4977
; ---------------------------------------------------------------------------

loc_4969:				; CODE XREF: icu_56::UnicodeSet::spanBack(icu_56::UnicodeString	const &,int,USetSpanCondition)+32j
		mov	eax, [ebp+arg_4]
		cmp	eax, [ebp+var_14]
		jle	short loc_4977
		mov	eax, [ebp+var_14]
		mov	[ebp+arg_4], eax

loc_4977:				; CODE XREF: icu_56::UnicodeSet::spanBack(icu_56::UnicodeString	const &,int,USetSpanCondition)+3Bj
					; icu_56::UnicodeSet::spanBack(icu_56::UnicodeString const &,int,USetSpanCondition)+43j
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ ; icu_56::UnicodeString::getBuffer(void)
		push	eax
		mov	ecx, [ebp+var_8]
		call	?spanBack@UnicodeSet@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z ;	icu_56::UnicodeSet::spanBack(wchar_t const *,int,USetSpanCondition)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?spanBack@UnicodeSet@icu_56@@QBEHABVUnicodeString@2@HW4USetSpanCondition@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 49A8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UVector::size(icu_56::UVector *__hidden this)
		public ?size@UVector@icu_56@@QBEHXZ
?size@UVector@icu_56@@QBEHXZ proc near	; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet const &,icu_56::UVector const &,uint)+E5p
					; icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSetStringSpan const	&,icu_56::UVector const	&)+F1p	...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?size@UVector@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 49D8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UVector::isEmpty(icu_56::UVector *__hidden this)
		public ?isEmpty@UVector@icu_56@@QBECXZ
?isEmpty@UVector@icu_56@@QBECXZ	proc near ; CODE XREF: icu_56::UStack::empty(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4], 0
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isEmpty@UVector@icu_56@@QBECXZ	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4A0Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UVector::contains(icu_56::UVector *this, void *)
		public ?contains@UVector@icu_56@@QBECPAX@Z
?contains@UVector@icu_56@@QBECPAX@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; void *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UVector@icu_56@@QBEHPAXH@Z ; icu_56::UVector::indexOf(void *,int)
		test	eax, eax
		setnl	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?contains@UVector@icu_56@@QBECPAX@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4A58h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UVector::contains(icu_56::UVector *this, int)
		public ?contains@UVector@icu_56@@QBECH@Z
?contains@UVector@icu_56@@QBECH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UVector@icu_56@@QBEHHH@Z ; icu_56::UVector::indexOf(int,int)
		test	eax, eax
		setnl	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?contains@UVector@icu_56@@QBECH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4AA4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__thiscall icu_56::UVector::firstElement(icu_56::UVector *__hidden this)
		public ?firstElement@UVector@icu_56@@QBEPAXXZ
?firstElement@UVector@icu_56@@QBEPAXXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?elementAt@UVector@icu_56@@QBEPAXH@Z ; icu_56::UVector::elementAt(int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?firstElement@UVector@icu_56@@QBEPAXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4AE8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__thiscall icu_56::UVector::lastElement(icu_56::UVector	*__hidden this)
		public ?lastElement@UVector@icu_56@@QBEPAXXZ
?lastElement@UVector@icu_56@@QBEPAXXZ proc near	; CODE XREF: icu_56::UStack::peek(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		sub	ecx, 1
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?elementAt@UVector@icu_56@@QBEPAXH@Z ; icu_56::UVector::elementAt(int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?lastElement@UVector@icu_56@@QBEPAXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4B34h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UVector::lastElementi(icu_56::UVector *__hidden this)
		public ?lastElementi@UVector@icu_56@@QBEHXZ
?lastElementi@UVector@icu_56@@QBEHXZ proc near ; CODE XREF: icu_56::UStack::peeki(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		sub	ecx, 1
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?elementAti@UVector@icu_56@@QBEHH@Z ; icu_56::UVector::elementAti(int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?lastElementi@UVector@icu_56@@QBEHXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4B80h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void * __thiscall icu_56::UVector::operator[](int)const
		public ??AUVector@icu_56@@QBEPAXH@Z
??AUVector@icu_56@@QBEPAXH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?elementAt@UVector@icu_56@@QBEPAXH@Z ; icu_56::UVector::elementAt(int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??AUVector@icu_56@@QBEPAXH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4BC8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::UVector::operator!=(class icu_56::UVector const &)
		public ??9UVector@icu_56@@QAECABV01@@Z
??9UVector@icu_56@@QAECABV01@@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??8UVector@icu_56@@QAECABV01@@Z	; icu_56::UVector::operator==(icu_56::UVector const &)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9UVector@icu_56@@QAECABV01@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4C18h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UStack::empty(icu_56::UStack	*__hidden this)
		public ?empty@UStack@icu_56@@QBECXZ
?empty@UStack@icu_56@@QBECXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?isEmpty@UVector@icu_56@@QBECXZ	; icu_56::UVector::isEmpty(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?empty@UStack@icu_56@@QBECXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4C58h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__thiscall icu_56::UStack::peek(icu_56::UStack *__hidden this)
		public ?peek@UStack@icu_56@@QBEPAXXZ
?peek@UStack@icu_56@@QBEPAXXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?lastElement@UVector@icu_56@@QBEPAXXZ ;	icu_56::UVector::lastElement(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?peek@UStack@icu_56@@QBEPAXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4C98h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UStack::peeki(icu_56::UStack *__hidden	this)
		public ?peeki@UStack@icu_56@@QBEHXZ
?peeki@UStack@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?lastElementi@UVector@icu_56@@QBEHXZ ; icu_56::UVector::lastElementi(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?peeki@UStack@icu_56@@QBEHXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4CD8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__thiscall icu_56::UStack::push(icu_56::UStack *this, void *, enum UErrorCode *)
		public ?push@UStack@icu_56@@QAEPAXPAXAAW4UErrorCode@@@Z
?push@UStack@icu_56@@QAEPAXPAXAAW4UErrorCode@@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; void *
		mov	ecx, [ebp+var_8] ; this
		call	?addElement@UVector@icu_56@@QAEXPAXAAW4UErrorCode@@@Z ;	icu_56::UVector::addElement(void *,UErrorCode &)
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?push@UStack@icu_56@@QAEPAXPAXAAW4UErrorCode@@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4D24h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UStack::push(icu_56::UStack *this, int, enum UErrorCode *)
		public ?push@UStack@icu_56@@QAEHHAAW4UErrorCode@@@Z
?push@UStack@icu_56@@QAEHHAAW4UErrorCode@@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?addElement@UVector@icu_56@@QAEXHAAW4UErrorCode@@@Z ; icu_56::UVector::addElement(int,UErrorCode &)
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?push@UStack@icu_56@@QAEHHAAW4UErrorCode@@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4D70h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSetStringSpan *this, const struct	icu_56::UnicodeSet *, const struct icu_56::UVector *, unsigned int)
		public ??0UnicodeSetStringSpan@icu_56@@QAE@ABVUnicodeSet@1@ABVUVector@1@I@Z
??0UnicodeSetStringSpan@icu_56@@QAE@ABVUnicodeSet@1@ABVUVector@1@I@Z proc near

var_210		= byte ptr -210h
var_14C		= dword	ptr -14Ch
var_140		= dword	ptr -140h
var_134		= word ptr -134h
var_128		= dword	ptr -128h
var_11C		= word ptr -11Ch
var_110		= dword	ptr -110h
var_104		= dword	ptr -104h
var_F8		= dword	ptr -0F8h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_D4		= dword	ptr -0D4h
var_C8		= dword	ptr -0C8h
var_BC		= dword	ptr -0BCh
var_B0		= dword	ptr -0B0h
var_A4		= dword	ptr -0A4h
var_98		= dword	ptr -98h
var_8C		= dword	ptr -8Ch
var_80		= dword	ptr -80h
var_71		= byte ptr -71h
var_68		= dword	ptr -68h
var_5C		= dword	ptr -5Ch
var_50		= dword	ptr -50h
var_41		= byte ptr -41h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0UnicodeSetStringSpan@icu_56@@QAE@ABVUnicodeSet@1@ABVUVector@1@I@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 204h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_210]
		mov	ecx, 81h ; ''
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		push	10FFFFh		; int
		push	0		; int
		mov	ecx, [ebp+var_14] ; this
		call	??0UnicodeSet@icu_56@@QAE@HH@Z ; icu_56::UnicodeSet::UnicodeSet(int,int)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+34h], 0
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_4]
		mov	[eax+38h], ecx
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+3Ch], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+40h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+44h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+48h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+4Ch], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+50h], 0
		cmp	[ebp+arg_8], 3Fh ; '?'
		setz	al
		mov	ecx, [ebp+var_14]
		mov	[ecx+54h], al
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_14]
		mov	eax, [edx+3Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_8]
		and	eax, 1
		jz	short loc_4E4F
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_14]
		mov	[eax+34h], ecx

loc_4E4F:				; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet const &,icu_56::UVector const &,uint)+D4j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+38h]	; this
		call	?size@UVector@icu_56@@QBEHXZ ; icu_56::UVector::size(void)
		mov	[ebp+var_20], eax
		mov	[ebp+var_41], 0
		mov	[ebp+var_2C], 0
		jmp	short loc_4E73
; ---------------------------------------------------------------------------

loc_4E6A:				; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet const &,icu_56::UVector const &,uint):loc_4F3Ej
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax

loc_4E73:				; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet const &,icu_56::UVector const &,uint)+F8j
		mov	eax, [ebp+var_2C]
		cmp	eax, [ebp+var_20]
		jge	loc_4F43
		mov	eax, [ebp+var_2C]
		push	eax		; int
		mov	ecx, [ebp+var_14]
		mov	ecx, [ecx+38h]	; this
		call	?elementAt@UVector@icu_56@@QBEPAXH@Z ; icu_56::UVector::elementAt(int)
		mov	[ebp+var_50], eax
		mov	ecx, [ebp+var_50] ; this
		call	?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ ; icu_56::UnicodeString::getBuffer(void)
		mov	[ebp+var_5C], eax
		mov	ecx, [ebp+var_50] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	[ebp+var_68], eax
		push	1
		mov	eax, [ebp+var_68]
		push	eax
		mov	ecx, [ebp+var_5C]
		push	ecx
		mov	ecx, [ebp+var_14]
		call	?span@UnicodeSet@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z ; icu_56::UnicodeSet::span(wchar_t const *,int,USetSpanCondition)
		mov	[ebp+var_38], eax
		mov	eax, [ebp+var_38]
		cmp	eax, [ebp+var_68]
		jge	short loc_4ED0
		mov	[ebp+var_71], 1
		mov	al, [ebp+var_71]
		mov	[ebp+var_41], al
		jmp	short loc_4ED4
; ---------------------------------------------------------------------------

loc_4ED0:				; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet const &,icu_56::UVector const &,uint)+152j
		mov	[ebp+var_71], 0

loc_4ED4:				; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet const &,icu_56::UVector const &,uint)+15Ej
		mov	eax, [ebp+arg_8]
		and	eax, 8
		jz	short loc_4EF0
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_68]
		cmp	ecx, [eax+4Ch]
		jle	short loc_4EF0
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_68]
		mov	[eax+4Ch], ecx

loc_4EF0:				; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet const &,icu_56::UVector const &,uint)+16Aj
					; icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet	const &,icu_56::UVector	const &,uint)+175j
		mov	eax, [ebp+arg_8]
		and	eax, 4
		jz	short loc_4F3E
		movsx	eax, [ebp+var_71]
		test	eax, eax
		jnz	short loc_4F08
		mov	eax, [ebp+arg_8]
		and	eax, 2
		jz	short loc_4F3E

loc_4F08:				; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet const &,icu_56::UVector const &,uint)+18Ej
		mov	eax, [ebp+var_68]
		push	eax
		mov	ecx, [ebp+var_5C]
		push	ecx
		call	?getUTF8Length@icu_56@@YAHPB_WH@Z ; icu_56::getUTF8Length(wchar_t const	*,int)
		add	esp, 8
		mov	[ebp+var_80], eax
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+48h]
		add	ecx, [ebp+var_80]
		mov	edx, [ebp+var_14]
		mov	[edx+48h], ecx
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_80]
		cmp	ecx, [eax+50h]
		jle	short loc_4F3E
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_80]
		mov	[eax+50h], ecx

loc_4F3E:				; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet const &,icu_56::UVector const &,uint)+186j
					; icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet	const &,icu_56::UVector	const &,uint)+196j ...
		jmp	loc_4E6A
; ---------------------------------------------------------------------------

loc_4F43:				; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet const &,icu_56::UVector const &,uint)+109j
		movsx	eax, [ebp+var_41]
		test	eax, eax
		jnz	short loc_4F64
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+50h], 0
		mov	ecx, [ebp+var_14]
		mov	dword ptr [ecx+4Ch], 0
		jmp	loc_5597
; ---------------------------------------------------------------------------

loc_4F64:				; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet const &,icu_56::UVector const &,uint)+1D9j
		mov	eax, [ebp+var_14]
		movsx	ecx, byte ptr [eax+54h]
		test	ecx, ecx
		jz	short loc_4F77
		mov	ecx, [ebp+var_14] ; this
		call	?freeze@UnicodeSet@icu_56@@QAEPAVUnicodeFunctor@2@XZ ; icu_56::UnicodeSet::freeze(void)

loc_4F77:				; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet const &,icu_56::UVector const &,uint)+1FDj
		mov	eax, [ebp+var_14]
		movsx	ecx, byte ptr [eax+54h]
		test	ecx, ecx
		jz	short loc_4F96
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+48h]
		mov	edx, [ebp+var_20]
		lea	eax, [ecx+edx*8]
		mov	[ebp+var_B0], eax
		jmp	short loc_4FBF
; ---------------------------------------------------------------------------

loc_4F96:				; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet const &,icu_56::UVector const &,uint)+210j
		mov	eax, [ebp+var_20]
		mov	[ebp+var_B0], eax
		mov	eax, [ebp+arg_8]
		and	eax, 4
		jz	short loc_4FBF
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+48h]
		mov	edx, [ebp+var_20]
		lea	eax, [ecx+edx*4]
		add	eax, [ebp+var_B0]
		mov	[ebp+var_B0], eax

loc_4FBF:				; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet const &,icu_56::UVector const &,uint)+224j
					; icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet	const &,icu_56::UVector	const &,uint)+235j
		cmp	[ebp+var_B0], 80h ; ''
		jg	short loc_4FD9
		mov	eax, [ebp+var_14]
		add	eax, 58h ; 'X'
		mov	ecx, [ebp+var_14]
		mov	[ecx+3Ch], eax
		jmp	short loc_5010
; ---------------------------------------------------------------------------

loc_4FD9:				; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet const &,icu_56::UVector const &,uint)+259j
		mov	eax, [ebp+var_B0]
		push	eax
		call	_uprv_malloc_56
		add	esp, 4
		mov	ecx, [ebp+var_14]
		mov	[ecx+3Ch], eax
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+3Ch], 0
		jnz	short loc_5010
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+50h], 0
		mov	ecx, [ebp+var_14]
		mov	dword ptr [ecx+4Ch], 0
		jmp	loc_5597
; ---------------------------------------------------------------------------

loc_5010:				; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet const &,icu_56::UVector const &,uint)+267j
					; icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet	const &,icu_56::UVector	const &,uint)+285j
		mov	eax, [ebp+var_14]
		movsx	ecx, byte ptr [eax+54h]
		test	ecx, ecx
		jz	short loc_506B
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+3Ch]
		mov	edx, [ebp+var_20]
		lea	eax, [ecx+edx*4]
		mov	ecx, [ebp+var_14]
		mov	[ecx+40h], eax
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+40h]
		add	ecx, [ebp+var_20]
		mov	[ebp+var_8C], ecx
		mov	eax, [ebp+var_8C]
		add	eax, [ebp+var_20]
		mov	[ebp+var_98], eax
		mov	eax, [ebp+var_98]
		add	eax, [ebp+var_20]
		mov	[ebp+var_A4], eax
		mov	eax, [ebp+var_A4]
		add	eax, [ebp+var_20]
		mov	ecx, [ebp+var_14]
		mov	[ecx+44h], eax
		jmp	short loc_50C6
; ---------------------------------------------------------------------------

loc_506B:				; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet const &,icu_56::UVector const &,uint)+2A9j
		mov	eax, [ebp+arg_8]
		and	eax, 4
		jz	short loc_5096
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+3Ch]
		mov	edx, [ebp+var_20]
		lea	eax, [ecx+edx*4]
		mov	ecx, [ebp+var_14]
		mov	[ecx+40h], eax
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+40h]
		add	ecx, [ebp+var_20]
		mov	edx, [ebp+var_14]
		mov	[edx+44h], ecx
		jmp	short loc_50A2
; ---------------------------------------------------------------------------

loc_5096:				; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet const &,icu_56::UVector const &,uint)+301j
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+3Ch]
		mov	[eax+40h], edx

loc_50A2:				; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet const &,icu_56::UVector const &,uint)+324j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+40h]
		mov	[ebp+var_A4], ecx
		mov	edx, [ebp+var_A4]
		mov	[ebp+var_98], edx
		mov	eax, [ebp+var_98]
		mov	[ebp+var_8C], eax

loc_50C6:				; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet const &,icu_56::UVector const &,uint)+2F9j
		mov	[ebp+var_BC], 0
		mov	[ebp+var_2C], 0
		jmp	short loc_50E2
; ---------------------------------------------------------------------------

loc_50D9:				; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet const &,icu_56::UVector const &,uint):loc_557Cj
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax

loc_50E2:				; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet const &,icu_56::UVector const &,uint)+367j
		mov	eax, [ebp+var_2C]
		cmp	eax, [ebp+var_20]
		jge	loc_5581
		mov	eax, [ebp+var_2C]
		push	eax		; int
		mov	ecx, [ebp+var_14]
		mov	ecx, [ecx+38h]	; this
		call	?elementAt@UVector@icu_56@@QBEPAXH@Z ; icu_56::UVector::elementAt(int)
		mov	[ebp+var_C8], eax
		mov	ecx, [ebp+var_C8] ; this
		call	?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ ; icu_56::UnicodeString::getBuffer(void)
		mov	[ebp+var_D4], eax
		mov	ecx, [ebp+var_C8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	[ebp+var_E0], eax
		push	1
		mov	eax, [ebp+var_E0]
		push	eax
		mov	ecx, [ebp+var_D4]
		push	ecx
		mov	ecx, [ebp+var_14]
		call	?span@UnicodeSet@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z ; icu_56::UnicodeSet::span(wchar_t const *,int,USetSpanCondition)
		mov	[ebp+var_38], eax
		mov	eax, [ebp+var_38]
		cmp	eax, [ebp+var_E0]
		jge	loc_54A5
		mov	eax, [ebp+arg_8]
		and	eax, 8
		jz	loc_51E0
		mov	eax, [ebp+arg_8]
		and	eax, 2
		jz	short loc_51C7
		mov	eax, [ebp+arg_8]
		and	eax, 20h
		jz	short loc_5183
		mov	eax, [ebp+var_38]
		push	eax
		call	?makeSpanLengthByte@icu_56@@YAEH@Z ; icu_56::makeSpanLengthByte(int)
		add	esp, 4
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+40h]
		mov	ecx, [ebp+var_2C]
		mov	[edx+ecx], al

loc_5183:				; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet const &,icu_56::UVector const &,uint)+3F9j
		mov	eax, [ebp+arg_8]
		and	eax, 10h
		jz	short loc_51C5
		push	1
		mov	eax, [ebp+var_E0]
		push	eax
		mov	ecx, [ebp+var_D4]
		push	ecx
		mov	ecx, [ebp+var_14]
		call	?spanBack@UnicodeSet@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z ;	icu_56::UnicodeSet::spanBack(wchar_t const *,int,USetSpanCondition)
		mov	edx, [ebp+var_E0]
		sub	edx, eax
		mov	[ebp+var_38], edx
		mov	eax, [ebp+var_38]
		push	eax
		call	?makeSpanLengthByte@icu_56@@YAEH@Z ; icu_56::makeSpanLengthByte(int)
		add	esp, 4
		mov	ecx, [ebp+var_8C]
		add	ecx, [ebp+var_2C]
		mov	[ecx], al

loc_51C5:				; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet const &,icu_56::UVector const &,uint)+419j
		jmp	short loc_51E0
; ---------------------------------------------------------------------------

loc_51C7:				; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet const &,icu_56::UVector const &,uint)+3F1j
		mov	eax, [ebp+var_8C]
		add	eax, [ebp+var_2C]
		mov	byte ptr [eax],	0
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+40h]
		mov	eax, [ebp+var_2C]
		mov	byte ptr [edx+eax], 0

loc_51E0:				; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet const &,icu_56::UVector const &,uint)+3E5j
					; icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet	const &,icu_56::UVector	const &,uint):loc_51C5j
		mov	eax, [ebp+arg_8]
		and	eax, 4
		jz	loc_5316
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+44h]
		add	ecx, [ebp+var_BC]
		mov	[ebp+var_EC], ecx
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+48h]
		sub	ecx, [ebp+var_BC]
		push	ecx
		mov	edx, [ebp+var_EC]
		push	edx
		mov	eax, [ebp+var_E0]
		push	eax
		mov	ecx, [ebp+var_D4]
		push	ecx
		call	?appendUTF8@icu_56@@YAHPB_WHPAEH@Z ; icu_56::appendUTF8(wchar_t	const *,int,uchar *,int)
		add	esp, 10h
		mov	[ebp+var_F8], eax
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+3Ch]
		mov	edx, [ebp+var_2C]
		mov	eax, [ebp+var_F8]
		mov	[ecx+edx*4], eax
		mov	ecx, [ebp+var_BC]
		add	ecx, [ebp+var_F8]
		mov	[ebp+var_BC], ecx
		cmp	[ebp+var_F8], 0
		jnz	short loc_5278
		mov	eax, [ebp+var_A4]
		add	eax, [ebp+var_2C]
		mov	byte ptr [eax],	0FFh
		mov	ecx, [ebp+var_98]
		add	ecx, [ebp+var_2C]
		mov	byte ptr [ecx],	0FFh
		jmp	loc_5316
; ---------------------------------------------------------------------------

loc_5278:				; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet const &,icu_56::UVector const &,uint)+4E9j
		mov	eax, [ebp+arg_8]
		and	eax, 2
		jz	short loc_52FE
		mov	eax, [ebp+arg_8]
		and	eax, 20h
		jz	short loc_52BA
		push	1
		mov	eax, [ebp+var_F8]
		push	eax
		mov	ecx, [ebp+var_EC]
		push	ecx
		mov	ecx, [ebp+var_14]
		call	?spanUTF8@UnicodeSet@icu_56@@QBEHPBDHW4USetSpanCondition@@@Z ; icu_56::UnicodeSet::spanUTF8(char const *,int,USetSpanCondition)
		mov	[ebp+var_38], eax
		mov	eax, [ebp+var_38]
		push	eax
		call	?makeSpanLengthByte@icu_56@@YAEH@Z ; icu_56::makeSpanLengthByte(int)
		add	esp, 4
		mov	ecx, [ebp+var_98]
		add	ecx, [ebp+var_2C]
		mov	[ecx], al

loc_52BA:				; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet const &,icu_56::UVector const &,uint)+516j
		mov	eax, [ebp+arg_8]
		and	eax, 10h
		jz	short loc_52FC
		push	1
		mov	eax, [ebp+var_F8]
		push	eax
		mov	ecx, [ebp+var_EC]
		push	ecx
		mov	ecx, [ebp+var_14]
		call	?spanBackUTF8@UnicodeSet@icu_56@@QBEHPBDHW4USetSpanCondition@@@Z ; icu_56::UnicodeSet::spanBackUTF8(char const *,int,USetSpanCondition)
		mov	edx, [ebp+var_F8]
		sub	edx, eax
		mov	[ebp+var_38], edx
		mov	eax, [ebp+var_38]
		push	eax
		call	?makeSpanLengthByte@icu_56@@YAEH@Z ; icu_56::makeSpanLengthByte(int)
		add	esp, 4
		mov	ecx, [ebp+var_A4]
		add	ecx, [ebp+var_2C]
		mov	[ecx], al

loc_52FC:				; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet const &,icu_56::UVector const &,uint)+550j
		jmp	short loc_5316
; ---------------------------------------------------------------------------

loc_52FE:				; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet const &,icu_56::UVector const &,uint)+50Ej
		mov	eax, [ebp+var_A4]
		add	eax, [ebp+var_2C]
		mov	byte ptr [eax],	0
		mov	ecx, [ebp+var_98]
		add	ecx, [ebp+var_2C]
		mov	byte ptr [ecx],	0

loc_5316:				; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet const &,icu_56::UVector const &,uint)+476j
					; icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet	const &,icu_56::UVector	const &,uint)+503j ...
		mov	eax, [ebp+arg_8]
		and	eax, 1
		jz	loc_54A0
		mov	eax, [ebp+arg_8]
		and	eax, 20h
		jz	loc_53E2
		mov	[ebp+var_110], 0
		mov	eax, [ebp+var_110]
		mov	ecx, [ebp+var_D4]
		movzx	edx, word ptr [ecx+eax*2]
		mov	[ebp+var_104], edx
		mov	eax, [ebp+var_110]
		add	eax, 1
		mov	[ebp+var_110], eax
		mov	eax, [ebp+var_104]
		and	eax, 0FFFFFC00h
		cmp	eax, 0D800h
		jnz	short loc_53D3
		mov	eax, [ebp+var_110]
		cmp	eax, [ebp+var_E0]
		jz	short loc_53D3
		mov	eax, [ebp+var_110]
		mov	ecx, [ebp+var_D4]
		mov	dx, [ecx+eax*2]
		mov	[ebp+var_11C], dx
		movzx	eax, [ebp+var_11C]
		and	eax, 0FFFFFC00h
		cmp	eax, 0DC00h
		jnz	short loc_53D3
		mov	eax, [ebp+var_110]
		add	eax, 1
		mov	[ebp+var_110], eax
		mov	eax, [ebp+var_104]
		shl	eax, 0Ah
		movzx	ecx, [ebp+var_11C]
		lea	edx, [eax+ecx-35FDC00h]
		mov	[ebp+var_104], edx

loc_53D3:				; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet const &,icu_56::UVector const &,uint)+5FDj
					; icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet	const &,icu_56::UVector	const &,uint)+60Bj ...
		mov	eax, [ebp+var_104]
		push	eax		; int
		mov	ecx, [ebp+var_14] ; this
		call	?addToSpanNotSet@UnicodeSetStringSpan@icu_56@@AAEXH@Z ;	icu_56::UnicodeSetStringSpan::addToSpanNotSet(int)

loc_53E2:				; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet const &,icu_56::UVector const &,uint)+5B8j
		mov	eax, [ebp+arg_8]
		and	eax, 10h
		jz	loc_54A0
		mov	eax, [ebp+var_E0]
		mov	[ebp+var_128], eax
		mov	eax, [ebp+var_128]
		sub	eax, 1
		mov	[ebp+var_128], eax
		mov	ecx, [ebp+var_128]
		mov	edx, [ebp+var_D4]
		movzx	eax, word ptr [edx+ecx*2]
		mov	[ebp+var_104], eax
		mov	eax, [ebp+var_104]
		and	eax, 0FFFFFC00h
		cmp	eax, 0DC00h
		jnz	short loc_5491
		cmp	[ebp+var_128], 0
		jle	short loc_5491
		mov	eax, [ebp+var_128]
		mov	ecx, [ebp+var_D4]
		mov	dx, [ecx+eax*2-2]
		mov	[ebp+var_134], dx
		movzx	eax, [ebp+var_134]
		and	eax, 0FFFFFC00h
		cmp	eax, 0D800h
		jnz	short loc_5491
		mov	eax, [ebp+var_128]
		sub	eax, 1
		mov	[ebp+var_128], eax
		movzx	eax, [ebp+var_134]
		shl	eax, 0Ah
		mov	ecx, [ebp+var_104]
		lea	edx, [eax+ecx-35FDC00h]
		mov	[ebp+var_104], edx

loc_5491:				; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet const &,icu_56::UVector const &,uint)+6BFj
					; icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet	const &,icu_56::UVector	const &,uint)+6C8j ...
		mov	eax, [ebp+var_104]
		push	eax		; int
		mov	ecx, [ebp+var_14] ; this
		call	?addToSpanNotSet@UnicodeSetStringSpan@icu_56@@AAEXH@Z ;	icu_56::UnicodeSetStringSpan::addToSpanNotSet(int)

loc_54A0:				; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet const &,icu_56::UVector const &,uint)+5ACj
					; icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet	const &,icu_56::UVector	const &,uint)+678j
		jmp	loc_557C
; ---------------------------------------------------------------------------

loc_54A5:				; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet const &,icu_56::UVector const &,uint)+3D9j
		mov	eax, [ebp+arg_8]
		and	eax, 4
		jz	loc_5531
		mov	eax, [ebp+arg_8]
		and	eax, 2
		jz	short loc_5521
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+44h]
		add	ecx, [ebp+var_BC]
		mov	[ebp+var_140], ecx
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+48h]
		sub	ecx, [ebp+var_BC]
		push	ecx
		mov	edx, [ebp+var_140]
		push	edx
		mov	eax, [ebp+var_E0]
		push	eax
		mov	ecx, [ebp+var_D4]
		push	ecx
		call	?appendUTF8@icu_56@@YAHPB_WHPAEH@Z ; icu_56::appendUTF8(wchar_t	const *,int,uchar *,int)
		add	esp, 10h
		mov	[ebp+var_14C], eax
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+3Ch]
		mov	edx, [ebp+var_2C]
		mov	eax, [ebp+var_14C]
		mov	[ecx+edx*4], eax
		mov	ecx, [ebp+var_BC]
		add	ecx, [ebp+var_14C]
		mov	[ebp+var_BC], ecx
		jmp	short loc_5531
; ---------------------------------------------------------------------------

loc_5521:				; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet const &,icu_56::UVector const &,uint)+747j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+3Ch]
		mov	edx, [ebp+var_2C]
		mov	dword ptr [ecx+edx*4], 0

loc_5531:				; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet const &,icu_56::UVector const &,uint)+73Bj
					; icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet	const &,icu_56::UVector	const &,uint)+7AFj
		mov	eax, [ebp+var_14]
		movsx	ecx, byte ptr [eax+54h]
		test	ecx, ecx
		jz	short loc_556F
		mov	eax, [ebp+var_A4]
		add	eax, [ebp+var_2C]
		mov	byte ptr [eax],	0FFh
		mov	ecx, [ebp+var_98]
		add	ecx, [ebp+var_2C]
		mov	byte ptr [ecx],	0FFh
		mov	edx, [ebp+var_8C]
		add	edx, [ebp+var_2C]
		mov	byte ptr [edx],	0FFh
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+40h]
		mov	edx, [ebp+var_2C]
		mov	byte ptr [ecx+edx], 0FFh
		jmp	short loc_557C
; ---------------------------------------------------------------------------

loc_556F:				; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet const &,icu_56::UVector const &,uint)+7CAj
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+40h]
		mov	edx, [ebp+var_2C]
		mov	byte ptr [ecx+edx], 0FFh

loc_557C:				; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet const &,icu_56::UVector const &,uint):loc_54A0j
					; icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet	const &,icu_56::UVector	const &,uint)+7FDj
		jmp	loc_50D9
; ---------------------------------------------------------------------------

loc_5581:				; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet const &,icu_56::UVector const &,uint)+378j
		mov	eax, [ebp+var_14]
		movsx	ecx, byte ptr [eax+54h]
		test	ecx, ecx
		jz	short loc_5597
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+34h]	; this
		call	?freeze@UnicodeSet@icu_56@@QAEPAVUnicodeFunctor@2@XZ ; icu_56::UnicodeSet::freeze(void)

loc_5597:				; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet const &,icu_56::UVector const &,uint)+1EFj
					; icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet	const &,icu_56::UVector	const &,uint)+29Bj ...
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 210h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
??0UnicodeSetStringSpan@icu_56@@QAE@ABVUnicodeSet@1@ABVUVector@1@I@Z endp ; sp-analysis	failed

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 55C4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0UnicodeSetStringSpan@icu_56@@QAE@ABVUnicodeSet@1@ABVUVector@1@I@Z$0 proc near
					; DATA XREF: .xdata$x:000055F0o
		mov	ecx, [ebp-14h]	; this
		jmp	??1UnicodeSet@icu_56@@UAE@XZ ; icu_56::UnicodeSet::~UnicodeSet(void)
__unwindfunclet$??0UnicodeSetStringSpan@icu_56@@QAE@ABVUnicodeSet@1@ABVUVector@1@I@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0UnicodeSetStringSpan@icu_56@@QAE@ABVUnicodeSet@1@ABVUVector@1@I@Z proc near
					; DATA XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet const &,icu_56::UVector const &,uint)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-214h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0UnicodeSetStringSpan@icu_56@@QAE@ABVUnicodeSet@1@ABVUVector@1@I@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0UnicodeSetStringSpan@icu_56@@QAE@ABVUnicodeSet@1@ABVUVector@1@I@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 55ECh
__unwindtable$??0UnicodeSetStringSpan@icu_56@@QAE@ABVUnicodeSet@1@ABVUVector@1@I@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000055FCo
		dd offset __unwindfunclet$??0UnicodeSetStringSpan@icu_56@@QAE@ABVUnicodeSet@1@ABVUVector@1@I@Z$0
__ehfuncinfo$??0UnicodeSetStringSpan@icu_56@@QAE@ABVUnicodeSet@1@ABVUVector@1@I@Z dd 19930522h,	1
					; DATA XREF: __ehhandler$??0UnicodeSetStringSpan@icu_56@@QAE@ABVUnicodeSet@1@ABVUVector@1@I@Z+14o
		dd offset __unwindtable$??0UnicodeSetStringSpan@icu_56@@QAE@ABVUnicodeSet@1@ABVUVector@1@I@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5618h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl icu_56::getUTF8Length(wchar_t const *, int)
?getUTF8Length@icu_56@@YAHPB_WH@Z proc near
					; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet const &,icu_56::UVector const &,uint)+1A0p

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	[ebp+var_14], 0
		lea	eax, [ebp+var_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		lea	eax, [ebp+var_14]
		push	eax
		push	0
		push	0
		call	_u_strToUTF8_56
		add	esp, 18h
		mov	eax, [ebp+var_8]
		push	eax
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jnz	short loc_5679
		cmp	[ebp+var_8], 0Fh
		jnz	short loc_5680

loc_5679:				; CODE XREF: icu_56::getUTF8Length(wchar_t const *,int)+59j
		mov	eax, [ebp+var_14]
		jmp	short loc_5682
; ---------------------------------------------------------------------------
		jmp	short loc_5682
; ---------------------------------------------------------------------------

loc_5680:				; CODE XREF: icu_56::getUTF8Length(wchar_t const *,int)+5Fj
		xor	eax, eax

loc_5682:				; CODE XREF: icu_56::getUTF8Length(wchar_t const *,int)+64j
					; icu_56::getUTF8Length(wchar_t	const *,int)+66j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN9
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getUTF8Length@icu_56@@YAHPB_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN9		dd 2			; DATA XREF: icu_56::getUTF8Length(wchar_t const *,int)+6Eo
		dd offset $LN8
$LN8		dd 0FFFFFFF8h, 4	; DATA XREF: .text:000056ACo
		dd offset $LN6		; "errorCode"
		dd 0FFFFFFECh, 4
		dd offset $LN7		; "length8"
$LN7		db 'length8',0          ; DATA XREF: .text:000056C4o
$LN6		db 'errorCode',0        ; DATA XREF: .text:000056B8o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 56DCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl U_SUCCESS(enum  UErrorCode)
?U_SUCCESS@@YACW4UErrorCode@@@Z	proc near
					; CODE XREF: icu_56::getUTF8Length(wchar_t const *,int)+4Cp
					; icu_56::appendUTF8(wchar_t const *,int,uchar *,int)+50p

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		setle	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?U_SUCCESS@@YACW4UErrorCode@@@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5708h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl icu_56::appendUTF8(wchar_t const *, int, unsigned	char *,	int)
?appendUTF8@icu_56@@YAHPB_WHPAEH@Z proc	near
					; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet const &,icu_56::UVector const &,uint)+4B0p
					; icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet	const &,icu_56::UVector	const &,uint)+77Dp

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	[ebp+var_14], 0
		lea	eax, [ebp+var_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		lea	eax, [ebp+var_14]
		push	eax
		mov	ecx, [ebp+arg_C]
		push	ecx
		mov	edx, [ebp+arg_8]
		push	edx
		call	_u_strToUTF8_56
		add	esp, 18h
		mov	eax, [ebp+var_8]
		push	eax
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_576E
		mov	eax, [ebp+var_14]
		jmp	short loc_5770
; ---------------------------------------------------------------------------
		jmp	short loc_5770
; ---------------------------------------------------------------------------

loc_576E:				; CODE XREF: icu_56::appendUTF8(wchar_t	const *,int,uchar *,int)+5Dj
		xor	eax, eax

loc_5770:				; CODE XREF: icu_56::appendUTF8(wchar_t	const *,int,uchar *,int)+62j
					; icu_56::appendUTF8(wchar_t const *,int,uchar *,int)+64j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN8_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?appendUTF8@icu_56@@YAHPB_WHPAEH@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN8_0		dd 2			; DATA XREF: icu_56::appendUTF8(wchar_t	const *,int,uchar *,int)+6Co
		dd offset $LN7_0
$LN7_0		dd 0FFFFFFF8h, 4	; DATA XREF: .text:0000579Co
		dd offset $LN5		; "errorCode"
		dd 0FFFFFFECh, 4
		dd offset $LN6_0	; "length8"
$LN6_0		db 'length8',0          ; DATA XREF: .text:000057B4o
$LN5		db 'errorCode',0        ; DATA XREF: .text:000057A8o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 57CCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; unsigned char	__cdecl	icu_56::makeSpanLengthByte(int)
?makeSpanLengthByte@icu_56@@YAEH@Z proc	near
					; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet const &,icu_56::UVector const &,uint)+3FFp
					; icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet	const &,icu_56::UVector	const &,uint)+442p ...

var_C4		= byte ptr -0C4h
var_C1		= byte ptr -0C1h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C4]
		mov	ecx, 31h ; '1'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0FEh ; ''
		jge	short loc_57FE
		mov	al, byte ptr [ebp+arg_0]
		mov	[ebp+var_C1], al
		jmp	short loc_5805
; ---------------------------------------------------------------------------

loc_57FE:				; CODE XREF: icu_56::makeSpanLengthByte(int)+25j
		mov	[ebp+var_C1], 0FEh ; ''

loc_5805:				; CODE XREF: icu_56::makeSpanLengthByte(int)+30j
		mov	al, [ebp+var_C1]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?makeSpanLengthByte@icu_56@@YAEH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5814h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSetStringSpan *this, const struct	icu_56::UnicodeSetStringSpan *,	const struct icu_56::UVector *)
		public ??0UnicodeSetStringSpan@icu_56@@QAE@ABV01@ABVUVector@1@@Z
??0UnicodeSetStringSpan@icu_56@@QAE@ABV01@ABVUVector@1@@Z proc near

var_F0		= byte ptr -0F0h
Size		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0UnicodeSetStringSpan@icu_56@@QAE@ABV01@ABVUVector@1@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F0]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeSet *
		mov	ecx, [ebp+var_14] ; this
		call	??0UnicodeSet@icu_56@@QAE@ABV01@@Z ; icu_56::UnicodeSet::UnicodeSet(icu_56::UnicodeSet const &)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+34h], 0
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_4]
		mov	[eax+38h], ecx
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+3Ch], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+40h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+44h], 0
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+48h]
		mov	[eax+48h], edx
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4Ch]
		mov	[eax+4Ch], edx
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+50h]
		mov	[eax+50h], edx
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+54h], 1
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+34h]
		cmp	ecx, [ebp+arg_0]
		jnz	short loc_58DB
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_14]
		mov	[eax+34h], ecx
		jmp	short loc_58FF
; ---------------------------------------------------------------------------

loc_58DB:				; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSetStringSpan const &,icu_56::UVector const &)+BAj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+34h]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+34h]
		mov	edx, [ecx]
		mov	esi, esp
		mov	ecx, eax
		mov	eax, [edx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_14]
		mov	[ecx+34h], eax

loc_58FF:				; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSetStringSpan const &,icu_56::UVector const &)+C5j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+38h]	; this
		call	?size@UVector@icu_56@@QBEHXZ ; icu_56::UVector::size(void)
		mov	[ebp+var_20], eax
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+48h]
		mov	edx, [ebp+var_20]
		lea	eax, [ecx+edx*8]
		mov	[ebp+Size], eax
		cmp	[ebp+Size], 80h	; ''
		jg	short loc_5933
		mov	eax, [ebp+var_14]
		add	eax, 58h ; 'X'
		mov	ecx, [ebp+var_14]
		mov	[ecx+3Ch], eax
		jmp	short loc_5964
; ---------------------------------------------------------------------------

loc_5933:				; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSetStringSpan const &,icu_56::UVector const &)+10Fj
		mov	eax, [ebp+Size]
		push	eax
		call	_uprv_malloc_56
		add	esp, 4
		mov	ecx, [ebp+var_14]
		mov	[ecx+3Ch], eax
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+3Ch], 0
		jnz	short loc_5964
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+50h], 0
		mov	ecx, [ebp+var_14]
		mov	dword ptr [ecx+4Ch], 0
		jmp	short loc_59B3
; ---------------------------------------------------------------------------

loc_5964:				; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSetStringSpan const &,icu_56::UVector const &)+11Dj
					; icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSetStringSpan const	&,icu_56::UVector const	&)+138j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+3Ch]
		mov	edx, [ebp+var_20]
		lea	eax, [ecx+edx*4]
		mov	ecx, [ebp+var_14]
		mov	[ecx+40h], eax
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+40h]
		mov	edx, [ebp+var_20]
		lea	eax, [ecx+edx*4]
		mov	ecx, [ebp+var_14]
		mov	[ecx+44h], eax
		push	1
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+3Ch]
		push	ecx
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	edx, [ebp+Size]
		push	edx		; Size
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+3Ch]
		push	ecx		; Src
		mov	edx, [ebp+var_14]
		mov	eax, [edx+3Ch]
		push	eax		; Dst
		call	_memcpy
		add	esp, 0Ch

loc_59B3:				; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSetStringSpan const &,icu_56::UVector const &)+14Ej
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??0UnicodeSetStringSpan@icu_56@@QAE@ABV01@ABVUVector@1@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 59E0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0UnicodeSetStringSpan@icu_56@@QAE@ABV01@ABVUVector@1@@Z$0 proc near
					; DATA XREF: .xdata$x:00005A0Co
		mov	ecx, [ebp-14h]	; this
		jmp	??1UnicodeSet@icu_56@@UAE@XZ ; icu_56::UnicodeSet::~UnicodeSet(void)
__unwindfunclet$??0UnicodeSetStringSpan@icu_56@@QAE@ABV01@ABVUVector@1@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0UnicodeSetStringSpan@icu_56@@QAE@ABV01@ABVUVector@1@@Z proc near
					; DATA XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSetStringSpan const &,icu_56::UVector const &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0F4h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0UnicodeSetStringSpan@icu_56@@QAE@ABV01@ABVUVector@1@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0UnicodeSetStringSpan@icu_56@@QAE@ABV01@ABVUVector@1@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 5A08h
__unwindtable$??0UnicodeSetStringSpan@icu_56@@QAE@ABV01@ABVUVector@1@@Z	dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00005A18o
		dd offset __unwindfunclet$??0UnicodeSetStringSpan@icu_56@@QAE@ABV01@ABVUVector@1@@Z$0
__ehfuncinfo$??0UnicodeSetStringSpan@icu_56@@QAE@ABV01@ABVUVector@1@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$??0UnicodeSetStringSpan@icu_56@@QAE@ABV01@ABVUVector@1@@Z+14o
		dd offset __unwindtable$??0UnicodeSetStringSpan@icu_56@@QAE@ABV01@ABVUVector@1@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5A34h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UnicodeSetStringSpan::~UnicodeSetStringSpan(icu_56::UnicodeSetStringSpan *__hidden this)
		public ??1UnicodeSetStringSpan@icu_56@@QAE@XZ
??1UnicodeSetStringSpan@icu_56@@QAE@XZ proc near

var_F4		= dword	ptr -0F4h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??1UnicodeSetStringSpan@icu_56@@QAE@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+34h], 0
		jz	short loc_5AE1
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+34h]
		cmp	ecx, [ebp+var_14]
		jz	short loc_5AE1
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+34h]
		mov	[ebp+var_E0], ecx
		mov	edx, [ebp+var_E0]
		mov	[ebp+var_EC], edx
		cmp	[ebp+var_EC], 0
		jz	short loc_5AD7
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_EC]
		mov	edx, [eax]
		mov	ecx, [ebp+var_EC]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_F4], eax
		jmp	short loc_5AE1
; ---------------------------------------------------------------------------

loc_5AD7:				; CODE XREF: icu_56::UnicodeSetStringSpan::~UnicodeSetStringSpan(void)+7Cj
		mov	[ebp+var_F4], 0

loc_5AE1:				; CODE XREF: icu_56::UnicodeSetStringSpan::~UnicodeSetStringSpan(void)+50j
					; icu_56::UnicodeSetStringSpan::~UnicodeSetStringSpan(void)+5Bj ...
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+3Ch], 0
		jz	short loc_5B07
		mov	eax, [ebp+var_14]
		add	eax, 58h ; 'X'
		mov	ecx, [ebp+var_14]
		cmp	[ecx+3Ch], eax
		jz	short loc_5B07
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+3Ch]
		push	ecx
		call	_uprv_free_56
		add	esp, 4

loc_5B07:				; CODE XREF: icu_56::UnicodeSetStringSpan::~UnicodeSetStringSpan(void)+B4j
					; icu_56::UnicodeSetStringSpan::~UnicodeSetStringSpan(void)+C2j
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_14] ; this
		call	??1UnicodeSet@icu_56@@UAE@XZ ; icu_56::UnicodeSet::~UnicodeSet(void)
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1UnicodeSetStringSpan@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 5B38h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1UnicodeSetStringSpan@icu_56@@QAE@XZ$0 proc near
					; DATA XREF: .xdata$x:00005B64o
		mov	ecx, [ebp-14h]	; this
		jmp	??1UnicodeSet@icu_56@@UAE@XZ ; icu_56::UnicodeSet::~UnicodeSet(void)
__unwindfunclet$??1UnicodeSetStringSpan@icu_56@@QAE@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??1UnicodeSetStringSpan@icu_56@@QAE@XZ proc	near
					; DATA XREF: icu_56::UnicodeSetStringSpan::~UnicodeSetStringSpan(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0F8h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??1UnicodeSetStringSpan@icu_56@@QAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??1UnicodeSetStringSpan@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 5B60h
__unwindtable$??1UnicodeSetStringSpan@icu_56@@QAE@XZ dd	0FFFFFFFFh
					; DATA XREF: .xdata$x:00005B70o
		dd offset __unwindfunclet$??1UnicodeSetStringSpan@icu_56@@QAE@XZ$0
__ehfuncinfo$??1UnicodeSetStringSpan@icu_56@@QAE@XZ dd 19930522h, 1
					; DATA XREF: __ehhandler$??1UnicodeSetStringSpan@icu_56@@QAE@XZ+14o
		dd offset __unwindtable$??1UnicodeSetStringSpan@icu_56@@QAE@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5B8Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeSetStringSpan::addToSpanNotSet(icu_56::UnicodeSetStringSpan *this, int)
		public ?addToSpanNotSet@UnicodeSetStringSpan@icu_56@@AAEXH@Z
?addToSpanNotSet@UnicodeSetStringSpan@icu_56@@AAEXH@Z proc near
					; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet const &,icu_56::UVector const &,uint)+66Dp
					; icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet	const &,icu_56::UVector	const &,uint)+72Bp

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+34h], 0
		jz	short loc_5BC3
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+34h]
		cmp	ecx, [ebp+var_8]
		jnz	short loc_5C04

loc_5BC3:				; CODE XREF: icu_56::UnicodeSetStringSpan::addToSpanNotSet(int)+2Aj
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+18h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_5BE6
		jmp	short loc_5C13
; ---------------------------------------------------------------------------

loc_5BE6:				; CODE XREF: icu_56::UnicodeSetStringSpan::addToSpanNotSet(int)+56j
		mov	ecx, [ebp+var_8] ; this
		call	?cloneAsThawed@UnicodeSet@icu_56@@QBEPAVUnicodeFunctor@2@XZ ; icu_56::UnicodeSet::cloneAsThawed(void)
		mov	[ebp+var_14], eax
		cmp	[ebp+var_14], 0
		jnz	short loc_5BFB
		jmp	short loc_5C13
; ---------------------------------------------------------------------------
		jmp	short loc_5C04
; ---------------------------------------------------------------------------

loc_5BFB:				; CODE XREF: icu_56::UnicodeSetStringSpan::addToSpanNotSet(int)+69j
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		mov	[eax+34h], ecx

loc_5C04:				; CODE XREF: icu_56::UnicodeSetStringSpan::addToSpanNotSet(int)+35j
					; icu_56::UnicodeSetStringSpan::addToSpanNotSet(int)+6Dj
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8]
		mov	ecx, [ecx+34h]	; this
		call	?add@UnicodeSet@icu_56@@QAEAAV12@H@Z ; icu_56::UnicodeSet::add(int)

loc_5C13:				; CODE XREF: icu_56::UnicodeSetStringSpan::addToSpanNotSet(int)+58j
					; icu_56::UnicodeSetStringSpan::addToSpanNotSet(int)+6Bj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?addToSpanNotSet@UnicodeSetStringSpan@icu_56@@AAEXH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5C2Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: int __thiscall icu_56::UnicodeSetStringSpan::span(wchar_t const *, int, enum	USetSpanCondition)const
		public ?span@UnicodeSetStringSpan@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z
?span@UnicodeSetStringSpan@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z proc near

var_218		= byte ptr -218h
var_214		= dword	ptr -214h
var_208		= dword	ptr -208h
var_1FC		= dword	ptr -1FCh
var_1F0		= dword	ptr -1F0h
var_1E4		= dword	ptr -1E4h
var_118		= dword	ptr -118h
var_10C		= dword	ptr -10Ch
var_100		= dword	ptr -100h
var_F4		= dword	ptr -0F4h
var_E8		= dword	ptr -0E8h
var_DC		= dword	ptr -0DCh
var_D0		= dword	ptr -0D0h
var_C4		= dword	ptr -0C4h
var_B8		= dword	ptr -0B8h
var_AC		= dword	ptr -0ACh
var_A0		= dword	ptr -0A0h
var_94		= dword	ptr -94h
var_88		= dword	ptr -88h
var_7C		= dword	ptr -7Ch
var_70		= dword	ptr -70h
var_64		= dword	ptr -64h
var_58		= dword	ptr -58h
var_4C		= byte ptr -4Ch
var_24		= dword	ptr -24h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?span@UnicodeSetStringSpan@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 20Ch
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_218]
		mov	ecx, 83h ; ''
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		cmp	[ebp+arg_8], 0
		jnz	short loc_5C8C
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; wchar_t *
		mov	ecx, [ebp+var_18] ; this
		call	?spanNot@UnicodeSetStringSpan@icu_56@@ABEHPB_WH@Z ; icu_56::UnicodeSetStringSpan::spanNot(wchar_t const	*,int)
		jmp	loc_620C
; ---------------------------------------------------------------------------

loc_5C8C:				; CODE XREF: icu_56::UnicodeSetStringSpan::span(wchar_t	const *,int,USetSpanCondition)+49j
		push	1
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	ecx, [ebp+var_18]
		call	?span@UnicodeSet@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z ; icu_56::UnicodeSet::span(wchar_t const *,int,USetSpanCondition)
		mov	[ebp+var_24], eax
		mov	eax, [ebp+var_24]
		cmp	eax, [ebp+arg_4]
		jnz	short loc_5CB1
		mov	eax, [ebp+arg_4]
		jmp	loc_620C
; ---------------------------------------------------------------------------

loc_5CB1:				; CODE XREF: icu_56::UnicodeSetStringSpan::span(wchar_t	const *,int,USetSpanCondition)+7Bj
		lea	ecx, [ebp+var_4C] ; this
		call	??0OffsetList@icu_56@@QAE@XZ ; icu_56::OffsetList::OffsetList(void)
		mov	[ebp+var_4], 0
		cmp	[ebp+arg_8], 1
		jnz	short loc_5CD5
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+4Ch]
		push	ecx		; int
		lea	ecx, [ebp+var_4C] ; this
		call	?setMaxLength@OffsetList@icu_56@@QAEXH@Z ; icu_56::OffsetList::setMaxLength(int)

loc_5CD5:				; CODE XREF: icu_56::UnicodeSetStringSpan::span(wchar_t	const *,int,USetSpanCondition)+98j
		mov	eax, [ebp+var_24]
		mov	[ebp+var_58], eax
		mov	eax, [ebp+arg_4]
		sub	eax, [ebp+var_58]
		mov	[ebp+var_64], eax
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+38h]	; this
		call	?size@UVector@icu_56@@QBEHXZ ; icu_56::UVector::size(void)
		mov	[ebp+var_7C], eax

loc_5CF2:				; CODE XREF: icu_56::UnicodeSetStringSpan::span(wchar_t	const *,int,USetSpanCondition)+46Bj
					; icu_56::UnicodeSetStringSpan::span(wchar_t const *,int,USetSpanCondition)+523j ...
		cmp	[ebp+arg_8], 1
		jnz	loc_5EDC
		mov	[ebp+var_70], 0
		jmp	short loc_5D0E
; ---------------------------------------------------------------------------

loc_5D05:				; CODE XREF: icu_56::UnicodeSetStringSpan::span(wchar_t	const *,int,USetSpanCondition)+10Dj
					; icu_56::UnicodeSetStringSpan::span(wchar_t const *,int,USetSpanCondition):loc_5ED2j
		mov	eax, [ebp+var_70]
		add	eax, 1
		mov	[ebp+var_70], eax

loc_5D0E:				; CODE XREF: icu_56::UnicodeSetStringSpan::span(wchar_t	const *,int,USetSpanCondition)+D7j
		mov	eax, [ebp+var_70]
		cmp	eax, [ebp+var_7C]
		jge	loc_5ED7
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+40h]
		mov	edx, [ebp+var_70]
		movzx	eax, byte ptr [ecx+edx]
		mov	[ebp+var_88], eax
		cmp	[ebp+var_88], 0FFh
		jnz	short loc_5D3B
		jmp	short loc_5D05
; ---------------------------------------------------------------------------

loc_5D3B:				; CODE XREF: icu_56::UnicodeSetStringSpan::span(wchar_t	const *,int,USetSpanCondition)+10Bj
		mov	eax, [ebp+var_70]
		push	eax		; int
		mov	ecx, [ebp+var_18]
		mov	ecx, [ecx+38h]	; this
		call	?elementAt@UVector@icu_56@@QBEPAXH@Z ; icu_56::UVector::elementAt(int)
		mov	[ebp+var_94], eax
		mov	ecx, [ebp+var_94] ; this
		call	?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ ; icu_56::UnicodeString::getBuffer(void)
		mov	[ebp+var_A0], eax
		mov	ecx, [ebp+var_94] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	[ebp+var_AC], eax
		cmp	[ebp+var_88], 0FEh ; ''
		jl	short loc_5DEC
		mov	eax, [ebp+var_AC]
		mov	[ebp+var_88], eax
		mov	eax, [ebp+var_88]
		sub	eax, 1
		mov	[ebp+var_88], eax
		mov	ecx, [ebp+var_88]
		mov	edx, [ebp+var_A0]
		movzx	eax, word ptr [edx+ecx*2]
		and	eax, 0FFFFFC00h
		cmp	eax, 0DC00h
		jnz	short loc_5DEC
		cmp	[ebp+var_88], 0
		jle	short loc_5DEC
		mov	eax, [ebp+var_88]
		mov	ecx, [ebp+var_A0]
		movzx	edx, word ptr [ecx+eax*2-2]
		and	edx, 0FFFFFC00h
		cmp	edx, 0D800h
		jnz	short loc_5DEC
		mov	eax, [ebp+var_88]
		sub	eax, 1
		mov	[ebp+var_88], eax

loc_5DEC:				; CODE XREF: icu_56::UnicodeSetStringSpan::span(wchar_t	const *,int,USetSpanCondition)+150j
					; icu_56::UnicodeSetStringSpan::span(wchar_t const *,int,USetSpanCondition)+187j ...
		mov	eax, [ebp+var_88]
		cmp	eax, [ebp+var_24]
		jle	short loc_5E00
		mov	eax, [ebp+var_24]
		mov	[ebp+var_88], eax

loc_5E00:				; CODE XREF: icu_56::UnicodeSetStringSpan::span(wchar_t	const *,int,USetSpanCondition)+1C9j
		mov	eax, [ebp+var_AC]
		sub	eax, [ebp+var_88]
		mov	[ebp+var_B8], eax

loc_5E12:				; CODE XREF: icu_56::UnicodeSetStringSpan::span(wchar_t	const *,int,USetSpanCondition)+2A1j
		mov	eax, [ebp+var_B8]
		cmp	eax, [ebp+var_64]
		jle	short loc_5E22
		jmp	loc_5ED2
; ---------------------------------------------------------------------------

loc_5E22:				; CODE XREF: icu_56::UnicodeSetStringSpan::span(wchar_t	const *,int,USetSpanCondition)+1EFj
		mov	eax, [ebp+var_B8]
		push	eax		; int
		lea	ecx, [ebp+var_4C] ; this
		call	?containsOffset@OffsetList@icu_56@@QBECH@Z ; icu_56::OffsetList::containsOffset(int)
		movsx	ecx, al
		test	ecx, ecx
		jnz	short loc_5EA4
		mov	eax, [ebp+var_AC]
		push	eax
		mov	ecx, [ebp+var_A0]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+var_58]
		sub	eax, [ebp+var_88]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?matches16CPB@icu_56@@YACPB_WHH0H@Z ; icu_56::matches16CPB(wchar_t const *,int,int,wchar_t const *,int)
		add	esp, 14h
		movsx	edx, al
		test	edx, edx
		jz	short loc_5EA4
		mov	eax, [ebp+var_B8]
		cmp	eax, [ebp+var_64]
		jnz	short loc_5E95
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_214], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_4C] ; this
		call	??1OffsetList@icu_56@@QAE@XZ ; icu_56::OffsetList::~OffsetList(void)
		mov	eax, [ebp+var_214]
		jmp	loc_620C
; ---------------------------------------------------------------------------

loc_5E95:				; CODE XREF: icu_56::UnicodeSetStringSpan::span(wchar_t	const *,int,USetSpanCondition)+244j
		mov	eax, [ebp+var_B8]
		push	eax		; int
		lea	ecx, [ebp+var_4C] ; this
		call	?addOffset@OffsetList@icu_56@@QAEXH@Z ;	icu_56::OffsetList::addOffset(int)

loc_5EA4:				; CODE XREF: icu_56::UnicodeSetStringSpan::span(wchar_t	const *,int,USetSpanCondition)+20Aj
					; icu_56::UnicodeSetStringSpan::span(wchar_t const *,int,USetSpanCondition)+239j
		cmp	[ebp+var_88], 0
		jnz	short loc_5EAF
		jmp	short loc_5ED2
; ---------------------------------------------------------------------------

loc_5EAF:				; CODE XREF: icu_56::UnicodeSetStringSpan::span(wchar_t	const *,int,USetSpanCondition)+27Fj
		mov	eax, [ebp+var_88]
		sub	eax, 1
		mov	[ebp+var_88], eax
		mov	eax, [ebp+var_B8]
		add	eax, 1
		mov	[ebp+var_B8], eax
		jmp	loc_5E12
; ---------------------------------------------------------------------------

loc_5ED2:				; CODE XREF: icu_56::UnicodeSetStringSpan::span(wchar_t	const *,int,USetSpanCondition)+1F1j
					; icu_56::UnicodeSetStringSpan::span(wchar_t const *,int,USetSpanCondition)+281j
		jmp	loc_5D05
; ---------------------------------------------------------------------------

loc_5ED7:				; CODE XREF: icu_56::UnicodeSetStringSpan::span(wchar_t	const *,int,USetSpanCondition)+E8j
		jmp	loc_609C
; ---------------------------------------------------------------------------

loc_5EDC:				; CODE XREF: icu_56::UnicodeSetStringSpan::span(wchar_t	const *,int,USetSpanCondition)+CAj
		mov	[ebp+var_C4], 0
		mov	[ebp+var_D0], 0
		mov	[ebp+var_70], 0
		jmp	short loc_5F02
; ---------------------------------------------------------------------------

loc_5EF9:				; CODE XREF: icu_56::UnicodeSetStringSpan::span(wchar_t	const *,int,USetSpanCondition):loc_603Cj
		mov	eax, [ebp+var_70]
		add	eax, 1
		mov	[ebp+var_70], eax

loc_5F02:				; CODE XREF: icu_56::UnicodeSetStringSpan::span(wchar_t	const *,int,USetSpanCondition)+2CBj
		mov	eax, [ebp+var_70]
		cmp	eax, [ebp+var_7C]
		jge	loc_6041
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+40h]
		mov	edx, [ebp+var_70]
		movzx	eax, byte ptr [ecx+edx]
		mov	[ebp+var_DC], eax
		mov	eax, [ebp+var_70]
		push	eax		; int
		mov	ecx, [ebp+var_18]
		mov	ecx, [ecx+38h]	; this
		call	?elementAt@UVector@icu_56@@QBEPAXH@Z ; icu_56::UVector::elementAt(int)
		mov	[ebp+var_E8], eax
		mov	ecx, [ebp+var_E8] ; this
		call	?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ ; icu_56::UnicodeString::getBuffer(void)
		mov	[ebp+var_F4], eax
		mov	ecx, [ebp+var_E8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	[ebp+var_100], eax
		cmp	[ebp+var_DC], 0FEh ; ''
		jl	short loc_5F70
		mov	eax, [ebp+var_100]
		mov	[ebp+var_DC], eax

loc_5F70:				; CODE XREF: icu_56::UnicodeSetStringSpan::span(wchar_t	const *,int,USetSpanCondition)+336j
		mov	eax, [ebp+var_DC]
		cmp	eax, [ebp+var_24]
		jle	short loc_5F84
		mov	eax, [ebp+var_24]
		mov	[ebp+var_DC], eax

loc_5F84:				; CODE XREF: icu_56::UnicodeSetStringSpan::span(wchar_t	const *,int,USetSpanCondition)+34Dj
		mov	eax, [ebp+var_100]
		sub	eax, [ebp+var_DC]
		mov	[ebp+var_10C], eax

loc_5F96:				; CODE XREF: icu_56::UnicodeSetStringSpan::span(wchar_t	const *,int,USetSpanCondition)+40Bj
		mov	eax, [ebp+var_10C]
		cmp	eax, [ebp+var_64]
		jg	short loc_5FAF
		mov	eax, [ebp+var_DC]
		cmp	eax, [ebp+var_D0]
		jge	short loc_5FB4

loc_5FAF:				; CODE XREF: icu_56::UnicodeSetStringSpan::span(wchar_t	const *,int,USetSpanCondition)+373j
		jmp	loc_603C
; ---------------------------------------------------------------------------

loc_5FB4:				; CODE XREF: icu_56::UnicodeSetStringSpan::span(wchar_t	const *,int,USetSpanCondition)+381j
		mov	eax, [ebp+var_DC]
		cmp	eax, [ebp+var_D0]
		jg	short loc_5FD0
		mov	eax, [ebp+var_10C]
		cmp	eax, [ebp+var_C4]
		jle	short loc_6019

loc_5FD0:				; CODE XREF: icu_56::UnicodeSetStringSpan::span(wchar_t	const *,int,USetSpanCondition)+394j
		mov	eax, [ebp+var_100]
		push	eax
		mov	ecx, [ebp+var_F4]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+var_58]
		sub	eax, [ebp+var_DC]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?matches16CPB@icu_56@@YACPB_WHH0H@Z ; icu_56::matches16CPB(wchar_t const *,int,int,wchar_t const *,int)
		add	esp, 14h
		movsx	edx, al
		test	edx, edx
		jz	short loc_6019
		mov	eax, [ebp+var_10C]
		mov	[ebp+var_C4], eax
		mov	eax, [ebp+var_DC]
		mov	[ebp+var_D0], eax
		jmp	short loc_603C
; ---------------------------------------------------------------------------

loc_6019:				; CODE XREF: icu_56::UnicodeSetStringSpan::span(wchar_t	const *,int,USetSpanCondition)+3A2j
					; icu_56::UnicodeSetStringSpan::span(wchar_t const *,int,USetSpanCondition)+3D1j
		mov	eax, [ebp+var_DC]
		sub	eax, 1
		mov	[ebp+var_DC], eax
		mov	eax, [ebp+var_10C]
		add	eax, 1
		mov	[ebp+var_10C], eax
		jmp	loc_5F96
; ---------------------------------------------------------------------------

loc_603C:				; CODE XREF: icu_56::UnicodeSetStringSpan::span(wchar_t	const *,int,USetSpanCondition):loc_5FAFj
					; icu_56::UnicodeSetStringSpan::span(wchar_t const *,int,USetSpanCondition)+3EBj
		jmp	loc_5EF9
; ---------------------------------------------------------------------------

loc_6041:				; CODE XREF: icu_56::UnicodeSetStringSpan::span(wchar_t	const *,int,USetSpanCondition)+2DCj
		cmp	[ebp+var_C4], 0
		jnz	short loc_6053
		cmp	[ebp+var_D0], 0
		jz	short loc_609C

loc_6053:				; CODE XREF: icu_56::UnicodeSetStringSpan::span(wchar_t	const *,int,USetSpanCondition)+41Cj
		mov	eax, [ebp+var_58]
		add	eax, [ebp+var_C4]
		mov	[ebp+var_58], eax
		mov	eax, [ebp+var_64]
		sub	eax, [ebp+var_C4]
		mov	[ebp+var_64], eax
		jnz	short loc_6090
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_208], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_4C] ; this
		call	??1OffsetList@icu_56@@QAE@XZ ; icu_56::OffsetList::~OffsetList(void)
		mov	eax, [ebp+var_208]
		jmp	loc_620C
; ---------------------------------------------------------------------------

loc_6090:				; CODE XREF: icu_56::UnicodeSetStringSpan::span(wchar_t	const *,int,USetSpanCondition)+43Fj
		mov	[ebp+var_24], 0
		jmp	loc_5CF2
; ---------------------------------------------------------------------------

loc_609C:				; CODE XREF: icu_56::UnicodeSetStringSpan::span(wchar_t	const *,int,USetSpanCondition):loc_5ED7j
					; icu_56::UnicodeSetStringSpan::span(wchar_t const *,int,USetSpanCondition)+425j
		cmp	[ebp+var_24], 0
		jnz	short loc_60A8
		cmp	[ebp+var_58], 0
		jnz	short loc_60DF

loc_60A8:				; CODE XREF: icu_56::UnicodeSetStringSpan::span(wchar_t	const *,int,USetSpanCondition)+474j
		lea	ecx, [ebp+var_4C] ; this
		call	?isEmpty@OffsetList@icu_56@@QBECXZ ; icu_56::OffsetList::isEmpty(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_60DA
		mov	eax, [ebp+var_58]
		mov	[ebp+var_1FC], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_4C] ; this
		call	??1OffsetList@icu_56@@QAE@XZ ; icu_56::OffsetList::~OffsetList(void)
		mov	eax, [ebp+var_1FC]
		jmp	loc_620C
; ---------------------------------------------------------------------------

loc_60DA:				; CODE XREF: icu_56::UnicodeSetStringSpan::span(wchar_t	const *,int,USetSpanCondition)+489j
		jmp	loc_61CB
; ---------------------------------------------------------------------------

loc_60DF:				; CODE XREF: icu_56::UnicodeSetStringSpan::span(wchar_t	const *,int,USetSpanCondition)+47Aj
		lea	ecx, [ebp+var_4C] ; this
		call	?isEmpty@OffsetList@icu_56@@QBECXZ ; icu_56::OffsetList::isEmpty(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_6156
		push	1
		mov	eax, [ebp+var_64]
		push	eax
		mov	ecx, [ebp+var_58]
		mov	edx, [ebp+arg_0]
		lea	eax, [edx+ecx*2]
		push	eax
		mov	ecx, [ebp+var_18]
		call	?span@UnicodeSet@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z ; icu_56::UnicodeSet::span(wchar_t const *,int,USetSpanCondition)
		mov	[ebp+var_24], eax
		mov	eax, [ebp+var_24]
		cmp	eax, [ebp+var_64]
		jz	short loc_6117
		cmp	[ebp+var_24], 0
		jnz	short loc_613D

loc_6117:				; CODE XREF: icu_56::UnicodeSetStringSpan::span(wchar_t	const *,int,USetSpanCondition)+4E3j
		mov	eax, [ebp+var_58]
		add	eax, [ebp+var_24]
		mov	[ebp+var_1F0], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_4C] ; this
		call	??1OffsetList@icu_56@@QAE@XZ ; icu_56::OffsetList::~OffsetList(void)
		mov	eax, [ebp+var_1F0]
		jmp	loc_620C
; ---------------------------------------------------------------------------

loc_613D:				; CODE XREF: icu_56::UnicodeSetStringSpan::span(wchar_t	const *,int,USetSpanCondition)+4E9j
		mov	eax, [ebp+var_58]
		add	eax, [ebp+var_24]
		mov	[ebp+var_58], eax
		mov	eax, [ebp+var_64]
		sub	eax, [ebp+var_24]
		mov	[ebp+var_64], eax
		jmp	loc_5CF2
; ---------------------------------------------------------------------------
		jmp	short loc_61CB
; ---------------------------------------------------------------------------

loc_6156:				; CODE XREF: icu_56::UnicodeSetStringSpan::span(wchar_t	const *,int,USetSpanCondition)+4C0j
		mov	eax, [ebp+var_64]
		push	eax
		mov	ecx, [ebp+var_58]
		mov	edx, [ebp+arg_0]
		lea	eax, [edx+ecx*2]
		push	eax
		mov	ecx, [ebp+var_18]
		push	ecx
		call	?spanOne@icu_56@@YAHABVUnicodeSet@1@PB_WH@Z ; icu_56::spanOne(icu_56::UnicodeSet const &,wchar_t const *,int)
		add	esp, 0Ch
		mov	[ebp+var_24], eax
		cmp	[ebp+var_24], 0
		jle	short loc_61CB
		mov	eax, [ebp+var_24]
		cmp	eax, [ebp+var_64]
		jnz	short loc_61A1
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_1E4], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_4C] ; this
		call	??1OffsetList@icu_56@@QAE@XZ ; icu_56::OffsetList::~OffsetList(void)
		mov	eax, [ebp+var_1E4]
		jmp	short loc_620C
; ---------------------------------------------------------------------------

loc_61A1:				; CODE XREF: icu_56::UnicodeSetStringSpan::span(wchar_t	const *,int,USetSpanCondition)+553j
		mov	eax, [ebp+var_58]
		add	eax, [ebp+var_24]
		mov	[ebp+var_58], eax
		mov	eax, [ebp+var_64]
		sub	eax, [ebp+var_24]
		mov	[ebp+var_64], eax
		mov	eax, [ebp+var_24]
		push	eax		; int
		lea	ecx, [ebp+var_4C] ; this
		call	?shift@OffsetList@icu_56@@QAEXH@Z ; icu_56::OffsetList::shift(int)
		mov	[ebp+var_24], 0
		jmp	loc_5CF2
; ---------------------------------------------------------------------------

loc_61CB:				; CODE XREF: icu_56::UnicodeSetStringSpan::span(wchar_t	const *,int,USetSpanCondition):loc_60DAj
					; icu_56::UnicodeSetStringSpan::span(wchar_t const *,int,USetSpanCondition)+528j ...
		lea	ecx, [ebp+var_4C] ; this
		call	?popMinimum@OffsetList@icu_56@@QAEHXZ ;	icu_56::OffsetList::popMinimum(void)
		mov	[ebp+var_118], eax
		mov	eax, [ebp+var_58]
		add	eax, [ebp+var_118]
		mov	[ebp+var_58], eax
		mov	eax, [ebp+var_64]
		sub	eax, [ebp+var_118]
		mov	[ebp+var_64], eax
		mov	[ebp+var_24], 0
		jmp	loc_5CF2
; ---------------------------------------------------------------------------
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_4C] ; this
		call	??1OffsetList@icu_56@@QAE@XZ ; icu_56::OffsetList::~OffsetList(void)

loc_620C:				; CODE XREF: icu_56::UnicodeSetStringSpan::span(wchar_t	const *,int,USetSpanCondition)+5Bj
					; icu_56::UnicodeSetStringSpan::span(wchar_t const *,int,USetSpanCondition)+80j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN54
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 218h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?span@UnicodeSetStringSpan@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z endp ; sp-analysis failed

; ---------------------------------------------------------------------------
$LN54		dd 1			; DATA XREF: icu_56::UnicodeSetStringSpan::span(wchar_t	const *,int,USetSpanCondition)+5E4o
		dd offset $LN53
$LN53		dd 0FFFFFFB4h, 20h	; DATA XREF: .text:0000624Co
		dd offset $LN51		; "offsets"
$LN51		db 'offsets',0          ; DATA XREF: .text:00006258o
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 6264h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?span@UnicodeSetStringSpan@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z$0 proc near
					; DATA XREF: .xdata$x:00006298o
		lea	ecx, [ebp-4Ch]	; this
		jmp	??1OffsetList@icu_56@@QAE@XZ ; icu_56::OffsetList::~OffsetList(void)
__unwindfunclet$?span@UnicodeSetStringSpan@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?span@UnicodeSetStringSpan@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z	proc near
					; DATA XREF: icu_56::UnicodeSetStringSpan::span(wchar_t	const *,int,USetSpanCondition)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-21Ch]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?span@UnicodeSetStringSpan@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?span@UnicodeSetStringSpan@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z	endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 6294h
__unwindtable$?span@UnicodeSetStringSpan@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000062A4o
		dd offset __unwindfunclet$?span@UnicodeSetStringSpan@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z$0
__ehfuncinfo$?span@UnicodeSetStringSpan@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$?span@UnicodeSetStringSpan@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z+1Eo
		dd offset __unwindtable$?span@UnicodeSetStringSpan@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 62C0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::OffsetList::OffsetList(icu_56::OffsetList *__hidden	this)
		public ??0OffsetList@icu_56@@QAE@XZ
??0OffsetList@icu_56@@QAE@XZ proc near	; CODE XREF: icu_56::UnicodeSetStringSpan::span(wchar_t	const *,int,USetSpanCondition)+88p
					; icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)+8Ep ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		add	eax, 10h
		mov	ecx, [ebp+var_8]
		mov	[ecx], eax
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+8], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+0Ch], 0
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0OffsetList@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6318h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::OffsetList::~OffsetList(icu_56::OffsetList *__hidden this)
		public ??1OffsetList@icu_56@@QAE@XZ
??1OffsetList@icu_56@@QAE@XZ proc near	; CODE XREF: icu_56::UnicodeSetStringSpan::span(wchar_t	const *,int,USetSpanCondition)+259p
					; icu_56::UnicodeSetStringSpan::span(wchar_t const *,int,USetSpanCondition)+454p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		add	eax, 10h
		mov	ecx, [ebp+var_8]
		cmp	[ecx], eax
		jz	short loc_6356
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		push	ecx
		call	_uprv_free_56
		add	esp, 4

loc_6356:				; CODE XREF: icu_56::OffsetList::~OffsetList(void)+2Ej
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1OffsetList@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 636Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::OffsetList::setMaxLength(icu_56::OffsetList *this, int)
		public ?setMaxLength@OffsetList@icu_56@@QAEXH@Z
?setMaxLength@OffsetList@icu_56@@QAEXH@Z proc near
					; CODE XREF: icu_56::UnicodeSetStringSpan::span(wchar_t	const *,int,USetSpanCondition)+A4p
					; icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)+AAp ...

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 10h
		jg	short loc_63A1
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 10h
		jmp	short loc_63C7
; ---------------------------------------------------------------------------

loc_63A1:				; CODE XREF: icu_56::OffsetList::setMaxLength(int)+27j
		mov	eax, [ebp+arg_0]
		push	eax
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+var_14], eax
		cmp	[ebp+var_14], 0
		jz	short loc_63C7
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		mov	[eax], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+4], ecx

loc_63C7:				; CODE XREF: icu_56::OffsetList::setMaxLength(int)+33j
					; icu_56::OffsetList::setMaxLength(int)+48j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		push	ecx		; Size
		push	0		; Val
		mov	edx, [ebp+var_8]
		mov	eax, [edx]
		push	eax		; Dst
		call	_memset
		add	esp, 0Ch
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setMaxLength@OffsetList@icu_56@@QAEXH@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 63F4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::OffsetList::isEmpty(icu_56::OffsetList *__hidden this)
		public ?isEmpty@OffsetList@icu_56@@QBECXZ
?isEmpty@OffsetList@icu_56@@QBECXZ proc	near
					; CODE XREF: icu_56::UnicodeSetStringSpan::span(wchar_t	const *,int,USetSpanCondition)+47Fp
					; icu_56::UnicodeSetStringSpan::span(wchar_t const *,int,USetSpanCondition)+4B6p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+8], 0
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isEmpty@OffsetList@icu_56@@QBECXZ endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6428h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::OffsetList::shift(icu_56::OffsetList *this, int)
		public ?shift@OffsetList@icu_56@@QAEXH@Z
?shift@OffsetList@icu_56@@QAEXH@Z proc near
					; CODE XREF: icu_56::UnicodeSetStringSpan::span(wchar_t	const *,int,USetSpanCondition)+58Ep
					; icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)+5C4p ...

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		add	ecx, [ebp+arg_0]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		cmp	ecx, [eax+4]
		jl	short loc_646E
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		sub	ecx, [eax+4]
		mov	[ebp+var_14], ecx

loc_646E:				; CODE XREF: icu_56::OffsetList::shift(int)+38j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		mov	edx, [ebp+var_14]
		movsx	eax, byte ptr [ecx+edx]
		test	eax, eax
		jz	short loc_6499
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		mov	edx, [ebp+var_14]
		mov	byte ptr [ecx+edx], 0
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		sub	ecx, 1
		mov	edx, [ebp+var_8]
		mov	[edx+8], ecx

loc_6499:				; CODE XREF: icu_56::OffsetList::shift(int)+54j
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		mov	[eax+0Ch], ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?shift@OffsetList@icu_56@@QAEXH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 64ACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::OffsetList::addOffset(icu_56::OffsetList *this, int)
		public ?addOffset@OffsetList@icu_56@@QAEXH@Z
?addOffset@OffsetList@icu_56@@QAEXH@Z proc near
					; CODE XREF: icu_56::UnicodeSetStringSpan::span(wchar_t	const *,int,USetSpanCondition)+273p
					; icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)+2C9p ...

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		add	ecx, [ebp+arg_0]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		cmp	ecx, [eax+4]
		jl	short loc_64F2
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		sub	ecx, [eax+4]
		mov	[ebp+var_14], ecx

loc_64F2:				; CODE XREF: icu_56::OffsetList::addOffset(int)+38j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		mov	edx, [ebp+var_14]
		mov	byte ptr [ecx+edx], 1
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		add	ecx, 1
		mov	edx, [ebp+var_8]
		mov	[edx+8], ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?addOffset@OffsetList@icu_56@@QAEXH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6518h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::OffsetList::containsOffset(icu_56::OffsetList *this,	int)
		public ?containsOffset@OffsetList@icu_56@@QBECH@Z
?containsOffset@OffsetList@icu_56@@QBECH@Z proc	near
					; CODE XREF: icu_56::UnicodeSetStringSpan::span(wchar_t	const *,int,USetSpanCondition)+200p
					; icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)+255p ...

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		add	ecx, [ebp+arg_0]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		cmp	ecx, [eax+4]
		jl	short loc_655E
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		sub	ecx, [eax+4]
		mov	[ebp+var_14], ecx

loc_655E:				; CODE XREF: icu_56::OffsetList::containsOffset(int)+38j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		mov	edx, [ebp+var_14]
		mov	al, [ecx+edx]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?containsOffset@OffsetList@icu_56@@QBECH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6574h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::OffsetList::popMinimum(icu_56::OffsetList *__hidden this)
		public ?popMinimum@OffsetList@icu_56@@QAEHXZ
?popMinimum@OffsetList@icu_56@@QAEHXZ proc near
					; CODE XREF: icu_56::UnicodeSetStringSpan::span(wchar_t	const *,int,USetSpanCondition)+5A2p
					; icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)+5D8p ...

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		mov	[ebp+var_14], ecx

loc_65A0:				; CODE XREF: icu_56::OffsetList::popMinimum(void):loc_65F9j
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ebp+var_14]
		cmp	edx, [ecx+4]
		jge	short loc_65FB
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		mov	edx, [ebp+var_14]
		movsx	eax, byte ptr [ecx+edx]
		test	eax, eax
		jz	short loc_65F9
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		mov	edx, [ebp+var_14]
		mov	byte ptr [ecx+edx], 0
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		sub	ecx, 1
		mov	edx, [ebp+var_8]
		mov	[edx+8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		sub	ecx, [eax+0Ch]
		mov	[ebp+var_20], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		mov	[eax+0Ch], ecx
		mov	eax, [ebp+var_20]
		jmp	short loc_665C
; ---------------------------------------------------------------------------

loc_65F9:				; CODE XREF: icu_56::OffsetList::popMinimum(void)+4Ej
		jmp	short loc_65A0
; ---------------------------------------------------------------------------

loc_65FB:				; CODE XREF: icu_56::OffsetList::popMinimum(void)+3Ej
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_8]
		mov	edx, [eax+4]
		sub	edx, [ecx+0Ch]
		mov	[ebp+var_20], edx
		mov	[ebp+var_14], 0

loc_6611:				; CODE XREF: icu_56::OffsetList::popMinimum(void)+B6j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		mov	edx, [ebp+var_14]
		movsx	eax, byte ptr [ecx+edx]
		test	eax, eax
		jnz	short loc_662C
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax
		jmp	short loc_6611
; ---------------------------------------------------------------------------

loc_662C:				; CODE XREF: icu_56::OffsetList::popMinimum(void)+ABj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		mov	edx, [ebp+var_14]
		mov	byte ptr [ecx+edx], 0
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		sub	ecx, 1
		mov	edx, [ebp+var_8]
		mov	[edx+8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		mov	[eax+0Ch], ecx
		mov	eax, [ebp+var_20]
		add	eax, [ebp+var_14]
		mov	[ebp+var_20], eax
		mov	eax, [ebp+var_20]

loc_665C:				; CODE XREF: icu_56::OffsetList::popMinimum(void)+83j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?popMinimum@OffsetList@icu_56@@QAEHXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6664h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl icu_56::matches16CPB(wchar_t const *, int, int, wchar_t const *, int)
?matches16CPB@icu_56@@YACPB_WHH0H@Z proc near
					; CODE XREF: icu_56::UnicodeSetStringSpan::span(wchar_t	const *,int,USetSpanCondition)+22Cp
					; icu_56::UnicodeSetStringSpan::span(wchar_t const *,int,USetSpanCondition)+3C4p ...

var_C4		= byte ptr -0C4h
var_C1		= byte ptr -0C1h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C4]
		mov	ecx, 31h ; '1'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+arg_0]
		lea	edx, [ecx+eax*2]
		mov	[ebp+arg_0], edx
		mov	eax, [ebp+arg_8]
		sub	eax, [ebp+arg_4]
		mov	[ebp+arg_8], eax
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+arg_C]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	?matches16@icu_56@@YACPB_W0H@Z ; icu_56::matches16(wchar_t const *,wchar_t const *,int)
		add	esp, 0Ch
		movsx	eax, al
		test	eax, eax
		jz	short loc_6723
		cmp	[ebp+arg_4], 0
		jle	short loc_66E1
		mov	ecx, [ebp+arg_0]
		movzx	edx, word ptr [ecx-2]
		and	edx, 0FFFFFC00h
		cmp	edx, 0D800h
		jnz	short loc_66E1
		mov	eax, [ebp+arg_0]
		movzx	ecx, word ptr [eax]
		and	ecx, 0FFFFFC00h
		cmp	ecx, 0DC00h
		jz	short loc_6723

loc_66E1:				; CODE XREF: icu_56::matches16CPB(wchar_t const	*,int,int,wchar_t const	*,int)+52j
					; icu_56::matches16CPB(wchar_t const *,int,int,wchar_t const *,int)+67j
		mov	edx, [ebp+arg_10]
		cmp	edx, [ebp+arg_8]
		jge	short loc_671A
		mov	eax, [ebp+arg_10]
		mov	ecx, [ebp+arg_0]
		movzx	edx, word ptr [ecx+eax*2-2]
		and	edx, 0FFFFFC00h
		cmp	edx, 0D800h
		jnz	short loc_671A
		mov	eax, [ebp+arg_10]
		mov	ecx, [ebp+arg_0]
		movzx	edx, word ptr [ecx+eax*2]
		and	edx, 0FFFFFC00h
		cmp	edx, 0DC00h
		jz	short loc_6723

loc_671A:				; CODE XREF: icu_56::matches16CPB(wchar_t const	*,int,int,wchar_t const	*,int)+83j
					; icu_56::matches16CPB(wchar_t const *,int,int,wchar_t const *,int)+9Cj
		mov	[ebp+var_C1], 1
		jmp	short loc_672A
; ---------------------------------------------------------------------------

loc_6723:				; CODE XREF: icu_56::matches16CPB(wchar_t const	*,int,int,wchar_t const	*,int)+4Cj
					; icu_56::matches16CPB(wchar_t const *,int,int,wchar_t const *,int)+7Bj ...
		mov	[ebp+var_C1], 0

loc_672A:				; CODE XREF: icu_56::matches16CPB(wchar_t const	*,int,int,wchar_t const	*,int)+BDj
		mov	al, [ebp+var_C1]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?matches16CPB@icu_56@@YACPB_WHH0H@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6744h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl icu_56::matches16(wchar_t	const *, wchar_t const *, int)
?matches16@icu_56@@YACPB_W0H@Z proc near
					; CODE XREF: icu_56::matches16CPB(wchar_t const	*,int,int,wchar_t const	*,int)+3Fp

var_C4		= dword	ptr -0C4h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C4]
		mov	ecx, 31h ; '1'
		mov	eax, 0CCCCCCCCh
		rep stosd

loc_6762:				; CODE XREF: icu_56::matches16(wchar_t const *,wchar_t const *,int)+70j
		mov	eax, [ebp+arg_4]
		movzx	ecx, word ptr [eax]
		mov	edx, [ebp+arg_0]
		movzx	eax, word ptr [edx]
		mov	edx, [ebp+arg_4]
		add	edx, 2
		mov	[ebp+arg_4], edx
		mov	edx, [ebp+arg_0]
		add	edx, 2
		mov	[ebp+arg_0], edx
		cmp	eax, ecx
		jz	short loc_6790
		mov	[ebp+var_C4], 1
		jmp	short loc_679A
; ---------------------------------------------------------------------------

loc_6790:				; CODE XREF: icu_56::matches16(wchar_t const *,wchar_t const *,int)+3Ej
		mov	[ebp+var_C4], 0

loc_679A:				; CODE XREF: icu_56::matches16(wchar_t const *,wchar_t const *,int)+4Aj
		cmp	[ebp+var_C4], 0
		jz	short loc_67A7
		xor	al, al
		jmp	short loc_67B8
; ---------------------------------------------------------------------------

loc_67A7:				; CODE XREF: icu_56::matches16(wchar_t const *,wchar_t const *,int)+5Dj
		mov	eax, [ebp+arg_8]
		sub	eax, 1
		mov	[ebp+arg_8], eax
		cmp	[ebp+arg_8], 0
		jg	short loc_6762
		mov	al, 1

loc_67B8:				; CODE XREF: icu_56::matches16(wchar_t const *,wchar_t const *,int)+61j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?matches16@icu_56@@YACPB_W0H@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 67C0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl icu_56::spanOne(class icu_56::UnicodeSet const &,	wchar_t	const *, int)
?spanOne@icu_56@@YAHABVUnicodeSet@1@PB_WH@Z proc near
					; CODE XREF: icu_56::UnicodeSetStringSpan::span(wchar_t	const *,int,USetSpanCondition)+53Cp
					; icu_56::UnicodeSetStringSpan::spanNot(wchar_t	const *,int)+90p

var_D8		= byte ptr -0D8h
var_14		= word ptr -14h
var_8		= word ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		mov	cx, [eax]
		mov	[ebp+var_8], cx
		movzx	eax, [ebp+var_8]
		cmp	eax, 0D800h
		jl	short loc_6859
		movzx	eax, [ebp+var_8]
		cmp	eax, 0DBFFh
		jg	short loc_6859
		cmp	[ebp+arg_8], 2
		jl	short loc_6859
		mov	eax, [ebp+arg_4]
		mov	cx, [eax+2]
		mov	[ebp+var_14], cx
		movzx	edx, [ebp+var_14]
		and	edx, 0FFFFFC00h
		cmp	edx, 0DC00h
		jnz	short loc_6859
		movzx	eax, [ebp+var_8]
		shl	eax, 0Ah
		movzx	ecx, [ebp+var_14]
		lea	edx, [eax+ecx-35FDC00h]
		mov	esi, esp
		push	edx
		mov	eax, [ebp+arg_0]
		mov	edx, [eax]
		mov	ecx, [ebp+arg_0]
		mov	eax, [edx+18h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	eax, al
		neg	eax
		sbb	eax, eax
		and	eax, 4
		add	eax, 0FFFFFFFEh
		jmp	short loc_6881
; ---------------------------------------------------------------------------

loc_6859:				; CODE XREF: icu_56::spanOne(icu_56::UnicodeSet	const &,wchar_t	const *,int)+31j
					; icu_56::spanOne(icu_56::UnicodeSet const &,wchar_t const *,int)+3Cj ...
		movzx	eax, [ebp+var_8]
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	ecx, [ebp+arg_0]
		mov	eax, [edx+18h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	eax, al
		neg	eax
		sbb	eax, eax
		and	eax, 2
		add	eax, 0FFFFFFFFh

loc_6881:				; CODE XREF: icu_56::spanOne(icu_56::UnicodeSet	const &,wchar_t	const *,int)+97j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?spanOne@icu_56@@YAHABVUnicodeSet@1@PB_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6898h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: int __thiscall icu_56::UnicodeSetStringSpan::spanBack(wchar_t	const *, int, enum  USetSpanCondition)const
		public ?spanBack@UnicodeSetStringSpan@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z
?spanBack@UnicodeSetStringSpan@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z	proc near

var_228		= dword	ptr -228h
var_220		= dword	ptr -220h
var_214		= dword	ptr -214h
var_208		= dword	ptr -208h
var_1FC		= dword	ptr -1FCh
var_1F0		= dword	ptr -1F0h
var_124		= dword	ptr -124h
var_118		= dword	ptr -118h
var_10C		= dword	ptr -10Ch
var_100		= dword	ptr -100h
var_F4		= dword	ptr -0F4h
var_E8		= dword	ptr -0E8h
var_DC		= dword	ptr -0DCh
var_D0		= dword	ptr -0D0h
var_C4		= dword	ptr -0C4h
var_B8		= dword	ptr -0B8h
var_AC		= dword	ptr -0ACh
var_A0		= dword	ptr -0A0h
var_94		= dword	ptr -94h
var_88		= dword	ptr -88h
var_7C		= dword	ptr -7Ch
var_70		= dword	ptr -70h
var_64		= dword	ptr -64h
var_58		= byte ptr -58h
var_30		= dword	ptr -30h
var_24		= dword	ptr -24h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?spanBack@UnicodeSetStringSpan@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 21Ch
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_228]
		mov	ecx, 87h ; ''
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		cmp	[ebp+arg_8], 0
		jnz	short loc_68F8
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; wchar_t *
		mov	ecx, [ebp+var_18] ; this
		call	?spanNotBack@UnicodeSetStringSpan@icu_56@@ABEHPB_WH@Z ;	icu_56::UnicodeSetStringSpan::spanNotBack(wchar_t const	*,int)
		jmp	loc_6E98
; ---------------------------------------------------------------------------

loc_68F8:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)+49j
		push	1
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	ecx, [ebp+var_18]
		call	?spanBack@UnicodeSet@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z ;	icu_56::UnicodeSet::spanBack(wchar_t const *,int,USetSpanCondition)
		mov	[ebp+var_24], eax
		cmp	[ebp+var_24], 0
		jnz	short loc_691A
		xor	eax, eax
		jmp	loc_6E98
; ---------------------------------------------------------------------------

loc_691A:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)+79j
		mov	eax, [ebp+arg_4]
		sub	eax, [ebp+var_24]
		mov	[ebp+var_30], eax
		lea	ecx, [ebp+var_58] ; this
		call	??0OffsetList@icu_56@@QAE@XZ ; icu_56::OffsetList::OffsetList(void)
		mov	[ebp+var_4], 0
		cmp	[ebp+arg_8], 1
		jnz	short loc_6947
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+4Ch]
		push	ecx		; int
		lea	ecx, [ebp+var_58] ; this
		call	?setMaxLength@OffsetList@icu_56@@QAEXH@Z ; icu_56::OffsetList::setMaxLength(int)

loc_6947:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)+9Ej
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+38h]	; this
		call	?size@UVector@icu_56@@QBEHXZ ; icu_56::UVector::size(void)
		mov	[ebp+var_70], eax
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+40h]
		mov	[ebp+var_7C], ecx
		mov	eax, [ebp+var_18]
		movsx	ecx, byte ptr [eax+54h]
		test	ecx, ecx
		jz	short loc_6972
		mov	eax, [ebp+var_7C]
		add	eax, [ebp+var_70]
		mov	[ebp+var_7C], eax

loc_6972:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)+CFj
					; icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)+4B2j ...
		cmp	[ebp+arg_8], 1
		jnz	loc_6B9E
		mov	[ebp+var_64], 0
		jmp	short loc_698E
; ---------------------------------------------------------------------------

loc_6985:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)+11Dj
					; icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition):loc_6B94j
		mov	eax, [ebp+var_64]
		add	eax, 1
		mov	[ebp+var_64], eax

loc_698E:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)+EBj
		mov	eax, [ebp+var_64]
		cmp	eax, [ebp+var_70]
		jge	loc_6B99
		mov	eax, [ebp+var_7C]
		add	eax, [ebp+var_64]
		movzx	ecx, byte ptr [eax]
		mov	[ebp+var_88], ecx
		cmp	[ebp+var_88], 0FFh
		jnz	short loc_69B7
		jmp	short loc_6985
; ---------------------------------------------------------------------------

loc_69B7:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)+11Bj
		mov	eax, [ebp+var_64]
		push	eax		; int
		mov	ecx, [ebp+var_18]
		mov	ecx, [ecx+38h]	; this
		call	?elementAt@UVector@icu_56@@QBEPAXH@Z ; icu_56::UVector::elementAt(int)
		mov	[ebp+var_94], eax
		mov	ecx, [ebp+var_94] ; this
		call	?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ ; icu_56::UnicodeString::getBuffer(void)
		mov	[ebp+var_A0], eax
		mov	ecx, [ebp+var_94] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	[ebp+var_AC], eax
		cmp	[ebp+var_88], 0FEh ; ''
		jl	loc_6AAD
		mov	eax, [ebp+var_AC]
		mov	[ebp+var_88], eax
		mov	[ebp+var_B8], 0
		mov	eax, [ebp+var_B8]
		mov	ecx, [ebp+var_A0]
		movzx	edx, word ptr [ecx+eax*2]
		and	edx, 0FFFFFC00h
		mov	eax, [ebp+var_B8]
		add	eax, 1
		mov	[ebp+var_B8], eax
		cmp	edx, 0D800h
		jnz	short loc_6A4D
		mov	[ebp+var_228], 1
		jmp	short loc_6A57
; ---------------------------------------------------------------------------

loc_6A4D:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)+1A7j
		mov	[ebp+var_228], 0

loc_6A57:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)+1B3j
		cmp	[ebp+var_228], 0
		jz	short loc_6A9B
		mov	eax, [ebp+var_B8]
		cmp	eax, [ebp+var_88]
		jz	short loc_6A9B
		mov	eax, [ebp+var_B8]
		mov	ecx, [ebp+var_A0]
		movzx	edx, word ptr [ecx+eax*2]
		and	edx, 0FFFFFC00h
		cmp	edx, 0DC00h
		jnz	short loc_6A9B
		mov	eax, [ebp+var_B8]
		add	eax, 1
		mov	[ebp+var_B8], eax

loc_6A9B:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)+1C6j
					; icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)+1D4j ...
		mov	eax, [ebp+var_88]
		sub	eax, [ebp+var_B8]
		mov	[ebp+var_88], eax

loc_6AAD:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)+160j
		mov	eax, [ebp+var_88]
		cmp	eax, [ebp+var_30]
		jle	short loc_6AC1
		mov	eax, [ebp+var_30]
		mov	[ebp+var_88], eax

loc_6AC1:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)+21Ej
		mov	eax, [ebp+var_AC]
		sub	eax, [ebp+var_88]
		mov	[ebp+var_C4], eax

loc_6AD3:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)+2F7j
		mov	eax, [ebp+var_C4]
		cmp	eax, [ebp+var_24]
		jle	short loc_6AE3
		jmp	loc_6B94
; ---------------------------------------------------------------------------

loc_6AE3:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)+244j
		mov	eax, [ebp+var_C4]
		push	eax		; int
		lea	ecx, [ebp+var_58] ; this
		call	?containsOffset@OffsetList@icu_56@@QBECH@Z ; icu_56::OffsetList::containsOffset(int)
		movsx	ecx, al
		test	ecx, ecx
		jnz	short loc_6B66
		mov	eax, [ebp+var_AC]
		push	eax
		mov	ecx, [ebp+var_A0]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+var_24]
		sub	eax, [ebp+var_C4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?matches16CPB@icu_56@@YACPB_WHH0H@Z ; icu_56::matches16CPB(wchar_t const *,int,int,wchar_t const *,int)
		add	esp, 14h
		movsx	edx, al
		test	edx, edx
		jz	short loc_6B66
		mov	eax, [ebp+var_C4]
		cmp	eax, [ebp+var_24]
		jnz	short loc_6B57
		mov	[ebp+var_220], 0
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_58] ; this
		call	??1OffsetList@icu_56@@QAE@XZ ; icu_56::OffsetList::~OffsetList(void)
		mov	eax, [ebp+var_220]
		jmp	loc_6E98
; ---------------------------------------------------------------------------

loc_6B57:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)+299j
		mov	eax, [ebp+var_C4]
		push	eax		; int
		lea	ecx, [ebp+var_58] ; this
		call	?addOffset@OffsetList@icu_56@@QAEXH@Z ;	icu_56::OffsetList::addOffset(int)

loc_6B66:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)+25Fj
					; icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)+28Ej
		cmp	[ebp+var_88], 0
		jnz	short loc_6B71
		jmp	short loc_6B94
; ---------------------------------------------------------------------------

loc_6B71:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)+2D5j
		mov	eax, [ebp+var_88]
		sub	eax, 1
		mov	[ebp+var_88], eax
		mov	eax, [ebp+var_C4]
		add	eax, 1
		mov	[ebp+var_C4], eax
		jmp	loc_6AD3
; ---------------------------------------------------------------------------

loc_6B94:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)+246j
					; icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)+2D7j
		jmp	loc_6985
; ---------------------------------------------------------------------------

loc_6B99:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)+FCj
		jmp	loc_6D4F
; ---------------------------------------------------------------------------

loc_6B9E:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)+DEj
		mov	[ebp+var_D0], 0
		mov	[ebp+var_DC], 0
		mov	[ebp+var_64], 0
		jmp	short loc_6BC4
; ---------------------------------------------------------------------------

loc_6BBB:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition):loc_6CFAj
		mov	eax, [ebp+var_64]
		add	eax, 1
		mov	[ebp+var_64], eax

loc_6BC4:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)+321j
		mov	eax, [ebp+var_64]
		cmp	eax, [ebp+var_70]
		jge	loc_6CFF
		mov	eax, [ebp+var_7C]
		add	eax, [ebp+var_64]
		movzx	ecx, byte ptr [eax]
		mov	[ebp+var_E8], ecx
		mov	eax, [ebp+var_64]
		push	eax		; int
		mov	ecx, [ebp+var_18]
		mov	ecx, [ecx+38h]	; this
		call	?elementAt@UVector@icu_56@@QBEPAXH@Z ; icu_56::UVector::elementAt(int)
		mov	[ebp+var_F4], eax
		mov	ecx, [ebp+var_F4] ; this
		call	?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ ; icu_56::UnicodeString::getBuffer(void)
		mov	[ebp+var_100], eax
		mov	ecx, [ebp+var_F4] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	[ebp+var_10C], eax
		cmp	[ebp+var_E8], 0FEh ; ''
		jl	short loc_6C2E
		mov	eax, [ebp+var_10C]
		mov	[ebp+var_E8], eax

loc_6C2E:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)+388j
		mov	eax, [ebp+var_E8]
		cmp	eax, [ebp+var_30]
		jle	short loc_6C42
		mov	eax, [ebp+var_30]
		mov	[ebp+var_E8], eax

loc_6C42:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)+39Fj
		mov	eax, [ebp+var_10C]
		sub	eax, [ebp+var_E8]
		mov	[ebp+var_118], eax

loc_6C54:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)+45Dj
		mov	eax, [ebp+var_118]
		cmp	eax, [ebp+var_24]
		jg	short loc_6C6D
		mov	eax, [ebp+var_E8]
		cmp	eax, [ebp+var_DC]
		jge	short loc_6C72

loc_6C6D:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)+3C5j
		jmp	loc_6CFA
; ---------------------------------------------------------------------------

loc_6C72:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)+3D3j
		mov	eax, [ebp+var_E8]
		cmp	eax, [ebp+var_DC]
		jg	short loc_6C8E
		mov	eax, [ebp+var_118]
		cmp	eax, [ebp+var_D0]
		jle	short loc_6CD7

loc_6C8E:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)+3E6j
		mov	eax, [ebp+var_10C]
		push	eax
		mov	ecx, [ebp+var_100]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+var_24]
		sub	eax, [ebp+var_118]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?matches16CPB@icu_56@@YACPB_WHH0H@Z ; icu_56::matches16CPB(wchar_t const *,int,int,wchar_t const *,int)
		add	esp, 14h
		movsx	edx, al
		test	edx, edx
		jz	short loc_6CD7
		mov	eax, [ebp+var_118]
		mov	[ebp+var_D0], eax
		mov	eax, [ebp+var_E8]
		mov	[ebp+var_DC], eax
		jmp	short loc_6CFA
; ---------------------------------------------------------------------------

loc_6CD7:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)+3F4j
					; icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)+423j
		mov	eax, [ebp+var_E8]
		sub	eax, 1
		mov	[ebp+var_E8], eax
		mov	eax, [ebp+var_118]
		add	eax, 1
		mov	[ebp+var_118], eax
		jmp	loc_6C54
; ---------------------------------------------------------------------------

loc_6CFA:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition):loc_6C6Dj
					; icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)+43Dj
		jmp	loc_6BBB
; ---------------------------------------------------------------------------

loc_6CFF:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)+332j
		cmp	[ebp+var_D0], 0
		jnz	short loc_6D11
		cmp	[ebp+var_DC], 0
		jz	short loc_6D4F

loc_6D11:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)+46Ej
		mov	eax, [ebp+var_24]
		sub	eax, [ebp+var_D0]
		mov	[ebp+var_24], eax
		jnz	short loc_6D43
		mov	[ebp+var_214], 0
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_58] ; this
		call	??1OffsetList@icu_56@@QAE@XZ ; icu_56::OffsetList::~OffsetList(void)
		mov	eax, [ebp+var_214]
		jmp	loc_6E98
; ---------------------------------------------------------------------------

loc_6D43:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)+485j
		mov	[ebp+var_30], 0
		jmp	loc_6972
; ---------------------------------------------------------------------------

loc_6D4F:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition):loc_6B99j
					; icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)+477j
		cmp	[ebp+var_30], 0
		jnz	short loc_6D5D
		mov	eax, [ebp+var_24]
		cmp	eax, [ebp+arg_4]
		jnz	short loc_6D94

loc_6D5D:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)+4BBj
		lea	ecx, [ebp+var_58] ; this
		call	?isEmpty@OffsetList@icu_56@@QBECXZ ; icu_56::OffsetList::isEmpty(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_6D8F
		mov	eax, [ebp+var_24]
		mov	[ebp+var_208], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_58] ; this
		call	??1OffsetList@icu_56@@QAE@XZ ; icu_56::OffsetList::~OffsetList(void)
		mov	eax, [ebp+var_208]
		jmp	loc_6E98
; ---------------------------------------------------------------------------

loc_6D8F:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)+4D2j
		jmp	loc_6E6D
; ---------------------------------------------------------------------------

loc_6D94:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)+4C3j
		lea	ecx, [ebp+var_58] ; this
		call	?isEmpty@OffsetList@icu_56@@QBECXZ ; icu_56::OffsetList::isEmpty(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_6E06
		mov	eax, [ebp+var_24]
		mov	[ebp+var_124], eax
		push	1
		mov	eax, [ebp+var_124]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	ecx, [ebp+var_18]
		call	?spanBack@UnicodeSet@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z ;	icu_56::UnicodeSet::spanBack(wchar_t const *,int,USetSpanCondition)
		mov	[ebp+var_24], eax
		mov	eax, [ebp+var_124]
		sub	eax, [ebp+var_24]
		mov	[ebp+var_30], eax
		cmp	[ebp+var_24], 0
		jz	short loc_6DDC
		cmp	[ebp+var_30], 0
		jnz	short loc_6DFF

loc_6DDC:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)+53Cj
		mov	eax, [ebp+var_24]
		mov	[ebp+var_1FC], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_58] ; this
		call	??1OffsetList@icu_56@@QAE@XZ ; icu_56::OffsetList::~OffsetList(void)
		mov	eax, [ebp+var_1FC]
		jmp	loc_6E98
; ---------------------------------------------------------------------------

loc_6DFF:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)+542j
		jmp	loc_6972
; ---------------------------------------------------------------------------
		jmp	short loc_6E6D
; ---------------------------------------------------------------------------

loc_6E06:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)+509j
		mov	eax, [ebp+var_24]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	edx, [ebp+var_18]
		push	edx
		call	?spanOneBack@icu_56@@YAHABVUnicodeSet@1@PB_WH@Z	; icu_56::spanOneBack(icu_56::UnicodeSet const &,wchar_t const *,int)
		add	esp, 0Ch
		mov	[ebp+var_30], eax
		cmp	[ebp+var_30], 0
		jle	short loc_6E6D
		mov	eax, [ebp+var_30]
		cmp	eax, [ebp+var_24]
		jnz	short loc_6E4C
		mov	[ebp+var_1F0], 0
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_58] ; this
		call	??1OffsetList@icu_56@@QAE@XZ ; icu_56::OffsetList::~OffsetList(void)
		mov	eax, [ebp+var_1F0]
		jmp	short loc_6E98
; ---------------------------------------------------------------------------

loc_6E4C:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)+591j
		mov	eax, [ebp+var_24]
		sub	eax, [ebp+var_30]
		mov	[ebp+var_24], eax
		mov	eax, [ebp+var_30]
		push	eax		; int
		lea	ecx, [ebp+var_58] ; this
		call	?shift@OffsetList@icu_56@@QAEXH@Z ; icu_56::OffsetList::shift(int)
		mov	[ebp+var_30], 0
		jmp	loc_6972
; ---------------------------------------------------------------------------

loc_6E6D:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition):loc_6D8Fj
					; icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)+56Cj ...
		lea	ecx, [ebp+var_58] ; this
		call	?popMinimum@OffsetList@icu_56@@QAEHXZ ;	icu_56::OffsetList::popMinimum(void)
		mov	ecx, [ebp+var_24]
		sub	ecx, eax
		mov	[ebp+var_24], ecx
		mov	[ebp+var_30], 0
		jmp	loc_6972
; ---------------------------------------------------------------------------
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_58] ; this
		call	??1OffsetList@icu_56@@QAE@XZ ; icu_56::OffsetList::~OffsetList(void)

loc_6E98:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)+5Bj
					; icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)+7Dj ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN57
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 228h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?spanBack@UnicodeSetStringSpan@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z	endp ; sp-analysis failed

; ---------------------------------------------------------------------------
$LN57		dd 1			; DATA XREF: icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)+604o
		dd offset $LN56
$LN56		dd 0FFFFFFA8h, 20h	; DATA XREF: .text:00006ED8o
		dd offset $LN54_0	; "offsets"
$LN54_0		db 'offsets',0          ; DATA XREF: .text:00006EE4o
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 6EF0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?spanBack@UnicodeSetStringSpan@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z$0 proc near
					; DATA XREF: .xdata$x:00006F24o
		lea	ecx, [ebp-58h]	; this
		jmp	??1OffsetList@icu_56@@QAE@XZ ; icu_56::OffsetList::~OffsetList(void)
__unwindfunclet$?spanBack@UnicodeSetStringSpan@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?spanBack@UnicodeSetStringSpan@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z proc near
					; DATA XREF: icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-22Ch]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?spanBack@UnicodeSetStringSpan@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?spanBack@UnicodeSetStringSpan@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 6F20h
__unwindtable$?spanBack@UnicodeSetStringSpan@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00006F30o
		dd offset __unwindfunclet$?spanBack@UnicodeSetStringSpan@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z$0
__ehfuncinfo$?spanBack@UnicodeSetStringSpan@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z dd	19930522h, 1
					; DATA XREF: __ehhandler$?spanBack@UnicodeSetStringSpan@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z+1Eo
		dd offset __unwindtable$?spanBack@UnicodeSetStringSpan@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6F4Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl icu_56::spanOneBack(class	icu_56::UnicodeSet const &, wchar_t const *, int)
?spanOneBack@icu_56@@YAHABVUnicodeSet@1@PB_WH@Z	proc near
					; CODE XREF: icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)+57Ap
					; icu_56::UnicodeSetStringSpan::spanNotBack(wchar_t const *,int)+68p

var_D8		= byte ptr -0D8h
var_14		= word ptr -14h
var_8		= word ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_8]
		mov	ecx, [ebp+arg_4]
		mov	dx, [ecx+eax*2-2]
		mov	[ebp+var_8], dx
		movzx	eax, [ebp+var_8]
		cmp	eax, 0DC00h
		jl	short loc_6FEC
		movzx	eax, [ebp+var_8]
		cmp	eax, 0DFFFh
		jg	short loc_6FEC
		cmp	[ebp+arg_8], 2
		jl	short loc_6FEC
		mov	eax, [ebp+arg_8]
		mov	ecx, [ebp+arg_4]
		mov	dx, [ecx+eax*2-4]
		mov	[ebp+var_14], dx
		movzx	eax, [ebp+var_14]
		and	eax, 0FFFFFC00h
		cmp	eax, 0D800h
		jnz	short loc_6FEC
		movzx	eax, [ebp+var_14]
		shl	eax, 0Ah
		movzx	ecx, [ebp+var_8]
		lea	edx, [eax+ecx-35FDC00h]
		mov	esi, esp
		push	edx
		mov	eax, [ebp+arg_0]
		mov	edx, [eax]
		mov	ecx, [ebp+arg_0]
		mov	eax, [edx+18h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	eax, al
		neg	eax
		sbb	eax, eax
		and	eax, 4
		add	eax, 0FFFFFFFEh
		jmp	short loc_7014
; ---------------------------------------------------------------------------

loc_6FEC:				; CODE XREF: icu_56::spanOneBack(icu_56::UnicodeSet const &,wchar_t const *,int)+36j
					; icu_56::spanOneBack(icu_56::UnicodeSet const &,wchar_t const *,int)+41j ...
		movzx	eax, [ebp+var_8]
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	ecx, [ebp+arg_0]
		mov	eax, [edx+18h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	eax, al
		neg	eax
		sbb	eax, eax
		and	eax, 2
		add	eax, 0FFFFFFFFh

loc_7014:				; CODE XREF: icu_56::spanOneBack(icu_56::UnicodeSet const &,wchar_t const *,int)+9Ej
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?spanOneBack@icu_56@@YAHABVUnicodeSet@1@PB_WH@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7028h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: int __thiscall icu_56::UnicodeSetStringSpan::spanUTF8(unsigned char const *, int, enum  USetSpanCondition)const
		public ?spanUTF8@UnicodeSetStringSpan@icu_56@@QBEHPBEHW4USetSpanCondition@@@Z
?spanUTF8@UnicodeSetStringSpan@icu_56@@QBEHPBEHW4USetSpanCondition@@@Z proc near

var_1F4		= byte ptr -1F4h
var_1F0		= dword	ptr -1F0h
var_1E4		= dword	ptr -1E4h
var_1D8		= dword	ptr -1D8h
var_1CC		= dword	ptr -1CCh
var_1C0		= dword	ptr -1C0h
var_F4		= dword	ptr -0F4h
var_E8		= dword	ptr -0E8h
var_DC		= dword	ptr -0DCh
var_D0		= dword	ptr -0D0h
var_C4		= dword	ptr -0C4h
var_B8		= dword	ptr -0B8h
var_AC		= dword	ptr -0ACh
var_A0		= dword	ptr -0A0h
var_94		= dword	ptr -94h
var_88		= dword	ptr -88h
var_7C		= dword	ptr -7Ch
var_70		= dword	ptr -70h
var_64		= dword	ptr -64h
var_58		= dword	ptr -58h
var_4C		= byte ptr -4Ch
var_24		= dword	ptr -24h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?spanUTF8@UnicodeSetStringSpan@icu_56@@QBEHPBEHW4USetSpanCondition@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 1E8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_1F4]
		mov	ecx, 7Ah ; 'z'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		cmp	[ebp+arg_8], 0
		jnz	short loc_7088
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; unsigned __int8 *
		mov	ecx, [ebp+var_18] ; this
		call	?spanNotUTF8@UnicodeSetStringSpan@icu_56@@ABEHPBEH@Z ; icu_56::UnicodeSetStringSpan::spanNotUTF8(uchar const *,int)
		jmp	loc_7651
; ---------------------------------------------------------------------------

loc_7088:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanUTF8(uchar const	*,int,USetSpanCondition)+49j
		push	1
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	ecx, [ebp+var_18]
		call	?spanUTF8@UnicodeSet@icu_56@@QBEHPBDHW4USetSpanCondition@@@Z ; icu_56::UnicodeSet::spanUTF8(char const *,int,USetSpanCondition)
		mov	[ebp+var_24], eax
		mov	eax, [ebp+var_24]
		cmp	eax, [ebp+arg_4]
		jnz	short loc_70AD
		mov	eax, [ebp+arg_4]
		jmp	loc_7651
; ---------------------------------------------------------------------------

loc_70AD:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanUTF8(uchar const	*,int,USetSpanCondition)+7Bj
		lea	ecx, [ebp+var_4C] ; this
		call	??0OffsetList@icu_56@@QAE@XZ ; icu_56::OffsetList::OffsetList(void)
		mov	[ebp+var_4], 0
		cmp	[ebp+arg_8], 1
		jnz	short loc_70D1
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+50h]
		push	ecx		; int
		lea	ecx, [ebp+var_4C] ; this
		call	?setMaxLength@OffsetList@icu_56@@QAEXH@Z ; icu_56::OffsetList::setMaxLength(int)

loc_70D1:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanUTF8(uchar const	*,int,USetSpanCondition)+98j
		mov	eax, [ebp+var_24]
		mov	[ebp+var_58], eax
		mov	eax, [ebp+arg_4]
		sub	eax, [ebp+var_58]
		mov	[ebp+var_64], eax
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+38h]	; this
		call	?size@UVector@icu_56@@QBEHXZ ; icu_56::UVector::size(void)
		mov	[ebp+var_7C], eax
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+40h]
		mov	[ebp+var_88], ecx
		mov	eax, [ebp+var_18]
		movsx	ecx, byte ptr [eax+54h]
		test	ecx, ecx
		jz	short loc_7117
		mov	eax, [ebp+var_7C]
		mov	ecx, [ebp+var_88]
		lea	edx, [ecx+eax*2]
		mov	[ebp+var_88], edx

loc_7117:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanUTF8(uchar const	*,int,USetSpanCondition)+DBj
					; icu_56::UnicodeSetStringSpan::spanUTF8(uchar const *,int,USetSpanCondition)+4BAj ...
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+44h]
		mov	[ebp+var_94], ecx
		cmp	[ebp+arg_8], 1
		jnz	loc_7317
		mov	[ebp+var_70], 0
		jmp	short loc_713F
; ---------------------------------------------------------------------------

loc_7136:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanUTF8(uchar const	*,int,USetSpanCondition)+13Ej
					; icu_56::UnicodeSetStringSpan::spanUTF8(uchar const *,int,USetSpanCondition)+170j ...
		mov	eax, [ebp+var_70]
		add	eax, 1
		mov	[ebp+var_70], eax

loc_713F:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanUTF8(uchar const	*,int,USetSpanCondition)+10Cj
		mov	eax, [ebp+var_70]
		cmp	eax, [ebp+var_7C]
		jge	loc_7312
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+3Ch]
		mov	edx, [ebp+var_70]
		mov	eax, [ecx+edx*4]
		mov	[ebp+var_A0], eax
		cmp	[ebp+var_A0], 0
		jnz	short loc_7168
		jmp	short loc_7136
; ---------------------------------------------------------------------------

loc_7168:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanUTF8(uchar const	*,int,USetSpanCondition)+13Cj
		mov	eax, [ebp+var_88]
		add	eax, [ebp+var_70]
		movzx	ecx, byte ptr [eax]
		mov	[ebp+var_AC], ecx
		cmp	[ebp+var_AC], 0FFh
		jnz	short loc_719A
		mov	eax, [ebp+var_94]
		add	eax, [ebp+var_A0]
		mov	[ebp+var_94], eax
		jmp	short loc_7136
; ---------------------------------------------------------------------------

loc_719A:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanUTF8(uchar const	*,int,USetSpanCondition)+15Cj
		cmp	[ebp+var_AC], 0FEh ; ''
		jl	short loc_71FC
		mov	eax, [ebp+var_A0]
		mov	[ebp+var_AC], eax
		mov	eax, [ebp+var_AC]
		sub	eax, 1
		mov	[ebp+var_AC], eax
		mov	ecx, [ebp+var_94]
		add	ecx, [ebp+var_AC]
		movzx	edx, byte ptr [ecx]
		and	edx, 0C0h
		cmp	edx, 80h ; ''
		jnz	short loc_71FC
		mov	eax, [ebp+var_AC]
		push	eax
		push	0
		mov	ecx, [ebp+var_94]
		push	ecx
		call	_utf8_back1SafeBody_56
		add	esp, 0Ch
		mov	[ebp+var_AC], eax

loc_71FC:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanUTF8(uchar const	*,int,USetSpanCondition)+17Cj
					; icu_56::UnicodeSetStringSpan::spanUTF8(uchar const *,int,USetSpanCondition)+1B4j
		mov	eax, [ebp+var_AC]
		cmp	eax, [ebp+var_24]
		jle	short loc_7210
		mov	eax, [ebp+var_24]
		mov	[ebp+var_AC], eax

loc_7210:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanUTF8(uchar const	*,int,USetSpanCondition)+1DDj
		mov	eax, [ebp+var_A0]
		sub	eax, [ebp+var_AC]
		mov	[ebp+var_B8], eax

loc_7222:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanUTF8(uchar const	*,int,USetSpanCondition)+2CEj
		mov	eax, [ebp+var_B8]
		cmp	eax, [ebp+var_64]
		jle	short loc_7232
		jmp	loc_72FB
; ---------------------------------------------------------------------------

loc_7232:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanUTF8(uchar const	*,int,USetSpanCondition)+203j
		mov	eax, [ebp+var_58]
		sub	eax, [ebp+var_AC]
		mov	ecx, [ebp+arg_0]
		movzx	edx, byte ptr [ecx+eax]
		and	edx, 0C0h
		cmp	edx, 80h ; ''
		jz	short loc_72CD
		mov	eax, [ebp+var_B8]
		push	eax		; int
		lea	ecx, [ebp+var_4C] ; this
		call	?containsOffset@OffsetList@icu_56@@QBECH@Z ; icu_56::OffsetList::containsOffset(int)
		movsx	ecx, al
		test	ecx, ecx
		jnz	short loc_72CD
		mov	eax, [ebp+var_A0]
		push	eax
		mov	ecx, [ebp+var_94]
		push	ecx
		mov	edx, [ebp+arg_0]
		add	edx, [ebp+var_58]
		sub	edx, [ebp+var_AC]
		push	edx
		call	?matches8@icu_56@@YACPBE0H@Z ; icu_56::matches8(uchar const *,uchar const *,int)
		add	esp, 0Ch
		movsx	eax, al
		test	eax, eax
		jz	short loc_72CD
		mov	eax, [ebp+var_B8]
		cmp	eax, [ebp+var_64]
		jnz	short loc_72BE
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_1F0], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_4C] ; this
		call	??1OffsetList@icu_56@@QAE@XZ ; icu_56::OffsetList::~OffsetList(void)
		mov	eax, [ebp+var_1F0]
		jmp	loc_7651
; ---------------------------------------------------------------------------

loc_72BE:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanUTF8(uchar const	*,int,USetSpanCondition)+271j
		mov	eax, [ebp+var_B8]
		push	eax		; int
		lea	ecx, [ebp+var_4C] ; this
		call	?addOffset@OffsetList@icu_56@@QAEXH@Z ;	icu_56::OffsetList::addOffset(int)

loc_72CD:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanUTF8(uchar const	*,int,USetSpanCondition)+226j
					; icu_56::UnicodeSetStringSpan::spanUTF8(uchar const *,int,USetSpanCondition)+23Cj ...
		cmp	[ebp+var_AC], 0
		jnz	short loc_72D8
		jmp	short loc_72FB
; ---------------------------------------------------------------------------

loc_72D8:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanUTF8(uchar const	*,int,USetSpanCondition)+2ACj
		mov	eax, [ebp+var_AC]
		sub	eax, 1
		mov	[ebp+var_AC], eax
		mov	eax, [ebp+var_B8]
		add	eax, 1
		mov	[ebp+var_B8], eax
		jmp	loc_7222
; ---------------------------------------------------------------------------

loc_72FB:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanUTF8(uchar const	*,int,USetSpanCondition)+205j
					; icu_56::UnicodeSetStringSpan::spanUTF8(uchar const *,int,USetSpanCondition)+2AEj
		mov	eax, [ebp+var_94]
		add	eax, [ebp+var_A0]
		mov	[ebp+var_94], eax
		jmp	loc_7136
; ---------------------------------------------------------------------------

loc_7312:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanUTF8(uchar const	*,int,USetSpanCondition)+11Dj
		jmp	loc_74E7
; ---------------------------------------------------------------------------

loc_7317:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanUTF8(uchar const	*,int,USetSpanCondition)+FFj
		mov	[ebp+var_C4], 0
		mov	[ebp+var_D0], 0
		mov	[ebp+var_70], 0
		jmp	short loc_733D
; ---------------------------------------------------------------------------

loc_7334:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanUTF8(uchar const	*,int,USetSpanCondition)+33Cj
					; icu_56::UnicodeSetStringSpan::spanUTF8(uchar const *,int,USetSpanCondition)+45Fj
		mov	eax, [ebp+var_70]
		add	eax, 1
		mov	[ebp+var_70], eax

loc_733D:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanUTF8(uchar const	*,int,USetSpanCondition)+30Aj
		mov	eax, [ebp+var_70]
		cmp	eax, [ebp+var_7C]
		jge	loc_748C
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+3Ch]
		mov	edx, [ebp+var_70]
		mov	eax, [ecx+edx*4]
		mov	[ebp+var_A0], eax
		cmp	[ebp+var_A0], 0
		jnz	short loc_7366
		jmp	short loc_7334
; ---------------------------------------------------------------------------

loc_7366:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanUTF8(uchar const	*,int,USetSpanCondition)+33Aj
		mov	eax, [ebp+var_88]
		add	eax, [ebp+var_70]
		movzx	ecx, byte ptr [eax]
		mov	[ebp+var_DC], ecx
		cmp	[ebp+var_DC], 0FEh ; ''
		jl	short loc_7390
		mov	eax, [ebp+var_A0]
		mov	[ebp+var_DC], eax

loc_7390:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanUTF8(uchar const	*,int,USetSpanCondition)+35Aj
		mov	eax, [ebp+var_DC]
		cmp	eax, [ebp+var_24]
		jle	short loc_73A4
		mov	eax, [ebp+var_24]
		mov	[ebp+var_DC], eax

loc_73A4:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanUTF8(uchar const	*,int,USetSpanCondition)+371j
		mov	eax, [ebp+var_A0]
		sub	eax, [ebp+var_DC]
		mov	[ebp+var_E8], eax

loc_73B6:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanUTF8(uchar const	*,int,USetSpanCondition)+448j
		mov	eax, [ebp+var_E8]
		cmp	eax, [ebp+var_64]
		jg	short loc_73CF
		mov	eax, [ebp+var_DC]
		cmp	eax, [ebp+var_D0]
		jge	short loc_73D4

loc_73CF:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanUTF8(uchar const	*,int,USetSpanCondition)+397j
		jmp	loc_7475
; ---------------------------------------------------------------------------

loc_73D4:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanUTF8(uchar const	*,int,USetSpanCondition)+3A5j
		mov	eax, [ebp+var_58]
		sub	eax, [ebp+var_DC]
		mov	ecx, [ebp+arg_0]
		movzx	edx, byte ptr [ecx+eax]
		and	edx, 0C0h
		cmp	edx, 80h ; ''
		jz	short loc_7452
		mov	eax, [ebp+var_DC]
		cmp	eax, [ebp+var_D0]
		jg	short loc_740E
		mov	eax, [ebp+var_E8]
		cmp	eax, [ebp+var_C4]
		jle	short loc_7452

loc_740E:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanUTF8(uchar const	*,int,USetSpanCondition)+3D6j
		mov	eax, [ebp+var_A0]
		push	eax
		mov	ecx, [ebp+var_94]
		push	ecx
		mov	edx, [ebp+arg_0]
		add	edx, [ebp+var_58]
		sub	edx, [ebp+var_DC]
		push	edx
		call	?matches8@icu_56@@YACPBE0H@Z ; icu_56::matches8(uchar const *,uchar const *,int)
		add	esp, 0Ch
		movsx	eax, al
		test	eax, eax
		jz	short loc_7452
		mov	eax, [ebp+var_E8]
		mov	[ebp+var_C4], eax
		mov	eax, [ebp+var_DC]
		mov	[ebp+var_D0], eax
		jmp	short loc_7475
; ---------------------------------------------------------------------------

loc_7452:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanUTF8(uchar const	*,int,USetSpanCondition)+3C8j
					; icu_56::UnicodeSetStringSpan::spanUTF8(uchar const *,int,USetSpanCondition)+3E4j ...
		mov	eax, [ebp+var_DC]
		sub	eax, 1
		mov	[ebp+var_DC], eax
		mov	eax, [ebp+var_E8]
		add	eax, 1
		mov	[ebp+var_E8], eax
		jmp	loc_73B6
; ---------------------------------------------------------------------------

loc_7475:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanUTF8(uchar const	*,int,USetSpanCondition):loc_73CFj
					; icu_56::UnicodeSetStringSpan::spanUTF8(uchar const *,int,USetSpanCondition)+428j
		mov	eax, [ebp+var_94]
		add	eax, [ebp+var_A0]
		mov	[ebp+var_94], eax
		jmp	loc_7334
; ---------------------------------------------------------------------------

loc_748C:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanUTF8(uchar const	*,int,USetSpanCondition)+31Bj
		cmp	[ebp+var_C4], 0
		jnz	short loc_749E
		cmp	[ebp+var_D0], 0
		jz	short loc_74E7

loc_749E:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanUTF8(uchar const	*,int,USetSpanCondition)+46Bj
		mov	eax, [ebp+var_58]
		add	eax, [ebp+var_C4]
		mov	[ebp+var_58], eax
		mov	eax, [ebp+var_64]
		sub	eax, [ebp+var_C4]
		mov	[ebp+var_64], eax
		jnz	short loc_74DB
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_1E4], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_4C] ; this
		call	??1OffsetList@icu_56@@QAE@XZ ; icu_56::OffsetList::~OffsetList(void)
		mov	eax, [ebp+var_1E4]
		jmp	loc_7651
; ---------------------------------------------------------------------------

loc_74DB:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanUTF8(uchar const	*,int,USetSpanCondition)+48Ej
		mov	[ebp+var_24], 0
		jmp	loc_7117
; ---------------------------------------------------------------------------

loc_74E7:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanUTF8(uchar const	*,int,USetSpanCondition):loc_7312j
					; icu_56::UnicodeSetStringSpan::spanUTF8(uchar const *,int,USetSpanCondition)+474j
		cmp	[ebp+var_24], 0
		jnz	short loc_74F3
		cmp	[ebp+var_58], 0
		jnz	short loc_752A

loc_74F3:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanUTF8(uchar const	*,int,USetSpanCondition)+4C3j
		lea	ecx, [ebp+var_4C] ; this
		call	?isEmpty@OffsetList@icu_56@@QBECXZ ; icu_56::OffsetList::isEmpty(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_7525
		mov	eax, [ebp+var_58]
		mov	[ebp+var_1D8], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_4C] ; this
		call	??1OffsetList@icu_56@@QAE@XZ ; icu_56::OffsetList::~OffsetList(void)
		mov	eax, [ebp+var_1D8]
		jmp	loc_7651
; ---------------------------------------------------------------------------

loc_7525:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanUTF8(uchar const	*,int,USetSpanCondition)+4D8j
		jmp	loc_7610
; ---------------------------------------------------------------------------

loc_752A:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanUTF8(uchar const	*,int,USetSpanCondition)+4C9j
		lea	ecx, [ebp+var_4C] ; this
		call	?isEmpty@OffsetList@icu_56@@QBECXZ ; icu_56::OffsetList::isEmpty(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_759E
		push	1
		mov	eax, [ebp+var_64]
		push	eax
		mov	ecx, [ebp+arg_0]
		add	ecx, [ebp+var_58]
		push	ecx
		mov	ecx, [ebp+var_18]
		call	?spanUTF8@UnicodeSet@icu_56@@QBEHPBDHW4USetSpanCondition@@@Z ; icu_56::UnicodeSet::spanUTF8(char const *,int,USetSpanCondition)
		mov	[ebp+var_24], eax
		mov	eax, [ebp+var_24]
		cmp	eax, [ebp+var_64]
		jz	short loc_755F
		cmp	[ebp+var_24], 0
		jnz	short loc_7585

loc_755F:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanUTF8(uchar const	*,int,USetSpanCondition)+52Fj
		mov	eax, [ebp+var_58]
		add	eax, [ebp+var_24]
		mov	[ebp+var_1CC], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_4C] ; this
		call	??1OffsetList@icu_56@@QAE@XZ ; icu_56::OffsetList::~OffsetList(void)
		mov	eax, [ebp+var_1CC]
		jmp	loc_7651
; ---------------------------------------------------------------------------

loc_7585:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanUTF8(uchar const	*,int,USetSpanCondition)+535j
		mov	eax, [ebp+var_58]
		add	eax, [ebp+var_24]
		mov	[ebp+var_58], eax
		mov	eax, [ebp+var_64]
		sub	eax, [ebp+var_24]
		mov	[ebp+var_64], eax
		jmp	loc_7117
; ---------------------------------------------------------------------------
		jmp	short loc_7610
; ---------------------------------------------------------------------------

loc_759E:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanUTF8(uchar const	*,int,USetSpanCondition)+50Fj
		mov	eax, [ebp+var_64]
		push	eax
		mov	ecx, [ebp+arg_0]
		add	ecx, [ebp+var_58]
		push	ecx
		mov	edx, [ebp+var_18]
		push	edx
		call	?spanOneUTF8@icu_56@@YAHABVUnicodeSet@1@PBEH@Z ; icu_56::spanOneUTF8(icu_56::UnicodeSet	const &,uchar const *,int)
		add	esp, 0Ch
		mov	[ebp+var_24], eax
		cmp	[ebp+var_24], 0
		jle	short loc_7610
		mov	eax, [ebp+var_24]
		cmp	eax, [ebp+var_64]
		jnz	short loc_75E6
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_1C0], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_4C] ; this
		call	??1OffsetList@icu_56@@QAE@XZ ; icu_56::OffsetList::~OffsetList(void)
		mov	eax, [ebp+var_1C0]
		jmp	short loc_7651
; ---------------------------------------------------------------------------

loc_75E6:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanUTF8(uchar const	*,int,USetSpanCondition)+59Cj
		mov	eax, [ebp+var_58]
		add	eax, [ebp+var_24]
		mov	[ebp+var_58], eax
		mov	eax, [ebp+var_64]
		sub	eax, [ebp+var_24]
		mov	[ebp+var_64], eax
		mov	eax, [ebp+var_24]
		push	eax		; int
		lea	ecx, [ebp+var_4C] ; this
		call	?shift@OffsetList@icu_56@@QAEXH@Z ; icu_56::OffsetList::shift(int)
		mov	[ebp+var_24], 0
		jmp	loc_7117
; ---------------------------------------------------------------------------

loc_7610:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanUTF8(uchar const	*,int,USetSpanCondition):loc_7525j
					; icu_56::UnicodeSetStringSpan::spanUTF8(uchar const *,int,USetSpanCondition)+574j ...
		lea	ecx, [ebp+var_4C] ; this
		call	?popMinimum@OffsetList@icu_56@@QAEHXZ ;	icu_56::OffsetList::popMinimum(void)
		mov	[ebp+var_F4], eax
		mov	eax, [ebp+var_58]
		add	eax, [ebp+var_F4]
		mov	[ebp+var_58], eax
		mov	eax, [ebp+var_64]
		sub	eax, [ebp+var_F4]
		mov	[ebp+var_64], eax
		mov	[ebp+var_24], 0
		jmp	loc_7117
; ---------------------------------------------------------------------------
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_4C] ; this
		call	??1OffsetList@icu_56@@QAE@XZ ; icu_56::OffsetList::~OffsetList(void)

loc_7651:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanUTF8(uchar const	*,int,USetSpanCondition)+5Bj
					; icu_56::UnicodeSetStringSpan::spanUTF8(uchar const *,int,USetSpanCondition)+80j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN57_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 1F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?spanUTF8@UnicodeSetStringSpan@icu_56@@QBEHPBEHW4USetSpanCondition@@@Z endp ; sp-analysis failed

; ---------------------------------------------------------------------------
		align 10h
$LN57_0		dd 1			; DATA XREF: icu_56::UnicodeSetStringSpan::spanUTF8(uchar const	*,int,USetSpanCondition)+62Do
		dd offset $LN56_0
$LN56_0		dd 0FFFFFFB4h, 20h	; DATA XREF: .text:00007694o
		dd offset $LN54_1	; "offsets"
$LN54_1		db 'offsets',0          ; DATA XREF: .text:000076A0o
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 76ACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?spanUTF8@UnicodeSetStringSpan@icu_56@@QBEHPBEHW4USetSpanCondition@@@Z$0 proc near
					; DATA XREF: .xdata$x:000076E0o
		lea	ecx, [ebp-4Ch]	; this
		jmp	??1OffsetList@icu_56@@QAE@XZ ; icu_56::OffsetList::~OffsetList(void)
__unwindfunclet$?spanUTF8@UnicodeSetStringSpan@icu_56@@QBEHPBEHW4USetSpanCondition@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?spanUTF8@UnicodeSetStringSpan@icu_56@@QBEHPBEHW4USetSpanCondition@@@Z proc	near
					; DATA XREF: icu_56::UnicodeSetStringSpan::spanUTF8(uchar const	*,int,USetSpanCondition)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-1F8h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?spanUTF8@UnicodeSetStringSpan@icu_56@@QBEHPBEHW4USetSpanCondition@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?spanUTF8@UnicodeSetStringSpan@icu_56@@QBEHPBEHW4USetSpanCondition@@@Z endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 76DCh
__unwindtable$?spanUTF8@UnicodeSetStringSpan@icu_56@@QBEHPBEHW4USetSpanCondition@@@Z dd	0FFFFFFFFh
					; DATA XREF: .xdata$x:000076ECo
		dd offset __unwindfunclet$?spanUTF8@UnicodeSetStringSpan@icu_56@@QBEHPBEHW4USetSpanCondition@@@Z$0
__ehfuncinfo$?spanUTF8@UnicodeSetStringSpan@icu_56@@QBEHPBEHW4USetSpanCondition@@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$?spanUTF8@UnicodeSetStringSpan@icu_56@@QBEHPBEHW4USetSpanCondition@@@Z+1Eo
		dd offset __unwindtable$?spanUTF8@UnicodeSetStringSpan@icu_56@@QBEHPBEHW4USetSpanCondition@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7708h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl icu_56::matches8(unsigned	char const *, unsigned char const *, int)
?matches8@icu_56@@YACPBE0H@Z proc near	; CODE XREF: icu_56::UnicodeSetStringSpan::spanUTF8(uchar const	*,int,USetSpanCondition)+259p
					; icu_56::UnicodeSetStringSpan::spanUTF8(uchar const *,int,USetSpanCondition)+401p ...

var_C4		= dword	ptr -0C4h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C4]
		mov	ecx, 31h ; '1'
		mov	eax, 0CCCCCCCCh
		rep stosd

loc_7726:				; CODE XREF: icu_56::matches8(uchar const *,uchar const	*,int)+70j
		mov	eax, [ebp+arg_4]
		movzx	ecx, byte ptr [eax]
		mov	edx, [ebp+arg_0]
		movzx	eax, byte ptr [edx]
		mov	edx, [ebp+arg_4]
		add	edx, 1
		mov	[ebp+arg_4], edx
		mov	edx, [ebp+arg_0]
		add	edx, 1
		mov	[ebp+arg_0], edx
		cmp	eax, ecx
		jz	short loc_7754
		mov	[ebp+var_C4], 1
		jmp	short loc_775E
; ---------------------------------------------------------------------------

loc_7754:				; CODE XREF: icu_56::matches8(uchar const *,uchar const	*,int)+3Ej
		mov	[ebp+var_C4], 0

loc_775E:				; CODE XREF: icu_56::matches8(uchar const *,uchar const	*,int)+4Aj
		cmp	[ebp+var_C4], 0
		jz	short loc_776B
		xor	al, al
		jmp	short loc_777C
; ---------------------------------------------------------------------------

loc_776B:				; CODE XREF: icu_56::matches8(uchar const *,uchar const	*,int)+5Dj
		mov	eax, [ebp+arg_8]
		sub	eax, 1
		mov	[ebp+arg_8], eax
		cmp	[ebp+arg_8], 0
		jg	short loc_7726
		mov	al, 1

loc_777C:				; CODE XREF: icu_56::matches8(uchar const *,uchar const	*,int)+61j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?matches8@icu_56@@YACPBE0H@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7784h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl icu_56::spanOneUTF8(class	icu_56::UnicodeSet const &, unsigned char const	*, int)
?spanOneUTF8@icu_56@@YAHABVUnicodeSet@1@PBEH@Z proc near
					; CODE XREF: icu_56::UnicodeSetStringSpan::spanUTF8(uchar const	*,int,USetSpanCondition)+585p
					; icu_56::UnicodeSetStringSpan::spanNotUTF8(uchar const	*,int)+AAp

var_F4		= dword	ptr -0F4h
var_29		= byte ptr -29h
var_1D		= byte ptr -1Dh
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0F4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Dh ; '='
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		movzx	ecx, byte ptr [eax]
		mov	[ebp+var_8], ecx
		movsx	eax, byte ptr [ebp+var_8]
		test	eax, eax
		jl	short loc_77DF
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	ecx, [ebp+arg_0]
		mov	eax, [edx+18h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	eax, al
		neg	eax
		sbb	eax, eax
		and	eax, 2
		add	eax, 0FFFFFFFFh
		jmp	loc_7934
; ---------------------------------------------------------------------------

loc_77DF:				; CODE XREF: icu_56::spanOneUTF8(icu_56::UnicodeSet const &,uchar const	*,int)+2Dj
		mov	[ebp+var_14], 0
		mov	eax, [ebp+arg_4]
		add	eax, [ebp+var_14]
		movzx	ecx, byte ptr [eax]
		mov	[ebp+var_8], ecx
		mov	edx, [ebp+var_14]
		add	edx, 1
		mov	[ebp+var_14], edx
		cmp	[ebp+var_8], 80h ; ''
		jl	loc_78F7
		cmp	[ebp+var_8], 0E0h ; ''
		jle	short loc_7888
		cmp	[ebp+var_8], 0ECh ; ''
		jg	short loc_7888
		mov	eax, [ebp+var_14]
		add	eax, 1
		cmp	eax, [ebp+arg_8]
		jl	short loc_782B
		cmp	[ebp+arg_8], 0
		jge	short loc_7888

loc_782B:				; CODE XREF: icu_56::spanOneUTF8(icu_56::UnicodeSet const &,uchar const	*,int)+9Fj
		mov	eax, [ebp+arg_4]
		add	eax, [ebp+var_14]
		movzx	ecx, byte ptr [eax]
		sub	ecx, 80h ; ''
		mov	[ebp+var_1D], cl
		movzx	edx, [ebp+var_1D]
		cmp	edx, 3Fh ; '?'
		jg	short loc_7888
		mov	eax, [ebp+arg_4]
		add	eax, [ebp+var_14]
		movzx	ecx, byte ptr [eax+1]
		sub	ecx, 80h ; ''
		mov	[ebp+var_29], cl
		movzx	edx, [ebp+var_29]
		cmp	edx, 3Fh ; '?'
		jg	short loc_7888
		mov	eax, [ebp+var_8]
		shl	eax, 0Ch
		movzx	ecx, [ebp+var_1D]
		shl	ecx, 6
		or	eax, ecx
		movzx	edx, [ebp+var_29]
		or	eax, edx
		movzx	eax, ax
		mov	[ebp+var_8], eax
		mov	eax, [ebp+var_14]
		add	eax, 2
		mov	[ebp+var_14], eax
		jmp	short loc_78F7
; ---------------------------------------------------------------------------

loc_7888:				; CODE XREF: icu_56::spanOneUTF8(icu_56::UnicodeSet const &,uchar const	*,int)+8Bj
					; icu_56::spanOneUTF8(icu_56::UnicodeSet const &,uchar const *,int)+94j ...
		cmp	[ebp+var_8], 0E0h ; ''
		jge	short loc_78DA
		cmp	[ebp+var_8], 0C2h ; ''
		jl	short loc_78DA
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+arg_8]
		jz	short loc_78DA
		mov	eax, [ebp+arg_4]
		add	eax, [ebp+var_14]
		movzx	ecx, byte ptr [eax]
		sub	ecx, 80h ; ''
		mov	[ebp+var_1D], cl
		movzx	edx, [ebp+var_1D]
		cmp	edx, 3Fh ; '?'
		jg	short loc_78DA
		mov	eax, [ebp+var_8]
		and	eax, 1Fh
		shl	eax, 6
		movzx	ecx, [ebp+var_1D]
		or	eax, ecx
		mov	[ebp+var_8], eax
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax
		jmp	short loc_78F7
; ---------------------------------------------------------------------------

loc_78DA:				; CODE XREF: icu_56::spanOneUTF8(icu_56::UnicodeSet const &,uchar const	*,int)+10Bj
					; icu_56::spanOneUTF8(icu_56::UnicodeSet const &,uchar const *,int)+114j ...
		push	0FFFFFFFDh
		mov	eax, [ebp+var_8]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		lea	edx, [ebp+var_14]
		push	edx
		mov	eax, [ebp+arg_4]
		push	eax
		call	_utf8_nextCharSafeBody_56
		add	esp, 14h
		mov	[ebp+var_8], eax

loc_78F7:				; CODE XREF: icu_56::spanOneUTF8(icu_56::UnicodeSet const &,uchar const	*,int)+7Ej
					; icu_56::spanOneUTF8(icu_56::UnicodeSet const &,uchar const *,int)+102j ...
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	ecx, [ebp+arg_0]
		mov	eax, [edx+18h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_7923
		mov	edx, [ebp+var_14]
		mov	[ebp+var_F4], edx
		jmp	short loc_792E
; ---------------------------------------------------------------------------

loc_7923:				; CODE XREF: icu_56::spanOneUTF8(icu_56::UnicodeSet const &,uchar const	*,int)+192j
		mov	eax, [ebp+var_14]
		neg	eax
		mov	[ebp+var_F4], eax

loc_792E:				; CODE XREF: icu_56::spanOneUTF8(icu_56::UnicodeSet const &,uchar const	*,int)+19Dj
		mov	eax, [ebp+var_F4]

loc_7934:				; CODE XREF: icu_56::spanOneUTF8(icu_56::UnicodeSet const &,uchar const	*,int)+56j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN14
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?spanOneUTF8@icu_56@@YAHABVUnicodeSet@1@PBEH@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN14		dd 1			; DATA XREF: icu_56::spanOneUTF8(icu_56::UnicodeSet const &,uchar const	*,int)+1B4o
		dd offset $LN13
$LN13		dd 0FFFFFFECh, 4	; DATA XREF: .text:00007960o
		dd offset $LN12
$LN12		db 69h,	0		; DATA XREF: .text:0000796Co
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7974h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: int __thiscall icu_56::UnicodeSetStringSpan::spanBackUTF8(unsigned char const	*, int,	enum  USetSpanCondition)const
		public ?spanBackUTF8@UnicodeSetStringSpan@icu_56@@QBEHPBEHW4USetSpanCondition@@@Z
?spanBackUTF8@UnicodeSetStringSpan@icu_56@@QBEHPBEHW4USetSpanCondition@@@Z proc	near

var_214		= dword	ptr -214h
var_210		= dword	ptr -210h
var_208		= dword	ptr -208h
var_1FC		= dword	ptr -1FCh
var_1F0		= dword	ptr -1F0h
var_1E4		= dword	ptr -1E4h
var_1D8		= dword	ptr -1D8h
var_10C		= dword	ptr -10Ch
var_100		= dword	ptr -100h
var_F4		= dword	ptr -0F4h
var_E8		= dword	ptr -0E8h
var_DC		= dword	ptr -0DCh
var_D0		= dword	ptr -0D0h
var_C1		= byte ptr -0C1h
var_B5		= byte ptr -0B5h
var_AC		= dword	ptr -0ACh
var_A0		= dword	ptr -0A0h
var_94		= dword	ptr -94h
var_88		= dword	ptr -88h
var_7C		= dword	ptr -7Ch
var_70		= dword	ptr -70h
var_64		= dword	ptr -64h
var_58		= byte ptr -58h
var_30		= dword	ptr -30h
var_24		= dword	ptr -24h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?spanBackUTF8@UnicodeSetStringSpan@icu_56@@QBEHPBEHW4USetSpanCondition@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 208h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_214]
		mov	ecx, 82h ; ''
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		cmp	[ebp+arg_8], 0
		jnz	short loc_79D4
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; unsigned __int8 *
		mov	ecx, [ebp+var_18] ; this
		call	?spanNotBackUTF8@UnicodeSetStringSpan@icu_56@@ABEHPBEH@Z ; icu_56::UnicodeSetStringSpan::spanNotBackUTF8(uchar const *,int)
		jmp	loc_807D
; ---------------------------------------------------------------------------

loc_79D4:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+49j
		push	1
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	ecx, [ebp+var_18]
		call	?spanBackUTF8@UnicodeSet@icu_56@@QBEHPBDHW4USetSpanCondition@@@Z ; icu_56::UnicodeSet::spanBackUTF8(char const *,int,USetSpanCondition)
		mov	[ebp+var_24], eax
		cmp	[ebp+var_24], 0
		jnz	short loc_79F6
		xor	eax, eax
		jmp	loc_807D
; ---------------------------------------------------------------------------

loc_79F6:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+79j
		mov	eax, [ebp+arg_4]
		sub	eax, [ebp+var_24]
		mov	[ebp+var_30], eax
		lea	ecx, [ebp+var_58] ; this
		call	??0OffsetList@icu_56@@QAE@XZ ; icu_56::OffsetList::OffsetList(void)
		mov	[ebp+var_4], 0
		cmp	[ebp+arg_8], 1
		jnz	short loc_7A23
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+50h]
		push	ecx		; int
		lea	ecx, [ebp+var_58] ; this
		call	?setMaxLength@OffsetList@icu_56@@QAEXH@Z ; icu_56::OffsetList::setMaxLength(int)

loc_7A23:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+9Ej
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+38h]	; this
		call	?size@UVector@icu_56@@QBEHXZ ; icu_56::UVector::size(void)
		mov	[ebp+var_70], eax
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+40h]
		mov	[ebp+var_7C], ecx
		mov	eax, [ebp+var_18]
		movsx	ecx, byte ptr [eax+54h]
		test	ecx, ecx
		jz	short loc_7A51
		mov	eax, [ebp+var_70]
		imul	eax, 3
		add	eax, [ebp+var_7C]
		mov	[ebp+var_7C], eax

loc_7A51:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+CFj
					; icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+5BBj	...
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+44h]
		mov	[ebp+var_88], ecx
		cmp	[ebp+arg_8], 1
		jnz	loc_7D72
		mov	[ebp+var_64], 0
		jmp	short loc_7A79
; ---------------------------------------------------------------------------

loc_7A70:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+12Cj
					; icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+15Bj	...
		mov	eax, [ebp+var_64]
		add	eax, 1
		mov	[ebp+var_64], eax

loc_7A79:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+FAj
		mov	eax, [ebp+var_64]
		cmp	eax, [ebp+var_70]
		jge	loc_7D6D
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+3Ch]
		mov	edx, [ebp+var_64]
		mov	eax, [ecx+edx*4]
		mov	[ebp+var_94], eax
		cmp	[ebp+var_94], 0
		jnz	short loc_7AA2
		jmp	short loc_7A70
; ---------------------------------------------------------------------------

loc_7AA2:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+12Aj
		mov	eax, [ebp+var_7C]
		add	eax, [ebp+var_64]
		movzx	ecx, byte ptr [eax]
		mov	[ebp+var_A0], ecx
		cmp	[ebp+var_A0], 0FFh
		jnz	short loc_7AD1
		mov	eax, [ebp+var_88]
		add	eax, [ebp+var_94]
		mov	[ebp+var_88], eax
		jmp	short loc_7A70
; ---------------------------------------------------------------------------

loc_7AD1:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+147j
		cmp	[ebp+var_A0], 0FEh ; ''
		jl	loc_7C56
		mov	eax, [ebp+var_94]
		mov	[ebp+var_A0], eax
		mov	[ebp+var_AC], 0
		mov	eax, [ebp+var_88]
		add	eax, [ebp+var_AC]
		mov	cl, [eax]
		mov	[ebp+var_B5], cl
		mov	edx, [ebp+var_AC]
		add	edx, 1
		mov	[ebp+var_AC], edx
		movzx	eax, [ebp+var_B5]
		sub	eax, 0C0h ; ''
		movzx	ecx, al
		cmp	ecx, 3Eh ; '>'
		jge	loc_7C44
		movzx	eax, [ebp+var_B5]
		cmp	eax, 0F0h ; ''
		jge	short loc_7B6D
		movzx	ecx, [ebp+var_B5]
		xor	edx, edx
		cmp	ecx, 0C0h ; ''
		setnl	dl
		movzx	eax, [ebp+var_B5]
		xor	ecx, ecx
		cmp	eax, 0E0h ; ''
		setnl	cl
		add	edx, ecx
		mov	[ebp+var_210], edx
		jmp	short loc_7BC1
; ---------------------------------------------------------------------------

loc_7B6D:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+1CAj
		movzx	edx, [ebp+var_B5]
		cmp	edx, 0FEh ; ''
		jge	short loc_7BAB
		movzx	eax, [ebp+var_B5]
		xor	ecx, ecx
		cmp	eax, 0F8h ; ''
		setnl	cl
		movzx	edx, [ebp+var_B5]
		xor	eax, eax
		cmp	edx, 0FCh ; ''
		setnl	al
		lea	ecx, [ecx+eax+3]
		mov	[ebp+var_214], ecx
		jmp	short loc_7BB5
; ---------------------------------------------------------------------------

loc_7BAB:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+206j
		mov	[ebp+var_214], 0

loc_7BB5:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+235j
		mov	edx, [ebp+var_214]
		mov	[ebp+var_210], edx

loc_7BC1:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+1F7j
		mov	al, byte ptr [ebp+var_210]
		mov	[ebp+var_C1], al
		movzx	eax, [ebp+var_C1]
		add	eax, [ebp+var_AC]
		cmp	eax, [ebp+var_A0]
		jle	short loc_7BFD
		cmp	[ebp+var_A0], 0
		jl	short loc_7BFD
		mov	eax, [ebp+var_A0]
		sub	eax, [ebp+var_AC]
		mov	[ebp+var_C1], al

loc_7BFD:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+26Cj
					; icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+275j	...
		movzx	eax, [ebp+var_C1]
		test	eax, eax
		jle	short loc_7C44
		mov	eax, [ebp+var_88]
		add	eax, [ebp+var_AC]
		movzx	ecx, byte ptr [eax]
		and	ecx, 0C0h
		cmp	ecx, 80h ; ''
		jnz	short loc_7C44
		mov	eax, [ebp+var_AC]
		add	eax, 1
		mov	[ebp+var_AC], eax
		mov	al, [ebp+var_C1]
		sub	al, 1
		mov	[ebp+var_C1], al
		jmp	short loc_7BFD
; ---------------------------------------------------------------------------

loc_7C44:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+1B8j
					; icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+292j	...
		mov	eax, [ebp+var_A0]
		sub	eax, [ebp+var_AC]
		mov	[ebp+var_A0], eax

loc_7C56:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+167j
		mov	eax, [ebp+var_A0]
		cmp	eax, [ebp+var_30]
		jle	short loc_7C6A
		mov	eax, [ebp+var_30]
		mov	[ebp+var_A0], eax

loc_7C6A:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+2EBj
		mov	eax, [ebp+var_94]
		sub	eax, [ebp+var_A0]
		mov	[ebp+var_D0], eax

loc_7C7C:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+3DDj
		mov	eax, [ebp+var_D0]
		cmp	eax, [ebp+var_24]
		jle	short loc_7C8C
		jmp	loc_7D56
; ---------------------------------------------------------------------------

loc_7C8C:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+311j
		mov	eax, [ebp+var_24]
		sub	eax, [ebp+var_D0]
		mov	ecx, [ebp+arg_0]
		movzx	edx, byte ptr [ecx+eax]
		and	edx, 0C0h
		cmp	edx, 80h ; ''
		jz	short loc_7D28
		mov	eax, [ebp+var_D0]
		push	eax		; int
		lea	ecx, [ebp+var_58] ; this
		call	?containsOffset@OffsetList@icu_56@@QBECH@Z ; icu_56::OffsetList::containsOffset(int)
		movsx	ecx, al
		test	ecx, ecx
		jnz	short loc_7D28
		mov	eax, [ebp+var_94]
		push	eax
		mov	ecx, [ebp+var_88]
		push	ecx
		mov	edx, [ebp+arg_0]
		add	edx, [ebp+var_24]
		sub	edx, [ebp+var_D0]
		push	edx
		call	?matches8@icu_56@@YACPBE0H@Z ; icu_56::matches8(uchar const *,uchar const *,int)
		add	esp, 0Ch
		movsx	eax, al
		test	eax, eax
		jz	short loc_7D28
		mov	eax, [ebp+var_D0]
		cmp	eax, [ebp+var_24]
		jnz	short loc_7D19
		mov	[ebp+var_208], 0
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_58] ; this
		call	??1OffsetList@icu_56@@QAE@XZ ; icu_56::OffsetList::~OffsetList(void)
		mov	eax, [ebp+var_208]
		jmp	loc_807D
; ---------------------------------------------------------------------------

loc_7D19:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+37Fj
		mov	eax, [ebp+var_D0]
		push	eax		; int
		lea	ecx, [ebp+var_58] ; this
		call	?addOffset@OffsetList@icu_56@@QAEXH@Z ;	icu_56::OffsetList::addOffset(int)

loc_7D28:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+334j
					; icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+34Aj	...
		cmp	[ebp+var_A0], 0
		jnz	short loc_7D33
		jmp	short loc_7D56
; ---------------------------------------------------------------------------

loc_7D33:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+3BBj
		mov	eax, [ebp+var_A0]
		sub	eax, 1
		mov	[ebp+var_A0], eax
		mov	eax, [ebp+var_D0]
		add	eax, 1
		mov	[ebp+var_D0], eax
		jmp	loc_7C7C
; ---------------------------------------------------------------------------

loc_7D56:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+313j
					; icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+3BDj
		mov	eax, [ebp+var_88]
		add	eax, [ebp+var_94]
		mov	[ebp+var_88], eax
		jmp	loc_7A70
; ---------------------------------------------------------------------------

loc_7D6D:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+10Bj
		jmp	loc_7F34
; ---------------------------------------------------------------------------

loc_7D72:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+EDj
		mov	[ebp+var_DC], 0
		mov	[ebp+var_E8], 0
		mov	[ebp+var_64], 0
		jmp	short loc_7D98
; ---------------------------------------------------------------------------

loc_7D8F:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+44Bj
					; icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+56Bj
		mov	eax, [ebp+var_64]
		add	eax, 1
		mov	[ebp+var_64], eax

loc_7D98:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+419j
		mov	eax, [ebp+var_64]
		cmp	eax, [ebp+var_70]
		jge	loc_7EE4
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+3Ch]
		mov	edx, [ebp+var_64]
		mov	eax, [ecx+edx*4]
		mov	[ebp+var_94], eax
		cmp	[ebp+var_94], 0
		jnz	short loc_7DC1
		jmp	short loc_7D8F
; ---------------------------------------------------------------------------

loc_7DC1:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+449j
		mov	eax, [ebp+var_7C]
		add	eax, [ebp+var_64]
		movzx	ecx, byte ptr [eax]
		mov	[ebp+var_F4], ecx
		cmp	[ebp+var_F4], 0FEh ; ''
		jl	short loc_7DE8
		mov	eax, [ebp+var_94]
		mov	[ebp+var_F4], eax

loc_7DE8:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+466j
		mov	eax, [ebp+var_F4]
		cmp	eax, [ebp+var_30]
		jle	short loc_7DFC
		mov	eax, [ebp+var_30]
		mov	[ebp+var_F4], eax

loc_7DFC:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+47Dj
		mov	eax, [ebp+var_94]
		sub	eax, [ebp+var_F4]
		mov	[ebp+var_100], eax

loc_7E0E:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+554j
		mov	eax, [ebp+var_100]
		cmp	eax, [ebp+var_24]
		jg	short loc_7E27
		mov	eax, [ebp+var_F4]
		cmp	eax, [ebp+var_E8]
		jge	short loc_7E2C

loc_7E27:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+4A3j
		jmp	loc_7ECD
; ---------------------------------------------------------------------------

loc_7E2C:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+4B1j
		mov	eax, [ebp+var_24]
		sub	eax, [ebp+var_100]
		mov	ecx, [ebp+arg_0]
		movzx	edx, byte ptr [ecx+eax]
		and	edx, 0C0h
		cmp	edx, 80h ; ''
		jz	short loc_7EAA
		mov	eax, [ebp+var_F4]
		cmp	eax, [ebp+var_E8]
		jg	short loc_7E66
		mov	eax, [ebp+var_100]
		cmp	eax, [ebp+var_DC]
		jle	short loc_7EAA

loc_7E66:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+4E2j
		mov	eax, [ebp+var_94]
		push	eax
		mov	ecx, [ebp+var_88]
		push	ecx
		mov	edx, [ebp+arg_0]
		add	edx, [ebp+var_24]
		sub	edx, [ebp+var_100]
		push	edx
		call	?matches8@icu_56@@YACPBE0H@Z ; icu_56::matches8(uchar const *,uchar const *,int)
		add	esp, 0Ch
		movsx	eax, al
		test	eax, eax
		jz	short loc_7EAA
		mov	eax, [ebp+var_100]
		mov	[ebp+var_DC], eax
		mov	eax, [ebp+var_F4]
		mov	[ebp+var_E8], eax
		jmp	short loc_7ECD
; ---------------------------------------------------------------------------

loc_7EAA:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+4D4j
					; icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+4F0j	...
		mov	eax, [ebp+var_F4]
		sub	eax, 1
		mov	[ebp+var_F4], eax
		mov	eax, [ebp+var_100]
		add	eax, 1
		mov	[ebp+var_100], eax
		jmp	loc_7E0E
; ---------------------------------------------------------------------------

loc_7ECD:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition):loc_7E27j
					; icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+534j
		mov	eax, [ebp+var_88]
		add	eax, [ebp+var_94]
		mov	[ebp+var_88], eax
		jmp	loc_7D8F
; ---------------------------------------------------------------------------

loc_7EE4:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+42Aj
		cmp	[ebp+var_DC], 0
		jnz	short loc_7EF6
		cmp	[ebp+var_E8], 0
		jz	short loc_7F34

loc_7EF6:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+577j
		mov	eax, [ebp+var_24]
		sub	eax, [ebp+var_DC]
		mov	[ebp+var_24], eax
		jnz	short loc_7F28
		mov	[ebp+var_1FC], 0
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_58] ; this
		call	??1OffsetList@icu_56@@QAE@XZ ; icu_56::OffsetList::~OffsetList(void)
		mov	eax, [ebp+var_1FC]
		jmp	loc_807D
; ---------------------------------------------------------------------------

loc_7F28:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+58Ej
		mov	[ebp+var_30], 0
		jmp	loc_7A51
; ---------------------------------------------------------------------------

loc_7F34:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition):loc_7D6Dj
					; icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+580j
		cmp	[ebp+var_30], 0
		jnz	short loc_7F42
		mov	eax, [ebp+var_24]
		cmp	eax, [ebp+arg_4]
		jnz	short loc_7F79

loc_7F42:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+5C4j
		lea	ecx, [ebp+var_58] ; this
		call	?isEmpty@OffsetList@icu_56@@QBECXZ ; icu_56::OffsetList::isEmpty(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_7F74
		mov	eax, [ebp+var_24]
		mov	[ebp+var_1F0], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_58] ; this
		call	??1OffsetList@icu_56@@QAE@XZ ; icu_56::OffsetList::~OffsetList(void)
		mov	eax, [ebp+var_1F0]
		jmp	loc_807D
; ---------------------------------------------------------------------------

loc_7F74:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+5DBj
		jmp	loc_8052
; ---------------------------------------------------------------------------

loc_7F79:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+5CCj
		lea	ecx, [ebp+var_58] ; this
		call	?isEmpty@OffsetList@icu_56@@QBECXZ ; icu_56::OffsetList::isEmpty(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_7FEB
		mov	eax, [ebp+var_24]
		mov	[ebp+var_10C], eax
		push	1
		mov	eax, [ebp+var_10C]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	ecx, [ebp+var_18]
		call	?spanBackUTF8@UnicodeSet@icu_56@@QBEHPBDHW4USetSpanCondition@@@Z ; icu_56::UnicodeSet::spanBackUTF8(char const *,int,USetSpanCondition)
		mov	[ebp+var_24], eax
		mov	eax, [ebp+var_10C]
		sub	eax, [ebp+var_24]
		mov	[ebp+var_30], eax
		cmp	[ebp+var_24], 0
		jz	short loc_7FC1
		cmp	[ebp+var_30], 0
		jnz	short loc_7FE4

loc_7FC1:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+645j
		mov	eax, [ebp+var_24]
		mov	[ebp+var_1E4], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_58] ; this
		call	??1OffsetList@icu_56@@QAE@XZ ; icu_56::OffsetList::~OffsetList(void)
		mov	eax, [ebp+var_1E4]
		jmp	loc_807D
; ---------------------------------------------------------------------------

loc_7FE4:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+64Bj
		jmp	loc_7A51
; ---------------------------------------------------------------------------
		jmp	short loc_8052
; ---------------------------------------------------------------------------

loc_7FEB:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+612j
		mov	eax, [ebp+var_24]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	edx, [ebp+var_18]
		push	edx
		call	?spanOneBackUTF8@icu_56@@YAHABVUnicodeSet@1@PBEH@Z ; icu_56::spanOneBackUTF8(icu_56::UnicodeSet	const &,uchar const *,int)
		add	esp, 0Ch

loc_7FFF:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::_Stdioo
		mov	[ebp+var_30], eax
		cmp	[ebp+var_30], 0
		jle	short loc_8052
		mov	eax, [ebp+var_30]
		cmp	eax, [ebp+var_24]
		jnz	short loc_8031
		mov	[ebp+var_1D8], 0
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_58] ; this
		call	??1OffsetList@icu_56@@QAE@XZ ; icu_56::OffsetList::~OffsetList(void)
		mov	eax, [ebp+var_1D8]
		jmp	short loc_807D
; ---------------------------------------------------------------------------

loc_8031:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+69Aj
		mov	eax, [ebp+var_24]
		sub	eax, [ebp+var_30]
		mov	[ebp+var_24], eax
		mov	eax, [ebp+var_30]
		push	eax		; int
		lea	ecx, [ebp+var_58] ; this
		call	?shift@OffsetList@icu_56@@QAEXH@Z ; icu_56::OffsetList::shift(int)
		mov	[ebp+var_30], 0
		jmp	loc_7A51
; ---------------------------------------------------------------------------

loc_8052:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition):loc_7F74j
					; icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+675j	...
		lea	ecx, [ebp+var_58] ; this
		call	?popMinimum@OffsetList@icu_56@@QAEHXZ ;	icu_56::OffsetList::popMinimum(void)
		mov	ecx, [ebp+var_24]
		sub	ecx, eax
		mov	[ebp+var_24], ecx
		mov	[ebp+var_30], 0
		jmp	loc_7A51
; ---------------------------------------------------------------------------
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_58] ; this
		call	??1OffsetList@icu_56@@QAE@XZ ; icu_56::OffsetList::~OffsetList(void)

loc_807D:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+5Bj
					; icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+7Dj ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN64
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 214h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?spanBackUTF8@UnicodeSetStringSpan@icu_56@@QBEHPBEHW4USetSpanCondition@@@Z endp	; sp-analysis failed

; ---------------------------------------------------------------------------
		align 4
$LN64		dd 1			; DATA XREF: icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+70Do
		dd offset $LN63
$LN63		dd 0FFFFFFA8h, 20h	; DATA XREF: .text:000080C0o
		dd offset $LN61		; "offsets"
$LN61		db 'offsets',0          ; DATA XREF: .text:000080CCo
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 80D8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?spanBackUTF8@UnicodeSetStringSpan@icu_56@@QBEHPBEHW4USetSpanCondition@@@Z$0 proc near
					; DATA XREF: .xdata$x:0000810Co
		lea	ecx, [ebp-58h]	; this
		jmp	??1OffsetList@icu_56@@QAE@XZ ; icu_56::OffsetList::~OffsetList(void)
__unwindfunclet$?spanBackUTF8@UnicodeSetStringSpan@icu_56@@QBEHPBEHW4USetSpanCondition@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?spanBackUTF8@UnicodeSetStringSpan@icu_56@@QBEHPBEHW4USetSpanCondition@@@Z proc near
					; DATA XREF: icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-218h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?spanBackUTF8@UnicodeSetStringSpan@icu_56@@QBEHPBEHW4USetSpanCondition@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?spanBackUTF8@UnicodeSetStringSpan@icu_56@@QBEHPBEHW4USetSpanCondition@@@Z endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 8108h
__unwindtable$?spanBackUTF8@UnicodeSetStringSpan@icu_56@@QBEHPBEHW4USetSpanCondition@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00008118o
		dd offset __unwindfunclet$?spanBackUTF8@UnicodeSetStringSpan@icu_56@@QBEHPBEHW4USetSpanCondition@@@Z$0
__ehfuncinfo$?spanBackUTF8@UnicodeSetStringSpan@icu_56@@QBEHPBEHW4USetSpanCondition@@@Z	dd 19930522h, 1
					; DATA XREF: __ehhandler$?spanBackUTF8@UnicodeSetStringSpan@icu_56@@QBEHPBEHW4USetSpanCondition@@@Z+1Eo
		dd offset __unwindtable$?spanBackUTF8@UnicodeSetStringSpan@icu_56@@QBEHPBEHW4USetSpanCondition@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8134h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl icu_56::spanOneBackUTF8(class icu_56::UnicodeSet const &,	unsigned char const *, int)
?spanOneBackUTF8@icu_56@@YAHABVUnicodeSet@1@PBEH@Z proc	near
					; CODE XREF: icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+683p
					; icu_56::UnicodeSetStringSpan::spanNotBackUTF8(uchar const *,int)+88p

var_DC		= dword	ptr -0DCh
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0DCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_DC]
		mov	ecx, 37h ; '7'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		add	eax, [ebp+arg_8]
		movzx	ecx, byte ptr [eax-1]
		mov	[ebp+var_8], ecx
		movsx	eax, byte ptr [ebp+var_8]
		test	eax, eax
		jl	short loc_8190
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	ecx, [ebp+arg_0]
		mov	eax, [edx+18h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	eax, al
		neg	eax
		sbb	eax, eax
		and	eax, 2
		add	eax, 0FFFFFFFFh
		jmp	short loc_81FA
; ---------------------------------------------------------------------------

loc_8190:				; CODE XREF: icu_56::spanOneBackUTF8(icu_56::UnicodeSet	const &,uchar const *,int)+31j
		mov	eax, [ebp+arg_8]
		sub	eax, 1
		mov	[ebp+var_14], eax
		push	0FFFFFFFDh
		mov	eax, [ebp+var_8]
		push	eax
		lea	ecx, [ebp+var_14]
		push	ecx
		push	0
		mov	edx, [ebp+arg_4]
		push	edx
		call	_utf8_prevCharSafeBody_56
		add	esp, 14h
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_8]
		sub	eax, [ebp+var_14]
		mov	[ebp+arg_8], eax
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	ecx, [ebp+arg_0]
		mov	eax, [edx+18h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_81E9
		mov	edx, [ebp+arg_8]
		mov	[ebp+var_DC], edx
		jmp	short loc_81F4
; ---------------------------------------------------------------------------

loc_81E9:				; CODE XREF: icu_56::spanOneBackUTF8(icu_56::UnicodeSet	const &,uchar const *,int)+A8j
		mov	eax, [ebp+arg_8]
		neg	eax
		mov	[ebp+var_DC], eax

loc_81F4:				; CODE XREF: icu_56::spanOneBackUTF8(icu_56::UnicodeSet	const &,uchar const *,int)+B3j
		mov	eax, [ebp+var_DC]

loc_81FA:				; CODE XREF: icu_56::spanOneBackUTF8(icu_56::UnicodeSet	const &,uchar const *,int)+5Aj
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN8_1
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0DCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?spanOneBackUTF8@icu_56@@YAHABVUnicodeSet@1@PBEH@Z endp

; ---------------------------------------------------------------------------
		align 10h
$LN8_1		dd 1			; DATA XREF: icu_56::spanOneBackUTF8(icu_56::UnicodeSet	const &,uchar const *,int)+CAo
		dd offset $LN7_1
$LN7_1		dd 0FFFFFFECh, 4	; DATA XREF: .text:00008224o
		dd offset $LN6_1
$LN6_1		db 69h,	0		; DATA XREF: .text:00008230o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8238h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeSetStringSpan::spanNot(icu_56::UnicodeSetStringSpan *this, const wchar_t *, int)
		public ?spanNot@UnicodeSetStringSpan@icu_56@@ABEHPB_WH@Z
?spanNot@UnicodeSetStringSpan@icu_56@@ABEHPB_WH@Z proc near
					; CODE XREF: icu_56::UnicodeSetStringSpan::span(wchar_t	const *,int,USetSpanCondition)+56p

var_12C		= byte ptr -12Ch
var_68		= dword	ptr -68h
var_5C		= dword	ptr -5Ch
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 12Ch
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_12C]
		mov	ecx, 4Bh ; 'K'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_14], 0
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_20], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+38h]	; this
		call	?size@UVector@icu_56@@QBEHXZ ; icu_56::UVector::size(void)
		mov	[ebp+var_38], eax

loc_8276:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanNot(wchar_t const *,int)+148j
		push	0
		mov	eax, [ebp+var_20]
		push	eax
		mov	ecx, [ebp+var_14]
		mov	edx, [ebp+arg_0]
		lea	eax, [edx+ecx*2]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	ecx, [ecx+34h]
		call	?span@UnicodeSet@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z ; icu_56::UnicodeSet::span(wchar_t const *,int,USetSpanCondition)
		mov	[ebp+var_2C], eax
		mov	eax, [ebp+var_2C]
		cmp	eax, [ebp+var_20]
		jnz	short loc_82A4
		mov	eax, [ebp+arg_4]
		jmp	loc_8389
; ---------------------------------------------------------------------------

loc_82A4:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanNot(wchar_t const *,int)+62j
		mov	eax, [ebp+var_14]
		add	eax, [ebp+var_2C]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_20]
		sub	eax, [ebp+var_2C]
		mov	[ebp+var_20], eax
		mov	eax, [ebp+var_20]
		push	eax
		mov	ecx, [ebp+var_14]
		mov	edx, [ebp+arg_0]
		lea	eax, [edx+ecx*2]
		push	eax
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?spanOne@icu_56@@YAHABVUnicodeSet@1@PB_WH@Z ; icu_56::spanOne(icu_56::UnicodeSet const &,wchar_t const *,int)
		add	esp, 0Ch
		mov	[ebp+var_44], eax
		cmp	[ebp+var_44], 0
		jle	short loc_82E1
		mov	eax, [ebp+var_14]
		jmp	loc_8389
; ---------------------------------------------------------------------------

loc_82E1:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanNot(wchar_t const *,int)+9Fj
		mov	[ebp+var_2C], 0
		jmp	short loc_82F3
; ---------------------------------------------------------------------------

loc_82EA:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanNot(wchar_t const *,int)+D7j
					; icu_56::UnicodeSetStringSpan::spanNot(wchar_t	const *,int):loc_8369j
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax

loc_82F3:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanNot(wchar_t const *,int)+B0j
		mov	eax, [ebp+var_2C]
		cmp	eax, [ebp+var_38]
		jge	short loc_836E
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+40h]
		mov	edx, [ebp+var_2C]
		movzx	eax, byte ptr [ecx+edx]
		cmp	eax, 0FFh
		jnz	short loc_8311
		jmp	short loc_82EA
; ---------------------------------------------------------------------------

loc_8311:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanNot(wchar_t const *,int)+D5j
		mov	eax, [ebp+var_2C]
		push	eax		; int
		mov	ecx, [ebp+var_8]
		mov	ecx, [ecx+38h]	; this
		call	?elementAt@UVector@icu_56@@QBEPAXH@Z ; icu_56::UVector::elementAt(int)
		mov	[ebp+var_50], eax
		mov	ecx, [ebp+var_50] ; this
		call	?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ ; icu_56::UnicodeString::getBuffer(void)
		mov	[ebp+var_5C], eax
		mov	ecx, [ebp+var_50] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	[ebp+var_68], eax
		mov	eax, [ebp+var_68]
		cmp	eax, [ebp+var_20]
		jg	short loc_8369
		mov	eax, [ebp+var_68]
		push	eax
		mov	ecx, [ebp+var_5C]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+var_14]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?matches16CPB@icu_56@@YACPB_WHH0H@Z ; icu_56::matches16CPB(wchar_t const *,int,int,wchar_t const *,int)
		add	esp, 14h
		movsx	edx, al
		test	edx, edx
		jz	short loc_8369
		mov	eax, [ebp+var_14]
		jmp	short loc_8389
; ---------------------------------------------------------------------------

loc_8369:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanNot(wchar_t const *,int)+107j
					; icu_56::UnicodeSetStringSpan::spanNot(wchar_t	const *,int)+12Aj
		jmp	loc_82EA
; ---------------------------------------------------------------------------

loc_836E:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanNot(wchar_t const *,int)+C1j
		mov	eax, [ebp+var_14]
		sub	eax, [ebp+var_44]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_20]
		add	eax, [ebp+var_44]
		mov	[ebp+var_20], eax
		jnz	loc_8276
		mov	eax, [ebp+arg_4]

loc_8389:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanNot(wchar_t const *,int)+67j
					; icu_56::UnicodeSetStringSpan::spanNot(wchar_t	const *,int)+A4j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 12Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?spanNot@UnicodeSetStringSpan@icu_56@@ABEHPB_WH@Z endp ; sp-analysis failed

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 83A0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeSetStringSpan::spanNotBack(icu_56::UnicodeSetStringSpan	*this, const wchar_t *,	int)
		public ?spanNotBack@UnicodeSetStringSpan@icu_56@@ABEHPB_WH@Z
?spanNotBack@UnicodeSetStringSpan@icu_56@@ABEHPB_WH@Z proc near
					; CODE XREF: icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)+56p

var_120		= byte ptr -120h
var_5C		= dword	ptr -5Ch
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 120h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_120]
		mov	ecx, 48h ; 'H'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+38h]	; this
		call	?size@UVector@icu_56@@QBEHXZ ; icu_56::UVector::size(void)
		mov	[ebp+var_2C], eax

loc_83D7:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanNotBack(wchar_t const *,int)+11Aj
		push	0
		mov	eax, [ebp+var_14]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	edx, [ebp+var_8]
		mov	ecx, [edx+34h]
		call	?spanBack@UnicodeSet@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z ;	icu_56::UnicodeSet::spanBack(wchar_t const *,int,USetSpanCondition)
		mov	[ebp+var_14], eax
		cmp	[ebp+var_14], 0
		jnz	short loc_83FC
		xor	eax, eax
		jmp	loc_84C2
; ---------------------------------------------------------------------------

loc_83FC:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanNotBack(wchar_t const *,int)+53j
		mov	eax, [ebp+var_14]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	edx, [ebp+var_8]
		push	edx
		call	?spanOneBack@icu_56@@YAHABVUnicodeSet@1@PB_WH@Z	; icu_56::spanOneBack(icu_56::UnicodeSet const &,wchar_t const *,int)
		add	esp, 0Ch
		mov	[ebp+var_38], eax
		cmp	[ebp+var_38], 0
		jle	short loc_8421
		mov	eax, [ebp+var_14]
		jmp	loc_84C2
; ---------------------------------------------------------------------------

loc_8421:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanNotBack(wchar_t const *,int)+77j
		mov	[ebp+var_20], 0
		jmp	short loc_8433
; ---------------------------------------------------------------------------

loc_842A:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanNotBack(wchar_t const *,int)+AFj
					; icu_56::UnicodeSetStringSpan::spanNotBack(wchar_t const *,int):loc_84ACj
		mov	eax, [ebp+var_20]
		add	eax, 1
		mov	[ebp+var_20], eax

loc_8433:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanNotBack(wchar_t const *,int)+88j
		mov	eax, [ebp+var_20]
		cmp	eax, [ebp+var_2C]
		jge	short loc_84B1
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+40h]
		mov	edx, [ebp+var_20]
		movzx	eax, byte ptr [ecx+edx]
		cmp	eax, 0FFh
		jnz	short loc_8451
		jmp	short loc_842A
; ---------------------------------------------------------------------------

loc_8451:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanNotBack(wchar_t const *,int)+ADj
		mov	eax, [ebp+var_20]
		push	eax		; int
		mov	ecx, [ebp+var_8]
		mov	ecx, [ecx+38h]	; this
		call	?elementAt@UVector@icu_56@@QBEPAXH@Z ; icu_56::UVector::elementAt(int)
		mov	[ebp+var_44], eax
		mov	ecx, [ebp+var_44] ; this
		call	?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ ; icu_56::UnicodeString::getBuffer(void)
		mov	[ebp+var_50], eax
		mov	ecx, [ebp+var_44] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	[ebp+var_5C], eax
		mov	eax, [ebp+var_5C]
		cmp	eax, [ebp+var_14]
		jg	short loc_84AC
		mov	eax, [ebp+var_5C]
		push	eax
		mov	ecx, [ebp+var_50]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+var_14]
		sub	eax, [ebp+var_5C]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?matches16CPB@icu_56@@YACPB_WHH0H@Z ; icu_56::matches16CPB(wchar_t const *,int,int,wchar_t const *,int)
		add	esp, 14h
		movsx	edx, al
		test	edx, edx
		jz	short loc_84AC
		mov	eax, [ebp+var_14]
		jmp	short loc_84C2
; ---------------------------------------------------------------------------

loc_84AC:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanNotBack(wchar_t const *,int)+DFj
					; icu_56::UnicodeSetStringSpan::spanNotBack(wchar_t const *,int)+105j
		jmp	loc_842A
; ---------------------------------------------------------------------------

loc_84B1:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanNotBack(wchar_t const *,int)+99j
		mov	eax, [ebp+var_14]
		add	eax, [ebp+var_38]
		mov	[ebp+var_14], eax
		jnz	loc_83D7
		xor	eax, eax

loc_84C2:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanNotBack(wchar_t const *,int)+57j
					; icu_56::UnicodeSetStringSpan::spanNotBack(wchar_t const *,int)+7Cj ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 120h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?spanNotBack@UnicodeSetStringSpan@icu_56@@ABEHPB_WH@Z endp ; sp-analysis failed

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 84D8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeSetStringSpan::spanNotUTF8(icu_56::UnicodeSetStringSpan	*this, const unsigned __int8 *,	int)
		public ?spanNotUTF8@UnicodeSetStringSpan@icu_56@@ABEHPBEH@Z
?spanNotUTF8@UnicodeSetStringSpan@icu_56@@ABEHPBEH@Z proc near
					; CODE XREF: icu_56::UnicodeSetStringSpan::spanUTF8(uchar const	*,int,USetSpanCondition)+56p

var_12C		= byte ptr -12Ch
var_68		= dword	ptr -68h
var_5C		= dword	ptr -5Ch
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 12Ch
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_12C]
		mov	ecx, 4Bh ; 'K'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_14], 0
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_20], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+38h]	; this
		call	?size@UVector@icu_56@@QBEHXZ ; icu_56::UVector::size(void)
		mov	[ebp+var_38], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+40h]
		mov	[ebp+var_44], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+54h]
		test	ecx, ecx
		jz	short loc_8536
		mov	eax, [ebp+var_38]
		mov	ecx, [ebp+var_44]
		lea	edx, [ecx+eax*2]
		mov	[ebp+var_44], edx

loc_8536:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanNotUTF8(uchar const *,int)+50j
					; icu_56::UnicodeSetStringSpan::spanNotUTF8(uchar const	*,int)+154j
		push	0
		mov	eax, [ebp+var_20]
		push	eax
		mov	ecx, [ebp+arg_0]
		add	ecx, [ebp+var_14]
		push	ecx
		mov	edx, [ebp+var_8]
		mov	ecx, [edx+34h]
		call	?spanUTF8@UnicodeSet@icu_56@@QBEHPBDHW4USetSpanCondition@@@Z ; icu_56::UnicodeSet::spanUTF8(char const *,int,USetSpanCondition)
		mov	[ebp+var_2C], eax
		mov	eax, [ebp+var_2C]
		cmp	eax, [ebp+var_20]
		jnz	short loc_8561
		mov	eax, [ebp+arg_4]
		jmp	loc_8635
; ---------------------------------------------------------------------------

loc_8561:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanNotUTF8(uchar const *,int)+7Fj
		mov	eax, [ebp+var_14]
		add	eax, [ebp+var_2C]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_20]
		sub	eax, [ebp+var_2C]
		mov	[ebp+var_20], eax
		mov	eax, [ebp+var_20]
		push	eax
		mov	ecx, [ebp+arg_0]
		add	ecx, [ebp+var_14]
		push	ecx
		mov	edx, [ebp+var_8]
		push	edx
		call	?spanOneUTF8@icu_56@@YAHABVUnicodeSet@1@PBEH@Z ; icu_56::spanOneUTF8(icu_56::UnicodeSet	const &,uchar const *,int)
		add	esp, 0Ch
		mov	[ebp+var_50], eax
		cmp	[ebp+var_50], 0
		jle	short loc_859B
		mov	eax, [ebp+var_14]
		jmp	loc_8635
; ---------------------------------------------------------------------------

loc_859B:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanNotUTF8(uchar const *,int)+B9j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+44h]
		mov	[ebp+var_5C], ecx
		mov	[ebp+var_2C], 0
		jmp	short loc_85B6
; ---------------------------------------------------------------------------

loc_85AD:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanNotUTF8(uchar const *,int)+140j
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax

loc_85B6:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanNotUTF8(uchar const *,int)+D3j
		mov	eax, [ebp+var_2C]
		cmp	eax, [ebp+var_38]
		jge	short loc_861A
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+3Ch]
		mov	edx, [ebp+var_2C]
		mov	eax, [ecx+edx*4]
		mov	[ebp+var_68], eax
		cmp	[ebp+var_68], 0
		jz	short loc_860F
		mov	eax, [ebp+var_44]
		add	eax, [ebp+var_2C]
		movzx	ecx, byte ptr [eax]
		cmp	ecx, 0FFh
		jz	short loc_860F
		mov	eax, [ebp+var_68]
		cmp	eax, [ebp+var_20]
		jg	short loc_860F
		mov	eax, [ebp+var_68]
		push	eax
		mov	ecx, [ebp+var_5C]
		push	ecx
		mov	edx, [ebp+arg_0]
		add	edx, [ebp+var_14]
		push	edx
		call	?matches8@icu_56@@YACPBE0H@Z ; icu_56::matches8(uchar const *,uchar const *,int)
		add	esp, 0Ch
		movsx	eax, al
		test	eax, eax
		jz	short loc_860F
		mov	eax, [ebp+var_14]
		jmp	short loc_8635
; ---------------------------------------------------------------------------

loc_860F:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanNotUTF8(uchar const *,int)+F9j
					; icu_56::UnicodeSetStringSpan::spanNotUTF8(uchar const	*,int)+10Aj ...
		mov	eax, [ebp+var_5C]
		add	eax, [ebp+var_68]
		mov	[ebp+var_5C], eax
		jmp	short loc_85AD
; ---------------------------------------------------------------------------

loc_861A:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanNotUTF8(uchar const *,int)+E4j
		mov	eax, [ebp+var_14]
		sub	eax, [ebp+var_50]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_20]
		add	eax, [ebp+var_50]
		mov	[ebp+var_20], eax
		jnz	loc_8536
		mov	eax, [ebp+arg_4]

loc_8635:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanNotUTF8(uchar const *,int)+84j
					; icu_56::UnicodeSetStringSpan::spanNotUTF8(uchar const	*,int)+BEj ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 12Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?spanNotUTF8@UnicodeSetStringSpan@icu_56@@ABEHPBEH@Z endp ; sp-analysis	failed

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 864Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeSetStringSpan::spanNotBackUTF8(icu_56::UnicodeSetStringSpan *this, const unsigned __int8 *, int)
		public ?spanNotBackUTF8@UnicodeSetStringSpan@icu_56@@ABEHPBEH@Z
?spanNotBackUTF8@UnicodeSetStringSpan@icu_56@@ABEHPBEH@Z proc near
					; CODE XREF: icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+56p

var_120		= byte ptr -120h
var_5C		= dword	ptr -5Ch
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 120h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_120]
		mov	ecx, 48h ; 'H'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+38h]	; this
		call	?size@UVector@icu_56@@QBEHXZ ; icu_56::UVector::size(void)
		mov	[ebp+var_2C], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+40h]
		mov	[ebp+var_38], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+54h]
		test	ecx, ecx
		jz	short loc_86A3
		mov	eax, [ebp+var_2C]
		imul	eax, 3
		add	eax, [ebp+var_38]
		mov	[ebp+var_38], eax

loc_86A3:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanNotBackUTF8(uchar const *,int)+49j
					; icu_56::UnicodeSetStringSpan::spanNotBackUTF8(uchar const *,int)+12Cj
		push	0
		mov	eax, [ebp+var_14]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	edx, [ebp+var_8]
		mov	ecx, [edx+34h]
		call	?spanBackUTF8@UnicodeSet@icu_56@@QBEHPBDHW4USetSpanCondition@@@Z ; icu_56::UnicodeSet::spanBackUTF8(char const *,int,USetSpanCondition)
		mov	[ebp+var_14], eax
		cmp	[ebp+var_14], 0
		jnz	short loc_86C8
		xor	eax, eax
		jmp	loc_8780
; ---------------------------------------------------------------------------

loc_86C8:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanNotBackUTF8(uchar const *,int)+73j
		mov	eax, [ebp+var_14]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	edx, [ebp+var_8]
		push	edx
		call	?spanOneBackUTF8@icu_56@@YAHABVUnicodeSet@1@PBEH@Z ; icu_56::spanOneBackUTF8(icu_56::UnicodeSet	const &,uchar const *,int)
		add	esp, 0Ch
		mov	[ebp+var_44], eax
		cmp	[ebp+var_44], 0
		jle	short loc_86ED
		mov	eax, [ebp+var_14]
		jmp	loc_8780
; ---------------------------------------------------------------------------

loc_86ED:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanNotBackUTF8(uchar const *,int)+97j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+44h]
		mov	[ebp+var_50], ecx
		mov	[ebp+var_20], 0
		jmp	short loc_8708
; ---------------------------------------------------------------------------

loc_86FF:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanNotBackUTF8(uchar const *,int)+121j
		mov	eax, [ebp+var_20]
		add	eax, 1
		mov	[ebp+var_20], eax

loc_8708:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanNotBackUTF8(uchar const *,int)+B1j
		mov	eax, [ebp+var_20]
		cmp	eax, [ebp+var_2C]
		jge	short loc_876F
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+3Ch]
		mov	edx, [ebp+var_20]
		mov	eax, [ecx+edx*4]
		mov	[ebp+var_5C], eax
		cmp	[ebp+var_5C], 0
		jz	short loc_8764
		mov	eax, [ebp+var_38]
		add	eax, [ebp+var_20]
		movzx	ecx, byte ptr [eax]
		cmp	ecx, 0FFh
		jz	short loc_8764
		mov	eax, [ebp+var_5C]
		cmp	eax, [ebp+var_14]
		jg	short loc_8764
		mov	eax, [ebp+var_5C]
		push	eax
		mov	ecx, [ebp+var_50]
		push	ecx
		mov	edx, [ebp+arg_0]
		add	edx, [ebp+var_14]
		sub	edx, [ebp+var_5C]
		push	edx
		call	?matches8@icu_56@@YACPBE0H@Z ; icu_56::matches8(uchar const *,uchar const *,int)
		add	esp, 0Ch
		movsx	eax, al
		test	eax, eax
		jz	short loc_8764
		mov	eax, [ebp+var_14]
		jmp	short loc_8780
; ---------------------------------------------------------------------------

loc_8764:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanNotBackUTF8(uchar const *,int)+D7j
					; icu_56::UnicodeSetStringSpan::spanNotBackUTF8(uchar const *,int)+E8j	...
		mov	eax, [ebp+var_50]
		add	eax, [ebp+var_5C]
		mov	[ebp+var_50], eax
		jmp	short loc_86FF
; ---------------------------------------------------------------------------

loc_876F:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanNotBackUTF8(uchar const *,int)+C2j
		mov	eax, [ebp+var_14]
		add	eax, [ebp+var_44]
		mov	[ebp+var_14], eax
		jnz	loc_86A3
		xor	eax, eax

loc_8780:				; CODE XREF: icu_56::UnicodeSetStringSpan::spanNotBackUTF8(uchar const *,int)+77j
					; icu_56::UnicodeSetStringSpan::spanNotBackUTF8(uchar const *,int)+9Cj	...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 120h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?spanNotBackUTF8@UnicodeSetStringSpan@icu_56@@ABEHPBEH@Z endp ;	sp-analysis failed

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8798h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char const * __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::data(void)const
		public ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ proc near
					; CODE XREF: icu_56::StringPiece::StringPiece(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::c_str(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 87D8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char const * __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::c_str(void)const
		public ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::data(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ;	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Myptr(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8818h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
		public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
					; CODE XREF: icu_56::StringPiece::StringPiece(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&)+33p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+14h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8848h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char const * __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Myptr(void)const
		public ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::c_str(void)+26p

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+18h], 10h
		jb	short loc_8882
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+4]
		mov	[ebp+var_D0], edx
		jmp	short loc_888E
; ---------------------------------------------------------------------------

loc_8882:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Myptr(void)+2Aj
		mov	eax, [ebp+var_8]
		add	eax, 4
		mov	[ebp+var_D0], eax

loc_888E:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Myptr(void)+38j
		mov	eax, [ebp+var_D0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 889Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; [thunk]:public: virtual void * __thiscall icu_56::UnicodeFilter::`vector deleting destructor'`adjustor{4}' (unsigned int)
		public ??_EUnicodeFilter@icu_56@@W3AEPAXI@Z
??_EUnicodeFilter@icu_56@@W3AEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::UnicodeFilter::`vftable'{for `icu_56::UnicodeMatcher'}o
		sub	ecx, 4
		jmp	??_EUnicodeFilter@icu_56@@UAEPAXI@Z ; icu_56::UnicodeFilter::`vector deleting destructor'(uint)
??_EUnicodeFilter@icu_56@@W3AEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn __RTC_Shutdown:near ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
		extrn __RTC_InitBase:near ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
; const	type_info::`vftable'
		extrn ??_7type_info@@6B@:near
					; DATA XREF: .data:icu_56::UObject `RTTI Type Descriptor'o
					; .data:icu_56::UMemory	`RTTI Type Descriptor'o ...
; public: virtual void * __thiscall icu_56::UObject::getDynamicClassID(void)const
		extrn ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ:near
					; DATA XREF: .rdata:0000022Co
					; .rdata:00000CC8o
; void __cdecl icu_56::UMemory::operator delete(void *)
		extrn ??3UMemory@icu_56@@SAXPAX@Z:near
					; CODE XREF: icu_56::UObject::`scalar deleting destructor'(uint)+37p
					; icu_56::UObject::`vector deleting destructor'(uint)+75p ...
; _DWORD __thiscall icu_56::UObject::~UObject(icu_56::UObject *__hidden	this)
		extrn ??1UObject@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::UObject::`scalar deleting destructor'(uint)+26p
					; icu_56::UObject::`vector deleting destructor'(uint)+64p
					; DATA XREF: ...
		extrn __RTC_CheckEsp:near
					; CODE XREF: icu_56::UObject::`scalar deleting destructor'(uint)+4Dp
					; icu_56::UObject::`vector deleting destructor'(uint)+8Bp ...
; void __cdecl icu_56::UMemory::operator delete[](void *)
		extrn ??_VUMemory@icu_56@@SAXPAX@Z:near
					; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+51p
					; icu_56::UnicodeFunctor::`vector deleting destructor'(uint)+51p ...
; void __stdcall `eh vector destructor iterator'(void *, unsigned int, int, void (__thiscall *)(void *))
		extrn ??_M@YGXPAXIHP6EX0@Z@Z:near
					; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+3Dp
					; icu_56::UnicodeFunctor::`vector deleting destructor'(uint)+3Dp ...
		extrn __purecall:near	; DATA XREF: .rdata:000004D8o
					; .rdata:000004DCo ...
; public: virtual class	icu_56::UnicodeMatcher * __thiscall icu_56::UnicodeFunctor::toMatcher(void)const
		extrn ?toMatcher@UnicodeFunctor@icu_56@@UBEPAVUnicodeMatcher@2@XZ:near
					; DATA XREF: .rdata:000004E0o
; public: virtual class	icu_56::UnicodeReplacer	* __thiscall icu_56::UnicodeFunctor::toReplacer(void)const
		extrn ?toReplacer@UnicodeFunctor@icu_56@@UBEPAVUnicodeReplacer@2@XZ:near
					; DATA XREF: .rdata:000004E4o
					; .rdata:000009C0o
; _DWORD __thiscall icu_56::UnicodeFunctor::~UnicodeFunctor(icu_56::UnicodeFunctor *__hidden this)
		extrn ??1UnicodeFunctor@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::UnicodeFunctor::`scalar deleting destructor'(uint)+26p
					; icu_56::UnicodeFunctor::`vector deleting destructor'(uint)+64p
					; DATA XREF: ...
; _DWORD __thiscall icu_56::UnicodeMatcher::~UnicodeMatcher(icu_56::UnicodeMatcher *__hidden this)
		extrn ??1UnicodeMatcher@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::UnicodeMatcher::`scalar deleting destructor'(uint)+26p
					; icu_56::UnicodeMatcher::`vector deleting destructor'(uint)+64p
					; DATA XREF: ...
; public: virtual class	icu_56::UnicodeMatcher * __thiscall icu_56::UnicodeFilter::toMatcher(void)const
		extrn ?toMatcher@UnicodeFilter@icu_56@@UBEPAVUnicodeMatcher@2@XZ:near
					; DATA XREF: .rdata:000009BCo
; public: virtual void __thiscall icu_56::UnicodeFilter::setData(class icu_56::TransliterationRuleData const *)
		extrn ?setData@UnicodeFilter@icu_56@@UAEXPBVTransliterationRuleData@2@@Z:near
					; DATA XREF: .rdata:000009C4o
; public: virtual enum	icu_56::UMatchDegree __thiscall	icu_56::UnicodeFilter::matches(class icu_56::Replaceable const &, int &, int, signed char)
		extrn ?matches@UnicodeFilter@icu_56@@UAE?AW4UMatchDegree@2@ABVReplaceable@2@AAHHC@Z:near
					; DATA XREF: .rdata:0000099Co
; _DWORD __thiscall icu_56::UnicodeFilter::~UnicodeFilter(icu_56::UnicodeFilter	*__hidden this)
		extrn ??1UnicodeFilter@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::UnicodeFilter::`scalar deleting destructor'(uint)+26p
					; icu_56::UnicodeFilter::`vector deleting destructor'(uint)+64p
					; DATA XREF: ...
; public: virtual signed char __thiscall icu_56::Replaceable::hasMetaData(void)const
		extrn ?hasMetaData@Replaceable@icu_56@@UBECXZ:near
					; DATA XREF: .rdata:00000CD8o
; public: virtual class	icu_56::Replaceable * __thiscall icu_56::Replaceable::clone(void)const
		extrn ?clone@Replaceable@icu_56@@UBEPAV12@XZ:near
					; DATA XREF: .rdata:00000CDCo
; _DWORD __thiscall icu_56::Replaceable::~Replaceable(icu_56::Replaceable *__hidden this)
		extrn ??1Replaceable@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::Replaceable::`scalar deleting destructor'(uint)+26p
					; icu_56::Replaceable::`vector deleting	destructor'(uint)+64p
					; DATA XREF: ...
; _DWORD __thiscall icu_56::StringPiece::StringPiece(icu_56::StringPiece *__hidden this, const struct icu_56::StringPiece *, int, int)
		extrn ??0StringPiece@icu_56@@QAE@ABV01@HH@Z:near
					; CODE XREF: icu_56::StringPiece::substr(int,int)+32p
; public: virtual char * __thiscall icu_56::ByteSink::GetAppendBuffer(int, int,	char *,	int, int *)
		extrn ?GetAppendBuffer@ByteSink@icu_56@@UAEPADHHPADHPAH@Z:near
					; DATA XREF: .rdata:00001388o
; public: virtual void __thiscall icu_56::ByteSink::Flush(void)
		extrn ?Flush@ByteSink@icu_56@@UAEXXZ:near ; DATA XREF: .rdata:0000138Co
; _DWORD __thiscall icu_56::ByteSink::~ByteSink(icu_56::ByteSink *__hidden this)
		extrn ??1ByteSink@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::ByteSink::`scalar deleting	destructor'(uint)+26p
					; icu_56::ByteSink::`vector deleting destructor'(uint)+64p
					; DATA XREF: ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::moveFrom(icu_56::UnicodeString *__hidden this, struct	icu_56::UnicodeString *)
		extrn ?moveFrom@UnicodeString@icu_56@@QAEAAV12@AAV12@@Z:near
					; CODE XREF: icu_56::UnicodeString::operator=(icu_56::UnicodeString &&)+2Ap
; void __thiscall icu_56::UnicodeString::swap(icu_56::UnicodeString *__hidden this, struct icu_56::UnicodeString *)
		extrn ?swap@UnicodeString@icu_56@@QAEXAAV12@@Z:near
					; CODE XREF: icu_56::swap(icu_56::UnicodeString	&,icu_56::UnicodeString	&)+25p
; _DWORD __thiscall icu_56::UnicodeString::~UnicodeString(icu_56::UnicodeString	*__hidden this)
		extrn ??1UnicodeString@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::UnicodeString::`scalar deleting destructor'(uint)+26p
					; icu_56::UnicodeString::`vector deleting destructor'(uint)+64p
					; DATA XREF: ...
; public: virtual void * __thiscall icu_56::UnicodeString::getDynamicClassID(void)const
		extrn ?getDynamicClassID@UnicodeString@icu_56@@UBEPAXXZ:near
					; DATA XREF: .rdata:00001904o
; public: virtual void __thiscall icu_56::UnicodeString::extractBetween(int, int, class	icu_56::UnicodeString &)const
		extrn ?extractBetween@UnicodeString@icu_56@@UBEXHHAAV12@@Z:near
					; DATA XREF: .rdata:00001908o
; public: virtual void __thiscall icu_56::UnicodeString::handleReplaceBetween(int, int,	class icu_56::UnicodeString const &)
		extrn ?handleReplaceBetween@UnicodeString@icu_56@@UAEXHHABV12@@Z:near
					; DATA XREF: .rdata:0000190Co
; public: virtual void __thiscall icu_56::UnicodeString::copy(int, int,	int)
		extrn ?copy@UnicodeString@icu_56@@UAEXHHH@Z:near
					; DATA XREF: .rdata:00001910o
; public: virtual signed char __thiscall icu_56::UnicodeString::hasMetaData(void)const
		extrn ?hasMetaData@UnicodeString@icu_56@@UBECXZ:near
					; DATA XREF: .rdata:00001914o
; public: virtual class	icu_56::Replaceable * __thiscall icu_56::UnicodeString::clone(void)const
		extrn ?clone@UnicodeString@icu_56@@UBEPAVReplaceable@2@XZ:near
					; DATA XREF: .rdata:00001918o
; protected: virtual int __thiscall icu_56::UnicodeString::getLength(void)const
		extrn ?getLength@UnicodeString@icu_56@@MBEHXZ:near
					; DATA XREF: .rdata:0000191Co
; protected: virtual wchar_t __thiscall	icu_56::UnicodeString::getCharAt(int)const
		extrn ?getCharAt@UnicodeString@icu_56@@MBE_WH@Z:near
					; DATA XREF: .rdata:00001920o
; protected: virtual int __thiscall icu_56::UnicodeString::getChar32At(int)const
		extrn ?getChar32At@UnicodeString@icu_56@@MBEHH@Z:near
					; DATA XREF: .rdata:00001924o
; int __thiscall icu_56::UnicodeString::doHashCode(icu_56::UnicodeString *__hidden this)
		extrn ?doHashCode@UnicodeString@icu_56@@ABEHXZ:near
					; CODE XREF: icu_56::UnicodeString::hashCode(void)+26p
; int __thiscall icu_56::UnicodeString::refCount(icu_56::UnicodeString *__hidden this)
		extrn ?refCount@UnicodeString@icu_56@@ABEHXZ:near
					; CODE XREF: icu_56::UnicodeString::isBufferWritable(void)+3Ep
; signed __int8	__thiscall icu_56::UnicodeString::doCompare(icu_56::UnicodeString *__hidden this, int, int, const wchar_t *, int, int)
		extrn ?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z:near
					; CODE XREF: icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+72p
					; icu_56::UnicodeString::compare(wchar_t const *,int)+3Bp ...
; signed __int8	__thiscall icu_56::UnicodeString::doEquals(icu_56::UnicodeString *__hidden this, const struct icu_56::UnicodeString *, int)
		extrn ?doEquals@UnicodeString@icu_56@@ABECABV12@H@Z:near
					; CODE XREF: icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)+76p
; signed __int8	__thiscall icu_56::UnicodeString::doCompareCodePointOrder(icu_56::UnicodeString	*__hidden this,	int, int, const	wchar_t	*, int,	int)
		extrn ?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHPB_WHH@Z:near
					; CODE XREF: icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const	&,int,int)+72p
					; icu_56::UnicodeString::compareCodePointOrder(wchar_t const *,int)+3Bp ...
; signed __int8	__thiscall icu_56::UnicodeString::doCaseCompare(icu_56::UnicodeString *__hidden	this, int, int,	const wchar_t *, int, int, unsigned int)
		extrn ?doCaseCompare@UnicodeString@icu_56@@ABECHHPB_WHHI@Z:near
					; CODE XREF: icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString	const &,int,int,uint)+76p
					; icu_56::UnicodeString::caseCompare(wchar_t const *,int,uint)+3Fp ...
; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *__hidden	this, const wchar_t *, int, int, int, int)
		extrn ?indexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z:near
					; CODE XREF: icu_56::UnicodeString::indexOf(icu_56::UnicodeString const	&,int,int,int,int)+64p
					; icu_56::UnicodeString::indexOf(wchar_t const *,int,int)+4Cp ...
; int __thiscall icu_56::UnicodeString::doIndexOf(icu_56::UnicodeString	*__hidden this,	wchar_t, int, int)
		extrn ?doIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z:near
					; CODE XREF: icu_56::UnicodeString::indexOf(wchar_t,int,int)+33p
					; icu_56::UnicodeString::indexOf(wchar_t)+36p ...
; int __thiscall icu_56::UnicodeString::doIndexOf(icu_56::UnicodeString	*__hidden this,	int, int, int)
		extrn ?doIndexOf@UnicodeString@icu_56@@ABEHHHH@Z:near
					; CODE XREF: icu_56::UnicodeString::indexOf(int,int,int)+32p
; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *__hidden this, const	wchar_t	*, int,	int, int, int)
		extrn ?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z:near
					; CODE XREF: icu_56::UnicodeString::lastIndexOf(wchar_t	const *,int,int,int)+38p
					; icu_56::UnicodeString::lastIndexOf(wchar_t const *,int,int)+4Cp ...
; int __thiscall icu_56::UnicodeString::doLastIndexOf(icu_56::UnicodeString *__hidden this, wchar_t, int, int)
		extrn ?doLastIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z:near
					; CODE XREF: icu_56::UnicodeString::lastIndexOf(wchar_t,int,int)+33p
					; icu_56::UnicodeString::lastIndexOf(wchar_t)+36p ...
; int __thiscall icu_56::UnicodeString::doLastIndexOf(icu_56::UnicodeString *__hidden this, int, int, int)
		extrn ?doLastIndexOf@UnicodeString@icu_56@@ABEHHHH@Z:near
					; CODE XREF: icu_56::UnicodeString::lastIndexOf(int,int,int)+32p
		extrn _u_strlen_56:near	; CODE XREF: icu_56::UnicodeString::startsWith(wchar_t const *,int)+2Dp
					; icu_56::UnicodeString::startsWith(wchar_t const *,int,int)+2Dp ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::doReplace(icu_56::UnicodeString *__hidden this, int, int, const struct icu_56::UnicodeString *, int, int)
		extrn ?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z:near
					; CODE XREF: icu_56::UnicodeString::replace(int,int,icu_56::UnicodeString const	&)+3Dp
					; icu_56::UnicodeString::replace(int,int,icu_56::UnicodeString const &,int,int)+3Ap ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::doReplace(icu_56::UnicodeString *__hidden this, int, int, const wchar_t *, int, int)
		extrn ?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z:near
					; CODE XREF: icu_56::UnicodeString::replace(int,int,wchar_t const *,int)+38p
					; icu_56::UnicodeString::replace(int,int,wchar_t const *,int,int)+3Ap ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::findAndReplace(icu_56::UnicodeString *__hidden this, int, int, const struct icu_56::UnicodeString *, int, int, const struct icu_56::UnicodeString *, int, int)
		extrn ?findAndReplace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH0HH@Z:near
					; CODE XREF: icu_56::UnicodeString::findAndReplace(icu_56::UnicodeString const &,icu_56::UnicodeString const &)+4Fp
					; icu_56::UnicodeString::findAndReplace(int,int,icu_56::UnicodeString const &,icu_56::UnicodeString const &)+4Cp
; void __thiscall icu_56::UnicodeString::doExtract(icu_56::UnicodeString *__hidden this, int, int, wchar_t *, int)
		extrn ?doExtract@UnicodeString@icu_56@@ABEXHHPA_WH@Z:near
					; CODE XREF: icu_56::UnicodeString::extract(int,int,wchar_t *,int)+36p
					; icu_56::UnicodeString::extractBetween(int,int,wchar_t	*,int)+51p
; int __thiscall icu_56::UnicodeString::extract(icu_56::UnicodeString *__hidden	this, int, int,	char *,	unsigned int, const char *)
		extrn ?extract@UnicodeString@icu_56@@QBEHHHPADIPBD@Z:near
					; CODE XREF: icu_56::UnicodeString::extract(int,int,char *,char	const *)+3Ep
; struct icu_56::UnicodeString __thiscall __high icu_56::UnicodeString::tempSubString(int, int)
		extrn ?tempSubString@UnicodeString@icu_56@@QBE?AV12@HH@Z:near
					; CODE XREF: icu_56::UnicodeString::tempSubStringBetween(int,int)+3Fp
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replace(icu_56::UnicodeString	*__hidden this,	int, int, int)
		extrn ?replace@UnicodeString@icu_56@@QAEAAV12@HHH@Z:near
					; CODE XREF: icu_56::UnicodeString::operator=(int)+35p
					; icu_56::UnicodeString::setTo(int)+3Dp ...
; void __thiscall icu_56::UnicodeString::unBogus(icu_56::UnicodeString *__hidden this)
		extrn ?unBogus@UnicodeString@icu_56@@AAEXXZ:near
					; CODE XREF: icu_56::UnicodeString::setTo(icu_56::UnicodeString	const &,int,int)+26p
					; icu_56::UnicodeString::setTo(icu_56::UnicodeString const &,int)+26p ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::copyFrom(icu_56::UnicodeString *__hidden this, const struct icu_56::UnicodeString *, signed __int8)
		extrn ?copyFrom@UnicodeString@icu_56@@AAEAAV12@ABV12@C@Z:near
					; CODE XREF: icu_56::UnicodeString::setTo(icu_56::UnicodeString	const &)+2Cp
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::doAppend(icu_56::UnicodeString *__hidden this, const struct icu_56::UnicodeString *, int, int)
		extrn ?doAppend@UnicodeString@icu_56@@AAEAAV12@ABV12@HH@Z:near
					; CODE XREF: icu_56::UnicodeString::append(icu_56::UnicodeString const &,int,int)+32p
					; icu_56::UnicodeString::append(icu_56::UnicodeString const &)+35p ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::doAppend(icu_56::UnicodeString *__hidden this, const wchar_t *, int, int)
		extrn ?doAppend@UnicodeString@icu_56@@AAEAAV12@PB_WHH@Z:near
					; CODE XREF: icu_56::UnicodeString::append(wchar_t const *,int,int)+32p
					; icu_56::UnicodeString::append(wchar_t	const *,int)+30p ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *__hidden this, int)
		extrn ?append@UnicodeString@icu_56@@QAEAAV12@H@Z:near
					; CODE XREF: icu_56::UnicodeString::operator+=(int)+2Ap
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::doReverse(icu_56::UnicodeString *__hidden this, int, int)
		extrn ?doReverse@UnicodeString@icu_56@@AAEAAV12@HH@Z:near
					; CODE XREF: icu_56::UnicodeString::reverse(void)+31p
					; icu_56::UnicodeString::reverse(int,int)+2Ep
; signed __int8	__thiscall icu_56::UnicodeSet::containsNone(icu_56::UnicodeSet *__hidden this, int, int)
		extrn ?containsNone@UnicodeSet@icu_56@@QBECHH@Z:near
					; CODE XREF: icu_56::UnicodeSet::containsSome(int,int)+2Ep
; signed __int8	__thiscall icu_56::UnicodeSet::containsNone(icu_56::UnicodeSet *__hidden this, const struct icu_56::UnicodeSet *)
		extrn ?containsNone@UnicodeSet@icu_56@@QBECABV12@@Z:near
					; CODE XREF: icu_56::UnicodeSet::containsSome(icu_56::UnicodeSet const &)+2Ap
; signed __int8	__thiscall icu_56::UnicodeSet::containsNone(icu_56::UnicodeSet *__hidden this, const struct icu_56::UnicodeString *)
		extrn ?containsNone@UnicodeSet@icu_56@@QBECABVUnicodeString@2@@Z:near
					; CODE XREF: icu_56::UnicodeSet::containsSome(icu_56::UnicodeString const &)+2Ap
; int __thiscall __high	icu_56::UnicodeSet::span(const wchar_t *, int, enum USetSpanCondition)
		extrn ?span@UnicodeSet@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z:near
					; CODE XREF: icu_56::UnicodeSet::span(icu_56::UnicodeString const &,int,USetSpanCondition)+68p
					; icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet	const &,icu_56::UVector	const &,uint)+144p ...
; int __thiscall __high	icu_56::UnicodeSet::spanBack(const wchar_t *, int, enum	USetSpanCondition)
		extrn ?spanBack@UnicodeSet@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z:near
					; CODE XREF: icu_56::UnicodeSet::spanBack(icu_56::UnicodeString	const &,int,USetSpanCondition)+5Fp
					; icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet	const &,icu_56::UVector	const &,uint)+42Ep ...
; int __thiscall icu_56::UVector::indexOf(icu_56::UVector *__hidden this, void *, int)
		extrn ?indexOf@UVector@icu_56@@QBEHPAXH@Z:near
					; CODE XREF: icu_56::UVector::contains(void *)+2Cp
; int __thiscall icu_56::UVector::indexOf(icu_56::UVector *__hidden this, int, int)
		extrn ?indexOf@UVector@icu_56@@QBEHHH@Z:near
					; CODE XREF: icu_56::UVector::contains(int)+2Cp
; void *__thiscall icu_56::UVector::elementAt(icu_56::UVector *__hidden	this, int)
		extrn ?elementAt@UVector@icu_56@@QBEPAXH@Z:near
					; CODE XREF: icu_56::UVector::firstElement(void)+28p
					; icu_56::UVector::lastElement(void)+30p ...
; int __thiscall icu_56::UVector::elementAti(icu_56::UVector *__hidden this, int)
		extrn ?elementAti@UVector@icu_56@@QBEHH@Z:near
					; CODE XREF: icu_56::UVector::lastElementi(void)+30p
; public: signed char __thiscall icu_56::UVector::operator==(class icu_56::UVector const &)
		extrn ??8UVector@icu_56@@QAECABV01@@Z:near
					; CODE XREF: icu_56::UVector::operator!=(icu_56::UVector const &)+2Ap
; void __thiscall icu_56::UVector::addElement(icu_56::UVector *__hidden	this, void *, enum UErrorCode *)
		extrn ?addElement@UVector@icu_56@@QAEXPAXAAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::UStack::push(void *,UErrorCode &)+2Ep
; void __thiscall icu_56::UVector::addElement(icu_56::UVector *__hidden	this, int, enum	UErrorCode *)
		extrn ?addElement@UVector@icu_56@@QAEXHAAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::UStack::push(int,UErrorCode &)+2Ep
; _DWORD __thiscall icu_56::UnicodeSet::~UnicodeSet(icu_56::UnicodeSet *__hidden this)
		extrn ??1UnicodeSet@icu_56@@UAE@XZ:near
					; CODE XREF: __unwindfunclet$??0UnicodeSetStringSpan@icu_56@@QAE@ABVUnicodeSet@1@ABVUVector@1@I@Z$0+3j
					; __unwindfunclet$??0UnicodeSetStringSpan@icu_56@@QAE@ABV01@ABVUVector@1@@Z$0+3j ...
; int __thiscall __high	icu_56::UnicodeSet::spanBackUTF8(const char *, int, enum USetSpanCondition)
		extrn ?spanBackUTF8@UnicodeSet@icu_56@@QBEHPBDHW4USetSpanCondition@@@Z:near
					; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet const &,icu_56::UVector const &,uint)+565p
					; icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)+6Dp ...
; int __thiscall __high	icu_56::UnicodeSet::spanUTF8(const char	*, int,	enum USetSpanCondition)
		extrn ?spanUTF8@UnicodeSet@icu_56@@QBEHPBDHW4USetSpanCondition@@@Z:near
					; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet const &,icu_56::UVector const &,uint)+52Bp
					; icu_56::UnicodeSetStringSpan::spanUTF8(uchar const *,int,USetSpanCondition)+6Dp ...
		extrn _uprv_malloc_56:near
					; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet const &,icu_56::UVector const &,uint)+270p
					; icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSetStringSpan const	&,icu_56::UVector const	&)+123p ...
; struct icu_56::UnicodeFunctor	*__thiscall icu_56::UnicodeSet::freeze(icu_56::UnicodeSet *__hidden this)
		extrn ?freeze@UnicodeSet@icu_56@@QAEPAVUnicodeFunctor@2@XZ:near
					; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet const &,icu_56::UVector const &,uint)+202p
					; icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet	const &,icu_56::UVector	const &,uint)+822p
; _DWORD __thiscall icu_56::UnicodeSet::UnicodeSet(icu_56::UnicodeSet *__hidden	this, int, int)
		extrn ??0UnicodeSet@icu_56@@QAE@HH@Z:near
					; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet const &,icu_56::UVector const &,uint)+4Cp
		extrn ___security_cookie:near
					; DATA XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet const &,icu_56::UVector const &,uint)+2Er
					; icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSetStringSpan const	&,icu_56::UVector const	&)+2Er	...
		extrn ___CxxFrameHandler3:near
					; CODE XREF: __ehhandler$??0UnicodeSetStringSpan@icu_56@@QAE@ABVUnicodeSet@1@ABVUVector@1@I@Z+19j
					; __ehhandler$??0UnicodeSetStringSpan@icu_56@@QAE@ABV01@ABVUVector@1@@Z+19j ...
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near
					; CODE XREF: __ehhandler$??0UnicodeSetStringSpan@icu_56@@QAE@ABVUnicodeSet@1@ABVUVector@1@I@Z+Fp
					; __ehhandler$??0UnicodeSetStringSpan@icu_56@@QAE@ABV01@ABVUVector@1@@Z+Fp ...
		extrn _u_strToUTF8_56:near
					; CODE XREF: icu_56::getUTF8Length(wchar_t const *,int)+40p
					; icu_56::appendUTF8(wchar_t const *,int,uchar *,int)+44p
; __fastcall _RTC_CheckStackVars(x, x)
		extrn @_RTC_CheckStackVars@8:near
					; CODE XREF: icu_56::getUTF8Length(wchar_t const *,int)+74p
					; icu_56::appendUTF8(wchar_t const *,int,uchar *,int)+72p ...
; void *__cdecl	memcpy(void *Dst, const	void *Src, size_t Size)
		extrn _memcpy:near	; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSetStringSpan const &,icu_56::UVector const &)+197p
		extrn _uprv_checkValidMemory:near
					; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSetStringSpan const &,icu_56::UVector const &)+17Dp
; _DWORD __thiscall icu_56::UnicodeSet::UnicodeSet(icu_56::UnicodeSet *__hidden	this, const struct icu_56::UnicodeSet *)
		extrn ??0UnicodeSet@icu_56@@QAE@ABV01@@Z:near
					; CODE XREF: icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSetStringSpan const &,icu_56::UVector const &)+49p
		extrn _uprv_free_56:near
					; CODE XREF: icu_56::UnicodeSetStringSpan::~UnicodeSetStringSpan(void)+CBp
					; icu_56::OffsetList::~OffsetList(void)+36p
; struct icu_56::UnicodeSet *__thiscall	icu_56::UnicodeSet::add(icu_56::UnicodeSet *__hidden this, int)
		extrn ?add@UnicodeSet@icu_56@@QAEAAV12@H@Z:near
					; CODE XREF: icu_56::UnicodeSetStringSpan::addToSpanNotSet(int)+82p
; struct icu_56::UnicodeFunctor	*__thiscall icu_56::UnicodeSet::cloneAsThawed(icu_56::UnicodeSet *__hidden this)
		extrn ?cloneAsThawed@UnicodeSet@icu_56@@QBEPAVUnicodeFunctor@2@XZ:near
					; CODE XREF: icu_56::UnicodeSetStringSpan::addToSpanNotSet(int)+5Dp
; void *__cdecl	memset(void *Dst, int Val, size_t Size)
		extrn _memset:near	; CODE XREF: icu_56::OffsetList::setMaxLength(int)+6Ap
		extrn _utf8_back1SafeBody_56:near
					; CODE XREF: icu_56::UnicodeSetStringSpan::spanUTF8(uchar const	*,int,USetSpanCondition)+1C6p
		extrn _utf8_nextCharSafeBody_56:near
					; CODE XREF: icu_56::spanOneUTF8(icu_56::UnicodeSet const &,uchar const	*,int)+168p
		extrn _utf8_prevCharSafeBody_56:near
					; CODE XREF: icu_56::spanOneBackUTF8(icu_56::UnicodeSet	const &,uchar const *,int)+75p


		end
