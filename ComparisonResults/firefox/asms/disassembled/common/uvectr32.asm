;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	F71FABCD6003288AE11E4E3E83F0F9FD
; Input	CRC32 :	AA10EA81

; File Name   :	D:\compspace\objfiles\firefox\common\uvectr32.obj
; Format      :	COFF (X386MAGIC)
; includelib "msvcprtd"
; includelib "MSVCRTD"
; includelib "OLDNAMES"

		include	uni.inc	; see unicode subdir of	ida for	info on	unicode

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	byte public 'BSS' use32
		assume cs:_bss
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing
; char `public:	static void * __cdecl icu_56::UVector32::getStaticClassID(void)'::`2'::classID
?classID@?1??getStaticClassID@UVector32@icu_56@@SAPAXXZ@4DA db ?
					; DATA XREF: icu_56::UVector32::getStaticClassID(void)+1Eo
		align 4
_bss		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	operator new(unsigned int)
		public ??2@YAPAXI@Z
??2@YAPAXI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??2@YAPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$TMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$TMZ
		;org 3Ch
__RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
_rtc$TMZ	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$IMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$IMZ
		;org 40h
__RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase	; DATA XREF: .rdata$r:000001A0o
					; .rdata$r:000001BCo ...
_rtc$IMZ	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 44h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl operator	delete(void *)
		public ??3@YAXPAX@Z
??3@YAXPAX@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??3@YAXPAX@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 78h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	icu_56::UMemory::operator new(unsigned int, void *)
		public ??2UMemory@icu_56@@SAPAXIPAX@Z
??2UMemory@icu_56@@SAPAXIPAX@Z proc near

var_C0		= byte ptr -0C0h
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??2UMemory@icu_56@@SAPAXIPAX@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A0h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl icu_56::UMemory::operator delete(void *)
		public ??3UMemory@icu_56@@SAXPAX0@Z
??3UMemory@icu_56@@SAXPAX0@Z proc near

var_C0		= byte ptr -0C0h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??3UMemory@icu_56@@SAXPAX0@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C8h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UMemory	& __thiscall icu_56::UMemory::operator=(class icu_56::UMemory const &)
		public ??4UMemory@icu_56@@QAEAAV01@ABV01@@Z
??4UMemory@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4UMemory@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0F8h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UObject::UObject(icu_56::UObject *__hidden this)
		public ??0UObject@icu_56@@QAE@XZ
??0UObject@icu_56@@QAE@XZ proc near	; CODE XREF: icu_56::UVector32::UVector32(UErrorCode &)+45p
					; icu_56::UVector32::UVector32(int,UErrorCode &)+45p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UObject@icu_56@@6B@	; const	icu_56::UObject::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0UObject@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 130h
		dd offset ??_R4UObject@icu_56@@6B@ ; const icu_56::UObject::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7UObject@icu_56@@6B@
; const	icu_56::UObject::`vftable'
??_7UObject@icu_56@@6B@	dd offset ??_EUObject@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::UObject::UObject(void)+26o
					; icu_56::UObject::UObject(icu_56::UObject const &)+44o
					; icu_56::UObject::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ ;	icu_56::UObject::getDynamicClassID(void)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 13Ch
		public ??_R4UObject@icu_56@@6B@
; const	icu_56::UObject::`RTTI Complete	Object Locator'
??_R4UObject@icu_56@@6B@ dd 3 dup(0)	; DATA XREF: .rdata:00000130o
		dd offset ??_R0?AVUObject@icu_56@@@8 ; icu_56::UObject `RTTI Type Descriptor'
		dd offset ??_R3UObject@icu_56@@8 ; icu_56::UObject::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 150h
		public ??_R0?AVUObject@icu_56@@@8
; class	icu_56::UObject	`RTTI Type Descriptor'
??_R0?AVUObject@icu_56@@@8 dd offset ??_7type_info@@6B@	; DATA XREF: .rdata$r:00000148o
					; .rdata$r:icu_56::UObject::`RTTI Base Class Descriptor	at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 8
a_?avuobject@ic	db '.?AVUObject@icu_56@@',0
		align 10h
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 170h
		public ??_R3UObject@icu_56@@8
; icu_56::UObject::`RTTI Class Hierarchy Descriptor'
??_R3UObject@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:0000014Co
					; .rdata$r:000001A4o
		dd 2
		dd offset ??_R2UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 180h
		public ??_R2UObject@icu_56@@8
; icu_56::UObject::`RTTI Base Class Array'
??_R2UObject@icu_56@@8 dd offset ??_R1A@?0A@EA@UObject@icu_56@@8
					; DATA XREF: .rdata$r:0000017Co
					; icu_56::UObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 18Ch
		public ??_R1A@?0A@EA@UObject@icu_56@@8
; icu_56::UObject::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UObject@icu_56@@8	dd offset ??_R0?AVUObject@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UObject::`RTTI Base Class	Array'o
					; .rdata$r:00000BD8o
					; icu_56::UObject `RTTI	Type Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset __RTC_InitBase_rtc$IMZ
		dd offset ??_R3UObject@icu_56@@8 ; icu_56::UObject::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1A8h
		public ??_R13?0A@EA@UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Descriptor at (4, -1, 0, 64)'
??_R13?0A@EA@UMemory@icu_56@@8 dd offset ??_R0?AVUMemory@icu_56@@@8
					; DATA XREF: .rdata$r:00000184o
					; .rdata$r:00000BDCo
					; icu_56::UMemory `RTTI	Type Descriptor'
		align 10h
		dd 4, 0FFFFFFFFh, 0
		dd offset __RTC_InitBase_rtc$IMZ
		dd offset ??_R3UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 1C4h
		public ??_R0?AVUMemory@icu_56@@@8
; class	icu_56::UMemory	`RTTI Type Descriptor'
??_R0?AVUMemory@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::UMemory::`RTTI Base Class	Descriptor at (4,-1,0,64)'o
					; .rdata$r:icu_56::UMemory::`RTTI Base Class Descriptor	at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avumemory@ic	db '.?AVUMemory@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1E4h
		public ??_R3UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Class Hierarchy Descriptor'
??_R3UMemory@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:000001C0o
					; .rdata$r:00000214o
		dd 1
		dd offset ??_R2UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1F4h
		public ??_R2UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Array'
??_R2UMemory@icu_56@@8 dd offset ??_R1A@?0A@EA@UMemory@icu_56@@8
					; DATA XREF: .rdata$r:000001F0o
					; icu_56::UMemory::`RTTI Base Class Descriptor at (0,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1FCh
		public ??_R1A@?0A@EA@UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UMemory@icu_56@@8	dd offset ??_R0?AVUMemory@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UMemory::`RTTI Base Class	Array'o
					; icu_56::UMemory `RTTI	Type Descriptor'
		dd 2 dup(0)
		dd 0FFFFFFFFh, 0
		dd offset __RTC_InitBase_rtc$IMZ
		dd offset ??_R3UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 218h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UObject::UObject(icu_56::UObject *this, const struct icu_56::UObject *)
		public ??0UObject@icu_56@@QAE@ABV01@@Z
??0UObject@icu_56@@QAE@ABV01@@Z	proc near

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jz	short loc_24F
		mov	eax, [ebp+arg_0]
		add	eax, 4
		mov	[ebp+var_D0], eax
		jmp	short loc_259
; ---------------------------------------------------------------------------

loc_24F:				; CODE XREF: icu_56::UObject::UObject(icu_56::UObject const &)+27j
		mov	[ebp+var_D0], 0

loc_259:				; CODE XREF: icu_56::UObject::UObject(icu_56::UObject const &)+35j
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UObject@icu_56@@6B@	; const	icu_56::UObject::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??0UObject@icu_56@@QAE@ABV01@@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 270h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UObject	& __thiscall icu_56::UObject::operator=(class icu_56::UObject const &)
		public ??4UObject@icu_56@@QAEAAV01@ABV01@@Z
??4UObject@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4UObject@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2A0h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UObject::`scalar deleting destructor'(unsigned int)
		public ??_GUObject@icu_56@@UAEPAXI@Z
??_GUObject@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_2DF
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_2DF:				; CODE XREF: icu_56::UObject::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GUObject@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2F8h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UObject::`vector deleting destructor'(unsigned int)
		public ??_EUObject@icu_56@@UAEPAXI@Z
??_EUObject@icu_56@@UAEPAXI@Z proc near	; DATA XREF: .rdata:const icu_56::UObject::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_359
		push	offset ??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	4
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_351
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_351:				; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_378
; ---------------------------------------------------------------------------

loc_359:				; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_375
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_375:				; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_378:				; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EUObject@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 390h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UVector32::`scalar deleting	destructor'(unsigned int)
		public ??_GUVector32@icu_56@@UAEPAXI@Z
??_GUVector32@icu_56@@UAEPAXI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1UVector32@icu_56@@UAE@XZ ; icu_56::UVector32::~UVector32(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_3CF
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_3CF:				; CODE XREF: icu_56::UVector32::`scalar	deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GUVector32@icu_56@@UAEPAXI@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3E8h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UVector32::`vector deleting	destructor'(unsigned int)
		public ??_EUVector32@icu_56@@UAEPAXI@Z
??_EUVector32@icu_56@@UAEPAXI@Z	proc near
					; DATA XREF: .rdata:const icu_56::UVector32::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_449
		push	offset ??1UVector32@icu_56@@UAE@XZ ; icu_56::UVector32::~UVector32(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	14h
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_441
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_441:				; CODE XREF: icu_56::UVector32::`vector	deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_468
; ---------------------------------------------------------------------------

loc_449:				; CODE XREF: icu_56::UVector32::`vector	deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1UVector32@icu_56@@UAE@XZ ; icu_56::UVector32::~UVector32(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_465
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_465:				; CODE XREF: icu_56::UVector32::`vector	deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_468:				; CODE XREF: icu_56::UVector32::`vector	deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EUVector32@icu_56@@UAEPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 480h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UVector32::ensureCapacity(icu_56::UVector32 *this, int, enum	UErrorCode *)
		public ?ensureCapacity@UVector32@icu_56@@QAECHAAW4UErrorCode@@@Z
?ensureCapacity@UVector32@icu_56@@QAECHAAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::UVector32::addElement(int,UErrorCode &)+34p
					; icu_56::UVector32::reserveBlock(int,UErrorCode &)+34p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jl	short loc_4BA
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		cmp	ecx, [ebp+arg_0]
		jl	short loc_4BA
		mov	al, 1
		jmp	short loc_4CA
; ---------------------------------------------------------------------------
		jmp	short loc_4CA
; ---------------------------------------------------------------------------

loc_4BA:				; CODE XREF: icu_56::UVector32::ensureCapacity(int,UErrorCode &)+27j
					; icu_56::UVector32::ensureCapacity(int,UErrorCode &)+32j
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?expandCapacity@UVector32@icu_56@@QAECHAAW4UErrorCode@@@Z ; icu_56::UVector32::expandCapacity(int,UErrorCode &)

loc_4CA:				; CODE XREF: icu_56::UVector32::ensureCapacity(int,UErrorCode &)+36j
					; icu_56::UVector32::ensureCapacity(int,UErrorCode &)+38j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?ensureCapacity@UVector32@icu_56@@QAECHAAW4UErrorCode@@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4E0h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UVector32::elementAti(icu_56::UVector32 *this,	int)
		public ?elementAti@UVector32@icu_56@@QBEHH@Z
?elementAti@UVector32@icu_56@@QBEHH@Z proc near
					; CODE XREF: icu_56::UVector32::lastElementi(void)+30p

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jl	short loc_533
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4], 0
		jle	short loc_533
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+4]
		sub	edx, [ebp+arg_0]
		test	edx, edx
		jle	short loc_533
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+arg_0]
		mov	eax, [ecx+edx*4]
		mov	[ebp+var_D0], eax
		jmp	short loc_53D
; ---------------------------------------------------------------------------

loc_533:				; CODE XREF: icu_56::UVector32::elementAti(int)+27j
					; icu_56::UVector32::elementAti(int)+30j ...
		mov	[ebp+var_D0], 0

loc_53D:				; CODE XREF: icu_56::UVector32::elementAti(int)+51j
		mov	eax, [ebp+var_D0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?elementAti@UVector32@icu_56@@QBEHH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 54Ch
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UVector32::addElement(icu_56::UVector32 *this, int, enum UErrorCode *)
		public ?addElement@UVector32@icu_56@@QAEXHAAW4UErrorCode@@@Z
?addElement@UVector32@icu_56@@QAEXHAAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::UVector32::push(int,UErrorCode &)+2Ep

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+4]
		add	edx, 1
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?ensureCapacity@UVector32@icu_56@@QAECHAAW4UErrorCode@@@Z ; icu_56::UVector32::ensureCapacity(int,UErrorCode &)
		movsx	eax, al
		test	eax, eax
		jz	short loc_5AD
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+10h]
		mov	edx, [ebp+arg_0]
		mov	[eax+ecx*4], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		add	ecx, 1
		mov	edx, [ebp+var_8]
		mov	[edx+4], ecx

loc_5AD:				; CODE XREF: icu_56::UVector32::addElement(int,UErrorCode &)+3Ej
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?addElement@UVector32@icu_56@@QAEXHAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5C4h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int *__thiscall icu_56::UVector32::reserveBlock(icu_56::UVector32 *this, int,	enum UErrorCode	*)
		public ?reserveBlock@UVector32@icu_56@@QAEPAHHAAW4UErrorCode@@@Z
?reserveBlock@UVector32@icu_56@@QAEPAHHAAW4UErrorCode@@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+4]
		add	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?ensureCapacity@UVector32@icu_56@@QAECHAAW4UErrorCode@@@Z ; icu_56::UVector32::ensureCapacity(int,UErrorCode &)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_608
		xor	eax, eax
		jmp	short loc_62C
; ---------------------------------------------------------------------------

loc_608:				; CODE XREF: icu_56::UVector32::reserveBlock(int,UErrorCode &)+3Ej
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+10h]
		lea	ecx, [eax+ecx*4]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		add	ecx, [ebp+arg_0]
		mov	edx, [ebp+var_8]
		mov	[edx+4], ecx
		mov	eax, [ebp+var_14]

loc_62C:				; CODE XREF: icu_56::UVector32::reserveBlock(int,UErrorCode &)+42j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?reserveBlock@UVector32@icu_56@@QAEPAHHAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 644h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int *__thiscall icu_56::UVector32::popFrame(icu_56::UVector32	*this, int)
		public ?popFrame@UVector32@icu_56@@QAEPAHH@Z
?popFrame@UVector32@icu_56@@QAEPAHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		cmp	ecx, [ebp+arg_0]
		jge	short loc_698
		mov	edx, ds:?__LINE__Var@?1??popFrame@UVector32@icu_56@@QAEPAHH@Z@4JA ; long `icu_56::UVector32::popFrame(int)'::`2'::__LINE__Var
		add	edx, 1
		mov	esi, esp
		push	edx		; Line
		push	offset ??_C@_1FK@CCGGFNFG@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@ ; "d:\\mozilla\\intl\\icu\\source\\common\"...
		push	offset ??_C@_1BM@FLCAFPEE@?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$AA@ ; "count >= size"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_698:				; CODE XREF: icu_56::UVector32::popFrame(int)+2Cj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		sub	ecx, [ebp+arg_0]
		mov	edx, [ebp+var_8]
		mov	[edx+4], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4], 0
		jge	short loc_6BA
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0

loc_6BA:				; CODE XREF: icu_56::UVector32::popFrame(int)+6Aj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+10h]
		lea	eax, [eax+ecx*4]
		mov	ecx, [ebp+arg_0]
		shl	ecx, 2
		sub	eax, ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?popFrame@UVector32@icu_56@@QAEPAHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6E8h
		public ??_C@_1BM@FLCAFPEE@?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
; wchar_t `string'
??_C@_1BM@FLCAFPEE@?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$AA@:
					; DATA XREF: icu_56::UVector32::popFrame(int)+3Fo
		unicode	0, <count >
		dw 3Eh
		unicode	0, <= size>,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 704h
		public ??_C@_1FK@CCGGFNFG@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@
; wchar_t `string'
??_C@_1FK@CCGGFNFG@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@:
					; DATA XREF: icu_56::UVector32::popFrame(int)+3Ao
		unicode	0, <d:\mozilla\intl\icu\source\common\uvectr32.h>,0
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 760h
		public ?__LINE__Var@?1??popFrame@UVector32@icu_56@@QAEPAHH@Z@4JA
; long `public:	int * __thiscall icu_56::UVector32::popFrame(int)'::`2'::__LINE__Var
?__LINE__Var@?1??popFrame@UVector32@icu_56@@QAEPAHH@Z@4JA dd 0F2h
					; DATA XREF: icu_56::UVector32::popFrame(int)+2Er
_data		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 764h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UVector32::size(icu_56::UVector32 *__hidden this)
		public ?size@UVector32@icu_56@@QBEHXZ
?size@UVector32@icu_56@@QBEHXZ proc near
					; CODE XREF: icu_56::UVector32::containsAll(icu_56::UVector32 const &)+38p
					; icu_56::UVector32::containsNone(icu_56::UVector32 const &)+38p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?size@UVector32@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 794h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UVector32::isEmpty(icu_56::UVector32	*__hidden this)
		public ?isEmpty@UVector32@icu_56@@QBECXZ
?isEmpty@UVector32@icu_56@@QBECXZ proc near ; CODE XREF: icu_56::UVector32::empty(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4], 0
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isEmpty@UVector32@icu_56@@QBECXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7C8h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UVector32::contains(icu_56::UVector32 *this,	int)
		public ?contains@UVector32@icu_56@@QBECH@Z
?contains@UVector32@icu_56@@QBECH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UVector32@icu_56@@QBEHHH@Z ; icu_56::UVector32::indexOf(int,int)
		test	eax, eax
		setnl	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?contains@UVector32@icu_56@@QBECH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 814h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UVector32::lastElementi(icu_56::UVector32 *__hidden this)
		public ?lastElementi@UVector32@icu_56@@QBEHXZ
?lastElementi@UVector32@icu_56@@QBEHXZ proc near
					; CODE XREF: icu_56::UVector32::peeki(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		sub	ecx, 1
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?elementAti@UVector32@icu_56@@QBEHH@Z ;	icu_56::UVector32::elementAti(int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?lastElementi@UVector32@icu_56@@QBEHXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 860h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::UVector32::operator!=(class icu_56::UVector32 const &)
		public ??9UVector32@icu_56@@QAECABV01@@Z
??9UVector32@icu_56@@QAECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??8UVector32@icu_56@@QAECABV01@@Z ; icu_56::UVector32::operator==(icu_56::UVector32 const &)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9UVector32@icu_56@@QAECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8B0h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int *__thiscall icu_56::UVector32::getBuffer(icu_56::UVector32 *__hidden this)
		public ?getBuffer@UVector32@icu_56@@QBEPAHXZ
?getBuffer@UVector32@icu_56@@QBEPAHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+10h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getBuffer@UVector32@icu_56@@QBEPAHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8E0h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UVector32::empty(icu_56::UVector32 *__hidden	this)
		public ?empty@UVector32@icu_56@@QBECXZ
?empty@UVector32@icu_56@@QBECXZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?isEmpty@UVector32@icu_56@@QBECXZ ; icu_56::UVector32::isEmpty(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?empty@UVector32@icu_56@@QBECXZ	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 920h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UVector32::peeki(icu_56::UVector32 *__hidden this)
		public ?peeki@UVector32@icu_56@@QBEHXZ
?peeki@UVector32@icu_56@@QBEHXZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?lastElementi@UVector32@icu_56@@QBEHXZ ; icu_56::UVector32::lastElementi(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?peeki@UVector32@icu_56@@QBEHXZ	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 960h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UVector32::push(icu_56::UVector32 *this, int, enum UErrorCode *)
		public ?push@UVector32@icu_56@@QAEHHAAW4UErrorCode@@@Z
?push@UVector32@icu_56@@QAEHHAAW4UErrorCode@@@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?addElement@UVector32@icu_56@@QAEXHAAW4UErrorCode@@@Z ;	icu_56::UVector32::addElement(int,UErrorCode &)
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?push@UVector32@icu_56@@QAEHHAAW4UErrorCode@@@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9ACh
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UVector32::popi(icu_56::UVector32 *__hidden this)
		public ?popi@UVector32@icu_56@@QAEHXZ
?popi@UVector32@icu_56@@QAEHXZ proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_14], 0
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4], 0
		jle	short loc_A00
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		sub	ecx, 1
		mov	edx, [ebp+var_8]
		mov	[edx+4], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+10h]
		mov	ecx, [eax+ecx*4]
		mov	[ebp+var_14], ecx

loc_A00:				; CODE XREF: icu_56::UVector32::popi(void)+31j
		mov	eax, [ebp+var_14]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?popi@UVector32@icu_56@@QAEHXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A0Ch
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	icu_56::UVector32::getStaticClassID()
		public ?getStaticClassID@UVector32@icu_56@@SAPAXXZ
?getStaticClassID@UVector32@icu_56@@SAPAXXZ proc near
					; CODE XREF: icu_56::UVector32::getDynamicClassID(void)+23p

var_C0		= byte ptr -0C0h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, offset ?classID@?1??getStaticClassID@UVector32@icu_56@@SAPAXXZ@4DA	; char `icu_56::UVector32::getStaticClassID(void)'::`2'::classID
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getStaticClassID@UVector32@icu_56@@SAPAXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A38h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__thiscall icu_56::UVector32::getDynamicClassID(icu_56::UVector32 *__hidden this)
		public ?getDynamicClassID@UVector32@icu_56@@UBEPAXXZ
?getDynamicClassID@UVector32@icu_56@@UBEPAXXZ proc near	; DATA XREF: .rdata:00000B60o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		call	?getStaticClassID@UVector32@icu_56@@SAPAXXZ ; icu_56::UVector32::getStaticClassID(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getDynamicClassID@UVector32@icu_56@@UBEPAXXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A74h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UVector32::UVector32(icu_56::UVector32 *this, enum UErrorCode *)
		public ??0UVector32@icu_56@@QAE@AAW4UErrorCode@@@Z
??0UVector32@icu_56@@QAE@AAW4UErrorCode@@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0UVector32@icu_56@@QAE@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	ecx, [ebp+var_14] ; this
		call	??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7UVector32@icu_56@@6B@ ; const icu_56::UVector32::`vftable'
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+8], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+0Ch], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+10h], 0
		mov	eax, [ebp+arg_0]
		push	eax		; enum UErrorCode *
		push	8		; int
		mov	ecx, [ebp+var_14] ; this
		call	?_init@UVector32@icu_56@@AAEXHAAW4UErrorCode@@@Z ; icu_56::UVector32::_init(int,UErrorCode &)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0UVector32@icu_56@@QAE@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0B30h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0UVector32@icu_56@@QAE@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:00000B68o
		mov	ecx, [ebp-14h]	; this
		jmp	??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
__unwindfunclet$??0UVector32@icu_56@@QAE@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0UVector32@icu_56@@QAE@AAW4UErrorCode@@@Z	proc near
					; DATA XREF: icu_56::UVector32::UVector32(UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0UVector32@icu_56@@QAE@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0UVector32@icu_56@@QAE@AAW4UErrorCode@@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B58h
		dd offset ??_R4UVector32@icu_56@@6B@ ; const icu_56::UVector32::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7UVector32@icu_56@@6B@
; const	icu_56::UVector32::`vftable'
??_7UVector32@icu_56@@6B@ dd offset ??_EUVector32@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::UVector32::UVector32(UErrorCode &)+54o
					; icu_56::UVector32::UVector32(int,UErrorCode &)+54o ...
					; icu_56::UVector32::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@UVector32@icu_56@@UBEPAXXZ	; icu_56::UVector32::getDynamicClassID(void)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 0B64h
__unwindtable$??0UVector32@icu_56@@QAE@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00000B74o
		dd offset __unwindfunclet$??0UVector32@icu_56@@QAE@AAW4UErrorCode@@@Z$0
__ehfuncinfo$??0UVector32@icu_56@@QAE@AAW4UErrorCode@@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$??0UVector32@icu_56@@QAE@AAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$??0UVector32@icu_56@@QAE@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0B90h
		public ??_R4UVector32@icu_56@@6B@
; const	icu_56::UVector32::`RTTI Complete Object Locator'
??_R4UVector32@icu_56@@6B@ dd 3	dup(0)	; DATA XREF: .rdata:00000B58o
		dd offset ??_R0?AVUVector32@icu_56@@@8 ; icu_56::UVector32 `RTTI Type Descriptor'
		dd offset ??_R3UVector32@icu_56@@8 ; icu_56::UVector32::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 0BA4h
		public ??_R0?AVUVector32@icu_56@@@8
; class	icu_56::UVector32 `RTTI	Type Descriptor'
??_R0?AVUVector32@icu_56@@@8 dd	offset ??_7type_info@@6B@ ; DATA XREF: .rdata$r:00000B9Co
					; .rdata$r:icu_56::UVector32::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avuvector32@	db '.?AVUVector32@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0BC4h
		public ??_R3UVector32@icu_56@@8
; icu_56::UVector32::`RTTI Class Hierarchy Descriptor'
??_R3UVector32@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:00000BA0o
					; .rdata$r:00000BFCo
		dd 3
		dd offset ??_R2UVector32@icu_56@@8 ; icu_56::UVector32::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0BD4h
		public ??_R2UVector32@icu_56@@8
; icu_56::UVector32::`RTTI Base	Class Array'
??_R2UVector32@icu_56@@8 dd offset ??_R1A@?0A@EA@UVector32@icu_56@@8
					; DATA XREF: .rdata$r:00000BD0o
					; icu_56::UVector32::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0BE4h
		public ??_R1A@?0A@EA@UVector32@icu_56@@8
; icu_56::UVector32::`RTTI Base	Class Descriptor at (0,	-1, 0, 64)'
??_R1A@?0A@EA@UVector32@icu_56@@8 dd offset ??_R0?AVUVector32@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UVector32::`RTTI Base Class Array'o
					; icu_56::UVector32 `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset __RTC_InitBase_rtc$IMZ
		dd offset ??_R3UVector32@icu_56@@8 ; icu_56::UVector32::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C00h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UVector32::UVector32(icu_56::UVector32 *this, int, enum UErrorCode *)
		public ??0UVector32@icu_56@@QAE@HAAW4UErrorCode@@@Z
??0UVector32@icu_56@@QAE@HAAW4UErrorCode@@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0UVector32@icu_56@@QAE@HAAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	ecx, [ebp+var_14] ; this
		call	??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7UVector32@icu_56@@6B@ ; const icu_56::UVector32::`vftable'
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+8], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+0Ch], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+10h], 0
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_14] ; this
		call	?_init@UVector32@icu_56@@AAEXHAAW4UErrorCode@@@Z ; icu_56::UVector32::_init(int,UErrorCode &)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??0UVector32@icu_56@@QAE@HAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0CC0h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0UVector32@icu_56@@QAE@HAAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:00000CECo
		mov	ecx, [ebp-14h]	; this
		jmp	??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
__unwindfunclet$??0UVector32@icu_56@@QAE@HAAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0UVector32@icu_56@@QAE@HAAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::UVector32::UVector32(int,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0UVector32@icu_56@@QAE@HAAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0UVector32@icu_56@@QAE@HAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 0CE8h
__unwindtable$??0UVector32@icu_56@@QAE@HAAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00000CF8o
		dd offset __unwindfunclet$??0UVector32@icu_56@@QAE@HAAW4UErrorCode@@@Z$0
__ehfuncinfo$??0UVector32@icu_56@@QAE@HAAW4UErrorCode@@@Z dd 19930522h,	1
					; DATA XREF: __ehhandler$??0UVector32@icu_56@@QAE@HAAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$??0UVector32@icu_56@@QAE@HAAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D14h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UVector32::_init(icu_56::UVector32 *this, int, enum UErrorCode *)
		public ?_init@UVector32@icu_56@@AAEXHAAW4UErrorCode@@@Z
?_init@UVector32@icu_56@@AAEXHAAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::UVector32::UVector32(UErrorCode &)+8Bp
					; icu_56::UVector32::UVector32(int,UErrorCode &)+8Dp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 1
		jge	short loc_D44
		mov	[ebp+arg_0], 8

loc_D44:				; CODE XREF: icu_56::UVector32::_init(int,UErrorCode &)+27j
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+0Ch], 0
		jle	short loc_D61
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		cmp	ecx, [ebp+arg_0]
		jge	short loc_D61
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		mov	[ebp+arg_0], ecx

loc_D61:				; CODE XREF: icu_56::UVector32::_init(int,UErrorCode &)+37j
					; icu_56::UVector32::_init(int,UErrorCode &)+42j
		cmp	[ebp+arg_0], 1FFFFFFFh
		jle	short loc_D7E
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		push	ecx
		push	8
		call	_uprv_min_56
		add	esp, 8
		mov	[ebp+arg_0], eax

loc_D7E:				; CODE XREF: icu_56::UVector32::_init(int,UErrorCode &)+54j
		mov	eax, [ebp+arg_0]
		shl	eax, 2
		push	eax
		call	_uprv_malloc_56
		add	esp, 4
		mov	ecx, [ebp+var_8]
		mov	[ecx+10h], eax
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+10h], 0
		jnz	short loc_DA7
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 7
		jmp	short loc_DB0
; ---------------------------------------------------------------------------

loc_DA7:				; CODE XREF: icu_56::UVector32::_init(int,UErrorCode &)+86j
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+8], ecx

loc_DB0:				; CODE XREF: icu_56::UVector32::_init(int,UErrorCode &)+91j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?_init@UVector32@icu_56@@AAEXHAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0DC8h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UVector32::~UVector32(icu_56::UVector32 *__hidden this)
		public ??1UVector32@icu_56@@UAE@XZ
??1UVector32@icu_56@@UAE@XZ proc near	; CODE XREF: icu_56::UVector32::`scalar	deleting destructor'(uint)+26p
					; icu_56::UVector32::`vector deleting destructor'(uint)+64p
					; DATA XREF: ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UVector32@icu_56@@6B@ ; const icu_56::UVector32::`vftable'
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		push	ecx
		call	_uprv_free_56
		add	esp, 4
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+10h], 0
		mov	ecx, [ebp+var_8] ; this
		call	??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1UVector32@icu_56@@UAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0E2Ch
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UVector32::assign(icu_56::UVector32 *this, const struct icu_56::UVector32 *, enum UErrorCode *)
		public ?assign@UVector32@icu_56@@QAEXABV12@AAW4UErrorCode@@@Z
?assign@UVector32@icu_56@@QAEXABV12@AAW4UErrorCode@@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?ensureCapacity@UVector32@icu_56@@QAECHAAW4UErrorCode@@@Z ; icu_56::UVector32::ensureCapacity(int,UErrorCode &)
		movsx	eax, al
		test	eax, eax
		jz	short loc_EAF
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?setSize@UVector32@icu_56@@QAEXH@Z ; icu_56::UVector32::setSize(int)
		mov	[ebp+var_14], 0
		jmp	short loc_E8A
; ---------------------------------------------------------------------------

loc_E81:				; CODE XREF: icu_56::UVector32::assign(icu_56::UVector32 const &,UErrorCode &)+81j
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_E8A:				; CODE XREF: icu_56::UVector32::assign(icu_56::UVector32 const &,UErrorCode &)+53j
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		cmp	ecx, [eax+4]
		jge	short loc_EAF
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+10h]
		mov	edx, [ebp+var_14]
		mov	esi, [ebp+var_14]
		mov	ecx, [ecx+esi*4]
		mov	[eax+edx*4], ecx
		jmp	short loc_E81
; ---------------------------------------------------------------------------

loc_EAF:				; CODE XREF: icu_56::UVector32::assign(icu_56::UVector32 const &,UErrorCode &)+3Bj
					; icu_56::UVector32::assign(icu_56::UVector32 const &,UErrorCode &)+67j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?assign@UVector32@icu_56@@QAEXABV12@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0EC8h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::UVector32::operator==(class icu_56::UVector32 const &)
		public ??8UVector32@icu_56@@QAECABV01@@Z
??8UVector32@icu_56@@QAECABV01@@Z proc near
					; CODE XREF: icu_56::UVector32::operator!=(icu_56::UVector32 const &)+2Ap

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax+4]
		cmp	edx, [ecx+4]
		jz	short loc_EFD
		xor	al, al
		jmp	short loc_F3C
; ---------------------------------------------------------------------------

loc_EFD:				; CODE XREF: icu_56::UVector32::operator==(icu_56::UVector32 const &)+2Fj
		mov	[ebp+var_14], 0
		jmp	short loc_F0F
; ---------------------------------------------------------------------------

loc_F06:				; CODE XREF: icu_56::UVector32::operator==(icu_56::UVector32 const &):loc_F38j
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_F0F:				; CODE XREF: icu_56::UVector32::operator==(icu_56::UVector32 const &)+3Cj
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		cmp	ecx, [eax+4]
		jge	short loc_F3A
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+10h]
		mov	edx, [ebp+var_14]
		mov	esi, [ebp+var_14]
		mov	ecx, [ecx+edx*4]
		cmp	ecx, [eax+esi*4]
		jz	short loc_F38
		xor	al, al
		jmp	short loc_F3C
; ---------------------------------------------------------------------------

loc_F38:				; CODE XREF: icu_56::UVector32::operator==(icu_56::UVector32 const &)+6Aj
		jmp	short loc_F06
; ---------------------------------------------------------------------------

loc_F3A:				; CODE XREF: icu_56::UVector32::operator==(icu_56::UVector32 const &)+50j
		mov	al, 1

loc_F3C:				; CODE XREF: icu_56::UVector32::operator==(icu_56::UVector32 const &)+33j
					; icu_56::UVector32::operator==(icu_56::UVector32 const	&)+6Ej
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??8UVector32@icu_56@@QAECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0F48h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UVector32::setElementAt(icu_56::UVector32 *this, int,	int)
		public ?setElementAt@UVector32@icu_56@@QAEXHH@Z
?setElementAt@UVector32@icu_56@@QAEXHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_4], 0
		jl	short loc_F8B
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		cmp	ecx, [eax+4]
		jge	short loc_F8B
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+arg_4]
		mov	eax, [ebp+arg_0]
		mov	[ecx+edx*4], eax

loc_F8B:				; CODE XREF: icu_56::UVector32::setElementAt(int,int)+27j
					; icu_56::UVector32::setElementAt(int,int)+32j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	8
?setElementAt@UVector32@icu_56@@QAEXHH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0F94h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UVector32::insertElementAt(icu_56::UVector32 *this, int, int,	enum UErrorCode	*)
		public ?insertElementAt@UVector32@icu_56@@QAEXHHAAW4UErrorCode@@@Z
?insertElementAt@UVector32@icu_56@@QAEXHHAAW4UErrorCode@@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_4], 0
		jl	short loc_103A
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		cmp	ecx, [eax+4]
		jg	short loc_103A
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+4]
		add	edx, 1
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?ensureCapacity@UVector32@icu_56@@QAECHAAW4UErrorCode@@@Z ; icu_56::UVector32::ensureCapacity(int,UErrorCode &)
		movsx	eax, al
		test	eax, eax
		jz	short loc_103A
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	[ebp+var_14], ecx
		jmp	short loc_FF9
; ---------------------------------------------------------------------------

loc_FF0:				; CODE XREF: icu_56::UVector32::insertElementAt(int,int,UErrorCode &)+86j
		mov	eax, [ebp+var_14]
		sub	eax, 1
		mov	[ebp+var_14], eax

loc_FF9:				; CODE XREF: icu_56::UVector32::insertElementAt(int,int,UErrorCode &)+5Aj
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+arg_4]
		jle	short loc_101C
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+10h]
		mov	edx, [ebp+var_14]
		mov	esi, [ebp+var_14]
		mov	ecx, [ecx+esi*4-4]
		mov	[eax+edx*4], ecx
		jmp	short loc_FF0
; ---------------------------------------------------------------------------

loc_101C:				; CODE XREF: icu_56::UVector32::insertElementAt(int,int,UErrorCode &)+6Bj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+arg_4]
		mov	eax, [ebp+arg_0]
		mov	[ecx+edx*4], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		add	ecx, 1
		mov	edx, [ebp+var_8]
		mov	[edx+4], ecx

loc_103A:				; CODE XREF: icu_56::UVector32::insertElementAt(int,int,UErrorCode &)+27j
					; icu_56::UVector32::insertElementAt(int,int,UErrorCode	&)+32j	...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?insertElementAt@UVector32@icu_56@@QAEXHHAAW4UErrorCode@@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1050h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UVector32::containsAll(icu_56::UVector32 *this, const struct	icu_56::UVector32 *)
		public ?containsAll@UVector32@icu_56@@QBECABV12@@Z
?containsAll@UVector32@icu_56@@QBECABV12@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_14], 0
		jmp	short loc_1085
; ---------------------------------------------------------------------------

loc_107C:				; CODE XREF: icu_56::UVector32::containsAll(icu_56::UVector32 const &):loc_10B1j
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_1085:				; CODE XREF: icu_56::UVector32::containsAll(icu_56::UVector32 const &)+2Aj
		mov	ecx, [ebp+arg_0] ; this
		call	?size@UVector32@icu_56@@QBEHXZ ; icu_56::UVector32::size(void)
		cmp	[ebp+var_14], eax
		jge	short loc_10B3
		push	0		; int
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_14]
		mov	eax, [ecx+edx*4]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UVector32@icu_56@@QBEHHH@Z ; icu_56::UVector32::indexOf(int,int)
		test	eax, eax
		jge	short loc_10B1
		xor	al, al
		jmp	short loc_10B5
; ---------------------------------------------------------------------------

loc_10B1:				; CODE XREF: icu_56::UVector32::containsAll(icu_56::UVector32 const &)+5Bj
		jmp	short loc_107C
; ---------------------------------------------------------------------------

loc_10B3:				; CODE XREF: icu_56::UVector32::containsAll(icu_56::UVector32 const &)+40j
		mov	al, 1

loc_10B5:				; CODE XREF: icu_56::UVector32::containsAll(icu_56::UVector32 const &)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?containsAll@UVector32@icu_56@@QBECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 10CCh
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UVector32::containsNone(icu_56::UVector32 *this, const struct icu_56::UVector32 *)
		public ?containsNone@UVector32@icu_56@@QBECABV12@@Z
?containsNone@UVector32@icu_56@@QBECABV12@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_14], 0
		jmp	short loc_1101
; ---------------------------------------------------------------------------

loc_10F8:				; CODE XREF: icu_56::UVector32::containsNone(icu_56::UVector32 const &):loc_112Dj
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_1101:				; CODE XREF: icu_56::UVector32::containsNone(icu_56::UVector32 const &)+2Aj
		mov	ecx, [ebp+arg_0] ; this
		call	?size@UVector32@icu_56@@QBEHXZ ; icu_56::UVector32::size(void)
		cmp	[ebp+var_14], eax
		jge	short loc_112F
		push	0		; int
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_14]
		mov	eax, [ecx+edx*4]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UVector32@icu_56@@QBEHHH@Z ; icu_56::UVector32::indexOf(int,int)
		test	eax, eax
		jl	short loc_112D
		xor	al, al
		jmp	short loc_1131
; ---------------------------------------------------------------------------

loc_112D:				; CODE XREF: icu_56::UVector32::containsNone(icu_56::UVector32 const &)+5Bj
		jmp	short loc_10F8
; ---------------------------------------------------------------------------

loc_112F:				; CODE XREF: icu_56::UVector32::containsNone(icu_56::UVector32 const &)+40j
		mov	al, 1

loc_1131:				; CODE XREF: icu_56::UVector32::containsNone(icu_56::UVector32 const &)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?containsNone@UVector32@icu_56@@QBECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1148h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UVector32::removeAll(icu_56::UVector32 *this, const struct icu_56::UVector32	*)
		public ?removeAll@UVector32@icu_56@@QAECABV12@@Z
?removeAll@UVector32@icu_56@@QAECABV12@@Z proc near

var_F0		= byte ptr -0F0h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_11		= byte ptr -11h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0F0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F0]
		mov	ecx, 3Ch ; '<'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_11], 0
		mov	[ebp+var_20], 0
		jmp	short loc_1181
; ---------------------------------------------------------------------------

loc_1178:				; CODE XREF: icu_56::UVector32::removeAll(icu_56::UVector32 const &):loc_11BEj
		mov	eax, [ebp+var_20]
		add	eax, 1
		mov	[ebp+var_20], eax

loc_1181:				; CODE XREF: icu_56::UVector32::removeAll(icu_56::UVector32 const &)+2Ej
		mov	ecx, [ebp+arg_0] ; this
		call	?size@UVector32@icu_56@@QBEHXZ ; icu_56::UVector32::size(void)
		cmp	[ebp+var_20], eax
		jge	short loc_11C0
		push	0		; int
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_20]
		mov	eax, [ecx+edx*4]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UVector32@icu_56@@QBEHHH@Z ; icu_56::UVector32::indexOf(int,int)
		mov	[ebp+var_2C], eax
		cmp	[ebp+var_2C], 0
		jl	short loc_11BE
		mov	eax, [ebp+var_2C]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?removeElementAt@UVector32@icu_56@@QAEXH@Z ; icu_56::UVector32::removeElementAt(int)
		mov	[ebp+var_11], 1

loc_11BE:				; CODE XREF: icu_56::UVector32::removeAll(icu_56::UVector32 const &)+64j
		jmp	short loc_1178
; ---------------------------------------------------------------------------

loc_11C0:				; CODE XREF: icu_56::UVector32::removeAll(icu_56::UVector32 const &)+44j
		mov	al, [ebp+var_11]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?removeAll@UVector32@icu_56@@QAECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 11DCh
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UVector32::retainAll(icu_56::UVector32 *this, const struct icu_56::UVector32	*)
		public ?retainAll@UVector32@icu_56@@QAECABV12@@Z
?retainAll@UVector32@icu_56@@QAECABV12@@Z proc near

var_F0		= byte ptr -0F0h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_11		= byte ptr -11h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0F0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F0]
		mov	ecx, 3Ch ; '<'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_11], 0
		mov	ecx, [ebp+var_8] ; this
		call	?size@UVector32@icu_56@@QBEHXZ ; icu_56::UVector32::size(void)
		sub	eax, 1
		mov	[ebp+var_20], eax
		jmp	short loc_121C
; ---------------------------------------------------------------------------

loc_1213:				; CODE XREF: icu_56::UVector32::retainAll(icu_56::UVector32 const &):loc_1252j
		mov	eax, [ebp+var_20]
		sub	eax, 1
		mov	[ebp+var_20], eax

loc_121C:				; CODE XREF: icu_56::UVector32::retainAll(icu_56::UVector32 const &)+35j
		cmp	[ebp+var_20], 0
		jl	short loc_1254
		push	0		; int
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_20]
		mov	eax, [ecx+edx*4]
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?indexOf@UVector32@icu_56@@QBEHHH@Z ; icu_56::UVector32::indexOf(int,int)
		mov	[ebp+var_2C], eax
		cmp	[ebp+var_2C], 0
		jge	short loc_1252
		mov	eax, [ebp+var_20]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?removeElementAt@UVector32@icu_56@@QAEXH@Z ; icu_56::UVector32::removeElementAt(int)
		mov	[ebp+var_11], 1

loc_1252:				; CODE XREF: icu_56::UVector32::retainAll(icu_56::UVector32 const &)+64j
		jmp	short loc_1213
; ---------------------------------------------------------------------------

loc_1254:				; CODE XREF: icu_56::UVector32::retainAll(icu_56::UVector32 const &)+44j
		mov	al, [ebp+var_11]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?retainAll@UVector32@icu_56@@QAECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1270h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UVector32::removeElementAt(icu_56::UVector32 *this, int)
		public ?removeElementAt@UVector32@icu_56@@QAEXH@Z
?removeElementAt@UVector32@icu_56@@QAEXH@Z proc	near
					; CODE XREF: icu_56::UVector32::removeAll(icu_56::UVector32 const &)+6Dp
					; icu_56::UVector32::retainAll(icu_56::UVector32 const &)+6Dp

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jl	short loc_12E2
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_14], eax
		jmp	short loc_12AA
; ---------------------------------------------------------------------------

loc_12A1:				; CODE XREF: icu_56::UVector32::removeElementAt(int)+61j
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_12AA:				; CODE XREF: icu_56::UVector32::removeElementAt(int)+2Fj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		sub	ecx, 1
		cmp	[ebp+var_14], ecx
		jge	short loc_12D3
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+10h]
		mov	edx, [ebp+var_14]
		mov	esi, [ebp+var_14]
		mov	ecx, [ecx+esi*4+4]
		mov	[eax+edx*4], ecx
		jmp	short loc_12A1
; ---------------------------------------------------------------------------

loc_12D3:				; CODE XREF: icu_56::UVector32::removeElementAt(int)+46j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		sub	ecx, 1
		mov	edx, [ebp+var_8]
		mov	[edx+4], ecx

loc_12E2:				; CODE XREF: icu_56::UVector32::removeElementAt(int)+27j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?removeElementAt@UVector32@icu_56@@QAEXH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 12ECh
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UVector32::removeAllElements(icu_56::UVector32 *__hidden this)
		public ?removeAllElements@UVector32@icu_56@@QAEXXZ
?removeAllElements@UVector32@icu_56@@QAEXXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?removeAllElements@UVector32@icu_56@@QAEXXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1320h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UVector32::equals(icu_56::UVector32 *this, const struct icu_56::UVector32 *)
		public ?equals@UVector32@icu_56@@QBECABV12@@Z
?equals@UVector32@icu_56@@QBECABV12@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax+4]
		cmp	edx, [ecx+4]
		jz	short loc_1355
		xor	al, al
		jmp	short loc_1394
; ---------------------------------------------------------------------------

loc_1355:				; CODE XREF: icu_56::UVector32::equals(icu_56::UVector32 const &)+2Fj
		mov	[ebp+var_14], 0
		jmp	short loc_1367
; ---------------------------------------------------------------------------

loc_135E:				; CODE XREF: icu_56::UVector32::equals(icu_56::UVector32 const &):loc_1390j
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_1367:				; CODE XREF: icu_56::UVector32::equals(icu_56::UVector32 const &)+3Cj
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		cmp	ecx, [eax+4]
		jge	short loc_1392
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+10h]
		mov	edx, [ebp+var_14]
		mov	esi, [ebp+var_14]
		mov	ecx, [ecx+edx*4]
		cmp	ecx, [eax+esi*4]
		jz	short loc_1390
		xor	al, al
		jmp	short loc_1394
; ---------------------------------------------------------------------------

loc_1390:				; CODE XREF: icu_56::UVector32::equals(icu_56::UVector32 const &)+6Aj
		jmp	short loc_135E
; ---------------------------------------------------------------------------

loc_1392:				; CODE XREF: icu_56::UVector32::equals(icu_56::UVector32 const &)+50j
		mov	al, 1

loc_1394:				; CODE XREF: icu_56::UVector32::equals(icu_56::UVector32 const &)+33j
					; icu_56::UVector32::equals(icu_56::UVector32 const &)+6Ej
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?equals@UVector32@icu_56@@QBECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 13A0h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UVector32::indexOf(icu_56::UVector32 *this, int, int)
		public ?indexOf@UVector32@icu_56@@QBEHHH@Z
?indexOf@UVector32@icu_56@@QBEHHH@Z proc near
					; CODE XREF: icu_56::UVector32::contains(int)+2Cp
					; icu_56::UVector32::containsAll(icu_56::UVector32 const &)+54p ...

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_14], eax
		jmp	short loc_13D4
; ---------------------------------------------------------------------------

loc_13CB:				; CODE XREF: icu_56::UVector32::indexOf(int,int):loc_13F5j
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_13D4:				; CODE XREF: icu_56::UVector32::indexOf(int,int)+29j
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		cmp	ecx, [eax+4]
		jge	short loc_13F7
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_14]
		mov	eax, [ebp+arg_0]
		cmp	eax, [ecx+edx*4]
		jnz	short loc_13F5
		mov	eax, [ebp+var_14]
		jmp	short loc_13FA
; ---------------------------------------------------------------------------

loc_13F5:				; CODE XREF: icu_56::UVector32::indexOf(int,int)+4Ej
		jmp	short loc_13CB
; ---------------------------------------------------------------------------

loc_13F7:				; CODE XREF: icu_56::UVector32::indexOf(int,int)+3Dj
		or	eax, 0FFFFFFFFh

loc_13FA:				; CODE XREF: icu_56::UVector32::indexOf(int,int)+53j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	8
?indexOf@UVector32@icu_56@@QBEHHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1404h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UVector32::expandCapacity(icu_56::UVector32 *this, int, enum	UErrorCode *)
		public ?expandCapacity@UVector32@icu_56@@QAECHAAW4UErrorCode@@@Z
?expandCapacity@UVector32@icu_56@@QAECHAAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::UVector32::ensureCapacity(int,UErrorCode &)+45p

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_1443
		xor	al, al
		jmp	loc_1537
; ---------------------------------------------------------------------------

loc_1443:				; CODE XREF: icu_56::UVector32::expandCapacity(int,UErrorCode &)+36j
		cmp	[ebp+arg_0], 0
		jge	short loc_1459
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 1
		xor	al, al
		jmp	loc_1537
; ---------------------------------------------------------------------------

loc_1459:				; CODE XREF: icu_56::UVector32::expandCapacity(int,UErrorCode &)+43j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		cmp	ecx, [ebp+arg_0]
		jl	short loc_146B
		mov	al, 1
		jmp	loc_1537
; ---------------------------------------------------------------------------

loc_146B:				; CODE XREF: icu_56::UVector32::expandCapacity(int,UErrorCode &)+5Ej
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+0Ch], 0
		jle	short loc_148F
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		cmp	ecx, [eax+0Ch]
		jle	short loc_148F
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Fh
		xor	al, al
		jmp	loc_1537
; ---------------------------------------------------------------------------

loc_148F:				; CODE XREF: icu_56::UVector32::expandCapacity(int,UErrorCode &)+6Ej
					; icu_56::UVector32::expandCapacity(int,UErrorCode &)+79j
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+8], 3FFFFFFFh
		jle	short loc_14AB
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 1
		xor	al, al
		jmp	loc_1537
; ---------------------------------------------------------------------------

loc_14AB:				; CODE XREF: icu_56::UVector32::expandCapacity(int,UErrorCode &)+95j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		shl	ecx, 1
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+arg_0]
		jge	short loc_14C4
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_14], eax

loc_14C4:				; CODE XREF: icu_56::UVector32::expandCapacity(int,UErrorCode &)+B8j
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+0Ch], 0
		jle	short loc_14E1
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		cmp	ecx, [eax+0Ch]
		jle	short loc_14E1
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		mov	[ebp+var_14], ecx

loc_14E1:				; CODE XREF: icu_56::UVector32::expandCapacity(int,UErrorCode &)+C7j
					; icu_56::UVector32::expandCapacity(int,UErrorCode &)+D2j
		cmp	[ebp+var_14], 1FFFFFFFh
		jle	short loc_14F7
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 1
		xor	al, al
		jmp	short loc_1537
; ---------------------------------------------------------------------------

loc_14F7:				; CODE XREF: icu_56::UVector32::expandCapacity(int,UErrorCode &)+E4j
		mov	eax, [ebp+var_14]
		shl	eax, 2
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+10h]
		push	edx
		call	_uprv_realloc_56
		add	esp, 8
		mov	[ebp+var_20], eax
		cmp	[ebp+var_20], 0
		jnz	short loc_1523
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 7
		xor	al, al
		jmp	short loc_1537
; ---------------------------------------------------------------------------

loc_1523:				; CODE XREF: icu_56::UVector32::expandCapacity(int,UErrorCode &)+110j
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_20]
		mov	[eax+10h], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		mov	[eax+8], ecx
		mov	al, 1

loc_1537:				; CODE XREF: icu_56::UVector32::expandCapacity(int,UErrorCode &)+3Aj
					; icu_56::UVector32::expandCapacity(int,UErrorCode &)+50j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?expandCapacity@UVector32@icu_56@@QAECHAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1550h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl U_FAILURE(enum  UErrorCode)
?U_FAILURE@@YACW4UErrorCode@@@Z	proc near
					; CODE XREF: icu_56::UVector32::expandCapacity(int,UErrorCode &)+29p

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		setnle	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?U_FAILURE@@YACW4UErrorCode@@@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 157Ch
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UVector32::setMaxCapacity(icu_56::UVector32 *this, int)
		public ?setMaxCapacity@UVector32@icu_56@@QAEXH@Z
?setMaxCapacity@UVector32@icu_56@@QAEXH@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jge	short loc_15CA
		mov	eax, ds:?__LINE__Var@?1??setMaxCapacity@UVector32@icu_56@@QAEXH@Z@4JA ;	long `icu_56::UVector32::setMaxCapacity(int)'::`2'::__LINE__Var
		add	eax, 1
		mov	esi, esp
		push	eax		; Line
		push	offset ??_C@_1FO@FBLCNBFD@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@ ; "d:\\mozilla\\intl\\icu\\source\\common\"...
		push	offset ??_C@_1BG@KDIADNAG@?$AAl?$AAi?$AAm?$AAi?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ;	"limit >= 0"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_15CA:				; CODE XREF: icu_56::UVector32::setMaxCapacity(int)+27j
		cmp	[ebp+arg_0], 0
		jge	short loc_15D7
		mov	[ebp+arg_0], 0

loc_15D7:				; CODE XREF: icu_56::UVector32::setMaxCapacity(int)+52j
		cmp	[ebp+arg_0], 1FFFFFFFh
		jle	short loc_15E2
		jmp	short loc_1657
; ---------------------------------------------------------------------------

loc_15E2:				; CODE XREF: icu_56::UVector32::setMaxCapacity(int)+62j
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+0Ch], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_8]
		mov	edx, [eax+8]
		cmp	edx, [ecx+0Ch]
		jle	short loc_1602
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+0Ch], 0
		jnz	short loc_1604

loc_1602:				; CODE XREF: icu_56::UVector32::setMaxCapacity(int)+7Bj
		jmp	short loc_1657
; ---------------------------------------------------------------------------

loc_1604:				; CODE XREF: icu_56::UVector32::setMaxCapacity(int)+84j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		shl	ecx, 2
		push	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx+10h]
		push	eax
		call	_uprv_realloc_56
		add	esp, 8
		mov	[ebp+var_14], eax
		cmp	[ebp+var_14], 0
		jnz	short loc_1628
		jmp	short loc_1657
; ---------------------------------------------------------------------------

loc_1628:				; CODE XREF: icu_56::UVector32::setMaxCapacity(int)+A8j
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		mov	[eax+10h], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+0Ch]
		mov	[eax+8], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_8]
		mov	edx, [eax+4]
		cmp	edx, [ecx+8]
		jle	short loc_1657
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+8]
		mov	[eax+4], edx

loc_1657:				; CODE XREF: icu_56::UVector32::setMaxCapacity(int)+64j
					; icu_56::UVector32::setMaxCapacity(int):loc_1602j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setMaxCapacity@UVector32@icu_56@@QAEXH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1670h
		public ??_C@_1BG@KDIADNAG@?$AAl?$AAi?$AAm?$AAi?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
; wchar_t `string'
??_C@_1BG@KDIADNAG@?$AAl?$AAi?$AAm?$AAi?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@:
					; DATA XREF: icu_56::UVector32::setMaxCapacity(int)+39o
		unicode	0, <limit >
		dw 3Eh
		unicode	0, <= 0>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 1688h
		public ??_C@_1FO@FBLCNBFD@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@
; wchar_t `string'
??_C@_1FO@FBLCNBFD@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@:
					; DATA XREF: icu_56::UVector32::setMaxCapacity(int)+34o
		unicode	0, <d:\mozilla\intl\icu\source\common\uvectr32.cpp>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 16E8h
		public ?__LINE__Var@?1??setMaxCapacity@UVector32@icu_56@@QAEXH@Z@4JA
; long `public:	void __thiscall	icu_56::UVector32::setMaxCapacity(int)'::`2'::__LINE__Var
?__LINE__Var@?1??setMaxCapacity@UVector32@icu_56@@QAEXH@Z@4JA dd 0F0h
					; DATA XREF: icu_56::UVector32::setMaxCapacity(int)+29r
_data		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 16ECh
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UVector32::setSize(icu_56::UVector32 *this, int)
		public ?setSize@UVector32@icu_56@@QAEXH@Z
?setSize@UVector32@icu_56@@QAEXH@Z proc	near
					; CODE XREF: icu_56::UVector32::assign(icu_56::UVector32 const &,UErrorCode &)+47p

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jge	short loc_1717
		jmp	short loc_1779
; ---------------------------------------------------------------------------

loc_1717:				; CODE XREF: icu_56::UVector32::setSize(int)+27j
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		cmp	ecx, [eax+4]
		jle	short loc_1770
		mov	[ebp+var_20], 0
		lea	eax, [ebp+var_20]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?ensureCapacity@UVector32@icu_56@@QAECHAAW4UErrorCode@@@Z ; icu_56::UVector32::ensureCapacity(int,UErrorCode &)
		movsx	edx, al
		test	edx, edx
		jnz	short loc_1742
		jmp	short loc_1779
; ---------------------------------------------------------------------------

loc_1742:				; CODE XREF: icu_56::UVector32::setSize(int)+52j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	[ebp+var_14], ecx
		jmp	short loc_1756
; ---------------------------------------------------------------------------

loc_174D:				; CODE XREF: icu_56::UVector32::setSize(int)+82j
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_1756:				; CODE XREF: icu_56::UVector32::setSize(int)+5Fj
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+arg_0]
		jge	short loc_1770
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_14]
		mov	dword ptr [ecx+edx*4], 0
		jmp	short loc_174D
; ---------------------------------------------------------------------------

loc_1770:				; CODE XREF: icu_56::UVector32::setSize(int)+34j
					; icu_56::UVector32::setSize(int)+70j
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+4], ecx

loc_1779:				; CODE XREF: icu_56::UVector32::setSize(int)+29j
					; icu_56::UVector32::setSize(int)+54j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN11
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setSize@UVector32@icu_56@@QAEXH@Z endp

; ---------------------------------------------------------------------------
$LN11		dd 1			; DATA XREF: icu_56::UVector32::setSize(int)+91o
		dd offset $LN10
$LN10		dd 0FFFFFFE0h, 4	; DATA XREF: .text:000017A4o
		dd offset $LN9
$LN9		db 65h,	63h, 0		; DATA XREF: .text:000017B0o
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 17B8h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UVector32::sortedInsert(icu_56::UVector32 *this, int,	enum UErrorCode	*)
		public ?sortedInsert@UVector32@icu_56@@QAEXHAAW4UErrorCode@@@Z
?sortedInsert@UVector32@icu_56@@QAEXHAAW4UErrorCode@@@Z	proc near

var_FC		= byte ptr -0FCh
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0FCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_FC]
		mov	ecx, 3Fh ; '?'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_14], 0
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	[ebp+var_20], ecx

loc_17EB:				; CODE XREF: icu_56::UVector32::sortedInsert(int,UErrorCode &):loc_1823j
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_20]
		jz	short loc_1825
		mov	eax, [ebp+var_14]
		add	eax, [ebp+var_20]
		cdq
		sub	eax, edx
		sar	eax, 1
		mov	[ebp+var_2C], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_2C]
		mov	eax, [ecx+edx*4]
		cmp	eax, [ebp+arg_0]
		jle	short loc_181A
		mov	eax, [ebp+var_2C]
		mov	[ebp+var_20], eax
		jmp	short loc_1823
; ---------------------------------------------------------------------------

loc_181A:				; CODE XREF: icu_56::UVector32::sortedInsert(int,UErrorCode &)+58j
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_1823:				; CODE XREF: icu_56::UVector32::sortedInsert(int,UErrorCode &)+60j
		jmp	short loc_17EB
; ---------------------------------------------------------------------------

loc_1825:				; CODE XREF: icu_56::UVector32::sortedInsert(int,UErrorCode &)+39j
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+4]
		add	edx, 1
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?ensureCapacity@UVector32@icu_56@@QAECHAAW4UErrorCode@@@Z ; icu_56::UVector32::ensureCapacity(int,UErrorCode &)
		movsx	eax, al
		test	eax, eax
		jz	short loc_1897
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	[ebp+var_38], ecx
		jmp	short loc_1856
; ---------------------------------------------------------------------------

loc_184D:				; CODE XREF: icu_56::UVector32::sortedInsert(int,UErrorCode &)+BFj
		mov	eax, [ebp+var_38]
		sub	eax, 1
		mov	[ebp+var_38], eax

loc_1856:				; CODE XREF: icu_56::UVector32::sortedInsert(int,UErrorCode &)+93j
		mov	eax, [ebp+var_38]
		cmp	eax, [ebp+var_14]
		jle	short loc_1879
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+10h]
		mov	edx, [ebp+var_38]
		mov	esi, [ebp+var_38]
		mov	ecx, [ecx+esi*4-4]
		mov	[eax+edx*4], ecx
		jmp	short loc_184D
; ---------------------------------------------------------------------------

loc_1879:				; CODE XREF: icu_56::UVector32::sortedInsert(int,UErrorCode &)+A4j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_14]
		mov	eax, [ebp+arg_0]
		mov	[ecx+edx*4], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		add	ecx, 1
		mov	edx, [ebp+var_8]
		mov	[edx+4], ecx

loc_1897:				; CODE XREF: icu_56::UVector32::sortedInsert(int,UErrorCode &)+88j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0FCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?sortedInsert@UVector32@icu_56@@QAEXHAAW4UErrorCode@@@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn __RTC_Shutdown:near ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
		extrn __RTC_InitBase:near ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
; const	type_info::`vftable'
		extrn ??_7type_info@@6B@:near
					; DATA XREF: .data:icu_56::UObject `RTTI Type Descriptor'o
					; .data:icu_56::UMemory	`RTTI Type Descriptor'o ...
; public: virtual void * __thiscall icu_56::UObject::getDynamicClassID(void)const
		extrn ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ:near
					; DATA XREF: .rdata:00000138o
; void __cdecl icu_56::UMemory::operator delete(void *)
		extrn ??3UMemory@icu_56@@SAXPAX@Z:near
					; CODE XREF: icu_56::UObject::`scalar deleting destructor'(uint)+37p
					; icu_56::UObject::`vector deleting destructor'(uint)+75p ...
; _DWORD __thiscall icu_56::UObject::~UObject(icu_56::UObject *__hidden	this)
		extrn ??1UObject@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::UObject::`scalar deleting destructor'(uint)+26p
					; icu_56::UObject::`vector deleting destructor'(uint)+64p ...
		extrn __RTC_CheckEsp:near
					; CODE XREF: icu_56::UObject::`scalar deleting destructor'(uint)+4Dp
					; icu_56::UObject::`vector deleting destructor'(uint)+8Bp ...
; void __cdecl icu_56::UMemory::operator delete[](void *)
		extrn ??_VUMemory@icu_56@@SAXPAX@Z:near
					; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+51p
					; icu_56::UVector32::`vector deleting destructor'(uint)+51p
; void __stdcall `eh vector destructor iterator'(void *, unsigned int, int, void (__thiscall *)(void *))
		extrn ??_M@YGXPAXIHP6EX0@Z@Z:near
					; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+3Dp
					; icu_56::UVector32::`vector deleting destructor'(uint)+3Dp
; void __cdecl __wassert(const wchar_t *Message, const wchar_t *File, unsigned int Line)
		extrn __imp___wassert:near ; CODE XREF:	icu_56::UVector32::popFrame(int)+44p
					; icu_56::UVector32::setMaxCapacity(int)+3Ep
					; DATA XREF: ...
		extrn ___security_cookie:near
					; DATA XREF: icu_56::UVector32::UVector32(UErrorCode &)+2Er
					; icu_56::UVector32::UVector32(int,UErrorCode &)+2Er
		extrn ___CxxFrameHandler3:near
					; CODE XREF: __ehhandler$??0UVector32@icu_56@@QAE@AAW4UErrorCode@@@Z+19j
					; __ehhandler$??0UVector32@icu_56@@QAE@HAAW4UErrorCode@@@Z+19j
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near
					; CODE XREF: __ehhandler$??0UVector32@icu_56@@QAE@AAW4UErrorCode@@@Z+Fp
					; __ehhandler$??0UVector32@icu_56@@QAE@HAAW4UErrorCode@@@Z+Fp
		extrn _uprv_malloc_56:near
					; CODE XREF: icu_56::UVector32::_init(int,UErrorCode &)+71p
		extrn _uprv_min_56:near	; CODE XREF: icu_56::UVector32::_init(int,UErrorCode &)+5Fp
		extrn _uprv_free_56:near
					; CODE XREF: icu_56::UVector32::~UVector32(void)+33p
		extrn _uprv_realloc_56:near
					; CODE XREF: icu_56::UVector32::expandCapacity(int,UErrorCode &)+101p
					; icu_56::UVector32::setMaxCapacity(int)+99p
; __fastcall _RTC_CheckStackVars(x, x)
		extrn @_RTC_CheckStackVars@8:near
					; CODE XREF: icu_56::UVector32::setSize(int)+97p


		end
