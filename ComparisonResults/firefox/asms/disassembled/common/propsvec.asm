;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	E600D11F1EA1845792116672201E6263
; Input	CRC32 :	922A8839

; File Name   :	D:\compspace\objfiles\firefox\common\propsvec.obj
; Format      :	COFF (X386MAGIC)
; includelib "msvcprtd"
; includelib "MSVCRTD"
; includelib "OLDNAMES"
;
; Exported entry
;

		include	uni.inc	; see unicode subdir of	ida for	info on	unicode

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _upvec_open_56
_upvec_open_56	proc near

var_F0		= byte ptr -0F0h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
Dst		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0F0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_F0]
		mov	ecx, 3Ch ; '<'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		cmp	dword ptr [eax], 0
		jle	short loc_2D
		xor	eax, eax
		jmp	loc_15A
; ---------------------------------------------------------------------------

loc_2D:					; CODE XREF: _upvec_open_56+24j
		cmp	[ebp+arg_0], 1
		jge	short loc_43
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	loc_15A
; ---------------------------------------------------------------------------

loc_43:					; CODE XREF: _upvec_open_56+31j
		mov	eax, [ebp+arg_0]
		add	eax, 2
		mov	[ebp+arg_0], eax
		push	18h
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+Dst], eax
		mov	eax, [ebp+arg_0]
		shl	eax, 0Ch
		shl	eax, 2
		push	eax
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+var_14], eax
		cmp	[ebp+Dst], 0
		jz	short loc_7A
		cmp	[ebp+var_14], 0
		jnz	short loc_A2

loc_7A:					; CODE XREF: _upvec_open_56+72j
		mov	eax, [ebp+Dst]
		push	eax
		call	_uprv_free_56
		add	esp, 4
		mov	eax, [ebp+var_14]
		push	eax
		call	_uprv_free_56
		add	esp, 4
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 7
		xor	eax, eax
		jmp	loc_15A
; ---------------------------------------------------------------------------

loc_A2:					; CODE XREF: _upvec_open_56+78j
		push	18h		; Size
		push	0		; Val
		mov	eax, [ebp+Dst]
		push	eax		; Dst
		call	_memset
		add	esp, 0Ch
		mov	eax, [ebp+Dst]
		mov	ecx, [ebp+var_14]
		mov	[eax], ecx
		mov	eax, [ebp+Dst]
		mov	ecx, [ebp+arg_0]
		mov	[eax+4], ecx
		mov	eax, [ebp+Dst]
		mov	dword ptr [eax+8], 1000h
		mov	eax, [ebp+Dst]
		mov	dword ptr [eax+0Ch], 3
		mov	eax, [ebp+Dst]
		mov	ecx, [eax]
		mov	[ebp+var_20], ecx
		mov	eax, [ebp+Dst]
		mov	ecx, [eax+0Ch]
		imul	ecx, [ebp+arg_0]
		shl	ecx, 2
		push	ecx		; Size
		push	0		; Val
		mov	edx, [ebp+var_20]
		push	edx		; Dst
		call	_memset
		add	esp, 0Ch
		mov	eax, [ebp+var_20]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+var_20]
		mov	dword ptr [eax+4], 110000h
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_20]
		lea	edx, [ecx+eax*4]
		mov	[ebp+var_20], edx
		mov	[ebp+var_2C], 110000h
		jmp	short loc_12C
; ---------------------------------------------------------------------------

loc_123:				; CODE XREF: _upvec_open_56+155j
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax

loc_12C:				; CODE XREF: _upvec_open_56+121j
		cmp	[ebp+var_2C], 110001h
		ja	short loc_157
		mov	eax, [ebp+var_20]
		mov	ecx, [ebp+var_2C]
		mov	[eax], ecx
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	ecx, [ebp+var_20]
		mov	[ecx+4], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_20]
		lea	edx, [ecx+eax*4]
		mov	[ebp+var_20], edx
		jmp	short loc_123
; ---------------------------------------------------------------------------

loc_157:				; CODE XREF: _upvec_open_56+133j
		mov	eax, [ebp+Dst]

loc_15A:				; CODE XREF: _upvec_open_56+28j
					; _upvec_open_56+3Ej ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_upvec_open_56	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$TMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$TMZ
		;org 170h
__RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
_rtc$TMZ	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$IMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$IMZ
		;org 174h
__RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
_rtc$IMZ	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 178h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _upvec_close_56
_upvec_close_56	proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		jz	short loc_1B6
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		call	_uprv_free_56
		add	esp, 4
		mov	eax, [ebp+arg_0]
		push	eax
		call	_uprv_free_56
		add	esp, 4

loc_1B6:				; CODE XREF: _upvec_close_56+22j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_upvec_close_56	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1CCh
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _upvec_setValue_56
_upvec_setValue_56 proc	near

var_13C		= byte ptr -13Ch
var_139		= byte ptr -139h
var_74		= dword	ptr -74h
Dst		= dword	ptr -68h
var_5C		= dword	ptr -5Ch
var_50		= dword	ptr -50h
var_41		= byte ptr -41h
var_35		= byte ptr -35h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
Src		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h

		push	ebp
		mov	ebp, esp
		sub	esp, 13Ch
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_13C]
		mov	ecx, 4Fh ; 'O'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_18]
		cmp	dword ptr [eax], 0
		jle	short loc_1F7
		jmp	loc_5B5
; ---------------------------------------------------------------------------

loc_1F7:				; CODE XREF: _upvec_setValue_56+24j
		cmp	[ebp+arg_0], 0
		jz	short loc_228
		cmp	[ebp+arg_4], 0
		jl	short loc_228
		mov	eax, [ebp+arg_4]
		cmp	eax, [ebp+arg_8]
		jg	short loc_228
		cmp	[ebp+arg_8], 110001h
		jg	short loc_228
		cmp	[ebp+arg_C], 0
		jl	short loc_228
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		sub	ecx, 2
		cmp	[ebp+arg_C], ecx
		jl	short loc_236

loc_228:				; CODE XREF: _upvec_setValue_56+2Fj
					; _upvec_setValue_56+35j ...
		mov	eax, [ebp+arg_18]
		mov	dword ptr [eax], 1
		jmp	loc_5B5
; ---------------------------------------------------------------------------

loc_236:				; CODE XREF: _upvec_setValue_56+5Aj
		mov	eax, [ebp+arg_0]
		movsx	ecx, byte ptr [eax+14h]
		test	ecx, ecx
		jz	short loc_24F
		mov	eax, [ebp+arg_18]
		mov	dword ptr [eax], 1Eh
		jmp	loc_5B5
; ---------------------------------------------------------------------------

loc_24F:				; CODE XREF: _upvec_setValue_56+73j
		mov	eax, [ebp+arg_8]
		add	eax, 1
		mov	[ebp+var_2C], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	[ebp+var_20], ecx
		mov	eax, [ebp+arg_C]
		add	eax, 2
		mov	[ebp+arg_C], eax
		mov	eax, [ebp+arg_10]
		and	eax, [ebp+arg_14]
		mov	[ebp+arg_10], eax
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	__findRow
		add	esp, 8
		mov	[ebp+Src], eax
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	__findRow
		add	esp, 8
		mov	[ebp+var_14], eax
		mov	eax, [ebp+Src]
		mov	ecx, [ebp+arg_4]
		cmp	ecx, [eax]
		jz	short loc_2BD
		mov	edx, [ebp+arg_C]
		mov	eax, [ebp+Src]
		mov	ecx, [eax+edx*4]
		and	ecx, [ebp+arg_14]
		cmp	[ebp+arg_10], ecx
		jz	short loc_2BD
		mov	[ebp+var_139], 1
		jmp	short loc_2C4
; ---------------------------------------------------------------------------

loc_2BD:				; CODE XREF: _upvec_setValue_56+D5j
					; _upvec_setValue_56+E6j
		mov	[ebp+var_139], 0

loc_2C4:				; CODE XREF: _upvec_setValue_56+EFj
		mov	dl, [ebp+var_139]
		mov	[ebp+var_35], dl
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_2C]
		cmp	ecx, [eax+4]
		jz	short loc_2F2
		mov	edx, [ebp+arg_C]
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+edx*4]
		and	ecx, [ebp+arg_14]
		cmp	[ebp+arg_10], ecx
		jz	short loc_2F2
		mov	[ebp+var_139], 1
		jmp	short loc_2F9
; ---------------------------------------------------------------------------

loc_2F2:				; CODE XREF: _upvec_setValue_56+10Aj
					; _upvec_setValue_56+11Bj
		mov	[ebp+var_139], 0

loc_2F9:				; CODE XREF: _upvec_setValue_56+124j
		mov	dl, [ebp+var_139]
		mov	[ebp+var_41], dl
		movsx	eax, [ebp+var_35]
		test	eax, eax
		jnz	short loc_316
		movsx	eax, [ebp+var_41]
		test	eax, eax
		jz	loc_556

loc_316:				; CODE XREF: _upvec_setValue_56+13Cj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+0Ch]
		mov	[ebp+var_5C], ecx
		movsx	eax, [ebp+var_35]
		add	eax, [ebp+var_5C]
		movsx	ecx, [ebp+var_41]
		add	eax, ecx
		mov	edx, [ebp+arg_0]
		cmp	eax, [edx+8]
		jle	loc_40E
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+8], 10000h
		jge	short loc_34D
		mov	[ebp+var_74], 10000h
		jmp	short loc_370
; ---------------------------------------------------------------------------

loc_34D:				; CODE XREF: _upvec_setValue_56+176j
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+8], 110002h
		jge	short loc_362
		mov	[ebp+var_74], 110002h
		jmp	short loc_370
; ---------------------------------------------------------------------------

loc_362:				; CODE XREF: _upvec_setValue_56+18Bj
		mov	eax, [ebp+arg_18]
		mov	dword ptr [eax], 5
		jmp	loc_5B5
; ---------------------------------------------------------------------------

loc_370:				; CODE XREF: _upvec_setValue_56+17Fj
					; _upvec_setValue_56+194j
		mov	eax, [ebp+var_74]
		imul	eax, [ebp+var_20]
		shl	eax, 2
		push	eax
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+Dst], eax
		cmp	[ebp+Dst], 0
		jnz	short loc_39A
		mov	eax, [ebp+arg_18]
		mov	dword ptr [eax], 7
		jmp	loc_5B5
; ---------------------------------------------------------------------------

loc_39A:				; CODE XREF: _upvec_setValue_56+1BEj
		push	1
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	edx, [ebp+var_5C]
		imul	edx, [ebp+var_20]
		shl	edx, 2
		push	edx		; Size
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx		; Src
		mov	edx, [ebp+Dst]
		push	edx		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+Src]
		sub	ecx, [eax]
		sar	ecx, 2
		mov	edx, [ebp+Dst]
		lea	eax, [edx+ecx*4]
		mov	[ebp+Src], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		sub	ecx, [eax]
		sar	ecx, 2
		mov	edx, [ebp+Dst]
		lea	eax, [edx+ecx*4]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		call	_uprv_free_56
		add	esp, 4
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+Dst]
		mov	[eax], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_74]
		mov	[eax+8], ecx

loc_40E:				; CODE XREF: _upvec_setValue_56+166j
		mov	eax, [ebp+var_5C]
		imul	eax, [ebp+var_20]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		lea	eax, [edx+eax*4]
		mov	ecx, [ebp+var_20]
		mov	edx, [ebp+var_14]
		lea	ecx, [edx+ecx*4]
		sub	eax, ecx
		sar	eax, 2
		mov	[ebp+var_50], eax
		cmp	[ebp+var_50], 0
		jle	short loc_482
		push	1
		mov	eax, [ebp+var_20]
		mov	ecx, [ebp+var_14]
		lea	edx, [ecx+eax*4]
		push	edx
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	eax, [ebp+var_50]
		shl	eax, 2
		mov	esi, esp
		push	eax		; Size
		mov	ecx, [ebp+var_20]
		mov	edx, [ebp+var_14]
		lea	eax, [edx+ecx*4]
		push	eax		; Src
		movsx	ecx, [ebp+var_35]
		movsx	edx, [ebp+var_41]
		lea	eax, [ecx+edx+1]
		imul	eax, [ebp+var_20]
		mov	ecx, [ebp+var_14]
		lea	edx, [ecx+eax*4]
		push	edx		; Dst
		call	dword ptr ds:__imp__memmove
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_482:				; CODE XREF: _upvec_setValue_56+266j
		movsx	eax, [ebp+var_35]
		add	eax, [ebp+var_5C]
		movsx	ecx, [ebp+var_41]
		add	eax, ecx
		mov	edx, [ebp+arg_0]
		mov	[edx+0Ch], eax
		movsx	eax, [ebp+var_35]
		test	eax, eax
		jz	short loc_50E
		mov	eax, [ebp+var_14]
		sub	eax, [ebp+Src]
		sar	eax, 2
		add	eax, [ebp+var_20]
		mov	[ebp+var_50], eax
		push	1
		mov	eax, [ebp+Src]
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	ecx, [ebp+var_50]
		shl	ecx, 2
		mov	esi, esp
		push	ecx		; Size
		mov	edx, [ebp+Src]
		push	edx		; Src
		mov	eax, [ebp+var_20]
		mov	ecx, [ebp+Src]
		lea	edx, [ecx+eax*4]
		push	edx		; Dst
		call	dword ptr ds:__imp__memmove
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_20]
		mov	ecx, [ebp+var_14]
		lea	edx, [ecx+eax*4]
		mov	[ebp+var_14], edx
		mov	eax, [ebp+var_20]
		mov	ecx, [ebp+Src]
		mov	edx, [ebp+arg_4]
		mov	[ecx+eax*4], edx
		mov	eax, [ebp+Src]
		mov	ecx, [ebp+arg_4]
		mov	[eax+4], ecx
		mov	eax, [ebp+var_20]
		mov	ecx, [ebp+Src]
		lea	edx, [ecx+eax*4]
		mov	[ebp+Src], edx

loc_50E:				; CODE XREF: _upvec_setValue_56+2CFj
		movsx	eax, [ebp+var_41]
		test	eax, eax
		jz	short loc_556
		push	1
		mov	eax, [ebp+var_14]
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	ecx, [ebp+var_20]
		shl	ecx, 2
		push	ecx		; Size
		mov	edx, [ebp+var_14]
		push	edx		; Src
		mov	eax, [ebp+var_20]
		mov	ecx, [ebp+var_14]
		lea	edx, [ecx+eax*4]
		push	edx		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	eax, [ebp+var_20]
		mov	ecx, [ebp+var_14]
		mov	edx, [ebp+var_2C]
		mov	[ecx+eax*4], edx
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_2C]
		mov	[eax+4], ecx

loc_556:				; CODE XREF: _upvec_setValue_56+144j
					; _upvec_setValue_56+348j
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		sub	ecx, [eax]
		sar	ecx, 2
		mov	eax, ecx
		cdq
		idiv	[ebp+var_20]
		mov	edx, [ebp+arg_0]
		mov	[edx+10h], eax
		mov	eax, [ebp+arg_C]
		mov	ecx, [ebp+Src]
		lea	edx, [ecx+eax*4]
		mov	[ebp+Src], edx
		mov	eax, [ebp+arg_C]
		mov	ecx, [ebp+var_14]
		lea	edx, [ecx+eax*4]
		mov	[ebp+var_14], edx
		mov	eax, [ebp+arg_14]
		not	eax
		mov	[ebp+arg_14], eax

loc_58D:				; CODE XREF: _upvec_setValue_56+3E7j
		mov	eax, [ebp+Src]
		mov	ecx, [eax]
		and	ecx, [ebp+arg_14]
		or	ecx, [ebp+arg_10]
		mov	edx, [ebp+Src]
		mov	[edx], ecx
		mov	eax, [ebp+Src]
		cmp	eax, [ebp+var_14]
		jnz	short loc_5A7
		jmp	short loc_5B5
; ---------------------------------------------------------------------------

loc_5A7:				; CODE XREF: _upvec_setValue_56+3D7j
		mov	eax, [ebp+var_20]
		mov	ecx, [ebp+Src]
		lea	edx, [ecx+eax*4]
		mov	[ebp+Src], edx
		jmp	short loc_58D
; ---------------------------------------------------------------------------

loc_5B5:				; CODE XREF: _upvec_setValue_56+26j
					; _upvec_setValue_56+65j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 13Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_upvec_setValue_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5CCh
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

__findRow	proc near		; CODE XREF: _upvec_setValue_56+AFp
					; _upvec_setValue_56+C2p ...

var_108		= byte ptr -108h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 108h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_108]
		mov	ecx, 42h ; 'B'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+0Ch]
		mov	[ebp+var_38], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		mov	[ebp+var_44], ecx
		mov	eax, [ebp+var_44]
		imul	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		lea	eax, [edx+eax*4]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		cmp	ecx, [eax]
		jl	loc_6E1
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		cmp	ecx, [eax+4]
		jge	short loc_63D
		mov	eax, [ebp+var_8]
		jmp	loc_77E
; ---------------------------------------------------------------------------
		jmp	loc_6DF
; ---------------------------------------------------------------------------

loc_63D:				; CODE XREF: __findRow+62j
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_8]
		lea	edx, [ecx+eax*4]
		mov	[ebp+var_8], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		cmp	ecx, [eax+4]
		jge	short loc_66A
		mov	eax, [ebp+var_44]
		add	eax, 1
		mov	ecx, [ebp+arg_0]
		mov	[ecx+10h], eax
		mov	eax, [ebp+var_8]
		jmp	loc_77E
; ---------------------------------------------------------------------------
		jmp	short loc_6DF
; ---------------------------------------------------------------------------

loc_66A:				; CODE XREF: __findRow+86j
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_8]
		lea	edx, [ecx+eax*4]
		mov	[ebp+var_8], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		cmp	ecx, [eax+4]
		jge	short loc_697
		mov	eax, [ebp+var_44]
		add	eax, 2
		mov	ecx, [ebp+arg_0]
		mov	[ecx+10h], eax
		mov	eax, [ebp+var_8]
		jmp	loc_77E
; ---------------------------------------------------------------------------
		jmp	short loc_6DF
; ---------------------------------------------------------------------------

loc_697:				; CODE XREF: __findRow+B3j
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		sub	ecx, [eax+4]
		cmp	ecx, 0Ah
		jge	short loc_6DF
		mov	eax, [ebp+var_44]
		add	eax, 2
		mov	[ebp+var_44], eax

loc_6AE:				; CODE XREF: __findRow+100j
		mov	eax, [ebp+var_44]
		add	eax, 1
		mov	[ebp+var_44], eax
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_8]
		lea	edx, [ecx+eax*4]
		mov	[ebp+var_8], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		cmp	ecx, [eax+4]
		jge	short loc_6AE
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_44]
		mov	[eax+10h], ecx
		mov	eax, [ebp+var_8]
		jmp	loc_77E
; ---------------------------------------------------------------------------

loc_6DF:				; CODE XREF: __findRow+6Cj
					; __findRow+9Cj ...
		jmp	short loc_6FF
; ---------------------------------------------------------------------------

loc_6E1:				; CODE XREF: __findRow+53j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ebp+arg_4]
		cmp	edx, [ecx+4]
		jge	short loc_6FF
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+10h], 0
		mov	eax, [ebp+arg_0]
		mov	eax, [eax]
		jmp	short loc_77E
; ---------------------------------------------------------------------------

loc_6FF:				; CODE XREF: __findRow:loc_6DFj
					; __findRow+120j
		mov	[ebp+var_2C], 0

loc_706:				; CODE XREF: __findRow:loc_764j
		mov	eax, [ebp+var_38]
		sub	eax, 1
		cmp	[ebp+var_2C], eax
		jge	short loc_766
		mov	eax, [ebp+var_2C]
		add	eax, [ebp+var_38]
		cdq
		sub	eax, edx
		sar	eax, 1
		mov	[ebp+var_20], eax
		mov	eax, [ebp+var_20]
		imul	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		lea	eax, [edx+eax*4]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		cmp	ecx, [eax]
		jge	short loc_743
		mov	eax, [ebp+var_20]
		mov	[ebp+var_38], eax
		jmp	short loc_764
; ---------------------------------------------------------------------------

loc_743:				; CODE XREF: __findRow+16Dj
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		cmp	ecx, [eax+4]
		jge	short loc_75E
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_20]
		mov	[eax+10h], ecx
		mov	eax, [ebp+var_8]
		jmp	short loc_77E
; ---------------------------------------------------------------------------
		jmp	short loc_764
; ---------------------------------------------------------------------------

loc_75E:				; CODE XREF: __findRow+180j
		mov	eax, [ebp+var_20]
		mov	[ebp+var_2C], eax

loc_764:				; CODE XREF: __findRow+175j
					; __findRow+190j
		jmp	short loc_706
; ---------------------------------------------------------------------------

loc_766:				; CODE XREF: __findRow+143j
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_2C]
		mov	[eax+10h], ecx
		mov	eax, [ebp+var_2C]
		imul	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		lea	eax, [edx+eax*4]

loc_77E:				; CODE XREF: __findRow+67j
					; __findRow+97j ...
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
__findRow	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 788h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _upvec_getValue_56
_upvec_getValue_56 proc	near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		movsx	ecx, byte ptr [eax+14h]
		test	ecx, ecx
		jnz	short loc_7D4
		cmp	[ebp+arg_4], 0
		jl	short loc_7D4
		cmp	[ebp+arg_4], 110001h
		jg	short loc_7D4
		cmp	[ebp+arg_8], 0
		jl	short loc_7D4
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		sub	ecx, 2
		cmp	[ebp+arg_8], ecx
		jl	short loc_7D8

loc_7D4:				; CODE XREF: _upvec_getValue_56+27j
					; _upvec_getValue_56+2Dj ...
		xor	eax, eax
		jmp	short loc_7FB
; ---------------------------------------------------------------------------

loc_7D8:				; CODE XREF: _upvec_getValue_56+4Aj
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_14]
		push	ecx
		call	__findRow
		add	esp, 8
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_8]
		mov	ecx, [ebp+var_8]
		mov	eax, [ecx+eax*4+8]

loc_7FB:				; CODE XREF: _upvec_getValue_56+4Ej
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_upvec_getValue_56 endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 810h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _upvec_getRow_56
_upvec_getRow_56 proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		movsx	ecx, byte ptr [eax+14h]
		test	ecx, ecx
		jnz	short loc_84A
		cmp	[ebp+arg_4], 0
		jl	short loc_84A
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		cmp	ecx, [eax+0Ch]
		jl	short loc_84E

loc_84A:				; CODE XREF: _upvec_getRow_56+27j
					; _upvec_getRow_56+2Dj
		xor	eax, eax
		jmp	short loc_893
; ---------------------------------------------------------------------------

loc_84E:				; CODE XREF: _upvec_getRow_56+38j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_4]
		imul	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		lea	eax, [edx+eax*4]
		mov	[ebp+var_8], eax
		cmp	[ebp+arg_8], 0
		jz	short loc_879
		mov	eax, [ebp+arg_8]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	[eax], edx

loc_879:				; CODE XREF: _upvec_getRow_56+5Dj
		cmp	[ebp+arg_C], 0
		jz	short loc_88D
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		sub	ecx, 1
		mov	edx, [ebp+arg_C]
		mov	[edx], ecx

loc_88D:				; CODE XREF: _upvec_getRow_56+6Dj
		mov	eax, [ebp+var_8]
		add	eax, 8

loc_893:				; CODE XREF: _upvec_getRow_56+3Cj
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
_upvec_getRow_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 89Ch
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _upvec_compact_56
_upvec_compact_56 proc near		; CODE XREF: _upvec_compactToUTrie2WithRowIndexes_56+41p

var_120		= byte ptr -120h
var_5C		= dword	ptr -5Ch
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 120h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_120]
		mov	ecx, 48h ; 'H'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_C]
		cmp	dword ptr [eax], 0
		jle	short loc_8C7
		jmp	loc_B93
; ---------------------------------------------------------------------------

loc_8C7:				; CODE XREF: _upvec_compact_56+24j
		cmp	[ebp+arg_4], 0
		jnz	short loc_8DB
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 1
		jmp	loc_B93
; ---------------------------------------------------------------------------

loc_8DB:				; CODE XREF: _upvec_compact_56+2Fj
		mov	eax, [ebp+arg_0]
		movsx	ecx, byte ptr [eax+14h]
		test	ecx, ecx
		jz	short loc_8EB
		jmp	loc_B93
; ---------------------------------------------------------------------------

loc_8EB:				; CODE XREF: _upvec_compact_56+48j
		mov	eax, [ebp+arg_0]
		mov	byte ptr [eax+14h], 1
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+0Ch]
		mov	[ebp+var_38], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	[ebp+var_20], ecx
		cmp	[ebp+var_20], 3
		jge	short loc_92F
		mov	eax, ds:?__LINE__Var@?1??upvec_compact_56@@9@9 ; `upvec_compact_56'::`2'::__LINE__Var
		add	eax, 16h
		mov	esi, esp
		push	eax		; Line
		push	offset ??_C@_1FK@GGCEBNMF@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@ ; "d:\\mozilla\\intl\\icu\\source\\common\"...
		push	offset ??_C@_1BG@MOOHBLO@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?$DO?$AA?$DN?$AA3?$AA?$AA@ ; "columns>=3"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_92F:				; CODE XREF: _upvec_compact_56+6Cj
		mov	eax, [ebp+var_20]
		sub	eax, 2
		mov	[ebp+var_2C], eax
		mov	eax, [ebp+arg_C]
		push	eax
		push	0
		mov	ecx, [ebp+arg_0]
		push	ecx
		push	offset _upvec_compareRows
		mov	edx, [ebp+var_20]
		shl	edx, 2
		push	edx
		mov	eax, [ebp+var_38]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		push	edx
		call	_uprv_sortArray_56
		add	esp, 1Ch
		mov	eax, [ebp+arg_C]
		cmp	dword ptr [eax], 0
		jle	short loc_96D
		jmp	loc_B93
; ---------------------------------------------------------------------------

loc_96D:				; CODE XREF: _upvec_compact_56+CAj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_2C]
		neg	eax
		mov	[ebp+var_44], eax
		mov	[ebp+var_14], 0
		jmp	short loc_98F
; ---------------------------------------------------------------------------

loc_986:				; CODE XREF: _upvec_compact_56+18Cj
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_98F:				; CODE XREF: _upvec_compact_56+E8j
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_38]
		jge	loc_A2D
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		mov	[ebp+var_50], ecx
		cmp	[ebp+var_44], 0
		jl	short loc_9CF
		mov	eax, [ebp+var_2C]
		shl	eax, 2
		push	eax		; Size
		mov	ecx, [ebp+var_2C]
		shl	ecx, 2
		mov	edx, [ebp+var_8]
		sub	edx, ecx
		push	edx		; Buf2
		mov	eax, [ebp+var_8]
		add	eax, 8
		push	eax		; Buf1
		call	_memcmp
		add	esp, 0Ch
		test	eax, eax
		jz	short loc_9D8

loc_9CF:				; CODE XREF: _upvec_compact_56+10Bj
		mov	eax, [ebp+var_44]
		add	eax, [ebp+var_2C]
		mov	[ebp+var_44], eax

loc_9D8:				; CODE XREF: _upvec_compact_56+131j
		cmp	[ebp+var_50], 110000h
		jl	short loc_A1C
		mov	esi, esp
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+var_2C]
		push	ecx
		mov	edx, [ebp+var_8]
		add	edx, 8
		push	edx
		mov	eax, [ebp+var_44]
		push	eax
		mov	ecx, [ebp+var_50]
		push	ecx
		mov	edx, [ebp+var_50]
		push	edx
		mov	eax, [ebp+arg_8]
		push	eax
		call	[ebp+arg_4]
		add	esp, 1Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_C]
		cmp	dword ptr [eax], 0
		jle	short loc_A1C
		jmp	loc_B93
; ---------------------------------------------------------------------------

loc_A1C:				; CODE XREF: _upvec_compact_56+143j
					; _upvec_compact_56+179j
		mov	eax, [ebp+var_20]
		mov	ecx, [ebp+var_8]
		lea	edx, [ecx+eax*4]
		mov	[ebp+var_8], edx
		jmp	loc_986
; ---------------------------------------------------------------------------

loc_A2D:				; CODE XREF: _upvec_compact_56+F9j
		mov	eax, [ebp+var_44]
		add	eax, [ebp+var_2C]
		mov	[ebp+var_44], eax
		mov	esi, esp
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+var_2C]
		push	ecx
		mov	edx, [ebp+var_2C]
		shl	edx, 2
		mov	eax, [ebp+var_8]
		sub	eax, edx
		push	eax
		mov	ecx, [ebp+var_44]
		push	ecx
		push	200000h
		push	200000h
		mov	edx, [ebp+arg_8]
		push	edx
		call	[ebp+arg_4]
		add	esp, 1Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_C]
		cmp	dword ptr [eax], 0
		jle	short loc_A78
		jmp	loc_B93
; ---------------------------------------------------------------------------

loc_A78:				; CODE XREF: _upvec_compact_56+1D5j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_2C]
		neg	eax
		mov	[ebp+var_44], eax
		mov	[ebp+var_14], 0
		jmp	short loc_A9A
; ---------------------------------------------------------------------------

loc_A91:				; CODE XREF: _upvec_compact_56+2E2j
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_A9A:				; CODE XREF: _upvec_compact_56+1F3j
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_38]
		jge	loc_B83
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		mov	[ebp+var_50], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	[ebp+var_5C], ecx
		cmp	[ebp+var_44], 0
		jl	short loc_AE3
		mov	eax, [ebp+var_2C]
		shl	eax, 2
		push	eax		; Size
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	eax, [ebp+var_44]
		lea	ecx, [edx+eax*4]
		push	ecx		; Buf2
		mov	edx, [ebp+var_8]
		add	edx, 8
		push	edx		; Buf1
		call	_memcmp
		add	esp, 0Ch
		test	eax, eax
		jz	short loc_B29

loc_AE3:				; CODE XREF: _upvec_compact_56+21Fj
		mov	eax, [ebp+var_44]
		add	eax, [ebp+var_2C]
		mov	[ebp+var_44], eax
		push	1
		mov	eax, [ebp+var_8]
		add	eax, 8
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	ecx, [ebp+var_2C]
		shl	ecx, 2
		mov	esi, esp
		push	ecx		; Size
		mov	edx, [ebp+var_8]
		add	edx, 8
		push	edx		; Src
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ebp+var_44]
		lea	eax, [ecx+edx*4]
		push	eax		; Dst
		call	dword ptr ds:__imp__memmove
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_B29:				; CODE XREF: _upvec_compact_56+245j
		cmp	[ebp+var_50], 110000h
		jge	short loc_B72
		mov	esi, esp
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+var_2C]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx]
		mov	ecx, [ebp+var_44]
		lea	edx, [eax+ecx*4]
		push	edx
		mov	eax, [ebp+var_44]
		push	eax
		mov	ecx, [ebp+var_5C]
		sub	ecx, 1
		push	ecx
		mov	edx, [ebp+var_50]
		push	edx
		mov	eax, [ebp+arg_8]
		push	eax
		call	[ebp+arg_4]
		add	esp, 1Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_C]
		cmp	dword ptr [eax], 0
		jle	short loc_B72
		jmp	short loc_B93
; ---------------------------------------------------------------------------

loc_B72:				; CODE XREF: _upvec_compact_56+294j
					; _upvec_compact_56+2D2j
		mov	eax, [ebp+var_20]
		mov	ecx, [ebp+var_8]
		lea	edx, [ecx+eax*4]
		mov	[ebp+var_8], edx
		jmp	loc_A91
; ---------------------------------------------------------------------------

loc_B83:				; CODE XREF: _upvec_compact_56+204j
		mov	eax, [ebp+var_44]
		cdq
		idiv	[ebp+var_2C]
		add	eax, 1
		mov	ecx, [ebp+arg_0]
		mov	[ecx+0Ch], eax

loc_B93:				; CODE XREF: _upvec_compact_56+26j
					; _upvec_compact_56+3Aj ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 120h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_upvec_compact_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0BA8h
		public ??_C@_1BG@MOOHBLO@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?$DO?$AA?$DN?$AA3?$AA?$AA@
; wchar_t `string'
??_C@_1BG@MOOHBLO@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?$DO?$AA?$DN?$AA3?$AA?$AA@:
					; DATA XREF: _upvec_compact_56+7Eo
		unicode	0, <columns>
		dw 3Eh
		unicode	0, <=3>,0
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 0BC0h
		public ??_C@_1FK@GGCEBNMF@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@
; wchar_t `string'
??_C@_1FK@GGCEBNMF@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@:
					; DATA XREF: _upvec_compact_56+79o
		unicode	0, <d:\mozilla\intl\icu\source\common\propsvec.c>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 0C1Ch
		public ?__LINE__Var@?1??upvec_compact_56@@9@9
; `upvec_compact_56'::`2'::__LINE__Var
?__LINE__Var@?1??upvec_compact_56@@9@9 dd 14Eh ; DATA XREF: _upvec_compact_56+6Er
_data		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C20h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

_upvec_compareRows proc	near		; DATA XREF: _upvec_compact_56+A6o

var_108		= byte ptr -108h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 108h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_108]
		mov	ecx, 42h ; 'B'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_8]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_20], eax
		mov	eax, [ebp+var_20]
		mov	ecx, [eax+4]
		mov	[ebp+var_44], ecx
		mov	edx, [ebp+var_44]
		mov	[ebp+var_38], edx
		mov	[ebp+var_2C], 2

loc_C66:				; CODE XREF: _upvec_compareRows+9Bj
		mov	eax, [ebp+var_2C]
		mov	ecx, [ebp+var_8]
		mov	edx, [ebp+var_2C]
		mov	esi, [ebp+var_14]
		mov	eax, [ecx+eax*4]
		cmp	eax, [esi+edx*4]
		jz	short loc_C96
		mov	eax, [ebp+var_2C]
		mov	ecx, [ebp+var_8]
		mov	edx, [ebp+var_2C]
		mov	esi, [ebp+var_14]
		mov	eax, [ecx+eax*4]
		cmp	eax, [esi+edx*4]
		sbb	eax, eax
		and	eax, 0FFFFFFFEh
		add	eax, 1
		jmp	short loc_CBF
; ---------------------------------------------------------------------------

loc_C96:				; CODE XREF: _upvec_compareRows+58j
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax
		mov	ecx, [ebp+var_2C]
		cmp	ecx, [ebp+var_44]
		jnz	short loc_CAE
		mov	[ebp+var_2C], 0

loc_CAE:				; CODE XREF: _upvec_compareRows+85j
		mov	eax, [ebp+var_38]
		sub	eax, 1
		mov	[ebp+var_38], eax
		cmp	[ebp+var_38], 0
		jg	short loc_C66
		xor	eax, eax

loc_CBF:				; CODE XREF: _upvec_compareRows+74j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
_upvec_compareRows endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0CC8h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _upvec_getArray_56
_upvec_getArray_56 proc	near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		movsx	ecx, byte ptr [eax+14h]
		test	ecx, ecx
		jnz	short loc_CF5
		xor	eax, eax
		jmp	short loc_D1F
; ---------------------------------------------------------------------------

loc_CF5:				; CODE XREF: _upvec_getArray_56+27j
		cmp	[ebp+arg_4], 0
		jz	short loc_D06
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+0Ch]
		mov	[eax], edx

loc_D06:				; CODE XREF: _upvec_getArray_56+31j
		cmp	[ebp+arg_8], 0
		jz	short loc_D1A
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		sub	ecx, 2
		mov	edx, [ebp+arg_8]
		mov	[edx], ecx

loc_D1A:				; CODE XREF: _upvec_getArray_56+42j
		mov	eax, [ebp+arg_0]
		mov	eax, [eax]

loc_D1F:				; CODE XREF: _upvec_getArray_56+2Bj
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
_upvec_getArray_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D28h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _upvec_cloneArray_56
_upvec_cloneArray_56 proc near

var_D8		= byte ptr -0D8h
Size		= dword	ptr -14h
Dst		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_C]
		cmp	dword ptr [eax], 0
		jle	short loc_D55
		xor	eax, eax
		jmp	loc_DF6
; ---------------------------------------------------------------------------

loc_D55:				; CODE XREF: _upvec_cloneArray_56+24j
		mov	eax, [ebp+arg_0]
		movsx	ecx, byte ptr [eax+14h]
		test	ecx, ecx
		jnz	short loc_D70
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	loc_DF6
; ---------------------------------------------------------------------------

loc_D70:				; CODE XREF: _upvec_cloneArray_56+36j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		sub	ecx, 2
		mov	edx, [ebp+arg_0]
		imul	ecx, [edx+0Ch]
		shl	ecx, 2
		mov	[ebp+Size], ecx
		mov	eax, [ebp+Size]
		push	eax
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+Dst], eax
		cmp	[ebp+Dst], 0
		jnz	short loc_DA8
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 7
		xor	eax, eax
		jmp	short loc_DF6
; ---------------------------------------------------------------------------

loc_DA8:				; CODE XREF: _upvec_cloneArray_56+71j
		push	1
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	edx, [ebp+Size]
		push	edx		; Size
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx		; Src
		mov	edx, [ebp+Dst]
		push	edx		; Dst
		call	_memcpy
		add	esp, 0Ch
		cmp	[ebp+arg_4], 0
		jz	short loc_DDF
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+0Ch]
		mov	[eax], edx

loc_DDF:				; CODE XREF: _upvec_cloneArray_56+AAj
		cmp	[ebp+arg_8], 0
		jz	short loc_DF3
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		sub	ecx, 2
		mov	edx, [ebp+arg_8]
		mov	[edx], ecx

loc_DF3:				; CODE XREF: _upvec_cloneArray_56+BBj
		mov	eax, [ebp+Dst]

loc_DF6:				; CODE XREF: _upvec_cloneArray_56+28j
					; _upvec_cloneArray_56+43j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_upvec_cloneArray_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0E0Ch
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _upvec_compactToUTrie2WithRowIndexes_56
_upvec_compactToUTrie2WithRowIndexes_56	proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_14], 0
		xor	eax, eax
		mov	[ebp+var_10], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_4]
		push	eax
		lea	ecx, [ebp+var_14]
		push	ecx
		push	offset _upvec_compactToUTrie2Handler_56
		mov	edx, [ebp+arg_0]
		push	edx
		call	_upvec_compact_56
		add	esp, 10h
		mov	eax, [ebp+arg_4]
		push	eax
		push	0
		mov	ecx, [ebp+var_14]
		push	ecx
		call	_utrie2_freeze_56
		add	esp, 0Ch
		mov	eax, [ebp+arg_4]
		cmp	dword ptr [eax], 0
		jle	short loc_E82
		mov	eax, [ebp+var_14]
		push	eax
		call	_utrie2_close_56
		add	esp, 4
		mov	[ebp+var_14], 0

loc_E82:				; CODE XREF: _upvec_compactToUTrie2WithRowIndexes_56+61j
		mov	eax, [ebp+var_14]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN6
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_upvec_compactToUTrie2WithRowIndexes_56	endp

; ---------------------------------------------------------------------------
		align 4
$LN6		dd 1			; DATA XREF: _upvec_compactToUTrie2WithRowIndexes_56+7Do
		dd offset $LN5
$LN5		dd 0FFFFFFECh, 10h	; DATA XREF: .text:00000EB0o
		dd offset $LN4		; "toUTrie2"
$LN4		db 'toUTrie2',0         ; DATA XREF: .text:00000EBCo
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0ECCh
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _upvec_compactToUTrie2Handler_56
_upvec_compactToUTrie2Handler_56 proc near
					; DATA XREF: _upvec_compactToUTrie2WithRowIndexes_56+38o

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_18		= dword	ptr  20h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		cmp	[ebp+arg_4], 110000h
		jge	short loc_F1E
		mov	eax, [ebp+arg_18]
		push	eax
		push	1
		mov	ecx, [ebp+arg_C]
		push	ecx
		mov	edx, [ebp+arg_8]
		push	edx
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		push	edx
		call	_utrie2_setRange32_56
		add	esp, 18h
		jmp	loc_F9F
; ---------------------------------------------------------------------------

loc_F1E:				; CODE XREF: _upvec_compactToUTrie2Handler_56+2Bj
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_D0], eax
		cmp	[ebp+var_D0], 110000h
		jz	short loc_F4D
		cmp	[ebp+var_D0], 110001h
		jz	short loc_F58
		cmp	[ebp+var_D0], 200000h
		jz	short loc_F63
		jmp	short loc_F9F
; ---------------------------------------------------------------------------

loc_F4D:				; CODE XREF: _upvec_compactToUTrie2Handler_56+65j
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_C]
		mov	[eax+4], ecx
		jmp	short loc_F9F
; ---------------------------------------------------------------------------

loc_F58:				; CODE XREF: _upvec_compactToUTrie2Handler_56+71j
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_C]
		mov	[eax+8], ecx
		jmp	short loc_F9F
; ---------------------------------------------------------------------------

loc_F63:				; CODE XREF: _upvec_compactToUTrie2Handler_56+7Dj
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_C]
		mov	[eax+0Ch], ecx
		cmp	[ebp+arg_C], 0FFFFh
		jle	short loc_F80
		mov	eax, [ebp+arg_18]
		mov	dword ptr [eax], 8
		jmp	short loc_F9F
; ---------------------------------------------------------------------------

loc_F80:				; CODE XREF: _upvec_compactToUTrie2Handler_56+A7j
		mov	eax, [ebp+arg_18]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+8]
		push	edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		push	ecx
		call	_utrie2_open_56
		add	esp, 0Ch
		mov	edx, [ebp+var_8]
		mov	[edx], eax

loc_F9F:				; CODE XREF: _upvec_compactToUTrie2Handler_56+4Dj
					; _upvec_compactToUTrie2Handler_56+7Fj	...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_upvec_compactToUTrie2Handler_56 endp

_text		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
; void *__cdecl	memset(void *Dst, int Val, size_t Size)
		extrn _memset:near	; CODE XREF: _upvec_open_56+AAp
					; _upvec_open_56+F3p
		extrn _uprv_free_56:near ; CODE	XREF: _upvec_open_56+7Ep
					; _upvec_open_56+8Ap ...
		extrn _uprv_malloc_56:near ; CODE XREF:	_upvec_open_56+4Ep
					; _upvec_open_56+63p ...
		extrn __RTC_CheckEsp:near ; CODE XREF: _upvec_open_56+165p
					; _upvec_close_56+49p ...
		extrn __RTC_Shutdown:near ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
		extrn __RTC_InitBase:near ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
; void *__cdecl	_memmove(void *Dst, const void *Src, size_t Size)
		extrn __imp__memmove:near ; CODE XREF: _upvec_setValue_56+2A6p
					; _upvec_setValue_56+305p ...
; void *__cdecl	memcpy(void *Dst, const	void *Src, size_t Size)
		extrn _memcpy:near	; CODE XREF: _upvec_setValue_56+1F3p
					; _upvec_setValue_56+36Dp ...
		extrn _uprv_checkValidMemory:near ; CODE XREF: _upvec_setValue_56+1D6p
					; _upvec_setValue_56+274p ...
; int __cdecl memcmp(const void	*Buf1, const void *Buf2, size_t	Size)
		extrn _memcmp:near	; CODE XREF: _upvec_compact_56+127p
					; _upvec_compact_56+23Bp
		extrn _uprv_sortArray_56:near ;	CODE XREF: _upvec_compact_56+BCp
; void __cdecl __wassert(const wchar_t *Message, const wchar_t *File, unsigned int Line)
		extrn __imp___wassert:near ; CODE XREF:	_upvec_compact_56+83p
					; DATA XREF: _upvec_compact_56+83r
		extrn _utrie2_close_56:near
					; CODE XREF: _upvec_compactToUTrie2WithRowIndexes_56+67p
		extrn _utrie2_freeze_56:near
					; CODE XREF: _upvec_compactToUTrie2WithRowIndexes_56+53p
; __fastcall _RTC_CheckStackVars(x, x)
		extrn @_RTC_CheckStackVars@8:near
					; CODE XREF: _upvec_compactToUTrie2WithRowIndexes_56+83p
		extrn _utrie2_open_56:near ; CODE XREF:	_upvec_compactToUTrie2Handler_56+C6p
		extrn _utrie2_setRange32_56:near
					; CODE XREF: _upvec_compactToUTrie2Handler_56+45p


		end
