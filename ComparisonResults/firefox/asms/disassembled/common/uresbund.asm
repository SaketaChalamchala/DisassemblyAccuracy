;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	26825ED5989955278113BA74F8D413FD
; Input	CRC32 :	4E88D0EA

; File Name   :	D:\compspace\objfiles\firefox\common\uresbund.obj
; Format      :	COFF (X386MAGIC)
; includelib "msvcprtd"
; includelib "MSVCRTD"
; includelib "OLDNAMES"

		include	uni.inc	; see unicode subdir of	ida for	info on	unicode

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		public ?value@?$integral_constant@_N$0A@@tr1@std@@2_NB
; public: static bool const std::tr1::integral_constant<bool, 0>::value
?value@?$integral_constant@_N$0A@@tr1@std@@2_NB	db 0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		;org 4
		public ?value@?$integral_constant@_N$00@tr1@std@@2_NB
; public: static bool const std::tr1::integral_constant<bool, 1>::value
?value@?$integral_constant@_N$00@tr1@std@@2_NB db 1
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8
		public ?value@?$integral_constant@I$0A@@tr1@std@@2IB
; public: static unsigned int const std::tr1::integral_constant<unsigned int, 0>::value
?value@?$integral_constant@I$0A@@tr1@std@@2IB dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0Ch
		public ?_Rank@?$_Arithmetic_traits@_N@std@@2HB
; public: static int const std::_Arithmetic_traits<bool>::_Rank
?_Rank@?$_Arithmetic_traits@_N@std@@2HB	dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 10h
		public ?_Rank@?$_Arithmetic_traits@D@std@@2HB
; public: static int const std::_Arithmetic_traits<char>::_Rank
?_Rank@?$_Arithmetic_traits@D@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 14h
		public ?_Rank@?$_Arithmetic_traits@C@std@@2HB
; public: static int const std::_Arithmetic_traits<signed char>::_Rank
?_Rank@?$_Arithmetic_traits@C@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 18h
		public ?_Rank@?$_Arithmetic_traits@E@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned char>::_Rank
?_Rank@?$_Arithmetic_traits@E@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1Ch
		public ?_Rank@?$_Arithmetic_traits@F@std@@2HB
; public: static int const std::_Arithmetic_traits<short>::_Rank
?_Rank@?$_Arithmetic_traits@F@std@@2HB dd 3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 20h
		public ?_Rank@?$_Arithmetic_traits@G@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned short>::_Rank
?_Rank@?$_Arithmetic_traits@G@std@@2HB dd 3
					; DATA XREF: .rdata:int	const std::_Locbase<int>::messageso
					; .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::showposo ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 24h
		public ?_Rank@?$_Arithmetic_traits@H@std@@2HB
; public: static int const std::_Arithmetic_traits<int>::_Rank
?_Rank@?$_Arithmetic_traits@H@std@@2HB dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 28h
		public ?_Rank@?$_Arithmetic_traits@I@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned int>::_Rank
?_Rank@?$_Arithmetic_traits@I@std@@2HB dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2Ch
		public ?_Rank@?$_Arithmetic_traits@J@std@@2HB
; public: static int const std::_Arithmetic_traits<long>::_Rank
?_Rank@?$_Arithmetic_traits@J@std@@2HB dd 5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 30h
		public ?_Rank@?$_Arithmetic_traits@K@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned long>::_Rank
?_Rank@?$_Arithmetic_traits@K@std@@2HB dd 5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 34h
		public ?_Rank@?$_Arithmetic_traits@_J@std@@2HB
; public: static int const std::_Arithmetic_traits<__int64>::_Rank
?_Rank@?$_Arithmetic_traits@_J@std@@2HB	dd 6
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 38h
		public ?_Rank@?$_Arithmetic_traits@_K@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned __int64>::_Rank
?_Rank@?$_Arithmetic_traits@_K@std@@2HB	dd 6
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3Ch
		public ?_Rank@?$_Arithmetic_traits@M@std@@2HB
; public: static int const std::_Arithmetic_traits<float>::_Rank
?_Rank@?$_Arithmetic_traits@M@std@@2HB dd 7
					; DATA XREF: .rdata:int	const std::_Locbase<int>::allo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 40h
		public ?_Rank@?$_Arithmetic_traits@N@std@@2HB
; public: static int const std::_Arithmetic_traits<double>::_Rank
?_Rank@?$_Arithmetic_traits@N@std@@2HB dd 8
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::lefto
					; .rdata:std::_Iosb<int>::_Openmode const std::_Iosb<int>::_Nocreateo ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 44h
		public ?_Rank@?$_Arithmetic_traits@O@std@@2HB
; public: static int const std::_Arithmetic_traits<long	double>::_Rank
?_Rank@?$_Arithmetic_traits@O@std@@2HB dd 9
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 48h
		public ?collate@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::collate
?collate@?$_Locbase@H@std@@2HB dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4Ch
		public ?ctype@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::ctype
?ctype@?$_Locbase@H@std@@2HB dd	2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 50h
		public ?monetary@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::monetary
?monetary@?$_Locbase@H@std@@2HB	dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 54h
		public ?numeric@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::numeric
?numeric@?$_Locbase@H@std@@2HB dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 58h
		public ?time@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::time
?time@?$_Locbase@H@std@@2HB dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5Ch
		public ?messages@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::messages
?messages@?$_Locbase@H@std@@2HB	dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 60h
		public ?all@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::all
?all@?$_Locbase@H@std@@2HB dd offset ?_Rank@?$_Arithmetic_traits@M@std@@2HB+3
					; DATA XREF: .text:000084F8o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 64h
		public ?none@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::none
?none@?$_Locbase@H@std@@2HB dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 68h
		public ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::skipws
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6Ch
		public ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::unitbuf
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 70h
		public ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::uppercase
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 74h
		public ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showbase
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 78h
		public ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showpoint
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 7Ch
		public ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showpos
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 80h
		public ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::left
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::righto
					; .rdata:std::_Iosb<int>::_Openmode const std::_Iosb<int>::_Noreplaceo
_rdata		ends			; int const std::_Arithmetic_traits<double>::_Rank

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 84h
		public ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::right
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B	dd offset ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B ; std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::left
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 88h
		public ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::internal
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset _cache
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8Ch
		public ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::dec
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	locret_200
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 90h
		public ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::oct
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_3FF+1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 94h
		public ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::hex
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_800
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 98h
		public ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::scientific
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd	offset loc_1000
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 9Ch
		public ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::fixed
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B	dd offset loc_1FFC+4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A0h
		public ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::hexfloat
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_3000
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A4h
		public ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::boolalpha
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ??_R3StringEnumeration@icu_56@@8 ; icu_56::StringEnumeration::`RTTI Class	Hierarchy Descriptor'
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A8h
		public ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::_Stdio
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset locret_8000
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0ACh
		public ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::adjustfield
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_1C0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B0h
		public ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::basefield
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_DFF+1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B4h
		public ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::floatfield
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd	offset loc_3000
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B8h
		public ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::goodbit
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0BCh
		public ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::eofbit
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B	dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C0h
		public ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::failbit
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C4h
		public ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::badbit
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B	dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C8h
		public ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::_Hardfail
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0CCh
		public ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::in
?in@?$_Iosb@H@std@@2W4_Openmode@12@B dd	1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D0h
		public ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::out
?out@?$_Iosb@H@std@@2W4_Openmode@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D4h
		public ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::ate
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D8h
		public ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::app
?app@?$_Iosb@H@std@@2W4_Openmode@12@B dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0DCh
		public ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::trunc
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B	dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E0h
		public ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::_Nocreate
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E4h
		public ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::_Noreplace
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B dd	offset ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B ;	std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::left
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E8h
		public ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::binary
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int	const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0ECh
		public ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::beg
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F0h
		public ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::cur
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F4h
		public ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::end
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	2
_rdata		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
		assume cs:_bss
		;org 0F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
; icu_56::UInitOnce gCacheInitOnce
_gCacheInitOnce	dd 2 dup(?)		; DATA XREF: initCache(UErrorCode *)+27o
					; ures_cleanup(void):loc_89ECo
_cache		dd ?			; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::internalo
					; createCache(UErrorCode &)+1Er ...
_resbMutex	dd 2 dup(?)		; DATA XREF: entryClose(UResourceDataEntry *)+1Eo
					; entryClose(UResourceDataEntry	*)+37o	...
		db 2 dup(?)
word_10E	dw ?			; DATA XREF: .data:?__LINE__Var@?1??createCache@@YAXAAW4UErrorCode@@@Z@4JA@8166c1feo
		dd 5 dup(?)
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 124h
_gLocalesEnum	dd 2 dup(0)		; DATA XREF: _ures_openAvailableLocales_56+A2o
					; _ures_openAvailableLocales_56+B1o
		dd offset ?ures_loc_closeLocales@@YAXPAUUEnumeration@@@Z ; ures_loc_closeLocales(UEnumeration *)
		dd offset ?ures_loc_countLocales@@YAHPAUUEnumeration@@PAW4UErrorCode@@@Z ; ures_loc_countLocales(UEnumeration *,UErrorCode *)
		dd offset _uenum_unextDefault_56
		dd offset ?ures_loc_nextLocale@@YAPBDPAUUEnumeration@@PAHPAW4UErrorCode@@@Z ; ures_loc_nextLocale(UEnumeration *,int *,UErrorCode *)
		dd offset ?ures_loc_resetLocales@@YAXPAUUEnumeration@@PAW4UErrorCode@@@Z ; ures_loc_resetLocales(UEnumeration *,UErrorCode *)
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 140h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	operator new(unsigned int)
		public ??2@YAPAXI@Z
??2@YAPAXI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??2@YAPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$TMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$TMZ
		;org 178h
__RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
_rtc$TMZ	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$IMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$IMZ
		;org 17Ch
__RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
_rtc$IMZ	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 180h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl operator	delete(void *)
		public ??3@YAXPAX@Z
??3@YAXPAX@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??3@YAXPAX@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1B4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	icu_56::UMemory::operator new(unsigned int, void *)
		public ??2UMemory@icu_56@@SAPAXIPAX@Z
??2UMemory@icu_56@@SAPAXIPAX@Z proc near

var_C0		= byte ptr -0C0h
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi

loc_1C0:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::adjustfieldo
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??2UMemory@icu_56@@SAPAXIPAX@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1DCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl icu_56::UMemory::operator delete(void *)
		public ??3UMemory@icu_56@@SAXPAX0@Z
??3UMemory@icu_56@@SAXPAX0@Z proc near

var_C0		= byte ptr -0C0h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp

locret_200:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::deco
		retn
??3UMemory@icu_56@@SAXPAX0@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 204h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UMemory	& __thiscall icu_56::UMemory::operator=(class icu_56::UMemory const &)
		public ??4UMemory@icu_56@@QAEAAV01@ABV01@@Z
??4UMemory@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4UMemory@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 234h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UObject::UObject(icu_56::UObject *__hidden this)
		public ??0UObject@icu_56@@QAE@XZ
??0UObject@icu_56@@QAE@XZ proc near	; CODE XREF: icu_56::Replaceable::Replaceable(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UObject@icu_56@@6B@	; const	icu_56::UObject::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0UObject@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 26Ch
		dd offset ??_R4UObject@icu_56@@6B@ ; const icu_56::UObject::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7UObject@icu_56@@6B@
; const	icu_56::UObject::`vftable'
??_7UObject@icu_56@@6B@	dd offset ??_EUObject@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::UObject::UObject(void)+26o
					; icu_56::UObject::UObject(icu_56::UObject const &)+44o
					; icu_56::UObject::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ ;	icu_56::UObject::getDynamicClassID(void)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 278h
		public ??_R4UObject@icu_56@@6B@
; const	icu_56::UObject::`RTTI Complete	Object Locator'
??_R4UObject@icu_56@@6B@ dd 3 dup(0)	; DATA XREF: .rdata:0000026Co
		dd offset ??_R0?AVUObject@icu_56@@@8 ; icu_56::UObject `RTTI Type Descriptor'
		dd offset ??_R3UObject@icu_56@@8 ; icu_56::UObject::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 28Ch
		public ??_R0?AVUObject@icu_56@@@8
; class	icu_56::UObject	`RTTI Type Descriptor'
??_R0?AVUObject@icu_56@@@8 dd offset ??_7type_info@@6B@	; DATA XREF: .rdata$r:00000284o
					; .rdata$r:icu_56::UObject::`RTTI Base Class Descriptor	at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avuobject@ic	db '.?AVUObject@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 2ACh
		public ??_R3UObject@icu_56@@8
; icu_56::UObject::`RTTI Class Hierarchy Descriptor'
??_R3UObject@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:00000288o
					; .rdata$r:000002E0o
		dd 2
		dd offset ??_R2UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 2BCh
		public ??_R2UObject@icu_56@@8
; icu_56::UObject::`RTTI Base Class Array'
??_R2UObject@icu_56@@8 dd offset ??_R1A@?0A@EA@UObject@icu_56@@8
					; DATA XREF: .rdata$r:000002B8o
					; icu_56::UObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 2C8h
		public ??_R1A@?0A@EA@UObject@icu_56@@8
; icu_56::UObject::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UObject@icu_56@@8	dd offset ??_R0?AVUObject@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UObject::`RTTI Base Class	Array'o
					; .rdata$r:00000598o ...
					; icu_56::UObject `RTTI	Type Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UObject@icu_56@@8 ; icu_56::UObject::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 2E4h
		public ??_R13?0A@EA@UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Descriptor at (4, -1, 0, 64)'
??_R13?0A@EA@UMemory@icu_56@@8 dd offset ??_R0?AVUMemory@icu_56@@@8
					; DATA XREF: .rdata$r:000002C0o
					; .rdata$r:0000059Co ...
					; icu_56::UMemory `RTTI	Type Descriptor'
		dd 0
		dd 4, 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 300h
		public ??_R0?AVUMemory@icu_56@@@8
; class	icu_56::UMemory	`RTTI Type Descriptor'
??_R0?AVUMemory@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::UMemory::`RTTI Base Class	Descriptor at (4,-1,0,64)'o
					; .rdata$r:icu_56::UMemory::`RTTI Base Class Descriptor	at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 8
a_?avumemory@ic	db '.?AVUMemory@icu_56@@',0
		align 10h
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 320h
		public ??_R3UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Class Hierarchy Descriptor'
??_R3UMemory@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:000002FCo
					; .rdata$r:00000350o
		dd 1
		dd offset ??_R2UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 330h
		public ??_R2UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Array'
??_R2UMemory@icu_56@@8 dd offset ??_R1A@?0A@EA@UMemory@icu_56@@8
					; DATA XREF: .rdata$r:0000032Co
					; icu_56::UMemory::`RTTI Base Class Descriptor at (0,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 338h
		public ??_R1A@?0A@EA@UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UMemory@icu_56@@8	dd offset ??_R0?AVUMemory@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UMemory::`RTTI Base Class	Array'o
					; icu_56::UMemory `RTTI	Type Descriptor'
		dd 2 dup(0)
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 354h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UObject::UObject(icu_56::UObject *this, const struct icu_56::UObject *)
		public ??0UObject@icu_56@@QAE@ABV01@@Z
??0UObject@icu_56@@QAE@ABV01@@Z	proc near
					; CODE XREF: icu_56::Replaceable::Replaceable(icu_56::Replaceable const	&)+2Ap
					; icu_56::StringEnumeration::StringEnumeration(icu_56::StringEnumeration const &)+49p

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jz	short loc_38B
		mov	eax, [ebp+arg_0]
		add	eax, 4
		mov	[ebp+var_D0], eax
		jmp	short loc_395
; ---------------------------------------------------------------------------

loc_38B:				; CODE XREF: icu_56::UObject::UObject(icu_56::UObject const &)+27j
		mov	[ebp+var_D0], 0

loc_395:				; CODE XREF: icu_56::UObject::UObject(icu_56::UObject const &)+35j
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UObject@icu_56@@6B@	; const	icu_56::UObject::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??0UObject@icu_56@@QAE@ABV01@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3ACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UObject	& __thiscall icu_56::UObject::operator=(class icu_56::UObject const &)
		public ??4UObject@icu_56@@QAEAAV01@ABV01@@Z
??4UObject@icu_56@@QAEAAV01@ABV01@@Z proc near
					; CODE XREF: icu_56::Replaceable::operator=(icu_56::Replaceable	const &)+2Ap
					; icu_56::StringEnumeration::operator=(icu_56::StringEnumeration const &)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4UObject@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3DCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UObject::`scalar deleting destructor'(unsigned int)
		public ??_GUObject@icu_56@@UAEPAXI@Z
??_GUObject@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx

loc_3FF:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::octo
		mov	ecx, [ebp+var_8] ; this
		call	??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_41B
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_41B:				; CODE XREF: icu_56::UObject::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GUObject@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 434h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UObject::`vector deleting destructor'(unsigned int)
		public ??_EUObject@icu_56@@UAEPAXI@Z
??_EUObject@icu_56@@UAEPAXI@Z proc near	; DATA XREF: .rdata:const icu_56::UObject::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_495
		push	offset ??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	4
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_48D
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_48D:				; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_4B4
; ---------------------------------------------------------------------------

loc_495:				; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_4B1
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_4B1:				; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_4B4:				; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EUObject@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4CCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::Replaceable::Replaceable(icu_56::Replaceable *this,	const struct icu_56::Replaceable *)
		public ??0Replaceable@icu_56@@QAE@ABV01@@Z
??0Replaceable@icu_56@@QAE@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UObject *
		mov	ecx, [ebp+var_8] ; this
		call	??0UObject@icu_56@@QAE@ABV01@@Z	; icu_56::UObject::UObject(icu_56::UObject const &)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7Replaceable@icu_56@@6B@ ; const icu_56::Replaceable::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0Replaceable@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 520h
		dd offset ??_R4Replaceable@icu_56@@6B@ ; const icu_56::Replaceable::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7Replaceable@icu_56@@6B@
; const	icu_56::Replaceable::`vftable'
??_7Replaceable@icu_56@@6B@ dd offset ??_EReplaceable@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::Replaceable::Replaceable(icu_56::Replaceable const	&)+32o
					; icu_56::Replaceable::Replaceable(void)+2Eo
					; icu_56::Replaceable::`vector deleting	destructor'(uint)
		dd offset ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ ;	icu_56::UObject::getDynamicClassID(void)
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
		dd offset ?hasMetaData@Replaceable@icu_56@@UBECXZ ; icu_56::Replaceable::hasMetaData(void)
		dd offset ?clone@Replaceable@icu_56@@UBEPAV12@XZ ; icu_56::Replaceable::clone(void)
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 54Ch
		public ??_R4Replaceable@icu_56@@6B@
; const	icu_56::Replaceable::`RTTI Complete Object Locator'
??_R4Replaceable@icu_56@@6B@ dd	3 dup(0) ; DATA	XREF: .rdata:00000520o
		dd offset ??_R0?AVReplaceable@icu_56@@@8 ; icu_56::Replaceable `RTTI Type Descriptor'
		dd offset ??_R3Replaceable@icu_56@@8 ; icu_56::Replaceable::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 560h
		public ??_R0?AVReplaceable@icu_56@@@8
; class	icu_56::Replaceable `RTTI Type Descriptor'
??_R0?AVReplaceable@icu_56@@@8 dd offset ??_7type_info@@6B@ ; DATA XREF: .rdata$r:00000558o
					; .rdata$r:icu_56::Replaceable::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 8
a_?avreplaceabl	db '.?AVReplaceable@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 584h
		public ??_R3Replaceable@icu_56@@8
; icu_56::Replaceable::`RTTI Class Hierarchy Descriptor'
??_R3Replaceable@icu_56@@8 dd 2	dup(0)	; DATA XREF: .rdata$r:0000055Co
					; .rdata$r:000005BCo
		dd 3
		dd offset ??_R2Replaceable@icu_56@@8 ; icu_56::Replaceable::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 594h
		public ??_R2Replaceable@icu_56@@8
; icu_56::Replaceable::`RTTI Base Class	Array'
??_R2Replaceable@icu_56@@8 dd offset ??_R1A@?0A@EA@Replaceable@icu_56@@8
					; DATA XREF: .rdata$r:00000590o
					; icu_56::Replaceable::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 5A4h
		public ??_R1A@?0A@EA@Replaceable@icu_56@@8
; icu_56::Replaceable::`RTTI Base Class	Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@Replaceable@icu_56@@8 dd offset ??_R0?AVReplaceable@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::Replaceable::`RTTI Base Class Array'o
					; .rdata$r:000011D4o
					; icu_56::Replaceable `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3Replaceable@icu_56@@8 ; icu_56::Replaceable::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5C0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::Replaceable & __thiscall icu_56::Replaceable::operator=(class icu_56::Replaceable const	&)
		public ??4Replaceable@icu_56@@QAEAAV01@ABV01@@Z
??4Replaceable@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??4UObject@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::UObject::operator=(icu_56::UObject const	&)
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4Replaceable@icu_56@@QAEAAV01@ABV01@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 608h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::Replaceable::`scalar deleting destructor'(unsigned int)
		public ??_GReplaceable@icu_56@@UAEPAXI@Z
??_GReplaceable@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1Replaceable@icu_56@@UAE@XZ ;	icu_56::Replaceable::~Replaceable(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_647
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_647:				; CODE XREF: icu_56::Replaceable::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GReplaceable@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 660h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::Replaceable::`vector deleting destructor'(unsigned int)
		public ??_EReplaceable@icu_56@@UAEPAXI@Z
??_EReplaceable@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::Replaceable::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_6C1
		push	offset ??1Replaceable@icu_56@@UAE@XZ ; icu_56::Replaceable::~Replaceable(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	4
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_6B9
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_6B9:				; CODE XREF: icu_56::Replaceable::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_6E0
; ---------------------------------------------------------------------------

loc_6C1:				; CODE XREF: icu_56::Replaceable::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1Replaceable@icu_56@@UAE@XZ ;	icu_56::Replaceable::~Replaceable(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_6DD
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_6DD:				; CODE XREF: icu_56::Replaceable::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_6E0:				; CODE XREF: icu_56::Replaceable::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EReplaceable@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::Replaceable::Replaceable(icu_56::Replaceable *__hidden this)
		public ??0Replaceable@icu_56@@IAE@XZ
??0Replaceable@icu_56@@IAE@XZ proc near	; CODE XREF: icu_56::UnicodeString::UnicodeString(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7Replaceable@icu_56@@6B@ ; const icu_56::Replaceable::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0Replaceable@icu_56@@IAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 744h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::Replaceable::length(icu_56::Replaceable *__hidden this)
		public ?length@Replaceable@icu_56@@QBEHXZ
?length@Replaceable@icu_56@@QBEHXZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+1Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?length@Replaceable@icu_56@@QBEHXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 794h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; wchar_t __thiscall icu_56::Replaceable::charAt(icu_56::Replaceable *this, int)
		public ?charAt@Replaceable@icu_56@@QBE_WH@Z
?charAt@Replaceable@icu_56@@QBE_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+20h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?charAt@Replaceable@icu_56@@QBE_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7E8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::Replaceable::char32At(icu_56::Replaceable *this, int)
		public ?char32At@Replaceable@icu_56@@QBEHH@Z
?char32At@Replaceable@icu_56@@QBEHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'

loc_800:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::hexo
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+24h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?char32At@Replaceable@icu_56@@QBEHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 83Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::StringPiece::StringPiece(icu_56::StringPiece *__hidden this)
		public ??0StringPiece@icu_56@@QAE@XZ
??0StringPiece@icu_56@@QAE@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0StringPiece@icu_56@@QAE@XZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 87Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::StringPiece::StringPiece(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &)
		public ??0StringPiece@icu_56@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
??0StringPiece@icu_56@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0]
		call	?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::data(void)
		mov	ecx, [ebp+var_8]
		mov	[ecx], eax
		mov	ecx, [ebp+arg_0]
		call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
		mov	ecx, [ebp+var_8]
		mov	[ecx+4], eax
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0StringPiece@icu_56@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8D4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::StringPiece::StringPiece(icu_56::StringPiece *this,	const char *, int)
		public ??0StringPiece@icu_56@@QAE@PBDH@Z
??0StringPiece@icu_56@@QAE@PBDH@Z proc near
					; CODE XREF: icu_56::CharString::toStringPiece(void)+36p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		mov	[eax+4], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	8
??0StringPiece@icu_56@@QAE@PBDH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 914h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	char *__thiscall icu_56::StringPiece::data(icu_56::StringPiece *__hidden this)
		public ?data@StringPiece@icu_56@@QBEPBDXZ
?data@StringPiece@icu_56@@QBEPBDXZ proc	near
					; CODE XREF: icu_56::CharString::append(icu_56::StringPiece const &,UErrorCode &)+33p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?data@StringPiece@icu_56@@QBEPBDXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 944h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::StringPiece::size(icu_56::StringPiece *__hidden this)
		public ?size@StringPiece@icu_56@@QBEHXZ
?size@StringPiece@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?size@StringPiece@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 974h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::StringPiece::length(icu_56::StringPiece *__hidden this)
		public ?length@StringPiece@icu_56@@QBEHXZ
?length@StringPiece@icu_56@@QBEHXZ proc	near
					; CODE XREF: icu_56::CharString::append(icu_56::StringPiece const &,UErrorCode &)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?length@StringPiece@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9A4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::StringPiece::empty(icu_56::StringPiece *__hidden this)
		public ?empty@StringPiece@icu_56@@QBECXZ
?empty@StringPiece@icu_56@@QBECXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4], 0
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?empty@StringPiece@icu_56@@QBECXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9D8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::StringPiece::clear(icu_56::StringPiece *__hidden this)
		public ?clear@StringPiece@icu_56@@QAEXXZ
?clear@StringPiece@icu_56@@QAEXXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?clear@StringPiece@icu_56@@QAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A18h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::StringPiece::set(icu_56::StringPiece *this, const char *, int)
		public ?set@StringPiece@icu_56@@QAEXPBDH@Z
?set@StringPiece@icu_56@@QAEXPBDH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		mov	[eax+4], ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	8
?set@StringPiece@icu_56@@QAEXPBDH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A58h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::StringPiece::remove_prefix(icu_56::StringPiece *this,	int)
		public ?remove_prefix@StringPiece@icu_56@@QAEXH@Z
?remove_prefix@StringPiece@icu_56@@QAEXH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jl	short loc_AB1
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		cmp	ecx, [eax+4]
		jle	short loc_A95
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	[ebp+arg_0], ecx

loc_A95:				; CODE XREF: icu_56::StringPiece::remove_prefix(int)+32j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		add	ecx, [ebp+arg_0]
		mov	edx, [ebp+var_8]
		mov	[edx], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		sub	ecx, [ebp+arg_0]
		mov	edx, [ebp+var_8]
		mov	[edx+4], ecx

loc_AB1:				; CODE XREF: icu_56::StringPiece::remove_prefix(int)+27j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?remove_prefix@StringPiece@icu_56@@QAEXH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0ABCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::StringPiece::remove_suffix(icu_56::StringPiece *this,	int)
		public ?remove_suffix@StringPiece@icu_56@@QAEXH@Z
?remove_suffix@StringPiece@icu_56@@QAEXH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jl	short loc_B0B
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		cmp	ecx, [eax+4]
		jg	short loc_B01
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		sub	ecx, [ebp+arg_0]
		mov	edx, [ebp+var_8]
		mov	[edx+4], ecx
		jmp	short loc_B0B
; ---------------------------------------------------------------------------

loc_B01:				; CODE XREF: icu_56::StringPiece::remove_suffix(int)+32j
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0

loc_B0B:				; CODE XREF: icu_56::StringPiece::remove_suffix(int)+27j
					; icu_56::StringPiece::remove_suffix(int)+43j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?remove_suffix@StringPiece@icu_56@@QAEXH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B14h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::StringPiece __thiscall icu_56::StringPiece::substr(int,	int)const
		public ?substr@StringPiece@icu_56@@QBE?AV12@HH@Z
?substr@StringPiece@icu_56@@QBE?AV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+var_8]
		push	edx		; struct icu_56::StringPiece *
		mov	ecx, [ebp+arg_0] ; this
		call	??0StringPiece@icu_56@@QAE@ABV01@HH@Z ;	icu_56::StringPiece::StringPiece(icu_56::StringPiece const &,int,int)
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?substr@StringPiece@icu_56@@QBE?AV12@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B64h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::StringPiece & __thiscall icu_56::StringPiece::operator=(class icu_56::StringPiece const	&)
		public ??4StringPiece@icu_56@@QAEAAV01@ABV01@@Z
??4StringPiece@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [eax+4]
		mov	eax, [ebp+var_8]
		mov	[eax], ecx
		mov	[eax+4], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4StringPiece@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0BA4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::ByteSink::ByteSink(icu_56::ByteSink	*__hidden this)
		public ??0ByteSink@icu_56@@QAE@XZ
??0ByteSink@icu_56@@QAE@XZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7ByteSink@icu_56@@6B@ ; const icu_56::ByteSink::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0ByteSink@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0BDCh
		dd offset ??_R4ByteSink@icu_56@@6B@ ; const icu_56::ByteSink::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7ByteSink@icu_56@@6B@
; const	icu_56::ByteSink::`vftable'
??_7ByteSink@icu_56@@6B@ dd offset ??_EByteSink@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::ByteSink::ByteSink(void)+26o
					; icu_56::ByteSink::`vector deleting destructor'(uint)
		dd offset __purecall
		dd offset ?GetAppendBuffer@ByteSink@icu_56@@UAEPADHHPADHPAH@Z ;	icu_56::ByteSink::GetAppendBuffer(int,int,char *,int,int *)
		dd offset ?Flush@ByteSink@icu_56@@UAEXXZ ; icu_56::ByteSink::Flush(void)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0BF0h
		public ??_R4ByteSink@icu_56@@6B@
; const	icu_56::ByteSink::`RTTI	Complete Object	Locator'
??_R4ByteSink@icu_56@@6B@ dd 3 dup(0)	; DATA XREF: .rdata:00000BDCo
		dd offset ??_R0?AVByteSink@icu_56@@@8 ;	icu_56::ByteSink `RTTI Type Descriptor'
		dd offset ??_R3ByteSink@icu_56@@8 ; icu_56::ByteSink::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 0C04h
		public ??_R0?AVByteSink@icu_56@@@8
; class	icu_56::ByteSink `RTTI Type Descriptor'
??_R0?AVByteSink@icu_56@@@8 dd offset ??_7type_info@@6B@ ; DATA	XREF: .rdata$r:00000BFCo
					; .rdata$r:icu_56::ByteSink::`RTTI Base	Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avbytesink@i	db '.?AVByteSink@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0C24h
		public ??_R3ByteSink@icu_56@@8
; icu_56::ByteSink::`RTTI Class	Hierarchy Descriptor'
??_R3ByteSink@icu_56@@8	dd 2 dup(0)	; DATA XREF: .rdata$r:00000C00o
					; .rdata$r:00000C58o
		dd 2
		dd offset ??_R2ByteSink@icu_56@@8 ; icu_56::ByteSink::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0C34h
		public ??_R2ByteSink@icu_56@@8
; icu_56::ByteSink::`RTTI Base Class Array'
??_R2ByteSink@icu_56@@8	dd offset ??_R1A@?0A@EA@ByteSink@icu_56@@8
					; DATA XREF: .rdata$r:00000C30o
					; icu_56::ByteSink::`RTTI Base Class Descriptor	at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0C40h
		public ??_R1A@?0A@EA@ByteSink@icu_56@@8
; icu_56::ByteSink::`RTTI Base Class Descriptor	at (0, -1, 0, 64)'
??_R1A@?0A@EA@ByteSink@icu_56@@8 dd offset ??_R0?AVByteSink@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::ByteSink::`RTTI Base Class Array'o
					; icu_56::ByteSink `RTTI Type Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3ByteSink@icu_56@@8 ; icu_56::ByteSink::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C5Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::ByteSink::`scalar deleting destructor'(unsigned int)
		public ??_GByteSink@icu_56@@UAEPAXI@Z
??_GByteSink@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1ByteSink@icu_56@@UAE@XZ ; icu_56::ByteSink::~ByteSink(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_C9B
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_C9B:				; CODE XREF: icu_56::ByteSink::`scalar deleting	destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GByteSink@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0CB4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::ByteSink::`vector deleting destructor'(unsigned int)
		public ??_EByteSink@icu_56@@UAEPAXI@Z
??_EByteSink@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::ByteSink::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_D15
		push	offset ??1ByteSink@icu_56@@UAE@XZ ; icu_56::ByteSink::~ByteSink(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	4
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_D0D
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_D0D:				; CODE XREF: icu_56::ByteSink::`vector deleting	destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_D34
; ---------------------------------------------------------------------------

loc_D15:				; CODE XREF: icu_56::ByteSink::`vector deleting	destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1ByteSink@icu_56@@UAE@XZ ; icu_56::ByteSink::~ByteSink(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_D31
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_D31:				; CODE XREF: icu_56::ByteSink::`vector deleting	destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_D34:				; CODE XREF: icu_56::ByteSink::`vector deleting	destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EByteSink@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D4Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::CheckedArrayByteSink::NumberOfBytesWritten(icu_56::CheckedArrayByteSink *__hidden this)
		public ?NumberOfBytesWritten@CheckedArrayByteSink@icu_56@@QBEHXZ
?NumberOfBytesWritten@CheckedArrayByteSink@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+0Ch]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?NumberOfBytesWritten@CheckedArrayByteSink@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D7Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::CheckedArrayByteSink::Overflowed(icu_56::CheckedArrayByteSink *__hidden this)
		public ?Overflowed@CheckedArrayByteSink@icu_56@@QBECXZ
?Overflowed@CheckedArrayByteSink@icu_56@@QBECXZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	al, [eax+14h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?Overflowed@CheckedArrayByteSink@icu_56@@QBECXZ	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0DACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::CheckedArrayByteSink::NumberOfBytesAppended(icu_56::CheckedArrayByteSink *__hidden this)
		public ?NumberOfBytesAppended@CheckedArrayByteSink@icu_56@@QBEHXZ
?NumberOfBytesAppended@CheckedArrayByteSink@icu_56@@QBEHXZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+10h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?NumberOfBytesAppended@CheckedArrayByteSink@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0DDCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator=(struct	icu_56::UnicodeString *)
		public ??4UnicodeString@icu_56@@QAEAAV01@$$QAV01@@Z
??4UnicodeString@icu_56@@QAEAAV01@$$QAV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx

loc_DFF:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::basefieldo
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?moveFrom@UnicodeString@icu_56@@QAEAAV12@AAV12@@Z ; icu_56::UnicodeString::moveFrom(icu_56::UnicodeString &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4UnicodeString@icu_56@@QAEAAV01@$$QAV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0E24h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl icu_56::swap(icu_56 *this, struct icu_56::UnicodeString *, struct icu_56::UnicodeString *)
		public ?swap@icu_56@@YAXAAVUnicodeString@1@0@Z
?swap@icu_56@@YAXAAVUnicodeString@1@0@Z	proc near

var_C0		= byte ptr -0C0h
this		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+this]	; this
		call	?swap@UnicodeString@icu_56@@QAEXAAV12@@Z ; icu_56::UnicodeString::swap(icu_56::UnicodeString &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?swap@icu_56@@YAXAAVUnicodeString@1@0@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0E64h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UnicodeString::`scalar deleting destructor'(unsigned int)
		public ??_GUnicodeString@icu_56@@UAEPAXI@Z
??_GUnicodeString@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_EA3
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_EA3:				; CODE XREF: icu_56::UnicodeString::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GUnicodeString@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0EBCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UnicodeString::`vector deleting destructor'(unsigned int)
		public ??_EUnicodeString@icu_56@@UAEPAXI@Z
??_EUnicodeString@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::UnicodeString::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_F1D
		push	offset ??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	40h ; '@'
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_F15
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_F15:				; CODE XREF: icu_56::UnicodeString::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_F3C
; ---------------------------------------------------------------------------

loc_F1D:				; CODE XREF: icu_56::UnicodeString::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_F39
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_F39:				; CODE XREF: icu_56::UnicodeString::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_F3C:				; CODE XREF: icu_56::UnicodeString::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EUnicodeString@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0F54h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::pinIndex(icu_56::UnicodeString	*this, int *)
		public ?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z
?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z proc near
					; CODE XREF: icu_56::UnicodeString::indexOf(icu_56::UnicodeString const	&,int)+2Ap
					; icu_56::UnicodeString::indexOf(wchar_t const *,int,int)+2Ap ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax], 0
		jge	short loc_F8A
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 0
		jmp	short loc_FA6
; ---------------------------------------------------------------------------

loc_F8A:				; CODE XREF: icu_56::UnicodeString::pinIndex(int &)+29j
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	ecx, [ebp+arg_0]
		cmp	[ecx], eax
		jle	short loc_FA6
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	ecx, [ebp+arg_0]
		mov	[ecx], eax

loc_FA6:				; CODE XREF: icu_56::UnicodeString::pinIndex(int &)+34j
					; icu_56::UnicodeString::pinIndex(int &)+43j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0FBCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::pinIndices(icu_56::UnicodeString *this, int *,	int *)
		public ?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z
?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z proc near
					; CODE XREF: icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+51p
					; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)+51p ...

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax], 0
		jge	short loc_FFD
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 0
		jmp	short loc_100F
; ---------------------------------------------------------------------------

loc_FFD:				; CODE XREF: icu_56::UnicodeString::pinIndices(int &,int &)+34j
		mov	eax, [ebp+arg_0]

loc_1000:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::scientifico
		mov	ecx, [eax]
		cmp	ecx, [ebp+var_14]
		jle	short loc_100F
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		mov	[eax], ecx

loc_100F:				; CODE XREF: icu_56::UnicodeString::pinIndices(int &,int &)+3Fj
					; icu_56::UnicodeString::pinIndices(int	&,int &)+49j
		mov	eax, [ebp+arg_4]
		cmp	dword ptr [eax], 0
		jge	short loc_1022
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0
		jmp	short loc_103E
; ---------------------------------------------------------------------------

loc_1022:				; CODE XREF: icu_56::UnicodeString::pinIndices(int &,int &)+59j
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		sub	ecx, [eax]
		mov	edx, [ebp+arg_4]
		cmp	[edx], ecx
		jle	short loc_103E
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		sub	ecx, [eax]
		mov	edx, [ebp+arg_4]
		mov	[edx], ecx

loc_103E:				; CODE XREF: icu_56::UnicodeString::pinIndices(int &,int &)+64j
					; icu_56::UnicodeString::pinIndices(int	&,int &)+73j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1054h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; wchar_t *__thiscall icu_56::UnicodeString::getArrayStart(icu_56::UnicodeString *__hidden this)
		public ?getArrayStart@UnicodeString@icu_56@@AAEPA_WXZ
?getArrayStart@UnicodeString@icu_56@@AAEPA_WXZ proc near

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 2
		jz	short loc_1091
		mov	edx, [ebp+var_8]
		add	edx, 6
		mov	[ebp+var_D0], edx
		jmp	short loc_109D
; ---------------------------------------------------------------------------

loc_1091:				; CODE XREF: icu_56::UnicodeString::getArrayStart(void)+2Dj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	[ebp+var_D0], ecx

loc_109D:				; CODE XREF: icu_56::UnicodeString::getArrayStart(void)+3Bj
		mov	eax, [ebp+var_D0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getArrayStart@UnicodeString@icu_56@@AAEPA_WXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 10ACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	wchar_t	*__thiscall icu_56::UnicodeString::getArrayStart(icu_56::UnicodeString *__hidden this)
		public ?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ
?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ proc near
					; CODE XREF: icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+61p
					; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)+61p ...

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 2
		jz	short loc_10E9
		mov	edx, [ebp+var_8]
		add	edx, 6
		mov	[ebp+var_D0], edx
		jmp	short loc_10F5
; ---------------------------------------------------------------------------

loc_10E9:				; CODE XREF: icu_56::UnicodeString::getArrayStart(void)+2Dj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	[ebp+var_D0], ecx

loc_10F5:				; CODE XREF: icu_56::UnicodeString::getArrayStart(void)+3Bj
		mov	eax, [ebp+var_D0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1104h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString *__hidden this)
		public ??0UnicodeString@icu_56@@QAE@XZ
??0UnicodeString@icu_56@@QAE@XZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??0Replaceable@icu_56@@IAE@XZ ;	icu_56::Replaceable::Replaceable(void)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UnicodeString@icu_56@@6B@ ;	const icu_56::UnicodeString::`vftable'
		mov	eax, 2
		mov	ecx, [ebp+var_8]
		mov	[ecx+4], ax
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0UnicodeString@icu_56@@QAE@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 115Ch
		dd offset ??_R4UnicodeString@icu_56@@6B@ ; const icu_56::UnicodeString::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7UnicodeString@icu_56@@6B@
; const	icu_56::UnicodeString::`vftable'
??_7UnicodeString@icu_56@@6B@ dd offset	??_EUnicodeString@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::UnicodeString::UnicodeString(void)+2Eo
					; icu_56::UnicodeString::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@UnicodeString@icu_56@@UBEPAXXZ ; icu_56::UnicodeString::getDynamicClassID(void)
		dd offset ?extractBetween@UnicodeString@icu_56@@UBEXHHAAV12@@Z ; icu_56::UnicodeString::extractBetween(int,int,icu_56::UnicodeString &)
		dd offset ?handleReplaceBetween@UnicodeString@icu_56@@UAEXHHABV12@@Z ; icu_56::UnicodeString::handleReplaceBetween(int,int,icu_56::UnicodeString const &)
		dd offset ?copy@UnicodeString@icu_56@@UAEXHHH@Z	; icu_56::UnicodeString::copy(int,int,int)
		dd offset ?hasMetaData@UnicodeString@icu_56@@UBECXZ ; icu_56::UnicodeString::hasMetaData(void)
		dd offset ?clone@UnicodeString@icu_56@@UBEPAVReplaceable@2@XZ ;	icu_56::UnicodeString::clone(void)
		dd offset ?getLength@UnicodeString@icu_56@@MBEHXZ ; icu_56::UnicodeString::getLength(void)
		dd offset ?getCharAt@UnicodeString@icu_56@@MBE_WH@Z ; icu_56::UnicodeString::getCharAt(int)
		dd offset ?getChar32At@UnicodeString@icu_56@@MBEHH@Z ; icu_56::UnicodeString::getChar32At(int)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1188h
		public ??_R4UnicodeString@icu_56@@6B@
; const	icu_56::UnicodeString::`RTTI Complete Object Locator'
??_R4UnicodeString@icu_56@@6B@ dd 3 dup(0) ; DATA XREF:	.rdata:0000115Co
		dd offset ??_R0?AVUnicodeString@icu_56@@@8 ; icu_56::UnicodeString `RTTI Type Descriptor'
		dd offset ??_R3UnicodeString@icu_56@@8 ; icu_56::UnicodeString::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 119Ch
		public ??_R0?AVUnicodeString@icu_56@@@8
; class	icu_56::UnicodeString `RTTI Type Descriptor'
??_R0?AVUnicodeString@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:00001194o
					; .rdata$r:icu_56::UnicodeString::`RTTI	Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avunicodestr	db '.?AVUnicodeString@icu_56@@',0
		align 10h
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 11C0h
		public ??_R3UnicodeString@icu_56@@8
; icu_56::UnicodeString::`RTTI Class Hierarchy Descriptor'
??_R3UnicodeString@icu_56@@8 dd	2 dup(0) ; DATA	XREF: .rdata$r:00001198o
					; .rdata$r:000011FCo
		dd 4
		dd offset ??_R2UnicodeString@icu_56@@8 ; icu_56::UnicodeString::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 11D0h
		public ??_R2UnicodeString@icu_56@@8
; icu_56::UnicodeString::`RTTI Base Class Array'
??_R2UnicodeString@icu_56@@8 dd	offset ??_R1A@?0A@EA@UnicodeString@icu_56@@8
					; DATA XREF: .rdata$r:000011CCo
					; icu_56::UnicodeString::`RTTI Base Class Descriptor at	(0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@Replaceable@icu_56@@8 ;	icu_56::Replaceable::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 11E4h
		public ??_R1A@?0A@EA@UnicodeString@icu_56@@8
; icu_56::UnicodeString::`RTTI Base Class Descriptor at	(0, -1,	0, 64)'
??_R1A@?0A@EA@UnicodeString@icu_56@@8 dd offset	??_R0?AVUnicodeString@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UnicodeString::`RTTI Base	Class Array'o
					; icu_56::UnicodeString	`RTTI Type Descriptor'
		dd 3, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UnicodeString@icu_56@@8 ; icu_56::UnicodeString::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1200h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::hasShortLength(icu_56::UnicodeString *__hidden this)
		public ?hasShortLength@UnicodeString@icu_56@@ABECXZ
?hasShortLength@UnicodeString@icu_56@@ABECXZ proc near
					; CODE XREF: icu_56::UnicodeString::length(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		test	ecx, ecx
		setnl	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?hasShortLength@UnicodeString@icu_56@@ABECXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1238h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::getShortLength(icu_56::UnicodeString *__hidden this)
		public ?getShortLength@UnicodeString@icu_56@@ABEHXZ
?getShortLength@UnicodeString@icu_56@@ABEHXZ proc near
					; CODE XREF: icu_56::UnicodeString::length(void)+35p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	eax, word ptr [eax+4]
		sar	eax, 5
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getShortLength@UnicodeString@icu_56@@ABEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 126Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::length(icu_56::UnicodeString *__hidden this)
		public ?length@UnicodeString@icu_56@@QBEHXZ
?length@UnicodeString@icu_56@@QBEHXZ proc near
					; CODE XREF: icu_56::UnicodeString::pinIndex(int &)+39p
					; icu_56::UnicodeString::pinIndex(int &)+48p ...

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?hasShortLength@UnicodeString@icu_56@@ABECXZ ; icu_56::UnicodeString::hasShortLength(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_12AE
		mov	ecx, [ebp+var_8] ; this
		call	?getShortLength@UnicodeString@icu_56@@ABEHXZ ; icu_56::UnicodeString::getShortLength(void)
		mov	[ebp+var_D0], eax
		jmp	short loc_12BA
; ---------------------------------------------------------------------------

loc_12AE:				; CODE XREF: icu_56::UnicodeString::length(void)+30j
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+8]
		mov	[ebp+var_D0], edx

loc_12BA:				; CODE XREF: icu_56::UnicodeString::length(void)+40j
		mov	eax, [ebp+var_D0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?length@UnicodeString@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 12D4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::getCapacity(icu_56::UnicodeString *__hidden this)
		public ?getCapacity@UnicodeString@icu_56@@QBEHXZ
?getCapacity@UnicodeString@icu_56@@QBEHXZ proc near

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 2
		jz	short loc_130F
		mov	[ebp+var_D0], 1Dh
		jmp	short loc_131B
; ---------------------------------------------------------------------------

loc_130F:				; CODE XREF: icu_56::UnicodeString::getCapacity(void)+2Dj
		mov	edx, [ebp+var_8]
		mov	eax, [edx+0Ch]
		mov	[ebp+var_D0], eax

loc_131B:				; CODE XREF: icu_56::UnicodeString::getCapacity(void)+39j
		mov	eax, [ebp+var_D0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getCapacity@UnicodeString@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1328h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::hashCode(icu_56::UnicodeString *__hidden this)
		public ?hashCode@UnicodeString@icu_56@@QBEHXZ
?hashCode@UnicodeString@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?doHashCode@UnicodeString@icu_56@@ABEHXZ ; icu_56::UnicodeString::doHashCode(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?hashCode@UnicodeString@icu_56@@QBEHXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1368h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::isBogus(icu_56::UnicodeString	*__hidden this)
		public ?isBogus@UnicodeString@icu_56@@QBECXZ
?isBogus@UnicodeString@icu_56@@QBECXZ proc near
					; CODE XREF: icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+26p
					; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+35p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	eax, word ptr [eax+4]
		and	eax, 1
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isBogus@UnicodeString@icu_56@@QBECXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 139Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::isWritable(icu_56::UnicodeString *__hidden this)
		public ?isWritable@UnicodeString@icu_56@@ABECXZ
?isWritable@UnicodeString@icu_56@@ABECXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 11h
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isWritable@UnicodeString@icu_56@@ABECXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 13D4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::isBufferWritable(icu_56::UnicodeString *__hidden this)
		public ?isBufferWritable@UnicodeString@icu_56@@ABECXZ
?isBufferWritable@UnicodeString@icu_56@@ABECXZ proc near

var_D0		= byte ptr -0D0h
var_CD		= byte ptr -0CDh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 19h
		jnz	short loc_1425
		mov	edx, [ebp+var_8]
		movsx	eax, word ptr [edx+4]
		and	eax, 4
		jz	short loc_141C
		mov	ecx, [ebp+var_8] ; this
		call	?refCount@UnicodeString@icu_56@@ABEHXZ ; icu_56::UnicodeString::refCount(void)
		cmp	eax, 1
		jnz	short loc_1425

loc_141C:				; CODE XREF: icu_56::UnicodeString::isBufferWritable(void)+39j
		mov	[ebp+var_CD], 1
		jmp	short loc_142C
; ---------------------------------------------------------------------------

loc_1425:				; CODE XREF: icu_56::UnicodeString::isBufferWritable(void)+2Dj
					; icu_56::UnicodeString::isBufferWritable(void)+46j
		mov	[ebp+var_CD], 0

loc_142C:				; CODE XREF: icu_56::UnicodeString::isBufferWritable(void)+4Fj
		mov	al, [ebp+var_CD]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?isBufferWritable@UnicodeString@icu_56@@ABECXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1448h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	wchar_t	*__thiscall icu_56::UnicodeString::getBuffer(icu_56::UnicodeString *__hidden this)
		public ?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ
?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 11h
		jz	short loc_147D
		xor	eax, eax
		jmp	short loc_1499
; ---------------------------------------------------------------------------
		jmp	short loc_1499
; ---------------------------------------------------------------------------

loc_147D:				; CODE XREF: icu_56::UnicodeString::getBuffer(void)+2Dj
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 2
		jz	short loc_1493
		mov	eax, [ebp+var_8]
		add	eax, 6
		jmp	short loc_1499
; ---------------------------------------------------------------------------
		jmp	short loc_1499
; ---------------------------------------------------------------------------

loc_1493:				; CODE XREF: icu_56::UnicodeString::getBuffer(void)+3Fj
		mov	eax, [ebp+var_8]
		mov	eax, [eax+10h]

loc_1499:				; CODE XREF: icu_56::UnicodeString::getBuffer(void)+31j
					; icu_56::UnicodeString::getBuffer(void)+33j ...
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 14A0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::doCompare(icu_56::UnicodeString *this, int, int, const struct	icu_56::UnicodeString *, int, int)
		public ?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z
?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z proc near
					; CODE XREF: icu_56::UnicodeString::operator>(icu_56::UnicodeString const &)+40p
					; icu_56::UnicodeString::operator<(icu_56::UnicodeString const &)+40p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_14E6
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		setz	al
		jmp	short loc_1517
; ---------------------------------------------------------------------------
		jmp	short loc_1517
; ---------------------------------------------------------------------------

loc_14E6:				; CODE XREF: icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+30j
		lea	eax, [ebp+arg_10]
		push	eax		; int *
		lea	ecx, [ebp+arg_C]
		push	ecx		; int *
		mov	ecx, [ebp+arg_8] ; this
		call	?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z ; icu_56::UnicodeString::pinIndices(int &,int &)
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	ecx, [ebp+arg_8] ; this
		call	?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ ; icu_56::UnicodeString::getArrayStart(void)
		push	eax		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)

loc_1517:				; CODE XREF: icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+42j
					; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+44j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1530h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator==(icu_56::UnicodeString	*)
		public ??8UnicodeString@icu_56@@QBECABV01@@Z
??8UnicodeString@icu_56@@QBECABV01@@Z proc near
					; CODE XREF: icu_56::UnicodeString::operator!=(icu_56::UnicodeString const &)+2Ap

var_E8		= byte ptr -0E8h
var_E5		= byte ptr -0E5h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E8]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_156E
		mov	ecx, [ebp+arg_0] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		jmp	short loc_15C8
; ---------------------------------------------------------------------------
		jmp	short loc_15C8
; ---------------------------------------------------------------------------

loc_156E:				; CODE XREF: icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)+30j
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	[ebp+var_14], eax
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	[ebp+var_20], eax
		mov	ecx, [ebp+arg_0] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_15BB
		mov	ecx, [ebp+var_14]
		cmp	ecx, [ebp+var_20]
		jnz	short loc_15BB
		mov	edx, [ebp+var_14]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?doEquals@UnicodeString@icu_56@@ABECABV12@H@Z ;	icu_56::UnicodeString::doEquals(icu_56::UnicodeString const &,int)
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_15BB
		mov	[ebp+var_E5], 1
		jmp	short loc_15C2
; ---------------------------------------------------------------------------

loc_15BB:				; CODE XREF: icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)+61j
					; icu_56::UnicodeString::operator==(icu_56::UnicodeString const	&)+69j	...
		mov	[ebp+var_E5], 0

loc_15C2:				; CODE XREF: icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)+89j
		mov	al, [ebp+var_E5]

loc_15C8:				; CODE XREF: icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)+3Aj
					; icu_56::UnicodeString::operator==(icu_56::UnicodeString const	&)+3Cj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??8UnicodeString@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 15E0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator!=(icu_56::UnicodeString	*)
		public ??9UnicodeString@icu_56@@QBECABV01@@Z
??9UnicodeString@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; icu_56::UnicodeString	*
		mov	ecx, [ebp+var_8]
		call	??8UnicodeString@icu_56@@QBECABV01@@Z ;	icu_56::UnicodeString::operator==(icu_56::UnicodeString	const &)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9UnicodeString@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1630h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator>(icu_56::UnicodeString *)
		public ??OUnicodeString@icu_56@@QBECABV01@@Z
??OUnicodeString@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		cmp	ecx, 1
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??OUnicodeString@icu_56@@QBECABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1694h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator<(icu_56::UnicodeString *)
		public ??MUnicodeString@icu_56@@QBECABV01@@Z
??MUnicodeString@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		cmp	ecx, 0FFFFFFFFh
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??MUnicodeString@icu_56@@QBECABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 16F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator>=(icu_56::UnicodeString	*)
		public ??PUnicodeString@icu_56@@QBECABV01@@Z
??PUnicodeString@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		cmp	ecx, 0FFFFFFFFh
		setnz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??PUnicodeString@icu_56@@QBECABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 175Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator<=(icu_56::UnicodeString	*)
		public ??NUnicodeString@icu_56@@QBECABV01@@Z
??NUnicodeString@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		cmp	ecx, 1
		setnz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??NUnicodeString@icu_56@@QBECABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 17C0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compare(icu_56::UnicodeString	*this, const struct icu_56::UnicodeString *)
		public ?compare@UnicodeString@icu_56@@QBECABV12@@Z
?compare@UnicodeString@icu_56@@QBECABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?compare@UnicodeString@icu_56@@QBECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 181Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compare(icu_56::UnicodeString	*this, int, int, const struct icu_56::UnicodeString *)
		public ?compare@UnicodeString@icu_56@@QBECHHABV12@@Z
?compare@UnicodeString@icu_56@@QBECHHABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?compare@UnicodeString@icu_56@@QBECHHABV12@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1874h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compare(icu_56::UnicodeString	*this, const wchar_t *,	int)
		public ?compare@UnicodeString@icu_56@@QBECPB_WH@Z
?compare@UnicodeString@icu_56@@QBECPB_WH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?compare@UnicodeString@icu_56@@QBECPB_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 18CCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compare(icu_56::UnicodeString	*this, int, int, const struct icu_56::UnicodeString *, int, int)
		public ?compare@UnicodeString@icu_56@@QBECHHABV12@HH@Z
?compare@UnicodeString@icu_56@@QBECHHABV12@HH@Z	proc near
					; CODE XREF: icu_56::UnicodeString::startsWith(icu_56::UnicodeString const &)+40p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?compare@UnicodeString@icu_56@@QBECHHABV12@HH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1924h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compare(icu_56::UnicodeString	*this, int, int, const wchar_t *)
		public ?compare@UnicodeString@icu_56@@QBECHHPB_W@Z
?compare@UnicodeString@icu_56@@QBECHHPB_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?compare@UnicodeString@icu_56@@QBECHHPB_W@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1978h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compare(icu_56::UnicodeString	*this, int, int, const wchar_t *, int, int)
		public ?compare@UnicodeString@icu_56@@QBECHHPB_WHH@Z
?compare@UnicodeString@icu_56@@QBECHHPB_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?compare@UnicodeString@icu_56@@QBECHHPB_WHH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 19D0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareBetween(icu_56::UnicodeString *this, int, int,	const struct icu_56::UnicodeString *, int, int)
		public ?compareBetween@UnicodeString@icu_56@@QBECHHABV12@HH@Z
?compareBetween@UnicodeString@icu_56@@QBECHHABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		sub	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_4]
		sub	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?compareBetween@UnicodeString@icu_56@@QBECHHABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1A2Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::doCompareCodePointOrder(icu_56::UnicodeString	*this, int, int, const struct icu_56::UnicodeString *, int, int)
		public ?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z
?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z	proc near
					; CODE XREF: icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString	const &)+40p
					; icu_56::UnicodeString::compareCodePointOrder(int,int,icu_56::UnicodeString const &)+3Dp ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_1A72
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		setz	al
		jmp	short loc_1AA3
; ---------------------------------------------------------------------------
		jmp	short loc_1AA3
; ---------------------------------------------------------------------------

loc_1A72:				; CODE XREF: icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const	&,int,int)+30j
		lea	eax, [ebp+arg_10]
		push	eax		; int *
		lea	ecx, [ebp+arg_C]
		push	ecx		; int *
		mov	ecx, [ebp+arg_8] ; this
		call	?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z ; icu_56::UnicodeString::pinIndices(int &,int &)
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	ecx, [ebp+arg_8] ; this
		call	?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ ; icu_56::UnicodeString::getArrayStart(void)
		push	eax		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHPB_WHH@Z ;	icu_56::UnicodeString::doCompareCodePointOrder(int,int,wchar_t const *,int,int)

loc_1AA3:				; CODE XREF: icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const	&,int,int)+42j
					; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)+44j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1ABCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*)
		public ?compareCodePointOrder@UnicodeString@icu_56@@QBECABV12@@Z
?compareCodePointOrder@UnicodeString@icu_56@@QBECABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z	; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?compareCodePointOrder@UnicodeString@icu_56@@QBECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1B18h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString *this, int, int, const struct icu_56::UnicodeString *)
		public ?compareCodePointOrder@UnicodeString@icu_56@@QBECHHABV12@@Z
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z	; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHABV12@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1B70h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString *this, const wchar_t *, int)
		public ?compareCodePointOrder@UnicodeString@icu_56@@QBECPB_WH@Z
?compareCodePointOrder@UnicodeString@icu_56@@QBECPB_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHPB_WHH@Z ;	icu_56::UnicodeString::doCompareCodePointOrder(int,int,wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?compareCodePointOrder@UnicodeString@icu_56@@QBECPB_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1BC8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString *this, int, int, const struct icu_56::UnicodeString *, int, int)
		public ?compareCodePointOrder@UnicodeString@icu_56@@QBECHHABV12@HH@Z
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z	; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1C20h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString *this, int, int, const wchar_t *)
		public ?compareCodePointOrder@UnicodeString@icu_56@@QBECHHPB_W@Z
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHPB_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHPB_WHH@Z ;	icu_56::UnicodeString::doCompareCodePointOrder(int,int,wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHPB_W@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1C74h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString *this, int, int, const wchar_t *,	int, int)
		public ?compareCodePointOrder@UnicodeString@icu_56@@QBECHHPB_WHH@Z
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHPB_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHPB_WHH@Z ;	icu_56::UnicodeString::doCompareCodePointOrder(int,int,wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHPB_WHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1CCCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrderBetween(icu_56::UnicodeString *this, int, int, const struct icu_56::UnicodeString *, int, int)
		public ?compareCodePointOrderBetween@UnicodeString@icu_56@@QBECHHABV12@HH@Z
?compareCodePointOrderBetween@UnicodeString@icu_56@@QBECHHABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		sub	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_4]
		sub	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z	; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?compareCodePointOrderBetween@UnicodeString@icu_56@@QBECHHABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1D28h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::doCaseCompare(icu_56::UnicodeString *this, int, int, const struct icu_56::UnicodeString *, int, int, unsigned	int)
		public ?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z
?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z proc near
					; CODE XREF: icu_56::UnicodeString::caseCompare(icu_56::UnicodeString const &,uint)+44p
					; icu_56::UnicodeString::caseCompare(int,int,icu_56::UnicodeString const &,uint)+41p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_1D6E
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		setz	al
		jmp	short loc_1DA3
; ---------------------------------------------------------------------------
		jmp	short loc_1DA3
; ---------------------------------------------------------------------------

loc_1D6E:				; CODE XREF: icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString	const &,int,int,uint)+30j
		lea	eax, [ebp+arg_10]
		push	eax		; int *
		lea	ecx, [ebp+arg_C]
		push	ecx		; int *
		mov	ecx, [ebp+arg_8] ; this
		call	?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z ; icu_56::UnicodeString::pinIndices(int &,int &)
		mov	eax, [ebp+arg_14]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_10]
		push	ecx		; int
		mov	edx, [ebp+arg_C]
		push	edx		; int
		mov	ecx, [ebp+arg_8] ; this
		call	?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ ; icu_56::UnicodeString::getArrayStart(void)
		push	eax		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHPB_WHHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,wchar_t const *,int,int,uint)

loc_1DA3:				; CODE XREF: icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString	const &,int,int,uint)+42j
					; icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString const &,int,int,uint)+44j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	18h
?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1DBCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompare(icu_56::UnicodeString *this, const struct	icu_56::UnicodeString *, unsigned int)
		public ?caseCompare@UnicodeString@icu_56@@QBECABV12@I@Z
?caseCompare@UnicodeString@icu_56@@QBECABV12@I@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString const &,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?caseCompare@UnicodeString@icu_56@@QBECABV12@I@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1E1Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompare(icu_56::UnicodeString *this, int,	int, const struct icu_56::UnicodeString	*, unsigned int)
		public ?caseCompare@UnicodeString@icu_56@@QBECHHABV12@I@Z
?caseCompare@UnicodeString@icu_56@@QBECHHABV12@I@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct icu_56::UnicodeString *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString const &,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?caseCompare@UnicodeString@icu_56@@QBECHHABV12@I@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1E78h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompare(icu_56::UnicodeString *this, const wchar_t *, int, unsigned int)
		public ?caseCompare@UnicodeString@icu_56@@QBECPB_WHI@Z
?caseCompare@UnicodeString@icu_56@@QBECPB_WHI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHPB_WHHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,wchar_t const *,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?caseCompare@UnicodeString@icu_56@@QBECPB_WHI@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1ED4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompare(icu_56::UnicodeString *this, int,	int, const struct icu_56::UnicodeString	*, int,	int, unsigned int)
		public ?caseCompare@UnicodeString@icu_56@@QBECHHABV12@HHI@Z
?caseCompare@UnicodeString@icu_56@@QBECHHABV12@HHI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_14]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_10]
		push	ecx		; int
		mov	edx, [ebp+arg_C]
		push	edx		; int
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString const &,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	18h
?caseCompare@UnicodeString@icu_56@@QBECHHABV12@HHI@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1F30h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompare(icu_56::UnicodeString *this, int,	int, const wchar_t *, unsigned int)
		public ?caseCompare@UnicodeString@icu_56@@QBECHHPB_WI@Z
?caseCompare@UnicodeString@icu_56@@QBECHHPB_WI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		push	0		; int
		mov	edx, [ebp+arg_8]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHPB_WHHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,wchar_t const *,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?caseCompare@UnicodeString@icu_56@@QBECHHPB_WI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1F88h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompare(icu_56::UnicodeString *this, int,	int, const wchar_t *, int, int,	unsigned int)
		public ?caseCompare@UnicodeString@icu_56@@QBECHHPB_WHHI@Z
?caseCompare@UnicodeString@icu_56@@QBECHHPB_WHHI@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_14]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_10]
		push	ecx		; int
		mov	edx, [ebp+arg_C]
		push	edx		; int
		mov	eax, [ebp+arg_8]
		push	eax		; wchar_t *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHPB_WHHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,wchar_t const *,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	18h
?caseCompare@UnicodeString@icu_56@@QBECHHPB_WHHI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1FE4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompareBetween(icu_56::UnicodeString *this, int, int, const struct icu_56::UnicodeString *, int, int, unsigned int)
		public ?caseCompareBetween@UnicodeString@icu_56@@QBECHHABV12@HHI@Z
?caseCompareBetween@UnicodeString@icu_56@@QBECHHABV12@HHI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'

loc_1FFC:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::fixedo
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_14]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_10]
		sub	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_C]
		push	edx		; int
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		sub	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString const &,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	18h
?caseCompareBetween@UnicodeString@icu_56@@QBECHHABV12@HHI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2044h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*, int,	int, int, int)
		public ?indexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z
?indexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z	proc near
					; CODE XREF: icu_56::UnicodeString::indexOf(icu_56::UnicodeString const	&)+40p
					; icu_56::UnicodeString::indexOf(icu_56::UnicodeString const &,int)+51p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_20AF
		lea	eax, [ebp+arg_8]
		push	eax		; int *
		lea	ecx, [ebp+arg_4]
		push	ecx		; int *
		mov	ecx, [ebp+arg_0] ; this
		call	?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z ; icu_56::UnicodeString::pinIndices(int &,int &)
		cmp	[ebp+arg_8], 0
		jle	short loc_20AF
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ ; icu_56::UnicodeString::getArrayStart(void)
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z ;	icu_56::UnicodeString::indexOf(wchar_t const *,int,int,int,int)
		jmp	short loc_20B2
; ---------------------------------------------------------------------------

loc_20AF:				; CODE XREF: icu_56::UnicodeString::indexOf(icu_56::UnicodeString const	&,int,int,int,int)+30j
					; icu_56::UnicodeString::indexOf(icu_56::UnicodeString const &,int,int,int,int)+46j
		or	eax, 0FFFFFFFFh

loc_20B2:				; CODE XREF: icu_56::UnicodeString::indexOf(icu_56::UnicodeString const	&,int,int,int,int)+69j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?indexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 20C8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*)
		public ?indexOf@UnicodeString@icu_56@@QBEHABV12@@Z
?indexOf@UnicodeString@icu_56@@QBEHABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z	; icu_56::UnicodeString::indexOf(icu_56::UnicodeString const &,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?indexOf@UnicodeString@icu_56@@QBEHABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2124h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*, int)
		public ?indexOf@UnicodeString@icu_56@@QBEHABV12@H@Z
?indexOf@UnicodeString@icu_56@@QBEHABV12@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z	; icu_56::UnicodeString::indexOf(icu_56::UnicodeString const &,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?indexOf@UnicodeString@icu_56@@QBEHABV12@H@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2190h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*, int,	int)
		public ?indexOf@UnicodeString@icu_56@@QBEHABV12@HH@Z
?indexOf@UnicodeString@icu_56@@QBEHABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z	; icu_56::UnicodeString::indexOf(icu_56::UnicodeString const &,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?indexOf@UnicodeString@icu_56@@QBEHABV12@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 21E8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, const wchar_t *, int, int)
		public ?indexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z
?indexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_8]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_8]
		push	eax		; int
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z ;	icu_56::UnicodeString::indexOf(wchar_t const *,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?indexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2250h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, const wchar_t *, int, int,	int)
		public ?indexOf@UnicodeString@icu_56@@QBEHPB_WHHH@Z
?indexOf@UnicodeString@icu_56@@QBEHPB_WHHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+arg_4]
		push	edx		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z ;	icu_56::UnicodeString::indexOf(wchar_t const *,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?indexOf@UnicodeString@icu_56@@QBEHPB_WHHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 22A4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, wchar_t, int, int)
		public ?indexOf@UnicodeString@icu_56@@QBEH_WHH@Z
?indexOf@UnicodeString@icu_56@@QBEH_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		movzx	edx, [ebp+arg_0]
		push	edx		; wchar_t
		mov	ecx, [ebp+var_8] ; this
		call	?doIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z ; icu_56::UnicodeString::doIndexOf(wchar_t,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?indexOf@UnicodeString@icu_56@@QBEH_WHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 22F4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, int, int, int)
		public ?indexOf@UnicodeString@icu_56@@QBEHHHH@Z
?indexOf@UnicodeString@icu_56@@QBEHHHH@Z proc near
					; CODE XREF: icu_56::UnicodeString::indexOf(int)+35p
					; icu_56::UnicodeString::indexOf(int,int)+46p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doIndexOf@UnicodeString@icu_56@@ABEHHHH@Z ; icu_56::UnicodeString::doIndexOf(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?indexOf@UnicodeString@icu_56@@QBEHHHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2344h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, wchar_t)
		public ?indexOf@UnicodeString@icu_56@@QBEH_W@Z
?indexOf@UnicodeString@icu_56@@QBEH_W@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		movzx	eax, [ebp+arg_0]
		push	eax		; wchar_t
		mov	ecx, [ebp+var_8] ; this
		call	?doIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z ; icu_56::UnicodeString::doIndexOf(wchar_t,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?indexOf@UnicodeString@icu_56@@QBEH_W@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2398h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, int)
		public ?indexOf@UnicodeString@icu_56@@QBEHH@Z
?indexOf@UnicodeString@icu_56@@QBEHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHHHH@Z ; icu_56::UnicodeString::indexOf(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?indexOf@UnicodeString@icu_56@@QBEHH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 23E8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, wchar_t, int)
		public ?indexOf@UnicodeString@icu_56@@QBEH_WH@Z
?indexOf@UnicodeString@icu_56@@QBEH_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		movzx	ecx, [ebp+arg_0]
		push	ecx		; wchar_t
		mov	ecx, [ebp+var_8] ; this
		call	?doIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z ; icu_56::UnicodeString::doIndexOf(wchar_t,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?indexOf@UnicodeString@icu_56@@QBEH_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 244Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, int, int)
		public ?indexOf@UnicodeString@icu_56@@QBEHHH@Z
?indexOf@UnicodeString@icu_56@@QBEHHH@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHHHH@Z ; icu_56::UnicodeString::indexOf(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?indexOf@UnicodeString@icu_56@@QBEHHH@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 24B0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, const wchar_t *, int, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+arg_4]
		push	edx		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z ; icu_56::UnicodeString::lastIndexOf(wchar_t const *,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2504h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, const wchar_t *, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_8]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_8]
		push	eax		; int
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z ; icu_56::UnicodeString::lastIndexOf(wchar_t const *,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 256Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *, int, int, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z proc near
					; CODE XREF: icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int)+3Dp
					; icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int)+51p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_25D7
		lea	eax, [ebp+arg_8]
		push	eax		; int *
		lea	ecx, [ebp+arg_4]
		push	ecx		; int *
		mov	ecx, [ebp+arg_0] ; this
		call	?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z ; icu_56::UnicodeString::pinIndices(int &,int &)
		cmp	[ebp+arg_8], 0
		jle	short loc_25D7
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ ; icu_56::UnicodeString::getArrayStart(void)
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z ; icu_56::UnicodeString::lastIndexOf(wchar_t const *,int,int,int,int)
		jmp	short loc_25DA
; ---------------------------------------------------------------------------

loc_25D7:				; CODE XREF: icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int,int,int)+30j
					; icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int,int,int)+46j
		or	eax, 0FFFFFFFFh

loc_25DA:				; CODE XREF: icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int,int,int)+69j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 25F0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z ; icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2648h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@H@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z ; icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@H@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 26B4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z ; icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2710h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, wchar_t, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEH_WHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEH_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		movzx	edx, [ebp+arg_0]
		push	edx		; wchar_t
		mov	ecx, [ebp+var_8] ; this
		call	?doLastIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z	; icu_56::UnicodeString::doLastIndexOf(wchar_t,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?lastIndexOf@UnicodeString@icu_56@@QBEH_WHH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2760h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, int, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHHHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHHHH@Z proc near
					; CODE XREF: icu_56::UnicodeString::lastIndexOf(int)+35p
					; icu_56::UnicodeString::lastIndexOf(int,int)+46p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doLastIndexOf@UnicodeString@icu_56@@ABEHHHH@Z ; icu_56::UnicodeString::doLastIndexOf(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?lastIndexOf@UnicodeString@icu_56@@QBEHHHH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 27B0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, wchar_t)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEH_W@Z
?lastIndexOf@UnicodeString@icu_56@@QBEH_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		movzx	eax, [ebp+arg_0]
		push	eax		; wchar_t
		mov	ecx, [ebp+var_8] ; this
		call	?doLastIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z	; icu_56::UnicodeString::doLastIndexOf(wchar_t,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?lastIndexOf@UnicodeString@icu_56@@QBEH_W@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2804h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHHHH@Z ; icu_56::UnicodeString::lastIndexOf(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?lastIndexOf@UnicodeString@icu_56@@QBEHH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2854h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, wchar_t, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEH_WH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEH_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		movzx	ecx, [ebp+arg_0]
		push	ecx		; wchar_t
		mov	ecx, [ebp+var_8] ; this
		call	?doLastIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z	; icu_56::UnicodeString::doLastIndexOf(wchar_t,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?lastIndexOf@UnicodeString@icu_56@@QBEH_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 28B8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHHHH@Z ; icu_56::UnicodeString::lastIndexOf(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?lastIndexOf@UnicodeString@icu_56@@QBEHHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 291Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::startsWith(icu_56::UnicodeString *this, const	struct icu_56::UnicodeString *)
		public ?startsWith@UnicodeString@icu_56@@QBECABV12@@Z
?startsWith@UnicodeString@icu_56@@QBECABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?compare@UnicodeString@icu_56@@QBECHHABV12@HH@Z	; icu_56::UnicodeString::compare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?startsWith@UnicodeString@icu_56@@QBECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2980h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::startsWith(icu_56::UnicodeString *this, const	struct icu_56::UnicodeString *,	int, int)
		public ?startsWith@UnicodeString@icu_56@@QBECABV12@HH@Z
?startsWith@UnicodeString@icu_56@@QBECABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_8]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?startsWith@UnicodeString@icu_56@@QBECABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 29DCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::startsWith(icu_56::UnicodeString *this, const	wchar_t	*, int)
		public ?startsWith@UnicodeString@icu_56@@QBECPB_WH@Z
?startsWith@UnicodeString@icu_56@@QBECPB_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_4], 0
		jge	short loc_2A14
		mov	eax, [ebp+arg_0]
		push	eax
		call	_u_strlen_56
		add	esp, 4
		mov	[ebp+arg_4], eax

loc_2A14:				; CODE XREF: icu_56::UnicodeString::startsWith(wchar_t const *,int)+27j
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		movsx	eax, al
		test	eax, eax
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?startsWith@UnicodeString@icu_56@@QBECPB_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2A4Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::startsWith(icu_56::UnicodeString *this, const	wchar_t	*, int,	int)
		public ?startsWith@UnicodeString@icu_56@@QBECPB_WHH@Z
?startsWith@UnicodeString@icu_56@@QBECPB_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_8], 0
		jge	short loc_2A84
		mov	eax, [ebp+arg_0]
		push	eax
		call	_u_strlen_56
		add	esp, 4
		mov	[ebp+arg_8], eax

loc_2A84:				; CODE XREF: icu_56::UnicodeString::startsWith(wchar_t const *,int,int)+27j
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_8]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?startsWith@UnicodeString@icu_56@@QBECPB_WHH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2ABCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::endsWith(icu_56::UnicodeString *this,	const struct icu_56::UnicodeString *)
		public ?endsWith@UnicodeString@icu_56@@QBECABV12@@Z
?endsWith@UnicodeString@icu_56@@QBECABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	esi, eax
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	esi, eax
		push	esi		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?endsWith@UnicodeString@icu_56@@QBECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2B34h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::endsWith(icu_56::UnicodeString *this,	const struct icu_56::UnicodeString *, int, int)
		public ?endsWith@UnicodeString@icu_56@@QBECABV12@HH@Z
?endsWith@UnicodeString@icu_56@@QBECABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_8]
		push	eax		; int *
		lea	ecx, [ebp+arg_4]
		push	ecx		; int *
		mov	ecx, [ebp+arg_0] ; this
		call	?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z ; icu_56::UnicodeString::pinIndices(int &,int &)
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?endsWith@UnicodeString@icu_56@@QBECABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2BACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::endsWith(icu_56::UnicodeString *this,	const wchar_t *, int)
		public ?endsWith@UnicodeString@icu_56@@QBECPB_WH@Z
?endsWith@UnicodeString@icu_56@@QBECPB_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_4], 0
		jge	short loc_2BE4
		mov	eax, [ebp+arg_0]
		push	eax
		call	_u_strlen_56
		add	esp, 4
		mov	[ebp+arg_4], eax

loc_2BE4:				; CODE XREF: icu_56::UnicodeString::endsWith(wchar_t const *,int)+27j
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		movsx	eax, al
		test	eax, eax
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?endsWith@UnicodeString@icu_56@@QBECPB_WH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2C24h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::endsWith(icu_56::UnicodeString *this,	const wchar_t *, int, int)
		public ?endsWith@UnicodeString@icu_56@@QBECPB_WHH@Z
?endsWith@UnicodeString@icu_56@@QBECPB_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_8], 0
		jge	short loc_2C62
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+arg_0]
		lea	edx, [ecx+eax*2]
		push	edx
		call	_u_strlen_56
		add	esp, 4
		mov	[ebp+arg_8], eax

loc_2C62:				; CODE XREF: icu_56::UnicodeString::endsWith(wchar_t const *,int,int)+27j
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?endsWith@UnicodeString@icu_56@@QBECPB_WHH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2CA4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replace(icu_56::UnicodeString	*this, int, int, const struct icu_56::UnicodeString *)
		public ?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@@Z
?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2CFCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replace(icu_56::UnicodeString	*this, int, int, const struct icu_56::UnicodeString *, int, int)
		public ?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z
?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z proc near
					; CODE XREF: icu_56::UnicodeString::doExtract(int,int,icu_56::UnicodeString &)+3Dp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2D54h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replace(icu_56::UnicodeString	*this, int, int, const wchar_t *, int)
		public ?replace@UnicodeString@icu_56@@QAEAAV12@HHPB_WH@Z
?replace@UnicodeString@icu_56@@QAEAAV12@HHPB_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?replace@UnicodeString@icu_56@@QAEAAV12@HHPB_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2DA8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replace(icu_56::UnicodeString	*this, int, int, const wchar_t *, int, int)
		public ?replace@UnicodeString@icu_56@@QAEAAV12@HHPB_WHH@Z
?replace@UnicodeString@icu_56@@QAEAAV12@HHPB_WHH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?replace@UnicodeString@icu_56@@QAEAAV12@HHPB_WHH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2E00h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replace(icu_56::UnicodeString	*this, int, int, wchar_t)
		public ?replace@UnicodeString@icu_56@@QAEAAV12@HH_W@Z
?replace@UnicodeString@icu_56@@QAEAAV12@HH_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= word ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	1		; int
		push	0		; int
		lea	eax, [ebp+arg_8]
		push	eax		; wchar_t *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?replace@UnicodeString@icu_56@@QAEAAV12@HH_W@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2E54h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replaceBetween(icu_56::UnicodeString *this, int, int,	const struct icu_56::UnicodeString *)
		public ?replaceBetween@UnicodeString@icu_56@@QAEAAV12@HHABV12@@Z
?replaceBetween@UnicodeString@icu_56@@QAEAAV12@HHABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		sub	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?replaceBetween@UnicodeString@icu_56@@QAEAAV12@HHABV12@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2EB0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replaceBetween(icu_56::UnicodeString *this, int, int,	const struct icu_56::UnicodeString *, int, int)
		public ?replaceBetween@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z
?replaceBetween@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		sub	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_4]
		sub	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?replaceBetween@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2F0Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::findAndReplace(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *, const struct icu_56::UnicodeString *)
		public ?findAndReplace@UnicodeString@icu_56@@QAEAAV12@ABV12@0@Z
?findAndReplace@UnicodeString@icu_56@@QAEAAV12@ABV12@0@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_4] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_4]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?findAndReplace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH0HH@Z ; icu_56::UnicodeString::findAndReplace(int,int,icu_56::UnicodeString const &,int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?findAndReplace@UnicodeString@icu_56@@QAEAAV12@ABV12@0@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2F78h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::findAndReplace(icu_56::UnicodeString *this, int, int,	const struct icu_56::UnicodeString *, const struct icu_56::UnicodeString *)
		public ?findAndReplace@UnicodeString@icu_56@@QAEAAV12@HHABV12@0@Z
?findAndReplace@UnicodeString@icu_56@@QAEAAV12@HHABV12@0@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_C] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_C]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct icu_56::UnicodeString *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?findAndReplace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH0HH@Z ; icu_56::UnicodeString::findAndReplace(int,int,icu_56::UnicodeString const &,int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?findAndReplace@UnicodeString@icu_56@@QAEAAV12@HHABV12@0@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2FE0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::doExtract(icu_56::UnicodeString *this,	int, int, struct icu_56::UnicodeString *)
		public ?doExtract@UnicodeString@icu_56@@ABEXHHAAV12@@Z
?doExtract@UnicodeString@icu_56@@ABEXHHAAV12@@Z	proc near
					; CODE XREF: icu_56::UnicodeString::extract(int,int,icu_56::UnicodeString &)+32p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx

loc_3000:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::hexfloato
					; .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::floatfieldo
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	edx, [ebp+var_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_8] ; this
		call	?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::replace(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?doExtract@UnicodeString@icu_56@@ABEXHHAAV12@@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3038h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::extract(icu_56::UnicodeString *this, int, int,	wchar_t	*, int)
		public ?extract@UnicodeString@icu_56@@QBEXHHPA_WH@Z
?extract@UnicodeString@icu_56@@QBEXHHPA_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doExtract@UnicodeString@icu_56@@ABEXHHPA_WH@Z ; icu_56::UnicodeString::doExtract(int,int,wchar_t *,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?extract@UnicodeString@icu_56@@QBEXHHPA_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 308Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::extract(icu_56::UnicodeString *this, int, int,	struct icu_56::UnicodeString *)
		public ?extract@UnicodeString@icu_56@@QBEXHHAAV12@@Z
?extract@UnicodeString@icu_56@@QBEXHHAAV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doExtract@UnicodeString@icu_56@@ABEXHHAAV12@@Z	; icu_56::UnicodeString::doExtract(int,int,icu_56::UnicodeString &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?extract@UnicodeString@icu_56@@QBEXHHAAV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 30DCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::extract(icu_56::UnicodeString *this, int, int, char *, const char *)
		public ?extract@UnicodeString@icu_56@@QBEHHHPADPBD@Z
?extract@UnicodeString@icu_56@@QBEHHHPADPBD@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; char *
		mov	ecx, [ebp+arg_8]
		neg	ecx
		sbb	ecx, ecx
		push	ecx		; unsigned int
		mov	edx, [ebp+arg_8]
		push	edx		; char *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?extract@UnicodeString@icu_56@@QBEHHHPADIPBD@Z ; icu_56::UnicodeString::extract(int,int,char *,uint,char const *)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?extract@UnicodeString@icu_56@@QBEHHHPADPBD@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3138h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::extractBetween(icu_56::UnicodeString *this, int, int, wchar_t *, int)
		public ?extractBetween@UnicodeString@icu_56@@QBEXHHPA_WH@Z
?extractBetween@UnicodeString@icu_56@@QBEXHHPA_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_0]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		sub	edx, [ebp+arg_0]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doExtract@UnicodeString@icu_56@@ABEXHHPA_WH@Z ; icu_56::UnicodeString::doExtract(int,int,wchar_t *,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?extractBetween@UnicodeString@icu_56@@QBEXHHPA_WH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 31A4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeString __thiscall icu_56::UnicodeString::tempSubStringBetween(int, int)const
		public ?tempSubStringBetween@UnicodeString@icu_56@@QBE?AV12@HH@Z
?tempSubStringBetween@UnicodeString@icu_56@@QBE?AV12@HH@Z proc near

var_D8		= byte ptr -0D8h
var_D4		= dword	ptr -0D4h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_D4], 0
		mov	eax, [ebp+arg_8]
		sub	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		mov	ecx, [ebp+var_8]
		call	?tempSubString@UnicodeString@icu_56@@QBE?AV12@HH@Z ; icu_56::UnicodeString::tempSubString(int,int)
		mov	eax, [ebp+var_D4]
		or	eax, 1
		mov	[ebp+var_D4], eax
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?tempSubStringBetween@UnicodeString@icu_56@@QBE?AV12@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3210h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; wchar_t __thiscall icu_56::UnicodeString::doCharAt(icu_56::UnicodeString *this, int)
		public ?doCharAt@UnicodeString@icu_56@@ABE_WH@Z
?doCharAt@UnicodeString@icu_56@@ABE_WH@Z proc near
					; CODE XREF: icu_56::UnicodeString::charAt(int)+2Ap
					; icu_56::UnicodeString::operator[](int)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		cmp	[ebp+arg_0], eax
		jnb	short loc_3253
		mov	ecx, [ebp+var_8] ; this
		call	?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ ; icu_56::UnicodeString::getArrayStart(void)
		mov	ecx, [ebp+arg_0]
		mov	ax, [eax+ecx*2]
		jmp	short loc_3258
; ---------------------------------------------------------------------------
		jmp	short loc_3258
; ---------------------------------------------------------------------------

loc_3253:				; CODE XREF: icu_56::UnicodeString::doCharAt(int)+2Ej
		mov	eax, 0FFFFh

loc_3258:				; CODE XREF: icu_56::UnicodeString::doCharAt(int)+3Fj
					; icu_56::UnicodeString::doCharAt(int)+41j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?doCharAt@UnicodeString@icu_56@@ABE_WH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3270h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; wchar_t __thiscall icu_56::UnicodeString::charAt(icu_56::UnicodeString *this,	int)
		public ?charAt@UnicodeString@icu_56@@QBE_WH@Z
?charAt@UnicodeString@icu_56@@QBE_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCharAt@UnicodeString@icu_56@@ABE_WH@Z ; icu_56::UnicodeString::doCharAt(int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?charAt@UnicodeString@icu_56@@QBE_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 32B8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: wchar_t __thiscall icu_56::UnicodeString::operator[](int)const
		public ??AUnicodeString@icu_56@@QBE_WH@Z
??AUnicodeString@icu_56@@QBE_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCharAt@UnicodeString@icu_56@@ABE_WH@Z ; icu_56::UnicodeString::doCharAt(int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??AUnicodeString@icu_56@@QBE_WH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3300h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::isEmpty(icu_56::UnicodeString	*__hidden this)
		public ?isEmpty@UnicodeString@icu_56@@QBECXZ
?isEmpty@UnicodeString@icu_56@@QBECXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		sar	ecx, 5
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isEmpty@UnicodeString@icu_56@@QBECXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 333Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::setZeroLength(icu_56::UnicodeString *__hidden this)
		public ?setZeroLength@UnicodeString@icu_56@@AAEXXZ
?setZeroLength@UnicodeString@icu_56@@AAEXXZ proc near
					; CODE XREF: icu_56::UnicodeString::remove(void)+3Fp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 1Fh
		mov	edx, [ebp+var_8]
		mov	[edx+4], cx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?setZeroLength@UnicodeString@icu_56@@AAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3378h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::setShortLength(icu_56::UnicodeString *this, int)
		public ?setShortLength@UnicodeString@icu_56@@AAEXH@Z
?setShortLength@UnicodeString@icu_56@@AAEXH@Z proc near
					; CODE XREF: icu_56::UnicodeString::setLength(int)+33p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 1Fh
		mov	edx, [ebp+arg_0]
		shl	edx, 5
		or	ecx, edx
		mov	eax, [ebp+var_8]
		mov	[eax+4], cx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?setShortLength@UnicodeString@icu_56@@AAEXH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 33C0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::setLength(icu_56::UnicodeString *this,	int)
		public ?setLength@UnicodeString@icu_56@@AAEXH@Z
?setLength@UnicodeString@icu_56@@AAEXH@Z proc near
					; CODE XREF: icu_56::UnicodeString::setArray(wchar_t *,int,int)+2Ap
					; icu_56::UnicodeString::truncate(int)+5Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 3FFh
		jg	short loc_33FA
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?setShortLength@UnicodeString@icu_56@@AAEXH@Z ;	icu_56::UnicodeString::setShortLength(int)
		jmp	short loc_3417
; ---------------------------------------------------------------------------

loc_33FA:				; CODE XREF: icu_56::UnicodeString::setLength(int)+2Aj
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		or	ecx, 0FFE0h
		mov	edx, [ebp+var_8]
		mov	[edx+4], cx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+8], ecx

loc_3417:				; CODE XREF: icu_56::UnicodeString::setLength(int)+38j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setLength@UnicodeString@icu_56@@AAEXH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3430h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::setToEmpty(icu_56::UnicodeString *__hidden this)
		public ?setToEmpty@UnicodeString@icu_56@@AAEXXZ
?setToEmpty@UnicodeString@icu_56@@AAEXXZ proc near
					; CODE XREF: icu_56::UnicodeString::remove(void)+35p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, 2
		mov	ecx, [ebp+var_8]
		mov	[ecx+4], ax
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?setToEmpty@UnicodeString@icu_56@@AAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3468h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::setArray(icu_56::UnicodeString	*this, wchar_t *, int, int)
		public ?setArray@UnicodeString@icu_56@@AAEXPA_WHH@Z
?setArray@UnicodeString@icu_56@@AAEXPA_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?setLength@UnicodeString@icu_56@@AAEXH@Z ; icu_56::UnicodeString::setLength(int)
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+10h], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_8]
		mov	[eax+0Ch], ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?setArray@UnicodeString@icu_56@@AAEXPA_WHH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 34C0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator=(wchar_t)
		public ??4UnicodeString@icu_56@@QAEAAV01@_W@Z
??4UnicodeString@icu_56@@QAEAAV01@_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	1		; int
		push	0		; int
		lea	eax, [ebp+arg_0]
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4UnicodeString@icu_56@@QAEAAV01@_W@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3514h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeString &	__thiscall icu_56::UnicodeString::operator=(int)
		public ??4UnicodeString@icu_56@@QAEAAV01@H@Z
??4UnicodeString@icu_56@@QAEAAV01@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?replace@UnicodeString@icu_56@@QAEAAV12@HHH@Z ;	icu_56::UnicodeString::replace(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4UnicodeString@icu_56@@QAEAAV01@H@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3564h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*, int,	int)
		public ?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z
?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?unBogus@UnicodeString@icu_56@@AAEXXZ ;	icu_56::UnicodeString::unBogus(void)
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 35C4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*, int)
		public ?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@H@Z
?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@H@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?unBogus@UnicodeString@icu_56@@AAEXXZ ;	icu_56::UnicodeString::unBogus(void)
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+arg_0] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@H@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3638h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*)
		public ?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z
?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	0		; signed __int8
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?copyFrom@UnicodeString@icu_56@@AAEAAV12@ABV12@C@Z ; icu_56::UnicodeString::copyFrom(icu_56::UnicodeString const &,signed char)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3680h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *this, const wchar_t *, int)
		public ?setTo@UnicodeString@icu_56@@QAEAAV12@PB_WH@Z
?setTo@UnicodeString@icu_56@@QAEAAV12@PB_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?unBogus@UnicodeString@icu_56@@AAEXXZ ;	icu_56::UnicodeString::unBogus(void)
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?setTo@UnicodeString@icu_56@@QAEAAV12@PB_WH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 36E0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *this, wchar_t)
		public ?setTo@UnicodeString@icu_56@@QAEAAV12@_W@Z
?setTo@UnicodeString@icu_56@@QAEAAV12@_W@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?unBogus@UnicodeString@icu_56@@AAEXXZ ;	icu_56::UnicodeString::unBogus(void)
		push	1		; int
		push	0		; int
		lea	eax, [ebp+arg_0]
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setTo@UnicodeString@icu_56@@QAEAAV12@_W@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 373Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *this, int)
		public ?setTo@UnicodeString@icu_56@@QAEAAV12@H@Z
?setTo@UnicodeString@icu_56@@QAEAAV12@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?unBogus@UnicodeString@icu_56@@AAEXXZ ;	icu_56::UnicodeString::unBogus(void)
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?replace@UnicodeString@icu_56@@QAEAAV12@HHH@Z ;	icu_56::UnicodeString::replace(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setTo@UnicodeString@icu_56@@QAEAAV12@H@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3794h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *, int, int)
		public ?append@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z
?append@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@ABV12@HH@Z ; icu_56::UnicodeString::doAppend(icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?append@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 37E4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *)
		public ?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z
?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@ABV12@HH@Z ; icu_56::UnicodeString::doAppend(icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3834h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *this, const wchar_t *, int, int)
		public ?append@UnicodeString@icu_56@@QAEAAV12@PB_WHH@Z
?append@UnicodeString@icu_56@@QAEAAV12@PB_WHH@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@PB_WHH@Z ; icu_56::UnicodeString::doAppend(wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?append@UnicodeString@icu_56@@QAEAAV12@PB_WHH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3884h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *this, const wchar_t *, int)
		public ?append@UnicodeString@icu_56@@QAEAAV12@PB_WH@Z
?append@UnicodeString@icu_56@@QAEAAV12@PB_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@PB_WHH@Z ; icu_56::UnicodeString::doAppend(wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?append@UnicodeString@icu_56@@QAEAAV12@PB_WH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 38D0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *this, wchar_t)
		public ?append@UnicodeString@icu_56@@QAEAAV12@_W@Z
?append@UnicodeString@icu_56@@QAEAAV12@_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	1		; int
		push	0		; int
		lea	eax, [ebp+arg_0]
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@PB_WHH@Z ; icu_56::UnicodeString::doAppend(wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?append@UnicodeString@icu_56@@QAEAAV12@_W@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 391Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator+=(wchar_t)
		public ??YUnicodeString@icu_56@@QAEAAV01@_W@Z
??YUnicodeString@icu_56@@QAEAAV01@_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	1		; int
		push	0		; int
		lea	eax, [ebp+arg_0]
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@PB_WHH@Z ; icu_56::UnicodeString::doAppend(wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??YUnicodeString@icu_56@@QAEAAV01@_W@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3968h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeString &	__thiscall icu_56::UnicodeString::operator+=(int)
		public ??YUnicodeString@icu_56@@QAEAAV01@H@Z
??YUnicodeString@icu_56@@QAEAAV01@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?append@UnicodeString@icu_56@@QAEAAV12@H@Z ; icu_56::UnicodeString::append(int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??YUnicodeString@icu_56@@QAEAAV01@H@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 39B0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator+=(struct icu_56::UnicodeString *)
		public ??YUnicodeString@icu_56@@QAEAAV01@ABV01@@Z
??YUnicodeString@icu_56@@QAEAAV01@ABV01@@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@ABV12@HH@Z ; icu_56::UnicodeString::doAppend(icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??YUnicodeString@icu_56@@QAEAAV01@ABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3A00h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::insert(icu_56::UnicodeString *this, int, const struct	icu_56::UnicodeString *, int, int)
		public ?insert@UnicodeString@icu_56@@QAEAAV12@HABV12@HH@Z
?insert@UnicodeString@icu_56@@QAEAAV12@HABV12@HH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+arg_4]
		push	edx		; struct icu_56::UnicodeString *
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?insert@UnicodeString@icu_56@@QAEAAV12@HABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3A54h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::insert(icu_56::UnicodeString *this, int, const struct	icu_56::UnicodeString *)
		public ?insert@UnicodeString@icu_56@@QAEAAV12@HABV12@@Z
?insert@UnicodeString@icu_56@@QAEAAV12@HABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_4] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_4]
		push	eax		; struct icu_56::UnicodeString *
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?insert@UnicodeString@icu_56@@QAEAAV12@HABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3AACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::insert(icu_56::UnicodeString *this, int, const wchar_t *, int, int)
		public ?insert@UnicodeString@icu_56@@QAEAAV12@HPB_WHH@Z
?insert@UnicodeString@icu_56@@QAEAAV12@HPB_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+arg_4]
		push	edx		; wchar_t *
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?insert@UnicodeString@icu_56@@QAEAAV12@HPB_WHH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3B00h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::insert(icu_56::UnicodeString *this, int, const wchar_t *, int)
		public ?insert@UnicodeString@icu_56@@QAEAAV12@HPB_WH@Z
?insert@UnicodeString@icu_56@@QAEAAV12@HPB_WH@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; wchar_t *
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?insert@UnicodeString@icu_56@@QAEAAV12@HPB_WH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3B54h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::insert(icu_56::UnicodeString *this, int, wchar_t)
		public ?insert@UnicodeString@icu_56@@QAEAAV12@H_W@Z
?insert@UnicodeString@icu_56@@QAEAAV12@H_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= word ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	1		; int
		push	0		; int
		lea	eax, [ebp+arg_4]
		push	eax		; wchar_t *
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?insert@UnicodeString@icu_56@@QAEAAV12@H_W@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3BA4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::insert(icu_56::UnicodeString *this, int, int)
		public ?insert@UnicodeString@icu_56@@QAEAAV12@HH@Z
?insert@UnicodeString@icu_56@@QAEAAV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?replace@UnicodeString@icu_56@@QAEAAV12@HHH@Z ;	icu_56::UnicodeString::replace(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?insert@UnicodeString@icu_56@@QAEAAV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3BF0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::remove(icu_56::UnicodeString *__hidden this)
		public ?remove@UnicodeString@icu_56@@QAEAAV12@XZ
?remove@UnicodeString@icu_56@@QAEAAV12@XZ proc near
					; CODE XREF: icu_56::UnicodeString::remove(int,int)+35p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_3C2C
		mov	ecx, [ebp+var_8] ; this
		call	?setToEmpty@UnicodeString@icu_56@@AAEXXZ ; icu_56::UnicodeString::setToEmpty(void)
		jmp	short loc_3C34
; ---------------------------------------------------------------------------

loc_3C2C:				; CODE XREF: icu_56::UnicodeString::remove(void)+30j
		mov	ecx, [ebp+var_8] ; this
		call	?setZeroLength@UnicodeString@icu_56@@AAEXXZ ; icu_56::UnicodeString::setZeroLength(void)

loc_3C34:				; CODE XREF: icu_56::UnicodeString::remove(void)+3Aj
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?remove@UnicodeString@icu_56@@QAEAAV12@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3C4Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::remove(icu_56::UnicodeString *this, int, int)
		public ?remove@UnicodeString@icu_56@@QAEAAV12@HH@Z
?remove@UnicodeString@icu_56@@QAEAAV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jg	short loc_3C88
		cmp	[ebp+arg_4], 7FFFFFFFh
		jnz	short loc_3C88
		mov	ecx, [ebp+var_8] ; this
		call	?remove@UnicodeString@icu_56@@QAEAAV12@XZ ; icu_56::UnicodeString::remove(void)
		jmp	short loc_3C9E
; ---------------------------------------------------------------------------

loc_3C88:				; CODE XREF: icu_56::UnicodeString::remove(int,int)+27j
					; icu_56::UnicodeString::remove(int,int)+30j
		push	0		; int
		push	0		; int
		push	0		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)

loc_3C9E:				; CODE XREF: icu_56::UnicodeString::remove(int,int)+3Aj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?remove@UnicodeString@icu_56@@QAEAAV12@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3CB4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::removeBetween(icu_56::UnicodeString *this, int, int)
		public ?removeBetween@UnicodeString@icu_56@@QAEAAV12@HH@Z
?removeBetween@UnicodeString@icu_56@@QAEAAV12@HH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	0		; int
		push	0		; int
		push	0		; wchar_t *
		mov	eax, [ebp+arg_4]
		sub	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?removeBetween@UnicodeString@icu_56@@QAEAAV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3D08h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::retainBetween(icu_56::UnicodeString *this, int, int)
		public ?retainBetween@UnicodeString@icu_56@@QAEAAV12@HH@Z
?retainBetween@UnicodeString@icu_56@@QAEAAV12@HH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?truncate@UnicodeString@icu_56@@QAECH@Z	; icu_56::UnicodeString::truncate(int)
		push	0		; int
		push	0		; int
		push	0		; wchar_t *
		mov	eax, [ebp+arg_0]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?retainBetween@UnicodeString@icu_56@@QAEAAV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3D64h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::truncate(icu_56::UnicodeString *this,	int)
		public ?truncate@UnicodeString@icu_56@@QAECH@Z
?truncate@UnicodeString@icu_56@@QAECH@Z	proc near
					; CODE XREF: icu_56::UnicodeString::retainBetween(int,int)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_3DAA
		cmp	[ebp+arg_0], 0
		jnz	short loc_3DAA
		mov	ecx, [ebp+var_8] ; this
		call	?unBogus@UnicodeString@icu_56@@AAEXXZ ;	icu_56::UnicodeString::unBogus(void)
		xor	al, al
		jmp	short loc_3DCB
; ---------------------------------------------------------------------------
		jmp	short loc_3DCB
; ---------------------------------------------------------------------------

loc_3DAA:				; CODE XREF: icu_56::UnicodeString::truncate(int)+30j
					; icu_56::UnicodeString::truncate(int)+36j
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		cmp	[ebp+arg_0], eax
		jnb	short loc_3DC9
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?setLength@UnicodeString@icu_56@@AAEXH@Z ; icu_56::UnicodeString::setLength(int)
		mov	al, 1
		jmp	short loc_3DCB
; ---------------------------------------------------------------------------
		jmp	short loc_3DCB
; ---------------------------------------------------------------------------

loc_3DC9:				; CODE XREF: icu_56::UnicodeString::truncate(int)+51j
		xor	al, al

loc_3DCB:				; CODE XREF: icu_56::UnicodeString::truncate(int)+42j
					; icu_56::UnicodeString::truncate(int)+44j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?truncate@UnicodeString@icu_56@@QAECH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3DE4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::reverse(icu_56::UnicodeString	*__hidden this)
		public ?reverse@UnicodeString@icu_56@@QAEAAV12@XZ
?reverse@UnicodeString@icu_56@@QAEAAV12@XZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReverse@UnicodeString@icu_56@@AAEAAV12@HH@Z ; icu_56::UnicodeString::doReverse(int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?reverse@UnicodeString@icu_56@@QAEAAV12@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3E30h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::reverse(icu_56::UnicodeString	*this, int, int)
		public ?reverse@UnicodeString@icu_56@@QAEAAV12@HH@Z
?reverse@UnicodeString@icu_56@@QAEAAV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReverse@UnicodeString@icu_56@@AAEAAV12@HH@Z ; icu_56::UnicodeString::doReverse(int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?reverse@UnicodeString@icu_56@@QAEAAV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3E7Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::StringEnumeration::StringEnumeration(icu_56::StringEnumeration *this, const	struct icu_56::StringEnumeration *)
		public ??0StringEnumeration@icu_56@@QAE@ABV01@@Z
??0StringEnumeration@icu_56@@QAE@ABV01@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0StringEnumeration@icu_56@@QAE@ABV01@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UObject *
		mov	ecx, [ebp+var_14] ; this
		call	??0UObject@icu_56@@QAE@ABV01@@Z	; icu_56::UObject::UObject(icu_56::UObject const &)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7StringEnumeration@icu_56@@6B@ ; const icu_56::StringEnumeration::`vftable'
		mov	eax, [ebp+arg_0]
		add	eax, 4
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_14]
		add	ecx, 4		; this
		call	??0UnicodeString@icu_56@@QAE@ABV01@@Z ;	icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString const &)
		mov	esi, [ebp+arg_0]
		add	esi, 44h ; 'D'
		mov	edi, [ebp+var_14]
		add	edi, 44h ; 'D'
		mov	ecx, 8
		rep movsd
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+64h]
		mov	[eax+64h], edx
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+68h]
		mov	[eax+68h], edx
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0StringEnumeration@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 3F44h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0StringEnumeration@icu_56@@QAE@ABV01@@Z$0 proc near
					; DATA XREF: .xdata$x:00003F9Co
		mov	ecx, [ebp-14h]	; this
		jmp	??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
__unwindfunclet$??0StringEnumeration@icu_56@@QAE@ABV01@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0StringEnumeration@icu_56@@QAE@ABV01@@Z proc near
					; DATA XREF: icu_56::StringEnumeration::StringEnumeration(icu_56::StringEnumeration const &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0StringEnumeration@icu_56@@QAE@ABV01@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0StringEnumeration@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3F6Ch
		dd offset ??_R4StringEnumeration@icu_56@@6B@ ; const icu_56::StringEnumeration::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7StringEnumeration@icu_56@@6B@
; const	icu_56::StringEnumeration::`vftable'
??_7StringEnumeration@icu_56@@6B@ dd offset ??_EStringEnumeration@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::StringEnumeration::StringEnumeration(icu_56::StringEnumeration const &)+58o
					; icu_56::StringEnumeration::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ ;	icu_56::UObject::getDynamicClassID(void)
		dd offset ?clone@StringEnumeration@icu_56@@UBEPAV12@XZ ; icu_56::StringEnumeration::clone(void)
		dd offset __purecall
		dd offset ?next@StringEnumeration@icu_56@@UAEPBDPAHAAW4UErrorCode@@@Z ;	icu_56::StringEnumeration::next(int *,UErrorCode &)
		dd offset ?unext@StringEnumeration@icu_56@@UAEPB_WPAHAAW4UErrorCode@@@Z	; icu_56::StringEnumeration::unext(int *,UErrorCode &)
		dd offset ?snext@StringEnumeration@icu_56@@UAEPBVUnicodeString@2@AAW4UErrorCode@@@Z ; icu_56::StringEnumeration::snext(UErrorCode &)
		dd offset __purecall
		dd offset ??8StringEnumeration@icu_56@@UBECABV01@@Z ; icu_56::StringEnumeration::operator==(icu_56::StringEnumeration const &)
		dd offset ??9StringEnumeration@icu_56@@UBECABV01@@Z ; icu_56::StringEnumeration::operator!=(icu_56::StringEnumeration const &)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 3F98h
__unwindtable$??0StringEnumeration@icu_56@@QAE@ABV01@@Z	dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00003FA8o
		dd offset __unwindfunclet$??0StringEnumeration@icu_56@@QAE@ABV01@@Z$0
__ehfuncinfo$??0StringEnumeration@icu_56@@QAE@ABV01@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$??0StringEnumeration@icu_56@@QAE@ABV01@@Z+14o
		dd offset __unwindtable$??0StringEnumeration@icu_56@@QAE@ABV01@@Z
		align 20h
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 3FC4h
		public ??_R4StringEnumeration@icu_56@@6B@
; const	icu_56::StringEnumeration::`RTTI Complete Object Locator'
??_R4StringEnumeration@icu_56@@6B@ dd 3	dup(0) ; DATA XREF: .rdata:00003F6Co
		dd offset ??_R0?AVStringEnumeration@icu_56@@@8 ; icu_56::StringEnumeration `RTTI Type Descriptor'
		dd offset ??_R3StringEnumeration@icu_56@@8 ; icu_56::StringEnumeration::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 3FD8h
		public ??_R0?AVStringEnumeration@icu_56@@@8
; class	icu_56::StringEnumeration `RTTI	Type Descriptor'
??_R0?AVStringEnumeration@icu_56@@@8 dd	offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:00003FD0o
					; .rdata$r:icu_56::StringEnumeration::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 10h
a_?avstringenum	db '.?AVStringEnumeration@icu_56@@',0
		align 10h
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 4000h
		public ??_R3StringEnumeration@icu_56@@8
; icu_56::StringEnumeration::`RTTI Class Hierarchy Descriptor'
??_R3StringEnumeration@icu_56@@8 dd 2 dup(0)
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::boolalphao
					; .rdata$r:00003FD4o ...
		dd 3
		dd offset ??_R2StringEnumeration@icu_56@@8 ; icu_56::StringEnumeration::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 4010h
		public ??_R2StringEnumeration@icu_56@@8
; icu_56::StringEnumeration::`RTTI Base	Class Array'
??_R2StringEnumeration@icu_56@@8 dd offset ??_R1A@?0A@EA@StringEnumeration@icu_56@@8
					; DATA XREF: .rdata$r:0000400Co
					; icu_56::StringEnumeration::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 4020h
		public ??_R1A@?0A@EA@StringEnumeration@icu_56@@8
; icu_56::StringEnumeration::`RTTI Base	Class Descriptor at (0,	-1, 0, 64)'
??_R1A@?0A@EA@StringEnumeration@icu_56@@8 dd offset ??_R0?AVStringEnumeration@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::StringEnumeration::`RTTI Base Class Array'o
					; icu_56::StringEnumeration `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3StringEnumeration@icu_56@@8 ; icu_56::StringEnumeration::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 403Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::StringEnumeration & __thiscall icu_56::StringEnumeration::operator=(class icu_56::StringEnumeration const &)
		public ??4StringEnumeration@icu_56@@QAEAAV01@ABV01@@Z
??4StringEnumeration@icu_56@@QAEAAV01@ABV01@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??4UObject@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::UObject::operator=(icu_56::UObject const	&)
		mov	eax, [ebp+arg_0]
		add	eax, 4
		push	eax
		mov	ecx, [ebp+var_8]
		add	ecx, 4
		call	??4UnicodeString@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::UnicodeString::operator=(icu_56::UnicodeString const &)
		mov	[ebp+var_14], 0
		jmp	short loc_408F
; ---------------------------------------------------------------------------

loc_4086:				; CODE XREF: icu_56::StringEnumeration::operator=(icu_56::StringEnumeration const &)+6Bj
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_408F:				; CODE XREF: icu_56::StringEnumeration::operator=(icu_56::StringEnumeration const &)+48j
		cmp	[ebp+var_14], 20h ; ' '
		jnb	short loc_40A9
		mov	eax, [ebp+var_8]
		add	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		add	ecx, [ebp+var_14]
		mov	dl, [ecx+44h]
		mov	[eax+44h], dl
		jmp	short loc_4086
; ---------------------------------------------------------------------------

loc_40A9:				; CODE XREF: icu_56::StringEnumeration::operator=(icu_56::StringEnumeration const &)+57j
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+64h]
		mov	[eax+64h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+68h]
		mov	[eax+68h], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4StringEnumeration@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 40DCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::StringEnumeration::`scalar deleting	destructor'(unsigned int)
		public ??_GStringEnumeration@icu_56@@UAEPAXI@Z
??_GStringEnumeration@icu_56@@UAEPAXI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1StringEnumeration@icu_56@@UAE@XZ ; icu_56::StringEnumeration::~StringEnumeration(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_411B
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_411B:				; CODE XREF: icu_56::StringEnumeration::`scalar	deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GStringEnumeration@icu_56@@UAEPAXI@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4134h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::StringEnumeration::`vector deleting	destructor'(unsigned int)
		public ??_EStringEnumeration@icu_56@@UAEPAXI@Z
??_EStringEnumeration@icu_56@@UAEPAXI@Z	proc near
					; DATA XREF: .rdata:const icu_56::StringEnumeration::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_4195
		push	offset ??1StringEnumeration@icu_56@@UAE@XZ ; icu_56::StringEnumeration::~StringEnumeration(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	6Ch ; 'l'
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_418D
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_418D:				; CODE XREF: icu_56::StringEnumeration::`vector	deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_41B4
; ---------------------------------------------------------------------------

loc_4195:				; CODE XREF: icu_56::StringEnumeration::`vector	deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1StringEnumeration@icu_56@@UAE@XZ ; icu_56::StringEnumeration::~StringEnumeration(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_41B1
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_41B1:				; CODE XREF: icu_56::StringEnumeration::`vector	deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_41B4:				; CODE XREF: icu_56::StringEnumeration::`vector	deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EStringEnumeration@icu_56@@UAEPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 41CCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::CharString::CharString(icu_56::CharString *__hidden	this)
		public ??0CharString@icu_56@@QAE@XZ
??0CharString@icu_56@@QAE@XZ proc near	; CODE XREF: _ures_getByKeyWithFallback_56+DBp
					; getTableItemByKeyPath(ResourceData const *,uint,char const *)+49p

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0CharString@icu_56@@QAE@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	ecx, [ebp+var_14]
		call	??0?$MaybeStackArray@D$0CI@@icu_56@@QAE@XZ ; icu_56::MaybeStackArray<char,40>::MaybeStackArray<char,40>(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+34h], 0
		push	0
		mov	ecx, [ebp+var_14]
		call	??A?$MaybeStackArray@D$0CI@@icu_56@@QAEAADH@Z ;	icu_56::MaybeStackArray<char,40>::operator[](int)
		mov	byte ptr [eax],	0
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0CharString@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 4260h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0CharString@icu_56@@QAE@XZ$0 proc near ; DATA	XREF: .xdata$x:0000428Co
		mov	ecx, [ebp-14h]
		jmp	??1?$MaybeStackArray@D$0CI@@icu_56@@QAE@XZ ; icu_56::MaybeStackArray<char,40>::~MaybeStackArray<char,40>(void)
__unwindfunclet$??0CharString@icu_56@@QAE@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0CharString@icu_56@@QAE@XZ proc near
					; DATA XREF: icu_56::CharString::CharString(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0CharString@icu_56@@QAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??0CharString@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 4288h
__unwindtable$??0CharString@icu_56@@QAE@XZ dd 0FFFFFFFFh ; DATA	XREF: .xdata$x:00004298o
		dd offset __unwindfunclet$??0CharString@icu_56@@QAE@XZ$0
__ehfuncinfo$??0CharString@icu_56@@QAE@XZ dd 19930522h,	1
					; DATA XREF: __ehhandler$??0CharString@icu_56@@QAE@XZ+14o
		dd offset __unwindtable$??0CharString@icu_56@@QAE@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 42B4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::CharString::CharString(icu_56::CharString *this, const struct icu_56::StringPiece *, enum UErrorCode *)
		public ??0CharString@icu_56@@QAE@ABVStringPiece@1@AAW4UErrorCode@@@Z
??0CharString@icu_56@@QAE@ABVStringPiece@1@AAW4UErrorCode@@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0CharString@icu_56@@QAE@ABVStringPiece@1@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	ecx, [ebp+var_14]
		call	??0?$MaybeStackArray@D$0CI@@icu_56@@QAE@XZ ; icu_56::MaybeStackArray<char,40>::MaybeStackArray<char,40>(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+34h], 0
		push	0
		mov	ecx, [ebp+var_14]
		call	??A?$MaybeStackArray@D$0CI@@icu_56@@QAEAADH@Z ;	icu_56::MaybeStackArray<char,40>::operator[](int)
		mov	byte ptr [eax],	0
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::StringPiece *
		mov	ecx, [ebp+var_14] ; this
		call	?append@CharString@icu_56@@QAEAAV12@ABVStringPiece@2@AAW4UErrorCode@@@Z	; icu_56::CharString::append(icu_56::StringPiece const &,UErrorCode &)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??0CharString@icu_56@@QAE@ABVStringPiece@1@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 4358h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0CharString@icu_56@@QAE@ABVStringPiece@1@AAW4UErrorCode@@@Z$0	proc near
					; DATA XREF: .xdata$x:00004384o
		mov	ecx, [ebp-14h]
		jmp	??1?$MaybeStackArray@D$0CI@@icu_56@@QAE@XZ ; icu_56::MaybeStackArray<char,40>::~MaybeStackArray<char,40>(void)
__unwindfunclet$??0CharString@icu_56@@QAE@ABVStringPiece@1@AAW4UErrorCode@@@Z$0	endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0CharString@icu_56@@QAE@ABVStringPiece@1@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::CharString::CharString(icu_56::StringPiece	const &,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0CharString@icu_56@@QAE@ABVStringPiece@1@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0CharString@icu_56@@QAE@ABVStringPiece@1@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 4380h
__unwindtable$??0CharString@icu_56@@QAE@ABVStringPiece@1@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00004390o
		dd offset __unwindfunclet$??0CharString@icu_56@@QAE@ABVStringPiece@1@AAW4UErrorCode@@@Z$0
__ehfuncinfo$??0CharString@icu_56@@QAE@ABVStringPiece@1@AAW4UErrorCode@@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$??0CharString@icu_56@@QAE@ABVStringPiece@1@AAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$??0CharString@icu_56@@QAE@ABVStringPiece@1@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 43ACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::CharString::CharString(icu_56::CharString *this, const struct icu_56::CharString *,	enum UErrorCode	*)
		public ??0CharString@icu_56@@QAE@ABV01@AAW4UErrorCode@@@Z
??0CharString@icu_56@@QAE@ABV01@AAW4UErrorCode@@@Z proc	near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0CharString@icu_56@@QAE@ABV01@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	ecx, [ebp+var_14]
		call	??0?$MaybeStackArray@D$0CI@@icu_56@@QAE@XZ ; icu_56::MaybeStackArray<char,40>::MaybeStackArray<char,40>(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+34h], 0
		push	0
		mov	ecx, [ebp+var_14]
		call	??A?$MaybeStackArray@D$0CI@@icu_56@@QAEAADH@Z ;	icu_56::MaybeStackArray<char,40>::operator[](int)
		mov	byte ptr [eax],	0
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::CharString *
		mov	ecx, [ebp+var_14] ; this
		call	?append@CharString@icu_56@@QAEAAV12@ABV12@AAW4UErrorCode@@@Z ; icu_56::CharString::append(icu_56::CharString const &,UErrorCode	&)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??0CharString@icu_56@@QAE@ABV01@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 4450h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0CharString@icu_56@@QAE@ABV01@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:0000447Co
		mov	ecx, [ebp-14h]
		jmp	??1?$MaybeStackArray@D$0CI@@icu_56@@QAE@XZ ; icu_56::MaybeStackArray<char,40>::~MaybeStackArray<char,40>(void)
__unwindfunclet$??0CharString@icu_56@@QAE@ABV01@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0CharString@icu_56@@QAE@ABV01@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::CharString::CharString(icu_56::CharString const &,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0CharString@icu_56@@QAE@ABV01@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0CharString@icu_56@@QAE@ABV01@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 4478h
__unwindtable$??0CharString@icu_56@@QAE@ABV01@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00004488o
		dd offset __unwindfunclet$??0CharString@icu_56@@QAE@ABV01@AAW4UErrorCode@@@Z$0
__ehfuncinfo$??0CharString@icu_56@@QAE@ABV01@AAW4UErrorCode@@@Z	dd 19930522h, 1
					; DATA XREF: __ehhandler$??0CharString@icu_56@@QAE@ABV01@AAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$??0CharString@icu_56@@QAE@ABV01@AAW4UErrorCode@@@Z
		align 20h
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 44A4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::CharString::CharString(icu_56::CharString *this, const char	*, int,	enum UErrorCode	*)
		public ??0CharString@icu_56@@QAE@PBDHAAW4UErrorCode@@@Z
??0CharString@icu_56@@QAE@PBDHAAW4UErrorCode@@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0CharString@icu_56@@QAE@PBDHAAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	ecx, [ebp+var_14]
		call	??0?$MaybeStackArray@D$0CI@@icu_56@@QAE@XZ ; icu_56::MaybeStackArray<char,40>::MaybeStackArray<char,40>(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+34h], 0
		push	0
		mov	ecx, [ebp+var_14]
		call	??A?$MaybeStackArray@D$0CI@@icu_56@@QAEAADH@Z ;	icu_56::MaybeStackArray<char,40>::operator[](int)
		mov	byte ptr [eax],	0
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; char *
		mov	ecx, [ebp+var_14] ; this
		call	?append@CharString@icu_56@@QAEAAV12@PBDHAAW4UErrorCode@@@Z ; icu_56::CharString::append(char const *,int,UErrorCode &)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
??0CharString@icu_56@@QAE@PBDHAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 454Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0CharString@icu_56@@QAE@PBDHAAW4UErrorCode@@@Z$0 proc	near
					; DATA XREF: .xdata$x:00004578o
		mov	ecx, [ebp-14h]
		jmp	??1?$MaybeStackArray@D$0CI@@icu_56@@QAE@XZ ; icu_56::MaybeStackArray<char,40>::~MaybeStackArray<char,40>(void)
__unwindfunclet$??0CharString@icu_56@@QAE@PBDHAAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0CharString@icu_56@@QAE@PBDHAAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::CharString::CharString(char const *,int,UErrorCode	&)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0CharString@icu_56@@QAE@PBDHAAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0CharString@icu_56@@QAE@PBDHAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 4574h
__unwindtable$??0CharString@icu_56@@QAE@PBDHAAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00004584o
		dd offset __unwindfunclet$??0CharString@icu_56@@QAE@PBDHAAW4UErrorCode@@@Z$0
__ehfuncinfo$??0CharString@icu_56@@QAE@PBDHAAW4UErrorCode@@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$??0CharString@icu_56@@QAE@PBDHAAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$??0CharString@icu_56@@QAE@PBDHAAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 45A0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::CharString::~CharString(icu_56::CharString *__hidden this)
		public ??1CharString@icu_56@@QAE@XZ
??1CharString@icu_56@@QAE@XZ proc near	; CODE XREF: _ures_getByKeyWithFallback_56+1BEp
					; _ures_getByKeyWithFallback_56+31Fp ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		call	??1?$MaybeStackArray@D$0CI@@icu_56@@QAE@XZ ; icu_56::MaybeStackArray<char,40>::~MaybeStackArray<char,40>(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1CharString@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 45E0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::CharString::isEmpty(icu_56::CharString *__hidden this)
		public ?isEmpty@CharString@icu_56@@QBECXZ
?isEmpty@CharString@icu_56@@QBECXZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+34h], 0
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isEmpty@CharString@icu_56@@QBECXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4614h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::CharString::length(icu_56::CharString *__hidden this)
		public ?length@CharString@icu_56@@QBEHXZ
?length@CharString@icu_56@@QBEHXZ proc near
					; CODE XREF: icu_56::CharString::append(icu_56::CharString const &,UErrorCode &)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+34h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?length@CharString@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4644h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char __thiscall icu_56::CharString::operator[](int)const
		public ??ACharString@icu_56@@QBEDH@Z
??ACharString@icu_56@@QBEDH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??A?$MaybeStackArray@D$0CI@@icu_56@@QBEABDH@Z ;	icu_56::MaybeStackArray<char,40>::operator[](int)
		mov	al, [eax]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??ACharString@icu_56@@QBEDH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 468Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::StringPiece __thiscall icu_56::CharString::toStringPiece(void)const
		public ?toStringPiece@CharString@icu_56@@QBE?AVStringPiece@2@XZ
?toStringPiece@CharString@icu_56@@QBE?AVStringPiece@2@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+34h]
		push	ecx		; int
		mov	ecx, [ebp+var_8]
		call	?getAlias@?$MaybeStackArray@D$0CI@@icu_56@@QBEPADXZ ; icu_56::MaybeStackArray<char,40>::getAlias(void)
		push	eax		; char *
		mov	ecx, [ebp+arg_0] ; this
		call	??0StringPiece@icu_56@@QAE@PBDH@Z ; icu_56::StringPiece::StringPiece(char const	*,int)
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?toStringPiece@CharString@icu_56@@QBE?AVStringPiece@2@XZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 46E0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	char *__thiscall icu_56::CharString::data(icu_56::CharString *__hidden this)
		public ?data@CharString@icu_56@@QBEPBDXZ
?data@CharString@icu_56@@QBEPBDXZ proc near
					; CODE XREF: icu_56::CharString::append(icu_56::CharString const &,UErrorCode &)+33p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		call	?getAlias@?$MaybeStackArray@D$0CI@@icu_56@@QBEPADXZ ; icu_56::MaybeStackArray<char,40>::getAlias(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?data@CharString@icu_56@@QBEPBDXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4720h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; char *__thiscall icu_56::CharString::data(icu_56::CharString *__hidden this)
		public ?data@CharString@icu_56@@QAEPADXZ
?data@CharString@icu_56@@QAEPADXZ proc near ; CODE XREF: _ures_getByKeyWithFallback_56+1D4p
					; getTableItemByKeyPath(ResourceData const *,uint,char const *)+B8p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		call	?getAlias@?$MaybeStackArray@D$0CI@@icu_56@@QBEPADXZ ; icu_56::MaybeStackArray<char,40>::getAlias(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?data@CharString@icu_56@@QAEPADXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4760h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::CharString *__thiscall	icu_56::CharString::clear(icu_56::CharString *__hidden this)
		public ?clear@CharString@icu_56@@QAEAAV12@XZ
?clear@CharString@icu_56@@QAEAAV12@XZ proc near
					; CODE XREF: _ures_getByKeyWithFallback_56+13Ep

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+34h], 0
		push	0
		mov	ecx, [ebp+var_8]
		call	??A?$MaybeStackArray@D$0CI@@icu_56@@QAEAADH@Z ;	icu_56::MaybeStackArray<char,40>::operator[](int)
		mov	byte ptr [eax],	0
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?clear@CharString@icu_56@@QAEAAV12@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 47B4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::CharString *__thiscall	icu_56::CharString::append(icu_56::CharString *this, const struct icu_56::StringPiece *, enum UErrorCode *)
		public ?append@CharString@icu_56@@QAEAAV12@ABVStringPiece@2@AAW4UErrorCode@@@Z
?append@CharString@icu_56@@QAEAAV12@ABVStringPiece@2@AAW4UErrorCode@@@Z	proc near
					; CODE XREF: icu_56::CharString::CharString(icu_56::StringPiece	const &,UErrorCode &)+73p
					; _ures_getByKeyWithFallback_56+189p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0] ; this
		call	?length@StringPiece@icu_56@@QBEHXZ ; icu_56::StringPiece::length(void)
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?data@StringPiece@icu_56@@QBEPBDXZ ; icu_56::StringPiece::data(void)
		push	eax		; char *
		mov	ecx, [ebp+var_8] ; this
		call	?append@CharString@icu_56@@QAEAAV12@PBDHAAW4UErrorCode@@@Z ; icu_56::CharString::append(char const *,int,UErrorCode &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?append@CharString@icu_56@@QAEAAV12@ABVStringPiece@2@AAW4UErrorCode@@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 480Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::CharString *__thiscall	icu_56::CharString::append(icu_56::CharString *this, const struct icu_56::CharString *,	enum UErrorCode	*)
		public ?append@CharString@icu_56@@QAEAAV12@ABV12@AAW4UErrorCode@@@Z
?append@CharString@icu_56@@QAEAAV12@ABV12@AAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::CharString::CharString(icu_56::CharString const &,UErrorCode &)+73p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0] ; this
		call	?length@CharString@icu_56@@QBEHXZ ; icu_56::CharString::length(void)
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?data@CharString@icu_56@@QBEPBDXZ ; icu_56::CharString::data(void)
		push	eax		; char *
		mov	ecx, [ebp+var_8] ; this
		call	?append@CharString@icu_56@@QAEAAV12@PBDHAAW4UErrorCode@@@Z ; icu_56::CharString::append(char const *,int,UErrorCode &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?append@CharString@icu_56@@QAEAAV12@ABV12@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4864h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl ures_initStackObject_56(void *Dst)
		public _ures_initStackObject_56
_ures_initStackObject_56 proc near	; CODE XREF: _ures_getStringByKeyWithFallback_56+39p
					; _ures_countArrayItems_56+2Fp	...

var_C0		= byte ptr -0C0h
Dst		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		push	98h ; ''       ; Size
		push	0		; Val
		mov	eax, [ebp+Dst]
		push	eax		; Dst
		call	_memset
		add	esp, 0Ch
		push	1
		mov	eax, [ebp+Dst]
		push	eax
		call	?ures_setIsStackObject@@YAXPAUUResourceBundle@@C@Z ; ures_setIsStackObject(UResourceBundle *,signed char)
		add	esp, 8
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_ures_initStackObject_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 48B8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl ures_setIsStackObject(struct UResourceBundle *, signed char)
?ures_setIsStackObject@@YAXPAUUResourceBundle@@C@Z proc	near
					; CODE XREF: _ures_initStackObject_56+37p
					; _ures_copyResb_56+103p ...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= byte ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		movsx	eax, [ebp+arg_4]
		test	eax, eax
		jz	short loc_48FA
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+88h], 0
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+8Ch], 0
		jmp	short loc_4914
; ---------------------------------------------------------------------------

loc_48FA:				; CODE XREF: ures_setIsStackObject(UResourceBundle *,signed char)+24j
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+88h], 12C9B17h
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+8Ch], 12BB38Bh

loc_4914:				; CODE XREF: ures_setIsStackObject(UResourceBundle *,signed char)+40j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?ures_setIsStackObject@@YAXPAUUResourceBundle@@C@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 491Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _ures_close_56
_ures_close_56	proc near		; CODE XREF: ures_getStringWithAlias(UResourceBundle const *,uint,int,int *,UErrorCode *)+64p
					; init_resb_result(ResourceData	const *,uint,char const	*,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+443p ...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		push	1
		mov	eax, [ebp+arg_0]
		push	eax
		call	?ures_closeBundle@@YAXPAUUResourceBundle@@C@Z ;	ures_closeBundle(UResourceBundle *,signed char)
		add	esp, 8
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_ures_close_56	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 495Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl ures_closeBundle(struct UResourceBundle *, signed char)
?ures_closeBundle@@YAXPAUUResourceBundle@@C@Z proc near	; CODE XREF: _ures_close_56+24p
					; _ures_copyResb_56+94p ...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= byte ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		jz	short loc_49E3
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+4], 0
		jz	short loc_4998
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		push	ecx
		call	?entryClose@@YAXPAUUResourceDataEntry@@@Z ; entryClose(UResourceDataEntry *)
		add	esp, 4

loc_4998:				; CODE XREF: ures_closeBundle(UResourceBundle *,signed char)+2Bj
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+8], 0
		jz	short loc_49B0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		push	ecx
		call	_uprv_free_56
		add	esp, 4

loc_49B0:				; CODE XREF: ures_closeBundle(UResourceBundle *,signed char)+43j
		mov	eax, [ebp+arg_0]
		push	eax
		call	?ures_freeResPath@@YAXPAUUResourceBundle@@@Z ; ures_freeResPath(UResourceBundle	*)
		add	esp, 4
		mov	eax, [ebp+arg_0]
		push	eax
		call	?ures_isStackObject@@YACPBUUResourceBundle@@@Z ; ures_isStackObject(UResourceBundle const *)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jnz	short loc_49E3
		movsx	eax, [ebp+arg_4]
		test	eax, eax
		jz	short loc_49E3
		mov	eax, [ebp+arg_0]
		push	eax
		call	_uprv_free_56
		add	esp, 4

loc_49E3:				; CODE XREF: ures_closeBundle(UResourceBundle *,signed char)+22j
					; ures_closeBundle(UResourceBundle *,signed char)+71j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?ures_closeBundle@@YAXPAUUResourceBundle@@C@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 49F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl ures_isStackObject(struct	UResourceBundle	const *)
?ures_isStackObject@@YACPBUUResourceBundle@@@Z proc near
					; CODE XREF: ures_closeBundle(UResourceBundle *,signed char)+64p
					; _ures_copyResb_56+83p ...

var_C4		= dword	ptr -0C4h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C4]
		mov	ecx, 31h ; '1'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+88h], 12C9B17h
		jnz	short loc_4A40
		mov	ecx, [ebp+arg_0]
		cmp	dword ptr [ecx+8Ch], 12BB38Bh
		jnz	short loc_4A40
		mov	[ebp+var_C4], 0
		jmp	short loc_4A4A
; ---------------------------------------------------------------------------

loc_4A40:				; CODE XREF: ures_isStackObject(UResourceBundle	const *)+2Bj
					; ures_isStackObject(UResourceBundle const *)+3Aj
		mov	[ebp+var_C4], 1

loc_4A4A:				; CODE XREF: ures_isStackObject(UResourceBundle	const *)+46j
		mov	al, byte ptr [ebp+var_C4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?ures_isStackObject@@YACPBUUResourceBundle@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4A58h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl entryClose(struct UResourceDataEntry *)
?entryClose@@YAXPAUUResourceDataEntry@@@Z proc near
					; CODE XREF: ures_closeBundle(UResourceBundle *,signed char)+34p
					; init_resb_result(ResourceData	const *,uint,char const	*,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+852p ...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		push	offset _resbMutex
		call	_umtx_lock_56
		add	esp, 4
		mov	eax, [ebp+arg_0]
		push	eax
		call	?entryCloseInt@@YAXPAUUResourceDataEntry@@@Z ; entryCloseInt(UResourceDataEntry	*)
		add	esp, 4
		push	offset _resbMutex
		call	_umtx_unlock_56
		add	esp, 4
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?entryClose@@YAXPAUUResourceDataEntry@@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4AB0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl entryCloseInt(struct UResourceDataEntry *)
?entryCloseInt@@YAXPAUUResourceDataEntry@@@Z proc near
					; CODE XREF: entryClose(UResourceDataEntry *)+2Fp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax

loc_4AD4:				; CODE XREF: entryCloseInt(UResourceDataEntry *)+48j
		cmp	[ebp+arg_0], 0
		jz	short loc_4AFA
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+40h]
		sub	ecx, 1
		mov	edx, [ebp+arg_0]
		mov	[edx+40h], ecx
		mov	eax, [ebp+var_8]
		mov	[ebp+arg_0], eax
		jmp	short loc_4AD4
; ---------------------------------------------------------------------------

loc_4AFA:				; CODE XREF: entryCloseInt(UResourceDataEntry *)+28j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?entryCloseInt@@YAXPAUUResourceDataEntry@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4B04h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl ures_freeResPath(struct UResourceBundle *)
?ures_freeResPath@@YAXPAUUResourceBundle@@@Z proc near
					; CODE XREF: ures_closeBundle(UResourceBundle *,signed char)+58p
					; init_resb_result(ResourceData	const *,uint,char const	*,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+87Ep

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+10h], 0
		jz	short loc_4B48
		mov	eax, [ebp+arg_0]
		add	eax, 3Ch ; '<'
		mov	ecx, [ebp+arg_0]
		cmp	[ecx+10h], eax
		jz	short loc_4B48
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		push	ecx
		call	_uprv_free_56
		add	esp, 4

loc_4B48:				; CODE XREF: ures_freeResPath(UResourceBundle *)+25j
					; ures_freeResPath(UResourceBundle *)+33j
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+10h], 0
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+7Ch], 0
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?ures_freeResPath@@YAXPAUUResourceBundle@@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4B70h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl ures_copyResb_56(void *Dst, void *Src, int)
		public _ures_copyResb_56
_ures_copyResb_56 proc near		; CODE XREF: _ures_getNextResource_56+DFp
					; _ures_getByIndex_56+C1p ...

var_CC		= byte ptr -0CCh
var_5		= byte ptr -5
Dst		= dword	ptr  8
Src		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jnz	short loc_4BAB
		mov	eax, [ebp+Dst]
		cmp	eax, [ebp+Src]
		jnz	short loc_4BB3

loc_4BAB:				; CODE XREF: _ures_copyResb_56+31j
		mov	eax, [ebp+Dst]
		jmp	loc_4C96
; ---------------------------------------------------------------------------

loc_4BB3:				; CODE XREF: _ures_copyResb_56+39j
		cmp	[ebp+Src], 0
		jz	loc_4C93
		cmp	[ebp+Dst], 0
		jnz	short loc_4BEF
		mov	[ebp+var_5], 0
		push	98h ; ''
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+Dst], eax
		cmp	[ebp+Dst], 0
		jnz	short loc_4BED
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 7
		xor	eax, eax
		jmp	loc_4C96
; ---------------------------------------------------------------------------

loc_4BED:				; CODE XREF: _ures_copyResb_56+6Bj
		jmp	short loc_4C0C
; ---------------------------------------------------------------------------

loc_4BEF:				; CODE XREF: _ures_copyResb_56+51j
		mov	eax, [ebp+Dst]
		push	eax
		call	?ures_isStackObject@@YACPBUUResourceBundle@@@Z ; ures_isStackObject(UResourceBundle const *)
		add	esp, 4
		mov	[ebp+var_5], al
		push	0
		mov	eax, [ebp+Dst]
		push	eax
		call	?ures_closeBundle@@YAXPAUUResourceBundle@@C@Z ;	ures_closeBundle(UResourceBundle *,signed char)
		add	esp, 8

loc_4C0C:				; CODE XREF: _ures_copyResb_56:loc_4BEDj
		push	1
		mov	eax, [ebp+Src]
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		push	98h ; ''       ; Size
		mov	ecx, [ebp+Src]
		push	ecx		; Src
		mov	edx, [ebp+Dst]
		push	edx		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	eax, [ebp+Dst]
		mov	dword ptr [eax+10h], 0
		mov	eax, [ebp+Dst]
		mov	dword ptr [eax+7Ch], 0
		mov	eax, [ebp+Src]
		cmp	dword ptr [eax+10h], 0
		jz	short loc_4C6A
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+Src]
		mov	edx, [ecx+7Ch]
		push	edx		; int
		mov	eax, [ebp+Src]
		mov	ecx, [eax+10h]
		push	ecx		; Source
		mov	edx, [ebp+Dst]
		push	edx		; int
		call	?ures_appendResPath@@YAXPAUUResourceBundle@@PBDHPAW4UErrorCode@@@Z ; ures_appendResPath(UResourceBundle	*,char const *,int,UErrorCode *)
		add	esp, 10h

loc_4C6A:				; CODE XREF: _ures_copyResb_56+DAj
		movzx	eax, [ebp+var_5]
		push	eax
		mov	ecx, [ebp+Dst]
		push	ecx
		call	?ures_setIsStackObject@@YAXPAUUResourceBundle@@C@Z ; ures_setIsStackObject(UResourceBundle *,signed char)
		add	esp, 8
		mov	eax, [ebp+Dst]
		cmp	dword ptr [eax+4], 0
		jz	short loc_4C93
		mov	eax, [ebp+Dst]
		mov	ecx, [eax+4]
		push	ecx
		call	?entryIncrease@@YAXPAUUResourceDataEntry@@@Z ; entryIncrease(UResourceDataEntry	*)
		add	esp, 4

loc_4C93:				; CODE XREF: _ures_copyResb_56+47j
					; _ures_copyResb_56+112j
		mov	eax, [ebp+Dst]

loc_4C96:				; CODE XREF: _ures_copyResb_56+3Ej
					; _ures_copyResb_56+78j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_ures_copyResb_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4CACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl U_FAILURE(enum  UErrorCode)
?U_FAILURE@@YACW4UErrorCode@@@Z	proc near ; CODE XREF: _ures_copyResb_56+24p
					; _ures_getString_56+2Ap ...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		setnle	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?U_FAILURE@@YACW4UErrorCode@@@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4CD8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl entryIncrease(struct UResourceDataEntry *)
?entryIncrease@@YAXPAUUResourceDataEntry@@@Z proc near ; CODE XREF: _ures_copyResb_56+11Bp
					; init_resb_result(ResourceData	const *,uint,char const	*,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+896p

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		push	offset _resbMutex
		call	_umtx_lock_56
		add	esp, 4
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+40h]
		add	ecx, 1
		mov	edx, [ebp+arg_0]
		mov	[edx+40h], ecx

loc_4D12:				; CODE XREF: entryIncrease(UResourceDataEntry *)+5Bj
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+8], 0
		jz	short loc_4D35
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		mov	[ebp+arg_0], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+40h]
		add	ecx, 1
		mov	edx, [ebp+arg_0]
		mov	[edx+40h], ecx
		jmp	short loc_4D12
; ---------------------------------------------------------------------------

loc_4D35:				; CODE XREF: entryIncrease(UResourceDataEntry *)+41j
		push	offset _resbMutex
		call	_umtx_unlock_56
		add	esp, 4
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?entryIncrease@@YAXPAUUResourceDataEntry@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4D58h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl ures_appendResPath(int, char *Source, int, int)
?ures_appendResPath@@YAXPAUUResourceBundle@@PBDHPAW4UErrorCode@@@Z proc	near
					; CODE XREF: _ures_copyResb_56+F2p
					; init_resb_result(ResourceData	const *,uint,char const	*,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+8FAp ...

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
Source		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+7Ch]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+10h], 0
		jnz	short loc_4DA7
		mov	eax, [ebp+arg_0]
		add	eax, 3Ch ; '<'
		mov	ecx, [ebp+arg_0]
		mov	[ecx+10h], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		mov	byte ptr [ecx],	0
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+7Ch], 0

loc_4DA7:				; CODE XREF: ures_appendResPath(UResourceBundle	*,char const *,int,UErrorCode *)+2Ej
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+7Ch]
		add	ecx, [ebp+arg_8]
		mov	edx, [ebp+arg_0]
		mov	[edx+7Ch], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+7Ch]
		add	ecx, 1
		cmp	ecx, 40h ; '@'
		jl	loc_4E50
		mov	eax, [ebp+arg_0]
		add	eax, 3Ch ; '<'
		mov	ecx, [ebp+arg_0]
		cmp	[ecx+10h], eax
		jnz	short loc_4E1A
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+7Ch]
		add	ecx, 1
		push	ecx
		call	_uprv_malloc_56
		add	esp, 4
		mov	edx, [ebp+arg_0]
		mov	[edx+10h], eax
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+10h], 0
		jnz	short loc_4E02
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 7
		jmp	short loc_4E66
; ---------------------------------------------------------------------------

loc_4E02:				; CODE XREF: ures_appendResPath(UResourceBundle	*,char const *,int,UErrorCode *)+9Dj
		mov	eax, [ebp+arg_0]
		add	eax, 3Ch ; '<'
		push	eax		; Source
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+10h]
		push	edx		; Dest
		call	_strcpy
		add	esp, 8
		jmp	short loc_4E50
; ---------------------------------------------------------------------------

loc_4E1A:				; CODE XREF: ures_appendResPath(UResourceBundle	*,char const *,int,UErrorCode *)+7Cj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+7Ch]
		add	ecx, 1
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+10h]
		push	eax
		call	_uprv_realloc_56
		add	esp, 8
		mov	[ebp+var_14], eax
		cmp	[ebp+var_14], 0
		jnz	short loc_4E47
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 7
		jmp	short loc_4E66
; ---------------------------------------------------------------------------

loc_4E47:				; CODE XREF: ures_appendResPath(UResourceBundle	*,char const *,int,UErrorCode *)+E2j
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		mov	[eax+10h], ecx

loc_4E50:				; CODE XREF: ures_appendResPath(UResourceBundle	*,char const *,int,UErrorCode *)+6Aj
					; ures_appendResPath(UResourceBundle *,char const *,int,UErrorCode *)+C0j
		mov	eax, [ebp+Source]
		push	eax		; Source
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+10h]
		add	edx, [ebp+var_8]
		push	edx		; Dest
		call	_strcpy
		add	esp, 8

loc_4E66:				; CODE XREF: ures_appendResPath(UResourceBundle	*,char const *,int,UErrorCode *)+A8j
					; ures_appendResPath(UResourceBundle *,char const *,int,UErrorCode *)+EDj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?ures_appendResPath@@YAXPAUUResourceBundle@@PBDHPAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4E7Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _ures_getString_56
_ures_getString_56 proc	near		; CODE XREF: _ures_getUTF8String_56+2Ap
					; ures_getStringWithAlias(UResourceBundle const	*,uint,int,int *,UErrorCode *)+55p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_8], 0
		jz	short loc_4EB5
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_4EB9

loc_4EB5:				; CODE XREF: _ures_getString_56+22j
		xor	eax, eax
		jmp	short loc_4EFE
; ---------------------------------------------------------------------------

loc_4EB9:				; CODE XREF: _ures_getString_56+37j
		cmp	[ebp+arg_0], 0
		jnz	short loc_4ECC
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	short loc_4EFE
; ---------------------------------------------------------------------------

loc_4ECC:				; CODE XREF: _ures_getString_56+41j
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+80h]
		push	edx
		mov	eax, [ebp+arg_0]
		add	eax, 14h
		push	eax
		call	_res_getString_56
		add	esp, 0Ch
		mov	[ebp+var_8], eax
		cmp	[ebp+var_8], 0
		jnz	short loc_4EFB
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 11h

loc_4EFB:				; CODE XREF: _ures_getString_56+74j
		mov	eax, [ebp+var_8]

loc_4EFE:				; CODE XREF: _ures_getString_56+3Bj
					; _ures_getString_56+4Ej
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_ures_getString_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4F14h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _ures_getUTF8String_56
_ures_getUTF8String_56 proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= byte ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_10]
		push	eax
		lea	ecx, [ebp+var_8]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	_ures_getString_56
		add	esp, 0Ch
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_10]
		push	eax
		movzx	ecx, [ebp+arg_C]
		push	ecx
		mov	edx, [ebp+arg_8]
		push	edx
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_8]
		push	ecx
		mov	edx, [ebp+var_14]
		push	edx
		call	?ures_toUTF8String@@YAPBDPB_WHPADPAHCPAW4UErrorCode@@@Z	; ures_toUTF8String(wchar_t const *,int,char *,int *,signed char,UErrorCode *)
		add	esp, 18h
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN5
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_ures_getUTF8String_56 endp

; ---------------------------------------------------------------------------
		align 10h
$LN5		dd 1			; DATA XREF: _ures_getUTF8String_56+5Ao
		dd offset $LN4
$LN4		dd 0FFFFFFF8h, 4	; DATA XREF: .text:00004F94o
		dd offset $LN3		; "length16"
$LN3		db 'length16',0         ; DATA XREF: .text:00004FA0o
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4FB0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; char const * __cdecl ures_toUTF8String(wchar_t const *, int, char *, int *, signed char, enum	 UErrorCode *)
?ures_toUTF8String@@YAPBDPB_WHPADPAHCPAW4UErrorCode@@@Z	proc near
					; CODE XREF: _ures_getUTF8String_56+4Ep
					; _ures_getUTF8StringByIndex_56+52p ...

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= byte ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_14]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_4FEA
		xor	eax, eax
		jmp	loc_50E6
; ---------------------------------------------------------------------------

loc_4FEA:				; CODE XREF: ures_toUTF8String(wchar_t const *,int,char	*,int *,signed char,UErrorCode *)+31j
		cmp	[ebp+arg_C], 0
		jz	short loc_4FFA
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		mov	[ebp+var_8], ecx
		jmp	short loc_5001
; ---------------------------------------------------------------------------

loc_4FFA:				; CODE XREF: ures_toUTF8String(wchar_t const *,int,char	*,int *,signed char,UErrorCode *)+3Ej
		mov	[ebp+var_8], 0

loc_5001:				; CODE XREF: ures_toUTF8String(wchar_t const *,int,char	*,int *,signed char,UErrorCode *)+48j
		cmp	[ebp+var_8], 0
		jl	short loc_5013
		cmp	[ebp+var_8], 0
		jle	short loc_5023
		cmp	[ebp+arg_8], 0
		jnz	short loc_5023

loc_5013:				; CODE XREF: ures_toUTF8String(wchar_t const *,int,char	*,int *,signed char,UErrorCode *)+55j
		mov	eax, [ebp+arg_14]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	loc_50E6
; ---------------------------------------------------------------------------

loc_5023:				; CODE XREF: ures_toUTF8String(wchar_t const *,int,char	*,int *,signed char,UErrorCode *)+5Bj
					; ures_toUTF8String(wchar_t const *,int,char *,int *,signed char,UErrorCode *)+61j
		cmp	[ebp+arg_4], 0
		jnz	short loc_5069
		cmp	[ebp+arg_C], 0
		jz	short loc_5038
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 0

loc_5038:				; CODE XREF: ures_toUTF8String(wchar_t const *,int,char	*,int *,signed char,UErrorCode *)+7Dj
		movsx	eax, [ebp+arg_10]
		test	eax, eax
		jz	short loc_5060
		mov	eax, [ebp+arg_14]
		push	eax
		push	0
		mov	ecx, [ebp+var_8]
		push	ecx
		mov	edx, [ebp+arg_8]
		push	edx
		call	_u_terminateChars_56
		add	esp, 10h
		mov	eax, [ebp+arg_8]
		jmp	loc_50E6
; ---------------------------------------------------------------------------
		jmp	short loc_5067
; ---------------------------------------------------------------------------

loc_5060:				; CODE XREF: ures_toUTF8String(wchar_t const *,int,char	*,int *,signed char,UErrorCode *)+8Ej
		mov	eax, offset ??_C@_00CNPNBAHC@?$AA@ ; `string'
		jmp	short loc_50E6
; ---------------------------------------------------------------------------

loc_5067:				; CODE XREF: ures_toUTF8String(wchar_t const *,int,char	*,int *,signed char,UErrorCode *)+AEj
		jmp	short loc_50E6
; ---------------------------------------------------------------------------

loc_5069:				; CODE XREF: ures_toUTF8String(wchar_t const *,int,char	*,int *,signed char,UErrorCode *)+77j
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+arg_4]
		jge	short loc_508F
		mov	eax, [ebp+arg_14]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		mov	eax, [ebp+arg_C]
		push	eax
		push	0
		push	0
		call	_u_strToUTF8_56
		add	esp, 18h
		jmp	short loc_50E6
; ---------------------------------------------------------------------------

loc_508F:				; CODE XREF: ures_toUTF8String(wchar_t const *,int,char	*,int *,signed char,UErrorCode *)+BFj
		movsx	eax, [ebp+arg_10]
		test	eax, eax
		jnz	short loc_50C6
		cmp	[ebp+arg_4], 2AAAAAAAh
		jg	short loc_50C6
		mov	eax, [ebp+arg_4]
		imul	eax, 3
		add	eax, 1
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+var_14]
		jle	short loc_50C6
		mov	eax, [ebp+var_8]
		sub	eax, [ebp+var_14]
		add	eax, [ebp+arg_8]
		mov	[ebp+arg_8], eax
		mov	eax, [ebp+var_14]
		mov	[ebp+var_8], eax

loc_50C6:				; CODE XREF: ures_toUTF8String(wchar_t const *,int,char	*,int *,signed char,UErrorCode *)+E5j
					; ures_toUTF8String(wchar_t const *,int,char *,int *,signed char,UErrorCode *)+EEj ...
		mov	eax, [ebp+arg_14]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+var_8]
		push	ecx
		mov	edx, [ebp+arg_8]
		push	edx
		call	_u_strToUTF8_56
		add	esp, 18h

loc_50E6:				; CODE XREF: ures_toUTF8String(wchar_t const *,int,char	*,int *,signed char,UErrorCode *)+35j
					; ures_toUTF8String(wchar_t const *,int,char *,int *,signed char,UErrorCode *)+6Ej ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?ures_toUTF8String@@YAPBDPB_WHPADPAHCPAW4UErrorCode@@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		;org 50FCh
		public ??_C@_00CNPNBAHC@?$AA@
; `string'
??_C@_00CNPNBAHC@?$AA@ db 0		; DATA XREF: ures_toUTF8String(wchar_t const *,int,char	*,int *,signed char,UErrorCode *):loc_5060o
					; _ures_getFunctionalEquivalent_56+2Cr	...
		align 10h
_rdata		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5100h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _ures_getBinary_56
_ures_getBinary_56 proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_8], 0
		jz	short loc_5139
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_513D

loc_5139:				; CODE XREF: _ures_getBinary_56+22j
		xor	eax, eax
		jmp	short loc_5182
; ---------------------------------------------------------------------------

loc_513D:				; CODE XREF: _ures_getBinary_56+37j
		cmp	[ebp+arg_0], 0
		jnz	short loc_5150
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	short loc_5182
; ---------------------------------------------------------------------------

loc_5150:				; CODE XREF: _ures_getBinary_56+41j
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+80h]
		push	edx
		mov	eax, [ebp+arg_0]
		add	eax, 14h
		push	eax
		call	_res_getBinary_56
		add	esp, 0Ch
		mov	[ebp+var_8], eax
		cmp	[ebp+var_8], 0
		jnz	short loc_517F
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 11h

loc_517F:				; CODE XREF: _ures_getBinary_56+74j
		mov	eax, [ebp+var_8]

loc_5182:				; CODE XREF: _ures_getBinary_56+3Bj
					; _ures_getBinary_56+4Ej
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_ures_getBinary_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5198h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _ures_getIntVector_56
_ures_getIntVector_56 proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_8], 0
		jz	short loc_51D1
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_51D5

loc_51D1:				; CODE XREF: _ures_getIntVector_56+22j
		xor	eax, eax
		jmp	short loc_521A
; ---------------------------------------------------------------------------

loc_51D5:				; CODE XREF: _ures_getIntVector_56+37j
		cmp	[ebp+arg_0], 0
		jnz	short loc_51E8
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	short loc_521A
; ---------------------------------------------------------------------------

loc_51E8:				; CODE XREF: _ures_getIntVector_56+41j
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+80h]
		push	edx
		mov	eax, [ebp+arg_0]
		add	eax, 14h
		push	eax
		call	_res_getIntVector_56
		add	esp, 0Ch
		mov	[ebp+var_8], eax
		cmp	[ebp+var_8], 0
		jnz	short loc_5217
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 11h

loc_5217:				; CODE XREF: _ures_getIntVector_56+74j
		mov	eax, [ebp+var_8]

loc_521A:				; CODE XREF: _ures_getIntVector_56+3Bj
					; _ures_getIntVector_56+4Ej
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_ures_getIntVector_56 endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5230h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _ures_getInt_56
_ures_getInt_56	proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_4], 0
		jz	short loc_5269
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_526E

loc_5269:				; CODE XREF: _ures_getInt_56+22j
		or	eax, 0FFFFFFFFh
		jmp	short loc_52B0
; ---------------------------------------------------------------------------

loc_526E:				; CODE XREF: _ures_getInt_56+37j
		cmp	[ebp+arg_0], 0
		jnz	short loc_5282
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 1
		or	eax, 0FFFFFFFFh
		jmp	short loc_52B0
; ---------------------------------------------------------------------------

loc_5282:				; CODE XREF: _ures_getInt_56+42j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+80h]
		shr	ecx, 1Ch
		cmp	ecx, 7
		jz	short loc_52A1
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 11h
		or	eax, 0FFFFFFFFh
		jmp	short loc_52B0
; ---------------------------------------------------------------------------

loc_52A1:				; CODE XREF: _ures_getInt_56+61j
		mov	eax, [ebp+arg_0]
		mov	eax, [eax+80h]
		shl	eax, 4
		sar	eax, 4

loc_52B0:				; CODE XREF: _ures_getInt_56+3Cj
					; _ures_getInt_56+50j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_ures_getInt_56	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 52C4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _ures_getUInt_56
_ures_getUInt_56 proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_4], 0
		jz	short loc_52FD
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_5302

loc_52FD:				; CODE XREF: _ures_getUInt_56+22j
		or	eax, 0FFFFFFFFh
		jmp	short loc_5343
; ---------------------------------------------------------------------------

loc_5302:				; CODE XREF: _ures_getUInt_56+37j
		cmp	[ebp+arg_0], 0
		jnz	short loc_5316
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 1
		or	eax, 0FFFFFFFFh
		jmp	short loc_5343
; ---------------------------------------------------------------------------

loc_5316:				; CODE XREF: _ures_getUInt_56+42j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+80h]
		shr	ecx, 1Ch
		cmp	ecx, 7
		jz	short loc_5335
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 11h
		or	eax, 0FFFFFFFFh
		jmp	short loc_5343
; ---------------------------------------------------------------------------

loc_5335:				; CODE XREF: _ures_getUInt_56+61j
		mov	eax, [ebp+arg_0]
		mov	eax, [eax+80h]
		and	eax, 0FFFFFFFh

loc_5343:				; CODE XREF: _ures_getUInt_56+3Cj
					; _ures_getUInt_56+50j	...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_ures_getUInt_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5358h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _ures_getType_56
_ures_getType_56 proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		jnz	short loc_5381
		or	eax, 0FFFFFFFFh
		jmp	short loc_5393
; ---------------------------------------------------------------------------

loc_5381:				; CODE XREF: _ures_getType_56+22j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+80h]
		push	ecx
		call	_res_getPublicType_56
		add	esp, 4

loc_5393:				; CODE XREF: _ures_getType_56+27j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_ures_getType_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 53A8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _ures_getKey_56
_ures_getKey_56	proc near		; CODE XREF: ures_loc_nextLocale(UEnumeration *,int *,UErrorCode *)+7Cp
					; _ures_getKeywordValues_56+1E0p

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		jnz	short loc_53D0
		xor	eax, eax
		jmp	short loc_53D5
; ---------------------------------------------------------------------------

loc_53D0:				; CODE XREF: _ures_getKey_56+22j
		mov	eax, [ebp+arg_0]
		mov	eax, [eax]

loc_53D5:				; CODE XREF: _ures_getKey_56+26j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
_ures_getKey_56	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 53DCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _ures_getSize_56
_ures_getSize_56 proc near		; CODE XREF: ures_loc_countLocales(UEnumeration	*,UErrorCode *)+2Bp

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		jnz	short loc_5404
		xor	eax, eax
		jmp	short loc_540D
; ---------------------------------------------------------------------------

loc_5404:				; CODE XREF: _ures_getSize_56+22j
		mov	eax, [ebp+arg_0]
		mov	eax, [eax+94h]

loc_540D:				; CODE XREF: _ures_getSize_56+26j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
_ures_getSize_56 endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5414h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _ures_resetIterator_56
_ures_resetIterator_56 proc near	; CODE XREF: ures_loc_resetLocales(UEnumeration	*,UErrorCode *)+2Bp

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		jnz	short loc_543A
		jmp	short loc_5447
; ---------------------------------------------------------------------------

loc_543A:				; CODE XREF: _ures_resetIterator_56+22j
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+90h], 0FFFFFFFFh

loc_5447:				; CODE XREF: _ures_resetIterator_56+24j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
_ures_resetIterator_56 endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5450h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _ures_hasNext_56
_ures_hasNext_56 proc near		; CODE XREF: ures_loc_nextLocale(UEnumeration *,int *,UErrorCode *)+46p

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		jnz	short loc_5478
		xor	al, al
		jmp	short loc_5490
; ---------------------------------------------------------------------------

loc_5478:				; CODE XREF: _ures_hasNext_56+22j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+94h]
		sub	ecx, 1
		mov	edx, [ebp+arg_0]
		cmp	[edx+90h], ecx
		setl	al

loc_5490:				; CODE XREF: _ures_hasNext_56+26j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
_ures_hasNext_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5498h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _ures_getNextString_56
_ures_getNextString_56 proc near

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0FFFFFFFFh
		cmp	[ebp+arg_C], 0
		jz	short loc_54D8
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_54DF

loc_54D8:				; CODE XREF: _ures_getNextString_56+29j
		xor	eax, eax
		jmp	loc_5658
; ---------------------------------------------------------------------------

loc_54DF:				; CODE XREF: _ures_getNextString_56+3Ej
		cmp	[ebp+arg_0], 0
		jnz	short loc_54F5
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	loc_5658
; ---------------------------------------------------------------------------

loc_54F5:				; CODE XREF: _ures_getNextString_56+4Bj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+94h]
		sub	ecx, 1
		mov	edx, [ebp+arg_0]
		cmp	[edx+90h], ecx
		jnz	short loc_551A
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 8
		jmp	loc_5656
; ---------------------------------------------------------------------------

loc_551A:				; CODE XREF: _ures_getNextString_56+72j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+90h]
		add	ecx, 1
		mov	edx, [ebp+arg_0]
		mov	[edx+90h], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+80h]
		shr	ecx, 1Ch
		mov	[ebp+var_D0], ecx
		cmp	[ebp+var_D0], 0Eh ; switch 15 cases
		ja	$LN1		; jumptable 0000555B default case
		mov	edx, [ebp+var_D0]
		movzx	eax, ds:$LN18[edx]
		jmp	ds:$LN19[eax*4]	; switch jump
; ---------------------------------------------------------------------------

$LN8:					; CODE XREF: _ures_getNextString_56+C3j
					; DATA XREF: .text:$LN19o
		mov	eax, [ebp+arg_4] ; jumptable 0000555B cases 0,6
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+80h]
		push	edx
		mov	eax, [ebp+arg_0]
		add	eax, 14h
		push	eax
		call	_res_getString_56
		add	esp, 0Ch
		jmp	loc_5658
; ---------------------------------------------------------------------------

$LN7:					; CODE XREF: _ures_getNextString_56+C3j
					; DATA XREF: .text:$LN19o
		mov	eax, [ebp+arg_8] ; jumptable 0000555B cases 2,4,5
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+90h]
		push	edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+80h]
		push	ecx
		mov	edx, [ebp+arg_0]
		add	edx, 14h
		push	edx
		call	_res_getTableItemByIndex_56
		add	esp, 10h
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+90h]
		push	eax
		mov	ecx, [ebp+var_8]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	?ures_getStringWithAlias@@YAPB_WPBUUResourceBundle@@IHPAHPAW4UErrorCode@@@Z ; ures_getStringWithAlias(UResourceBundle const *,uint,int,int *,UErrorCode	*)
		add	esp, 14h
		jmp	loc_5658
; ---------------------------------------------------------------------------

$LN5_0:					; CODE XREF: _ures_getNextString_56+C3j
					; DATA XREF: .text:$LN19o
		mov	eax, [ebp+arg_0] ; jumptable 0000555B cases 8,9
		mov	ecx, [eax+90h]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+80h]
		push	eax
		mov	ecx, [ebp+arg_0]
		add	ecx, 14h
		push	ecx
		call	_res_getArrayItem_56
		add	esp, 0Ch
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+90h]
		push	eax
		mov	ecx, [ebp+var_8]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	?ures_getStringWithAlias@@YAPB_WPBUUResourceBundle@@IHPAHPAW4UErrorCode@@@Z ; ures_getStringWithAlias(UResourceBundle const *,uint,int,int *,UErrorCode	*)
		add	esp, 14h
		jmp	short loc_5658
; ---------------------------------------------------------------------------

$LN3_0:					; CODE XREF: _ures_getNextString_56+C3j
					; DATA XREF: .text:$LN19o
		mov	eax, [ebp+arg_C] ; jumptable 0000555B case 3
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+90h]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+80h]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		call	?ures_getStringWithAlias@@YAPB_WPBUUResourceBundle@@IHPAHPAW4UErrorCode@@@Z ; ures_getStringWithAlias(UResourceBundle const *,uint,int,int *,UErrorCode	*)
		add	esp, 14h
		jmp	short loc_5658
; ---------------------------------------------------------------------------

$LN2:					; CODE XREF: _ures_getNextString_56+C3j
					; DATA XREF: .text:$LN19o
		mov	eax, [ebp+arg_C] ; jumptable 0000555B cases 1,7,14
		mov	dword ptr [eax], 11h

$LN1:					; CODE XREF: _ures_getNextString_56+B0j
					; _ures_getNextString_56+C3j
					; DATA XREF: ...
		xor	eax, eax	; jumptable 0000555B default case
		jmp	short loc_5658
; ---------------------------------------------------------------------------

loc_5656:				; CODE XREF: _ures_getNextString_56+7Dj
		xor	eax, eax

loc_5658:				; CODE XREF: _ures_getNextString_56+42j
					; _ures_getNextString_56+58j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_ures_getNextString_56 endp

; ---------------------------------------------------------------------------
$LN19		dd offset $LN8		; DATA XREF: _ures_getNextString_56+C3r
		dd offset $LN2		; jump table for switch	statement
		dd offset $LN7
		dd offset $LN3_0
		dd offset $LN5_0
		dd offset $LN1
$LN18		db	0,     1,     2,     3 ; DATA XREF: _ures_getNextString_56+BCr
		db	2,     2,     0,     1 ; indirect table	for switch statement
		db	4,     4,     5,     5
		db	5,     5,     1
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5694h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; wchar_t const	* __cdecl ures_getStringWithAlias(struct UResourceBundle const *, unsigned int,	int, int *, enum  UErrorCode *)
?ures_getStringWithAlias@@YAPB_WPBUUResourceBundle@@IHPAHPAW4UErrorCode@@@Z proc near
					; CODE XREF: _ures_getNextString_56+130p
					; _ures_getNextString_56+17Dp ...

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
Src		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		shr	eax, 1Ch
		cmp	eax, 3
		jnz	short loc_5707
		mov	[ebp+var_8], 0
		mov	eax, [ebp+arg_10]
		push	eax		; int
		push	0		; Dst
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+Src]
		push	edx		; Src
		call	_ures_getByIndex_56
		add	esp, 10h
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+arg_C]
		push	ecx
		mov	edx, [ebp+var_14]
		push	edx
		call	_ures_getString_56
		add	esp, 0Ch
		mov	[ebp+var_8], eax
		mov	eax, [ebp+var_14]
		push	eax
		call	_ures_close_56
		add	esp, 4
		mov	eax, [ebp+var_8]
		jmp	short loc_571E
; ---------------------------------------------------------------------------
		jmp	short loc_571E
; ---------------------------------------------------------------------------

loc_5707:				; CODE XREF: ures_getStringWithAlias(UResourceBundle const *,uint,int,int *,UErrorCode *)+27j
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+Src]
		add	edx, 14h
		push	edx
		call	_res_getString_56
		add	esp, 0Ch

loc_571E:				; CODE XREF: ures_getStringWithAlias(UResourceBundle const *,uint,int,int *,UErrorCode *)+6Fj
					; ures_getStringWithAlias(UResourceBundle const	*,uint,int,int *,UErrorCode *)+71j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?ures_getStringWithAlias@@YAPB_WPBUUResourceBundle@@IHPAHPAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5734h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl ures_getNextResource_56(void *Src, void *Dst, int)
		public _ures_getNextResource_56
_ures_getNextResource_56 proc near	; CODE XREF: ures_loc_nextLocale(UEnumeration *,int *,UErrorCode *)+67p
					; _ures_getKeywordValues_56+1A4p

var_DC		= dword	ptr -0DCh
var_14		= dword	ptr -14h
Str		= dword	ptr -8
Src		= dword	ptr  8
Dst		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0DCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_DC]
		mov	ecx, 37h ; '7'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+Str], 0
		mov	[ebp+var_14], 0FFFFFFFFh
		cmp	[ebp+arg_8], 0
		jz	short loc_577B
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_5783

loc_577B:				; CODE XREF: _ures_getNextResource_56+30j
		mov	eax, [ebp+Dst]
		jmp	loc_58E8
; ---------------------------------------------------------------------------

loc_5783:				; CODE XREF: _ures_getNextResource_56+45j
		cmp	[ebp+Src], 0
		jnz	short loc_579A
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 1
		mov	eax, [ebp+Dst]
		jmp	loc_58E8
; ---------------------------------------------------------------------------

loc_579A:				; CODE XREF: _ures_getNextResource_56+53j
		mov	eax, [ebp+Src]
		mov	ecx, [eax+94h]
		sub	ecx, 1
		mov	edx, [ebp+Src]
		cmp	[edx+90h], ecx
		jnz	short loc_57BF
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 8
		jmp	loc_58E5
; ---------------------------------------------------------------------------

loc_57BF:				; CODE XREF: _ures_getNextResource_56+7Bj
		mov	eax, [ebp+Src]
		mov	ecx, [eax+90h]
		add	ecx, 1
		mov	edx, [ebp+Src]
		mov	[edx+90h], ecx
		mov	eax, [ebp+Src]
		mov	ecx, [eax+80h]
		shr	ecx, 1Ch
		mov	[ebp+var_DC], ecx
		cmp	[ebp+var_DC], 0Eh ; switch 15 cases
		ja	$LN1_0		; jumptable 00005800 default case
		mov	edx, [ebp+var_DC]
		movzx	eax, ds:$LN16[edx]
		jmp	ds:$LN20[eax*4]	; switch jump
; ---------------------------------------------------------------------------

$LN6:					; CODE XREF: _ures_getNextResource_56+CCj
					; DATA XREF: .text:$LN20o
		mov	eax, [ebp+arg_8] ; jumptable 00005800 cases 0,1,6,7,14
		push	eax		; int
		mov	ecx, [ebp+Src]
		push	ecx		; Src
		mov	edx, [ebp+Dst]
		push	edx		; Dst
		call	_ures_copyResb_56
		add	esp, 0Ch
		jmp	loc_58E8
; ---------------------------------------------------------------------------

$LN5_1:					; CODE XREF: _ures_getNextResource_56+CCj
					; DATA XREF: .text:$LN20o
		lea	eax, [ebp+Str]	; jumptable 00005800 cases 2,4,5
		push	eax
		mov	ecx, [ebp+Src]
		mov	edx, [ecx+90h]
		push	edx
		mov	eax, [ebp+Src]
		mov	ecx, [eax+80h]
		push	ecx
		mov	edx, [ebp+Src]
		add	edx, 14h
		push	edx
		call	_res_getTableItemByIndex_56
		add	esp, 10h
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+Dst]
		push	ecx		; int
		push	0		; int
		mov	edx, [ebp+Src]
		push	edx		; int
		mov	eax, [ebp+Src]
		mov	ecx, [eax+4]
		push	ecx		; int
		mov	edx, [ebp+Src]
		mov	eax, [edx+90h]
		push	eax		; int
		mov	ecx, [ebp+Str]
		push	ecx		; Str
		mov	edx, [ebp+var_14]
		push	edx		; int
		mov	eax, [ebp+Src]
		add	eax, 14h
		push	eax		; Src
		call	?init_resb_result@@YAPAUUResourceBundle@@PBUResourceData@@IPBDHPAUUResourceDataEntry@@PBU1@HPAU1@PAW4UErrorCode@@@Z ; init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode	*)
		add	esp, 24h
		jmp	short loc_58E8
; ---------------------------------------------------------------------------

$LN3_1:					; CODE XREF: _ures_getNextResource_56+CCj
					; DATA XREF: .text:$LN20o
		mov	eax, [ebp+Src]	; jumptable 00005800 cases 8,9
		mov	ecx, [eax+90h]
		push	ecx
		mov	edx, [ebp+Src]
		mov	eax, [edx+80h]
		push	eax
		mov	ecx, [ebp+Src]
		add	ecx, 14h
		push	ecx
		call	_res_getArrayItem_56
		add	esp, 0Ch
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+Dst]
		push	ecx		; int
		push	0		; int
		mov	edx, [ebp+Src]
		push	edx		; int
		mov	eax, [ebp+Src]
		mov	ecx, [eax+4]
		push	ecx		; int
		mov	edx, [ebp+Src]
		mov	eax, [edx+90h]
		push	eax		; int
		mov	ecx, [ebp+Str]
		push	ecx		; Str
		mov	edx, [ebp+var_14]
		push	edx		; int
		mov	eax, [ebp+Src]
		add	eax, 14h
		push	eax		; Src
		call	?init_resb_result@@YAPAUUResourceBundle@@PBUResourceData@@IPBDHPAUUResourceDataEntry@@PBU1@HPAU1@PAW4UErrorCode@@@Z ; init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode	*)
		add	esp, 24h
		jmp	short loc_58E8
; ---------------------------------------------------------------------------

$LN1_0:					; CODE XREF: _ures_getNextResource_56+B9j
					; _ures_getNextResource_56+CCj
					; DATA XREF: ...
		mov	eax, [ebp+Dst]	; jumptable 00005800 default case
		jmp	short loc_58E8
; ---------------------------------------------------------------------------

loc_58E5:				; CODE XREF: _ures_getNextResource_56+86j
		mov	eax, [ebp+Dst]

loc_58E8:				; CODE XREF: _ures_getNextResource_56+4Aj
					; _ures_getNextResource_56+61j	...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN19_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0DCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_ures_getNextResource_56 endp

; ---------------------------------------------------------------------------
		align 10h
$LN19_0		dd 1			; DATA XREF: _ures_getNextResource_56+1B8o
		dd offset $LN18_0
$LN18_0		dd 0FFFFFFF8h, 4	; DATA XREF: .text:00005914o
		dd offset $LN17
$LN17		dd 79656Bh		; DATA XREF: .text:00005920o
$LN20		dd offset $LN6		; DATA XREF: _ures_getNextResource_56+CCr
		dd offset $LN5_1	; jump table for switch	statement
		dd offset $LN3_1
		dd offset $LN1_0
$LN16		db	0,     0,     1,     3 ; DATA XREF: _ures_getNextResource_56+C5r
		db	1,     1,     0,     0 ; indirect table	for switch statement
		db	2,     2,     3,     3
		db	3,     3,     0
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5948h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl init_resb_result(void *Src, int, char *Str, int, int, int, int, int, int)
?init_resb_result@@YAPAUUResourceBundle@@PBUResourceData@@IPBDHPAUUResourceDataEntry@@PBU1@HPAU1@PAW4UErrorCode@@@Z proc near
					; CODE XREF: _ures_getNextResource_56+144p
					; _ures_getNextResource_56+1A2p ...

var_480		= dword	ptr -480h
var_3B8		= dword	ptr -3B8h
var_3AC		= dword	ptr -3ACh
var_3A0		= byte ptr -3A0h
var_298		= dword	ptr -298h
var_28C		= dword	ptr -28Ch
var_280		= byte ptr -280h
var_178		= dword	ptr -178h
var_16C		= dword	ptr -16Ch
Source		= dword	ptr -160h
var_154		= dword	ptr -154h
var_148		= dword	ptr -148h
var_13C		= dword	ptr -13Ch
var_130		= dword	ptr -130h
var_124		= dword	ptr -124h
var_118		= dword	ptr -118h
var_10C		= dword	ptr -10Ch
Str1		= dword	ptr -100h
Dest		= dword	ptr -0F4h
var_E8		= byte ptr -0E8h
var_18		= dword	ptr -18h
Size		= dword	ptr -0Ch
var_4		= dword	ptr -4
Src		= dword	ptr  8
arg_4		= dword	ptr  0Ch
Str		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h
arg_1C		= dword	ptr  24h
arg_20		= dword	ptr  28h

		push	ebp
		mov	ebp, esp
		sub	esp, 480h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_480]
		mov	ecx, 120h
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		cmp	[ebp+arg_20], 0
		jz	short loc_598B
		mov	eax, [ebp+arg_20]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_5993

loc_598B:				; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+2Cj
		mov	eax, [ebp+arg_1C]
		jmp	loc_63CA
; ---------------------------------------------------------------------------

loc_5993:				; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+41j
		cmp	[ebp+arg_14], 0
		jnz	short loc_59A9
		mov	eax, [ebp+arg_20]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	loc_63CA
; ---------------------------------------------------------------------------

loc_59A9:				; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+4Fj
		mov	eax, [ebp+arg_4]
		shr	eax, 1Ch
		cmp	eax, 3
		jnz	loc_613A
		cmp	[ebp+arg_18], 100h
		jge	loc_6129
		mov	[ebp+Size], 0
		lea	eax, [ebp+Size]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+Src]
		push	edx
		call	_res_getAlias_56
		add	esp, 0Ch
		mov	[ebp+var_18], eax
		cmp	[ebp+Size], 0
		jle	loc_6116
		mov	[ebp+Dest], 0
		mov	[ebp+Str1], 0
		mov	[ebp+var_10C], 0
		mov	[ebp+var_118], 0
		mov	eax, [ebp+Size]
		add	eax, 1
		mov	[ebp+Size], eax
		mov	eax, [ebp+arg_14]
		cmp	dword ptr [eax+10h], 0
		jz	short loc_5A41
		mov	eax, [ebp+arg_14]
		mov	ecx, [eax+10h]
		push	ecx		; Str
		call	_strlen
		add	esp, 4
		add	eax, 1
		mov	[ebp+var_124], eax
		jmp	short loc_5A4B
; ---------------------------------------------------------------------------

loc_5A41:				; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+DDj
		mov	[ebp+var_124], 0

loc_5A4B:				; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+F7j
		mov	eax, [ebp+var_124]
		cmp	eax, [ebp+Size]
		jge	short loc_5A5F
		mov	eax, [ebp+Size]
		mov	[ebp+var_124], eax

loc_5A5F:				; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+10Cj
		cmp	[ebp+var_124], 0C8h ; ''
		jg	short loc_5A83
		mov	[ebp+var_124], 0C8h ; ''
		lea	eax, [ebp+var_E8]
		mov	[ebp+Dest], eax
		jmp	short loc_5AB1
; ---------------------------------------------------------------------------

loc_5A83:				; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+121j
		mov	eax, [ebp+var_124]
		push	eax
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+Dest], eax
		cmp	[ebp+Dest], 0
		jnz	short loc_5AB1
		mov	eax, [ebp+arg_20]
		mov	dword ptr [eax], 7
		xor	eax, eax
		jmp	loc_63CA
; ---------------------------------------------------------------------------

loc_5AB1:				; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+139j
					; init_resb_result(ResourceData	const *,uint,char const	*,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+157j
		mov	eax, [ebp+Size]
		push	eax
		mov	ecx, [ebp+Dest]
		push	ecx
		mov	edx, [ebp+var_18]
		push	edx
		call	_u_UCharsToChars_56
		add	esp, 0Ch
		mov	eax, [ebp+Dest]
		movsx	ecx, byte ptr [eax]
		cmp	ecx, 2Fh ; '/'
		jnz	loc_5BD9
		push	2Fh ; '/'       ; Val
		mov	eax, [ebp+Dest]
		add	eax, 1
		push	eax		; Str
		call	?strchr@@YAPADPADH@Z ; strchr(char *,int)
		add	esp, 8
		mov	[ebp+var_10C], eax
		cmp	[ebp+var_10C], 0
		jnz	short loc_5B16
		push	0		; Val
		mov	eax, [ebp+Dest]
		push	eax		; Str
		call	?strchr@@YAPADPADH@Z ; strchr(char *,int)
		add	esp, 8
		mov	[ebp+var_10C], eax
		jmp	short loc_5B2E
; ---------------------------------------------------------------------------

loc_5B16:				; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+1B3j
		mov	eax, [ebp+var_10C]
		mov	byte ptr [eax],	0
		mov	eax, [ebp+var_10C]
		add	eax, 1
		mov	[ebp+var_10C], eax

loc_5B2E:				; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+1CCj
		mov	eax, [ebp+Dest]
		add	eax, 1
		mov	[ebp+Str1], eax
		push	offset ??_C@_06NHEDFFBA@LOCALE?$AA@ ; "LOCALE"
		mov	eax, [ebp+Str1]
		push	eax		; Str1
		call	_strcmp
		add	esp, 8
		test	eax, eax
		jnz	short loc_5B7D
		mov	eax, [ebp+var_10C]
		mov	[ebp+var_118], eax
		mov	eax, [ebp+arg_14]
		mov	ecx, [eax+0Ch]
		mov	edx, [ecx]
		mov	[ebp+var_10C], edx
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax+4]
		mov	[ebp+Str1], ecx
		jmp	short loc_5BD7
; ---------------------------------------------------------------------------

loc_5B7D:				; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+20Bj
		push	offset ??_C@_07IJKDDGAJ@ICUDATA?$AA@ ; "ICUDATA"
		mov	eax, [ebp+Str1]
		push	eax		; Str1
		call	_strcmp
		add	esp, 8
		test	eax, eax
		jnz	short loc_5B9F
		mov	[ebp+Str1], 0

loc_5B9F:				; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+24Bj
		push	2Fh ; '/'       ; Val
		mov	eax, [ebp+var_10C]
		push	eax		; Str
		call	?strchr@@YAPADPADH@Z ; strchr(char *,int)
		add	esp, 8
		mov	[ebp+var_118], eax
		cmp	[ebp+var_118], 0
		jz	short loc_5BD7
		mov	eax, [ebp+var_118]
		mov	byte ptr [eax],	0
		mov	eax, [ebp+var_118]
		add	eax, 1
		mov	[ebp+var_118], eax

loc_5BD7:				; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+233j
					; init_resb_result(ResourceData	const *,uint,char const	*,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+275j
		jmp	short loc_5C29
; ---------------------------------------------------------------------------

loc_5BD9:				; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+18Cj
		mov	eax, [ebp+Dest]
		mov	[ebp+var_10C], eax
		push	2Fh ; '/'       ; Val
		mov	eax, [ebp+var_10C]
		push	eax		; Str
		call	?strchr@@YAPADPADH@Z ; strchr(char *,int)
		add	esp, 8
		mov	[ebp+var_118], eax
		cmp	[ebp+var_118], 0
		jz	short loc_5C1D
		mov	eax, [ebp+var_118]
		mov	byte ptr [eax],	0
		mov	eax, [ebp+var_118]
		add	eax, 1
		mov	[ebp+var_118], eax

loc_5C1D:				; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+2BBj
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax+4]
		mov	[ebp+Str1], ecx

loc_5C29:				; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *):loc_5BD7j
		mov	eax, [ebp+arg_1C]
		mov	[ebp+var_130], eax
		mov	[ebp+var_13C], 0
		mov	[ebp+var_148], 0
		lea	eax, [ebp+var_148]
		push	eax
		mov	ecx, [ebp+var_10C]
		push	ecx
		mov	edx, [ebp+Str1]
		push	edx
		call	_ures_openDirect_56
		add	esp, 0Ch
		mov	[ebp+var_154], eax
		mov	eax, [ebp+var_148]
		push	eax
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	loc_60C2
		cmp	[ebp+var_118], 0
		jnz	loc_5ED1
		mov	eax, [ebp+arg_14]
		mov	ecx, [eax+10h]
		mov	[ebp+Source], ecx
		cmp	[ebp+Source], 0
		jz	short loc_5CF9
		mov	eax, [ebp+Source]
		push	eax		; Source
		mov	ecx, [ebp+Dest]
		push	ecx		; Dest
		call	_strcpy
		add	esp, 8
		mov	eax, [ebp+Dest]
		mov	[ebp+Source], eax
		lea	eax, [ebp+var_13C]
		push	eax
		lea	ecx, [ebp+Source]
		push	ecx
		mov	edx, [ebp+var_154]
		mov	eax, [edx+80h]
		push	eax
		mov	ecx, [ebp+var_154]
		add	ecx, 14h
		push	ecx
		call	_res_findResource_56
		add	esp, 10h
		mov	[ebp+arg_4], eax
		jmp	short loc_5D08
; ---------------------------------------------------------------------------

loc_5CF9:				; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+35Bj
		mov	eax, [ebp+var_154]
		mov	ecx, [eax+80h]
		mov	[ebp+arg_4], ecx

loc_5D08:				; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+3AFj
		cmp	[ebp+Str], 0
		jz	loc_5DFD
		mov	eax, [ebp+Str]
		push	eax		; Str
		call	_strlen
		add	esp, 4
		add	eax, 1
		mov	[ebp+Size], eax
		mov	eax, [ebp+Size]
		cmp	eax, [ebp+var_124]
		jle	short loc_5DA3
		mov	eax, [ebp+Size]
		mov	[ebp+var_124], eax
		mov	eax, [ebp+Dest]
		lea	ecx, [ebp+var_E8]
		cmp	eax, ecx
		jnz	short loc_5D5F
		mov	eax, [ebp+var_124]
		push	eax
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+Dest], eax
		jmp	short loc_5D7B
; ---------------------------------------------------------------------------

loc_5D5F:				; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+3FEj
		mov	eax, [ebp+var_124]
		push	eax
		mov	ecx, [ebp+Dest]
		push	ecx
		call	_uprv_realloc_56
		add	esp, 8
		mov	[ebp+Dest], eax

loc_5D7B:				; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+415j
		cmp	[ebp+Dest], 0
		jnz	short loc_5DA3
		mov	eax, [ebp+var_154]
		push	eax
		call	_ures_close_56
		add	esp, 4
		mov	eax, [ebp+arg_20]
		mov	dword ptr [eax], 7
		xor	eax, eax
		jmp	loc_63CA
; ---------------------------------------------------------------------------

loc_5DA3:				; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+3E5j
					; init_resb_result(ResourceData	const *,uint,char const	*,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+43Aj
		push	1
		mov	eax, [ebp+Str]
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	ecx, [ebp+Size]
		push	ecx		; Size
		mov	edx, [ebp+Str]
		push	edx		; Src
		mov	eax, [ebp+Dest]
		push	eax		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	eax, [ebp+Dest]
		mov	[ebp+Source], eax
		lea	eax, [ebp+var_13C]
		push	eax
		lea	ecx, [ebp+Source]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+var_154]
		add	eax, 14h
		push	eax
		call	_res_findResource_56
		add	esp, 10h
		mov	[ebp+arg_4], eax
		jmp	short loc_5E6D
; ---------------------------------------------------------------------------

loc_5DFD:				; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+3C4j
		cmp	[ebp+arg_C], 0FFFFFFFFh
		jz	short loc_5E6D
		mov	eax, [ebp+arg_4]
		shr	eax, 1Ch
		mov	[ebp+var_16C], eax
		cmp	[ebp+var_16C], 2
		jz	short loc_5E2A
		cmp	[ebp+var_16C], 5
		jz	short loc_5E2A
		cmp	[ebp+var_16C], 4
		jnz	short loc_5E50

loc_5E2A:				; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+4CEj
					; init_resb_result(ResourceData	const *,uint,char const	*,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+4D7j
		lea	eax, [ebp+Source]
		push	eax
		mov	ecx, [ebp+arg_C]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+var_154]
		add	eax, 14h
		push	eax
		call	_res_getTableItemByIndex_56
		add	esp, 10h
		mov	[ebp+arg_4], eax
		jmp	short loc_5E6D
; ---------------------------------------------------------------------------

loc_5E50:				; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+4E0j
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+var_154]
		add	edx, 14h
		push	edx
		call	_res_getArrayItem_56
		add	esp, 0Ch
		mov	[ebp+arg_4], eax

loc_5E6D:				; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+4B3j
					; init_resb_result(ResourceData	const *,uint,char const	*,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+4B9j ...
		cmp	[ebp+arg_4], 0FFFFFFFFh
		jz	short loc_5EBA
		mov	eax, [ebp+arg_20]
		push	eax		; int
		mov	ecx, [ebp+arg_1C]
		push	ecx		; int
		mov	edx, [ebp+arg_18]
		add	edx, 1
		push	edx		; int
		mov	eax, [ebp+var_154]
		push	eax		; int
		mov	ecx, [ebp+var_154]
		mov	edx, [ecx+4]
		push	edx		; int
		push	0FFFFFFFFh	; int
		mov	eax, [ebp+var_13C]
		push	eax		; Str
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+var_154]
		add	edx, 14h
		push	edx		; Src
		call	?init_resb_result@@YAPAUUResourceBundle@@PBUResourceData@@IPBDHPAUUResourceDataEntry@@PBU1@HPAU1@PAW4UErrorCode@@@Z ; init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode	*)
		add	esp, 24h
		mov	[ebp+var_130], eax
		jmp	short loc_5ECC
; ---------------------------------------------------------------------------

loc_5EBA:				; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+529j
		mov	eax, [ebp+arg_20]
		mov	dword ptr [eax], 2
		mov	eax, [ebp+arg_1C]
		mov	[ebp+var_130], eax

loc_5ECC:				; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+570j
		jmp	loc_60C0
; ---------------------------------------------------------------------------

loc_5ED1:				; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+342j
		mov	eax, [ebp+var_154]
		mov	ecx, [eax+4]
		mov	[ebp+var_178], ecx
		lea	eax, [ebp+var_280]
		mov	[ebp+var_28C], eax
		mov	eax, [ebp+var_28C]
		mov	[ebp+var_298], eax
		mov	eax, [ebp+var_118]
		push	eax		; Str
		call	_strlen
		add	esp, 4
		cmp	eax, 100h
		jbe	short loc_5F48
		mov	eax, [ebp+var_118]
		push	eax		; Str
		call	_strlen
		add	esp, 4
		add	eax, 1
		push	eax
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+var_28C], eax
		cmp	[ebp+var_28C], 0
		jnz	short loc_5F48
		mov	eax, [ebp+arg_20]
		mov	dword ptr [eax], 7
		xor	eax, eax
		jmp	loc_63CA
; ---------------------------------------------------------------------------

loc_5F48:				; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+5C4j
					; init_resb_result(ResourceData	const *,uint,char const	*,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+5EEj
		mov	eax, [ebp+var_118]
		push	eax		; Source
		mov	ecx, [ebp+var_28C]
		push	ecx		; Dest
		call	_strcpy
		add	esp, 8
		mov	eax, [ebp+var_154]
		mov	[ebp+var_130], eax

loc_5F6A:				; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+73Bj
		mov	eax, [ebp+var_178]
		mov	ecx, [eax+24h]
		mov	[ebp+arg_4], ecx

loc_5F76:				; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *):loc_6040j
		mov	eax, [ebp+var_298]
		movsx	ecx, byte ptr [eax]
		test	ecx, ecx
		jz	loc_6045
		mov	eax, [ebp+arg_20]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	loc_6045
		lea	eax, [ebp+var_13C]
		push	eax
		lea	ecx, [ebp+var_298]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+var_178]
		add	eax, 14h
		push	eax
		call	_res_findResource_56
		add	esp, 10h
		mov	[ebp+arg_4], eax
		cmp	[ebp+arg_4], 0FFFFFFFFh
		jz	short loc_603E
		mov	eax, [ebp+arg_20]
		push	eax		; int
		mov	ecx, [ebp+arg_1C]
		push	ecx		; int
		mov	edx, [ebp+arg_18]
		add	edx, 1
		push	edx		; int
		mov	eax, [ebp+var_130]
		push	eax		; int
		mov	ecx, [ebp+var_178]
		push	ecx		; int
		push	0FFFFFFFFh	; int
		mov	edx, [ebp+var_13C]
		push	edx		; Str
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+var_178]
		add	ecx, 14h
		push	ecx		; Src
		call	?init_resb_result@@YAPAUUResourceBundle@@PBUResourceData@@IPBDHPAUUResourceDataEntry@@PBU1@HPAU1@PAW4UErrorCode@@@Z ; init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode	*)
		add	esp, 24h
		mov	[ebp+arg_1C], eax
		mov	eax, [ebp+arg_1C]
		mov	[ebp+var_130], eax
		cmp	[ebp+var_130], 0
		jz	short loc_603C
		mov	eax, [ebp+var_130]
		mov	ecx, [eax+80h]
		mov	[ebp+arg_4], ecx
		mov	eax, [ebp+var_130]
		mov	ecx, [eax+4]
		mov	[ebp+var_178], ecx

loc_603C:				; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+6D4j
		jmp	short loc_6040
; ---------------------------------------------------------------------------

loc_603E:				; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+683j
		jmp	short loc_6045
; ---------------------------------------------------------------------------

loc_6040:				; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *):loc_603Cj
		jmp	loc_5F76
; ---------------------------------------------------------------------------

loc_6045:				; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+639j
					; init_resb_result(ResourceData	const *,uint,char const	*,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+652j ...
		mov	eax, [ebp+var_178]
		mov	ecx, [eax+8]
		mov	[ebp+var_178], ecx
		mov	eax, [ebp+var_118]
		push	eax		; Source
		mov	ecx, [ebp+var_28C]
		push	ecx		; Dest
		call	_strcpy
		add	esp, 8
		mov	eax, [ebp+var_28C]
		mov	[ebp+var_298], eax
		cmp	[ebp+arg_4], 0FFFFFFFFh
		jnz	short loc_6089
		cmp	[ebp+var_178], 0
		jnz	loc_5F6A

loc_6089:				; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+732j
		cmp	[ebp+arg_4], 0FFFFFFFFh
		jnz	short loc_60A1
		mov	eax, [ebp+arg_20]
		mov	dword ptr [eax], 2
		mov	eax, [ebp+arg_1C]
		mov	[ebp+var_130], eax

loc_60A1:				; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+745j
		mov	eax, [ebp+var_28C]
		lea	ecx, [ebp+var_280]
		cmp	eax, ecx
		jz	short loc_60C0
		mov	eax, [ebp+var_28C]
		push	eax
		call	_uprv_free_56
		add	esp, 4

loc_60C0:				; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *):loc_5ECCj
					; init_resb_result(ResourceData	const *,uint,char const	*,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+767j
		jmp	short loc_60CD
; ---------------------------------------------------------------------------

loc_60C2:				; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+335j
		mov	eax, [ebp+arg_20]
		mov	ecx, [ebp+var_148]
		mov	[eax], ecx

loc_60CD:				; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *):loc_60C0j
		mov	eax, [ebp+Dest]
		lea	ecx, [ebp+var_E8]
		cmp	eax, ecx
		jz	short loc_60EC
		mov	eax, [ebp+Dest]
		push	eax
		call	_uprv_free_56
		add	esp, 4

loc_60EC:				; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+793j
		mov	eax, [ebp+var_154]
		cmp	eax, [ebp+var_130]
		jz	short loc_6109
		mov	eax, [ebp+var_154]
		push	eax
		call	_ures_close_56
		add	esp, 4

loc_6109:				; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+7B0j
		mov	eax, [ebp+var_130]
		jmp	loc_63CA
; ---------------------------------------------------------------------------
		jmp	short loc_6127
; ---------------------------------------------------------------------------

loc_6116:				; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+9Fj
		mov	eax, [ebp+arg_20]
		mov	dword ptr [eax], 1
		mov	eax, [ebp+arg_1C]
		jmp	loc_63CA
; ---------------------------------------------------------------------------

loc_6127:				; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+7CCj
		jmp	short loc_613A
; ---------------------------------------------------------------------------

loc_6129:				; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+77j
		mov	eax, [ebp+arg_20]
		mov	dword ptr [eax], 18h
		mov	eax, [ebp+arg_1C]
		jmp	loc_63CA
; ---------------------------------------------------------------------------

loc_613A:				; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+6Aj
					; init_resb_result(ResourceData	const *,uint,char const	*,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *):loc_6127j
		cmp	[ebp+arg_1C], 0
		jnz	short loc_618A
		push	98h ; ''
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+arg_1C], eax
		cmp	[ebp+arg_1C], 0
		jnz	short loc_6166
		mov	eax, [ebp+arg_20]
		mov	dword ptr [eax], 7
		xor	eax, eax
		jmp	loc_63CA
; ---------------------------------------------------------------------------

loc_6166:				; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+80Cj
		push	0
		mov	eax, [ebp+arg_1C]
		push	eax
		call	?ures_setIsStackObject@@YAXPAUUResourceBundle@@C@Z ; ures_setIsStackObject(UResourceBundle *,signed char)
		add	esp, 8
		mov	eax, [ebp+arg_1C]
		mov	dword ptr [eax+10h], 0
		mov	eax, [ebp+arg_1C]
		mov	dword ptr [eax+7Ch], 0
		jmp	short loc_61CE
; ---------------------------------------------------------------------------

loc_618A:				; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+7F6j
		mov	eax, [ebp+arg_1C]
		cmp	dword ptr [eax+4], 0
		jz	short loc_61A2
		mov	eax, [ebp+arg_1C]
		mov	ecx, [eax+4]
		push	ecx
		call	?entryClose@@YAXPAUUResourceDataEntry@@@Z ; entryClose(UResourceDataEntry *)
		add	esp, 4

loc_61A2:				; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+849j
		mov	eax, [ebp+arg_1C]
		cmp	dword ptr [eax+8], 0
		jz	short loc_61BA
		mov	eax, [ebp+arg_1C]
		mov	ecx, [eax+8]
		push	ecx
		call	_uprv_free_56
		add	esp, 4

loc_61BA:				; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+861j
		mov	eax, [ebp+arg_14]
		cmp	eax, [ebp+arg_1C]
		jz	short loc_61CE
		mov	eax, [ebp+arg_1C]
		push	eax
		call	?ures_freeResPath@@YAXPAUUResourceBundle@@@Z ; ures_freeResPath(UResourceBundle	*)
		add	esp, 4

loc_61CE:				; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+840j
					; init_resb_result(ResourceData	const *,uint,char const	*,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+878j
		mov	eax, [ebp+arg_1C]
		mov	ecx, [ebp+arg_10]
		mov	[eax+4], ecx
		mov	eax, [ebp+arg_1C]
		mov	ecx, [eax+4]
		push	ecx
		call	?entryIncrease@@YAXPAUUResourceDataEntry@@@Z ; entryIncrease(UResourceDataEntry	*)
		add	esp, 4
		mov	eax, [ebp+arg_1C]
		mov	byte ptr [eax+84h], 0
		mov	eax, [ebp+arg_1C]
		mov	byte ptr [eax+85h], 0
		mov	eax, [ebp+arg_1C]
		mov	dword ptr [eax+90h], 0FFFFFFFFh
		mov	eax, [ebp+arg_1C]
		mov	ecx, [ebp+Str]
		mov	[eax], ecx
		mov	eax, [ebp+arg_1C]
		mov	ecx, [ebp+arg_14]
		mov	edx, [ecx+0Ch]
		mov	[eax+0Ch], edx
		mov	eax, [ebp+arg_14]
		cmp	dword ptr [eax+10h], 0
		jz	short loc_624A
		mov	eax, [ebp+arg_14]
		cmp	eax, [ebp+arg_1C]
		jz	short loc_624A
		mov	eax, [ebp+arg_20]
		push	eax		; int
		mov	ecx, [ebp+arg_14]
		mov	edx, [ecx+7Ch]
		push	edx		; int
		mov	eax, [ebp+arg_14]
		mov	ecx, [eax+10h]
		push	ecx		; Source
		mov	edx, [ebp+arg_1C]
		push	edx		; int
		call	?ures_appendResPath@@YAXPAUUResourceBundle@@PBDHPAW4UErrorCode@@@Z ; ures_appendResPath(UResourceBundle	*,char const *,int,UErrorCode *)
		add	esp, 10h

loc_624A:				; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+8DAj
					; init_resb_result(ResourceData	const *,uint,char const	*,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+8E2j
		cmp	[ebp+Str], 0
		jz	short loc_62A0
		mov	eax, [ebp+arg_20]
		push	eax		; int
		mov	ecx, [ebp+Str]
		push	ecx		; Str
		call	_strlen
		add	esp, 4
		push	eax		; int
		mov	edx, [ebp+Str]
		push	edx		; Source
		mov	eax, [ebp+arg_1C]
		push	eax		; int
		call	?ures_appendResPath@@YAXPAUUResourceBundle@@PBDHPAW4UErrorCode@@@Z ; ures_appendResPath(UResourceBundle	*,char const *,int,UErrorCode *)
		add	esp, 10h
		mov	eax, [ebp+arg_1C]
		mov	ecx, [eax+7Ch]
		mov	edx, [ebp+arg_1C]
		mov	eax, [edx+10h]
		movsx	ecx, byte ptr [eax+ecx-1]
		cmp	ecx, 2Fh ; '/'
		jz	short loc_629E
		mov	eax, [ebp+arg_20]
		push	eax		; int
		push	1		; int
		push	offset ??_C@_01KMDKNFGN@?1?$AA@	; "/"
		mov	ecx, [ebp+arg_1C]
		push	ecx		; int
		call	?ures_appendResPath@@YAXPAUUResourceBundle@@PBDHPAW4UErrorCode@@@Z ; ures_appendResPath(UResourceBundle	*,char const *,int,UErrorCode *)
		add	esp, 10h

loc_629E:				; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+93Dj
		jmp	short loc_630C
; ---------------------------------------------------------------------------

loc_62A0:				; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+906j
		cmp	[ebp+arg_C], 0
		jl	short loc_630C
		push	0Ah
		mov	eax, [ebp+arg_C]
		push	eax
		lea	ecx, [ebp+var_3A0]
		push	ecx
		call	_T_CString_integerToString_56
		add	esp, 0Ch
		mov	[ebp+var_3AC], eax
		mov	eax, [ebp+arg_20]
		push	eax		; int
		mov	ecx, [ebp+var_3AC]
		push	ecx		; int
		lea	edx, [ebp+var_3A0]
		push	edx		; Source
		mov	eax, [ebp+arg_1C]
		push	eax		; int
		call	?ures_appendResPath@@YAXPAUUResourceBundle@@PBDHPAW4UErrorCode@@@Z ; ures_appendResPath(UResourceBundle	*,char const *,int,UErrorCode *)
		add	esp, 10h
		mov	eax, [ebp+arg_1C]
		mov	ecx, [eax+7Ch]
		mov	edx, [ebp+arg_1C]
		mov	eax, [edx+10h]
		movsx	ecx, byte ptr [eax+ecx-1]
		cmp	ecx, 2Fh ; '/'
		jz	short loc_630C
		mov	eax, [ebp+arg_20]
		push	eax		; int
		push	1		; int
		push	offset ??_C@_01KMDKNFGN@?1?$AA@	; "/"
		mov	ecx, [ebp+arg_1C]
		push	ecx		; int
		call	?ures_appendResPath@@YAXPAUUResourceBundle@@PBDHPAW4UErrorCode@@@Z ; ures_appendResPath(UResourceBundle	*,char const *,int,UErrorCode *)
		add	esp, 10h

loc_630C:				; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *):loc_629Ej
					; init_resb_result(ResourceData	const *,uint,char const	*,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+95Cj ...
		mov	eax, [ebp+arg_1C]
		add	eax, 3Ch ; '<'
		mov	ecx, [ebp+arg_1C]
		cmp	eax, [ecx+10h]
		jnz	short loc_6328
		mov	edx, [ebp+arg_1C]
		mov	eax, [edx+7Ch]
		mov	[ebp+var_480], eax
		jmp	short loc_6332
; ---------------------------------------------------------------------------

loc_6328:				; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+9D0j
		mov	[ebp+var_480], 0

loc_6332:				; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+9DEj
		mov	ecx, [ebp+var_480]
		mov	[ebp+var_3B8], ecx
		mov	eax, 40h ; '@'
		sub	eax, [ebp+var_3B8]
		push	eax		; Size
		push	0		; Val
		mov	ecx, [ebp+var_3B8]
		mov	edx, [ebp+arg_1C]
		lea	eax, [edx+ecx+3Ch]
		push	eax		; Dst
		call	_memset
		add	esp, 0Ch
		mov	eax, [ebp+arg_1C]
		mov	dword ptr [eax+8], 0
		mov	eax, [ebp+arg_1C]
		mov	ecx, [ebp+arg_4]
		mov	[eax+80h], ecx
		push	1
		mov	eax, [ebp+Src]
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	esi, esp
		push	28h ; '('       ; Size
		mov	ecx, [ebp+Src]
		push	ecx		; Src
		mov	edx, [ebp+arg_1C]
		add	edx, 14h
		push	edx		; Dst
		call	dword ptr ds:__imp__memmove
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_1C]
		mov	ecx, [eax+80h]
		push	ecx
		mov	edx, [ebp+arg_1C]
		add	edx, 14h
		push	edx
		call	_res_countArrayItems_56
		add	esp, 8
		mov	ecx, [ebp+arg_1C]
		mov	[ecx+94h], eax
		mov	eax, [ebp+arg_1C]

loc_63CA:				; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+46j
					; init_resb_result(ResourceData	const *,uint,char const	*,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+5Cj ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN82
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 480h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?init_resb_result@@YAPAUUResourceBundle@@PBUResourceData@@IPBDHPAUUResourceDataEntry@@PBU1@HPAU1@PAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN82		dd 8			; DATA XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+A86o
		dd offset $LN81
$LN81		dd 0FFFFFFF4h, 4	; DATA XREF: .text:00006400o
		dd offset $LN73		; "len"
		dd 0FFFFFF18h, 0C8h
		dd offset $LN74		; "stackAlias"
		dd 0FFFFFEC4h, 4
		dd offset $LN75		; "temp"
		dd 0FFFFFEB8h, 4
		dd offset $LN76		; "intStatus"
		dd 0FFFFFEA0h, 4
		dd offset $LN77		; "aKey"
		dd 0FFFFFD80h, 100h
		dd offset $LN78		; "stackPath"
		dd 0FFFFFD68h, 4
		dd offset $LN79		; "myPath"
		dd 0FFFFFC60h, 100h
		dd offset $LN80
$LN80		dd 667562h		; DATA XREF: .text:00006460o
$LN79		db 'myPath',0           ; DATA XREF: .text:00006454o
$LN78		db 'stackPath',0        ; DATA XREF: .text:00006448o
$LN77		db 'aKey',0             ; DATA XREF: .text:0000643Co
$LN76		db 'intStatus',0        ; DATA XREF: .text:00006430o
$LN75		db 'temp',0             ; DATA XREF: .text:00006424o
$LN74		db 'stackAlias',0       ; DATA XREF: .text:00006418o
$LN73		db 'len',0              ; DATA XREF: .text:0000640Co
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 649Ch
		public ??_C@_01KMDKNFGN@?1?$AA@
; char `string'[]
??_C@_01KMDKNFGN@?1?$AA@ db '/',0       ; DATA XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+945o
					; init_resb_result(ResourceData	const *,uint,char const	*,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+9B3o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 64A0h
		public ??_C@_07IJKDDGAJ@ICUDATA?$AA@
; char `string'[]
??_C@_07IJKDDGAJ@ICUDATA?$AA@ db 'ICUDATA',0
					; DATA XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *):loc_5B7Do
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 64A8h
		public ??_C@_06NHEDFFBA@LOCALE?$AA@
; char `string'[]
??_C@_06NHEDFFBA@LOCALE?$AA@ db	'LOCALE',0
					; DATA XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+1F5o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 64B0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl U_SUCCESS(enum  UErrorCode)
?U_SUCCESS@@YACW4UErrorCode@@@Z	proc near
					; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+328p
					; init_resb_result(ResourceData	const *,uint,char const	*,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+645p ...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		setle	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?U_SUCCESS@@YACW4UErrorCode@@@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 64DCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; char *__cdecl	strchr(char *Str, int Val)
		public ?strchr@@YAPADPADH@Z
?strchr@@YAPADPADH@Z proc near		; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+19Ep
					; init_resb_result(ResourceData	const *,uint,char const	*,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+1BEp ...

var_C0		= byte ptr -0C0h
Str		= dword	ptr  8
Val		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	esi, esp
		mov	eax, [ebp+Val]
		push	eax		; Val
		mov	ecx, [ebp+Str]
		push	ecx		; Str
		call	dword ptr ds:__imp__strchr
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?strchr@@YAPADPADH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6528h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl ures_getByIndex_56(void *Src, int, void *Dst, int)
		public _ures_getByIndex_56
_ures_getByIndex_56 proc near		; CODE XREF: ures_getStringWithAlias(UResourceBundle const *,uint,int,int *,UErrorCode *)+3Ep

var_DC		= dword	ptr -0DCh
var_14		= dword	ptr -14h
Str		= dword	ptr -8
Src		= dword	ptr  8
arg_4		= dword	ptr  0Ch
Dst		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0DCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_DC]
		mov	ecx, 37h ; '7'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+Str], 0
		mov	[ebp+var_14], 0FFFFFFFFh
		cmp	[ebp+arg_C], 0
		jz	short loc_656F
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_6577

loc_656F:				; CODE XREF: _ures_getByIndex_56+30j
		mov	eax, [ebp+Dst]
		jmp	loc_66B1
; ---------------------------------------------------------------------------

loc_6577:				; CODE XREF: _ures_getByIndex_56+45j
		cmp	[ebp+Src], 0
		jnz	short loc_658E
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 1
		mov	eax, [ebp+Dst]
		jmp	loc_66B1
; ---------------------------------------------------------------------------

loc_658E:				; CODE XREF: _ures_getByIndex_56+53j
		cmp	[ebp+arg_4], 0
		jl	loc_66A5
		mov	eax, [ebp+Src]
		mov	ecx, [eax+94h]
		cmp	ecx, [ebp+arg_4]
		jle	loc_66A5
		mov	eax, [ebp+Src]
		mov	ecx, [eax+80h]
		shr	ecx, 1Ch
		mov	[ebp+var_DC], ecx
		cmp	[ebp+var_DC], 0Eh ; switch 15 cases
		ja	$LN2_0		; jumptable 000065D6 default case
		mov	edx, [ebp+var_DC]
		movzx	eax, ds:$LN16_0[edx]
		jmp	ds:$LN20_0[eax*4] ; switch jump
; ---------------------------------------------------------------------------

$LN7_0:					; CODE XREF: _ures_getByIndex_56+AEj
					; DATA XREF: .text:$LN20_0o
		mov	eax, [ebp+arg_C] ; jumptable 000065D6 cases 0,1,6,7,14
		push	eax		; int
		mov	ecx, [ebp+Src]
		push	ecx		; Src
		mov	edx, [ebp+Dst]
		push	edx		; Dst
		call	_ures_copyResb_56
		add	esp, 0Ch
		jmp	loc_66B1
; ---------------------------------------------------------------------------

$LN6_0:					; CODE XREF: _ures_getByIndex_56+AEj
					; DATA XREF: .text:$LN20_0o
		lea	eax, [ebp+Str]	; jumptable 000065D6 cases 2,4,5
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+Src]
		mov	eax, [edx+80h]
		push	eax
		mov	ecx, [ebp+Src]
		add	ecx, 14h
		push	ecx
		call	_res_getTableItemByIndex_56
		add	esp, 10h
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+Dst]
		push	ecx		; int
		push	0		; int
		mov	edx, [ebp+Src]
		push	edx		; int
		mov	eax, [ebp+Src]
		mov	ecx, [eax+4]
		push	ecx		; int
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+Str]
		push	eax		; Str
		mov	ecx, [ebp+var_14]
		push	ecx		; int
		mov	edx, [ebp+Src]
		add	edx, 14h
		push	edx		; Src
		call	?init_resb_result@@YAPAUUResourceBundle@@PBUResourceData@@IPBDHPAUUResourceDataEntry@@PBU1@HPAU1@PAW4UErrorCode@@@Z ; init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode	*)
		add	esp, 24h
		jmp	short loc_66B1
; ---------------------------------------------------------------------------

$LN4_0:					; CODE XREF: _ures_getByIndex_56+AEj
					; DATA XREF: .text:$LN20_0o
		mov	eax, [ebp+arg_4] ; jumptable 000065D6 cases 8,9
		push	eax
		mov	ecx, [ebp+Src]
		mov	edx, [ecx+80h]
		push	edx
		mov	eax, [ebp+Src]
		add	eax, 14h
		push	eax
		call	_res_getArrayItem_56
		add	esp, 0Ch
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+Dst]
		push	ecx		; int
		push	0		; int
		mov	edx, [ebp+Src]
		push	edx		; int
		mov	eax, [ebp+Src]
		mov	ecx, [eax+4]
		push	ecx		; int
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+Str]
		push	eax		; Str
		mov	ecx, [ebp+var_14]
		push	ecx		; int
		mov	edx, [ebp+Src]
		add	edx, 14h
		push	edx		; Src
		call	?init_resb_result@@YAPAUUResourceBundle@@PBUResourceData@@IPBDHPAUUResourceDataEntry@@PBU1@HPAU1@PAW4UErrorCode@@@Z ; init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode	*)
		add	esp, 24h
		jmp	short loc_66B1
; ---------------------------------------------------------------------------

$LN2_0:					; CODE XREF: _ures_getByIndex_56+9Bj
					; _ures_getByIndex_56+AEj
					; DATA XREF: ...
		mov	eax, [ebp+Dst]	; jumptable 000065D6 default case
		jmp	short loc_66B1
; ---------------------------------------------------------------------------
		jmp	short loc_66AE
; ---------------------------------------------------------------------------

loc_66A5:				; CODE XREF: _ures_getByIndex_56+6Aj
					; _ures_getByIndex_56+7Cj
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 2

loc_66AE:				; CODE XREF: _ures_getByIndex_56+17Bj
		mov	eax, [ebp+Dst]

loc_66B1:				; CODE XREF: _ures_getByIndex_56+4Aj
					; _ures_getByIndex_56+61j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN19_1
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0DCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_ures_getByIndex_56 endp

; ---------------------------------------------------------------------------
		align 4
$LN19_1		dd 1			; DATA XREF: _ures_getByIndex_56+18Do
		dd offset $LN18_1
$LN18_1		dd 0FFFFFFF8h, 4	; DATA XREF: .text:000066DCo
		dd offset $LN17_0
$LN17_0		dd 79656Bh		; DATA XREF: .text:000066E8o
$LN20_0		dd offset $LN7_0	; DATA XREF: _ures_getByIndex_56+AEr
		dd offset $LN6_0	; jump table for switch	statement
		dd offset $LN4_0
		dd offset $LN2_0
$LN16_0		db	0,     0,     1,     3 ; DATA XREF: _ures_getByIndex_56+A7r
		db	1,     1,     0,     0 ; indirect table	for switch statement
		db	2,     2,     3,     3
		db	3,     3,     0
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6710h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _ures_getStringByIndex_56
_ures_getStringByIndex_56 proc near	; CODE XREF: _ures_getUTF8StringByIndex_56+2Ep

var_DC		= dword	ptr -0DCh
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0DCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_DC]
		mov	ecx, 37h ; '7'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	[ebp+var_14], 0FFFFFFFFh
		cmp	[ebp+arg_C], 0
		jz	short loc_6757
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_675E

loc_6757:				; CODE XREF: _ures_getStringByIndex_56+30j
		xor	eax, eax
		jmp	loc_68AD
; ---------------------------------------------------------------------------

loc_675E:				; CODE XREF: _ures_getStringByIndex_56+45j
		cmp	[ebp+arg_0], 0
		jnz	short loc_6774
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	loc_68AD
; ---------------------------------------------------------------------------

loc_6774:				; CODE XREF: _ures_getStringByIndex_56+52j
		cmp	[ebp+arg_4], 0
		jl	loc_68A2
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+94h]
		cmp	ecx, [ebp+arg_4]
		jle	loc_68A2
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+80h]
		shr	ecx, 1Ch
		mov	[ebp+var_DC], ecx
		cmp	[ebp+var_DC], 0Eh ; switch 15 cases
		ja	$LN2_1		; jumptable 000067BC default case
		mov	edx, [ebp+var_DC]
		movzx	eax, ds:$LN18_2[edx]
		jmp	ds:$LN22[eax*4]	; switch jump
; ---------------------------------------------------------------------------

$LN9:					; CODE XREF: _ures_getStringByIndex_56+ACj
					; DATA XREF: .text:$LN22o
		mov	eax, [ebp+arg_8] ; jumptable 000067BC cases 0,6
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+80h]
		push	edx
		mov	eax, [ebp+arg_0]
		add	eax, 14h
		push	eax
		call	_res_getString_56
		add	esp, 0Ch
		jmp	loc_68AD
; ---------------------------------------------------------------------------

$LN8_0:					; CODE XREF: _ures_getStringByIndex_56+ACj
					; DATA XREF: .text:$LN22o
		lea	eax, [ebp+var_8] ; jumptable 000067BC cases 2,4,5
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+80h]
		push	eax
		mov	ecx, [ebp+arg_0]
		add	ecx, 14h
		push	ecx
		call	_res_getTableItemByIndex_56
		add	esp, 10h
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+var_14]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?ures_getStringWithAlias@@YAPB_WPBUUResourceBundle@@IHPAHPAW4UErrorCode@@@Z ; ures_getStringWithAlias(UResourceBundle const *,uint,int,int *,UErrorCode	*)
		add	esp, 14h
		jmp	loc_68AD
; ---------------------------------------------------------------------------

$LN6_1:					; CODE XREF: _ures_getStringByIndex_56+ACj
					; DATA XREF: .text:$LN22o
		mov	eax, [ebp+arg_4] ; jumptable 000067BC cases 8,9
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+80h]
		push	edx
		mov	eax, [ebp+arg_0]
		add	eax, 14h
		push	eax
		call	_res_getArrayItem_56
		add	esp, 0Ch
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+var_14]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?ures_getStringWithAlias@@YAPB_WPBUUResourceBundle@@IHPAHPAW4UErrorCode@@@Z ; ures_getStringWithAlias(UResourceBundle const *,uint,int,int *,UErrorCode	*)
		add	esp, 14h
		jmp	short loc_68AD
; ---------------------------------------------------------------------------

$LN4_1:					; CODE XREF: _ures_getStringByIndex_56+ACj
					; DATA XREF: .text:$LN22o
		mov	eax, [ebp+arg_C] ; jumptable 000067BC case 3
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+80h]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	?ures_getStringWithAlias@@YAPB_WPBUUResourceBundle@@IHPAHPAW4UErrorCode@@@Z ; ures_getStringWithAlias(UResourceBundle const *,uint,int,int *,UErrorCode	*)
		add	esp, 14h
		jmp	short loc_68AD
; ---------------------------------------------------------------------------

$LN3_2:					; CODE XREF: _ures_getStringByIndex_56+ACj
					; DATA XREF: .text:$LN22o
		mov	eax, [ebp+arg_C] ; jumptable 000067BC cases 1,7,14
		mov	dword ptr [eax], 11h
		jmp	short loc_68A0
; ---------------------------------------------------------------------------

$LN2_1:					; CODE XREF: _ures_getStringByIndex_56+99j
					; _ures_getStringByIndex_56+ACj
					; DATA XREF: ...
		mov	eax, [ebp+arg_C] ; jumptable 000067BC default case
		mov	dword ptr [eax], 5

loc_68A0:				; CODE XREF: _ures_getStringByIndex_56+185j
		jmp	short loc_68AB
; ---------------------------------------------------------------------------

loc_68A2:				; CODE XREF: _ures_getStringByIndex_56+68j
					; _ures_getStringByIndex_56+7Aj
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 2

loc_68AB:				; CODE XREF: _ures_getStringByIndex_56:loc_68A0j
		xor	eax, eax

loc_68AD:				; CODE XREF: _ures_getStringByIndex_56+49j
					; _ures_getStringByIndex_56+5Fj ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN21
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0DCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_ures_getStringByIndex_56 endp

; ---------------------------------------------------------------------------
		align 4
$LN21		dd 1			; DATA XREF: _ures_getStringByIndex_56+1A1o
		dd offset $LN20_1
$LN20_1		dd 0FFFFFFF8h, 4	; DATA XREF: .text:000068D8o
		dd offset $LN19_2
$LN19_2		dd 79656Bh		; DATA XREF: .text:000068E4o
$LN22		dd offset $LN9		; DATA XREF: _ures_getStringByIndex_56+ACr
		dd offset $LN3_2	; jump table for switch	statement
		dd offset $LN8_0
		dd offset $LN4_1
		dd offset $LN6_1
		dd offset $LN2_1
$LN18_2		db	0,     1,     2,     3 ; DATA XREF: _ures_getStringByIndex_56+A5r
		db	2,     2,     0,     1 ; indirect table	for switch statement
		db	4,     4,     5,     5
		db	5,     5,     1
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6914h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _ures_getUTF8StringByIndex_56
_ures_getUTF8StringByIndex_56 proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= byte ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_14]
		push	eax
		lea	ecx, [ebp+var_8]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		call	_ures_getStringByIndex_56
		add	esp, 10h
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_14]
		push	eax
		movzx	ecx, [ebp+arg_10]
		push	ecx
		mov	edx, [ebp+arg_C]
		push	edx
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+var_8]
		push	ecx
		mov	edx, [ebp+var_14]
		push	edx
		call	?ures_toUTF8String@@YAPBDPB_WHPADPAHCPAW4UErrorCode@@@Z	; ures_toUTF8String(wchar_t const *,int,char *,int *,signed char,UErrorCode *)
		add	esp, 18h
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN5_2
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_ures_getUTF8StringByIndex_56 endp

; ---------------------------------------------------------------------------
		align 4
$LN5_2		dd 1			; DATA XREF: _ures_getUTF8StringByIndex_56+5Eo
		dd offset $LN4_2
$LN4_2		dd 0FFFFFFF8h, 4	; DATA XREF: .text:00006998o
		dd offset $LN3_3	; "length16"
$LN3_3		db 'length16',0         ; DATA XREF: .text:000069A4o
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 69B4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl ures_findResource_56(char	*Str, void *, int)
		public _ures_findResource_56
_ures_findResource_56 proc near

var_120		= byte ptr -120h
Size		= dword	ptr -5Ch
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
Dst		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
Src		= dword	ptr -8
Str		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 120h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_120]
		mov	ecx, 48h ; 'H'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+Src], 0
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_14], eax
		mov	[ebp+var_20], 0
		mov	[ebp+Dst], 0
		mov	[ebp+var_38], 0
		mov	[ebp+var_44], 0
		mov	[ebp+var_50], 0
		cmp	[ebp+arg_8], 0
		jz	short loc_6A1D
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_6A25

loc_6A1D:				; CODE XREF: _ures_findResource_56+52j
		mov	eax, [ebp+var_14]
		jmp	loc_6B77
; ---------------------------------------------------------------------------

loc_6A25:				; CODE XREF: _ures_findResource_56+67j
		mov	eax, [ebp+Str]
		push	eax		; Str
		call	_strlen
		add	esp, 4
		add	eax, 1
		mov	[ebp+Size], eax
		mov	eax, [ebp+Size]
		push	eax
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+Dst], eax
		mov	ecx, [ebp+Dst]
		mov	[ebp+var_38], ecx
		cmp	[ebp+Dst], 0
		jnz	short loc_6A63
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 7
		mov	eax, [ebp+var_14]
		jmp	loc_6B77
; ---------------------------------------------------------------------------

loc_6A63:				; CODE XREF: _ures_findResource_56+9Cj
		push	1
		mov	eax, [ebp+Str]
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	ecx, [ebp+Size]
		push	ecx		; Size
		mov	edx, [ebp+Str]
		push	edx		; Src
		mov	eax, [ebp+Dst]
		push	eax		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	eax, [ebp+Dst]
		mov	[ebp+var_44], eax
		mov	eax, [ebp+Dst]
		movsx	ecx, byte ptr [eax]
		cmp	ecx, 2Fh ; '/'
		jnz	short loc_6AD6
		mov	eax, [ebp+Dst]
		add	eax, 1
		mov	[ebp+Dst], eax
		mov	eax, [ebp+Dst]
		mov	[ebp+var_20], eax
		push	2Fh ; '/'       ; Val
		mov	eax, [ebp+Dst]
		push	eax		; Str
		call	?strchr@@YAPADPADH@Z ; strchr(char *,int)
		add	esp, 8
		mov	[ebp+Dst], eax
		cmp	[ebp+Dst], 0
		jnz	short loc_6AC7
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 1
		jmp	short loc_6AD6
; ---------------------------------------------------------------------------

loc_6AC7:				; CODE XREF: _ures_findResource_56+106j
		mov	eax, [ebp+Dst]
		mov	byte ptr [eax],	0
		mov	eax, [ebp+Dst]
		add	eax, 1
		mov	[ebp+var_44], eax

loc_6AD6:				; CODE XREF: _ures_findResource_56+E0j
					; _ures_findResource_56+111j
		push	2Fh ; '/'       ; Val
		mov	eax, [ebp+var_44]
		push	eax		; Str
		call	?strchr@@YAPADPADH@Z ; strchr(char *,int)
		add	esp, 8
		mov	[ebp+var_50], eax
		cmp	[ebp+var_50], 0
		jz	short loc_6AF3
		mov	eax, [ebp+var_50]
		mov	byte ptr [eax],	0

loc_6AF3:				; CODE XREF: _ures_findResource_56+137j
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+var_44]
		push	ecx
		mov	edx, [ebp+var_20]
		push	edx
		call	_ures_open_56
		add	esp, 0Ch
		mov	[ebp+Src], eax
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_6B68
		cmp	[ebp+var_50], 0
		jz	short loc_6B45
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+var_50]
		add	edx, 1
		push	edx
		mov	eax, [ebp+Src]
		push	eax
		call	_ures_findSubResource_56
		add	esp, 10h
		mov	[ebp+var_14], eax
		jmp	short loc_6B5C
; ---------------------------------------------------------------------------

loc_6B45:				; CODE XREF: _ures_findResource_56+16Fj
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+Src]
		push	ecx		; Src
		mov	edx, [ebp+arg_4]
		push	edx		; Dst
		call	_ures_copyResb_56
		add	esp, 0Ch
		mov	[ebp+var_14], eax

loc_6B5C:				; CODE XREF: _ures_findResource_56+18Fj
		mov	eax, [ebp+Src]
		push	eax
		call	_ures_close_56
		add	esp, 4

loc_6B68:				; CODE XREF: _ures_findResource_56+169j
		mov	eax, [ebp+var_38]
		push	eax
		call	_uprv_free_56
		add	esp, 4
		mov	eax, [ebp+var_14]

loc_6B77:				; CODE XREF: _ures_findResource_56+6Cj
					; _ures_findResource_56+AAj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 120h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_ures_findResource_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6B8Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _ures_findSubResource_56
_ures_findSubResource_56 proc near	; CODE XREF: _ures_findResource_56+184p

var_E4		= byte ptr -0E4h
Str		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0FFFFFFFFh
		mov	eax, [ebp+arg_8]
		mov	[ebp+var_14], eax
		cmp	[ebp+arg_C], 0
		jz	short loc_6BD2
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_6BD7

loc_6BD2:				; CODE XREF: _ures_findSubResource_56+2Fj
		mov	eax, [ebp+var_14]
		jmp	short loc_6C52
; ---------------------------------------------------------------------------

loc_6BD7:				; CODE XREF: _ures_findSubResource_56+44j
					; _ures_findSubResource_56+C1j
		lea	eax, [ebp+Str]
		push	eax
		lea	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+80h]
		push	eax
		mov	ecx, [ebp+arg_0]
		add	ecx, 14h
		push	ecx
		call	_res_findResource_56
		add	esp, 10h
		mov	[ebp+var_8], eax
		cmp	[ebp+var_8], 0FFFFFFFFh
		jz	short loc_6C3A
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		push	ecx		; int
		push	0FFFFFFFFh	; int
		mov	edx, [ebp+Str]
		push	edx		; Str
		mov	eax, [ebp+var_8]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		add	ecx, 14h
		push	ecx		; Src
		call	?init_resb_result@@YAPAUUResourceBundle@@PBUResourceData@@IPBDHPAUUResourceDataEntry@@PBU1@HPAU1@PAW4UErrorCode@@@Z ; init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode	*)
		add	esp, 24h
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_14]
		mov	[ebp+arg_0], eax
		jmp	short loc_6C45
; ---------------------------------------------------------------------------

loc_6C3A:				; CODE XREF: _ures_findSubResource_56+73j
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 2
		jmp	short loc_6C4F
; ---------------------------------------------------------------------------

loc_6C45:				; CODE XREF: _ures_findSubResource_56+ACj
		mov	eax, [ebp+arg_4]
		movsx	ecx, byte ptr [eax]
		test	ecx, ecx
		jnz	short loc_6BD7

loc_6C4F:				; CODE XREF: _ures_findSubResource_56+B7j
		mov	eax, [ebp+var_14]

loc_6C52:				; CODE XREF: _ures_findSubResource_56+49j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN12
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_ures_findSubResource_56 endp

; ---------------------------------------------------------------------------
		align 4
$LN12		dd 1			; DATA XREF: _ures_findSubResource_56+CAo
		dd offset $LN11
$LN11		dd 0FFFFFFE0h, 4	; DATA XREF: .text:00006C7Co
		dd offset $LN10
$LN10		dd 79656Bh		; DATA XREF: .text:00006C88o
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6C90h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _ures_getStringByKeyWithFallback_56
_ures_getStringByKeyWithFallback_56 proc near

var_17C		= byte ptr -17Ch
var_B8		= dword	ptr -0B8h
var_AC		= dword	ptr -0ACh
Dst		= byte ptr -0A0h
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
Str		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 17Ch
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_17C]
		mov	ecx, 5Fh ; '_'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	[ebp+var_AC], 0
		lea	eax, [ebp+Dst]
		push	eax		; Dst
		call	_ures_initStackObject_56
		add	esp, 4
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+Dst]
		push	ecx		; int
		mov	edx, [ebp+Str]
		push	edx		; Str
		mov	eax, [ebp+arg_0]
		push	eax		; int
		call	_ures_getByKeyWithFallback_56
		add	esp, 10h
		mov	eax, [ebp+arg_C]
		push	eax
		lea	ecx, [ebp+var_B8]
		push	ecx
		lea	edx, [ebp+Dst]
		push	edx
		call	_ures_getString_56
		add	esp, 0Ch
		mov	[ebp+var_AC], eax
		lea	eax, [ebp+Dst]
		push	eax
		call	_ures_close_56
		add	esp, 4
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_6D34
		xor	eax, eax
		jmp	short loc_6DA6
; ---------------------------------------------------------------------------

loc_6D34:				; CODE XREF: _ures_getStringByKeyWithFallback_56+9Ej
		cmp	[ebp+var_B8], 3
		jnz	short loc_6D8F
		mov	eax, [ebp+var_AC]
		movzx	ecx, word ptr [eax]
		cmp	ecx, 2205h
		jnz	short loc_6D8F
		mov	eax, [ebp+var_AC]
		movzx	ecx, word ptr [eax+2]
		cmp	ecx, 2205h
		jnz	short loc_6D8F
		mov	eax, [ebp+var_AC]
		movzx	ecx, word ptr [eax+4]
		cmp	ecx, 2205h
		jnz	short loc_6D8F
		mov	[ebp+var_AC], 0
		mov	[ebp+var_B8], 0
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 2

loc_6D8F:				; CODE XREF: _ures_getStringByKeyWithFallback_56+ABj
					; _ures_getStringByKeyWithFallback_56+BCj ...
		cmp	[ebp+arg_8], 0
		jz	short loc_6DA0
		mov	eax, [ebp+arg_8]
		mov	ecx, [ebp+var_B8]
		mov	[eax], ecx

loc_6DA0:				; CODE XREF: _ures_getStringByKeyWithFallback_56+103j
		mov	eax, [ebp+var_AC]

loc_6DA6:				; CODE XREF: _ures_getStringByKeyWithFallback_56+A2j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN9_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 17Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_ures_getStringByKeyWithFallback_56 endp

; ---------------------------------------------------------------------------
		align 4
$LN9_0		dd 2			; DATA XREF: _ures_getStringByKeyWithFallback_56+11Ao
		dd offset $LN8_1
$LN8_1		dd 0FFFFFF60h, 98h	; DATA XREF: .text:00006DDCo
		dd offset $LN6_2	; "stack"
		dd 0FFFFFF48h, 4
		dd offset $LN7_1	; "length"
$LN7_1		db 'length',0           ; DATA XREF: .text:00006DF4o
$LN6_2		db 'stack',0            ; DATA XREF: .text:00006DE8o
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6E08h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl ures_getByKeyWithFallback_56(int,	char *Str, int,	enum UErrorCode	*)
		public _ures_getByKeyWithFallback_56
_ures_getByKeyWithFallback_56 proc near	; CODE XREF: _ures_getStringByKeyWithFallback_56+54p

var_18C		= byte ptr -18Ch
var_188		= byte ptr -188h
var_178		= dword	ptr -178h
var_AC		= dword	ptr -0ACh
var_A0		= dword	ptr -0A0h
var_94		= dword	ptr -94h
var_88		= byte ptr -88h
var_48		= dword	ptr -48h
var_3C		= dword	ptr -3Ch
var_30		= dword	ptr -30h
var_24		= dword	ptr -24h
var_18		= dword	ptr -18h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
Str		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 18Ch
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_18C]
		mov	ecx, 63h ; 'c'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	[ebp+var_C], 0FFFFFFFFh
		mov	[ebp+var_18], 0FFFFFFFFh
		mov	[ebp+var_24], 0
		cmp	[ebp+arg_C], 0
		jz	short loc_6E60
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_6E68

loc_6E60:				; CODE XREF: _ures_getByKeyWithFallback_56+41j
		mov	eax, [ebp+arg_8]
		jmp	loc_7179
; ---------------------------------------------------------------------------

loc_6E68:				; CODE XREF: _ures_getByKeyWithFallback_56+56j
		cmp	[ebp+arg_0], 0
		jnz	short loc_6E7F
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 1
		mov	eax, [ebp+arg_8]
		jmp	loc_7179
; ---------------------------------------------------------------------------

loc_6E7F:				; CODE XREF: _ures_getByKeyWithFallback_56+64j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+80h]
		shr	ecx, 1Ch
		mov	[ebp+var_30], ecx
		cmp	[ebp+var_30], 2
		jz	short loc_6EA4
		cmp	[ebp+var_30], 5
		jz	short loc_6EA4
		cmp	[ebp+var_30], 4
		jnz	loc_7161

loc_6EA4:				; CODE XREF: _ures_getByKeyWithFallback_56+8Aj
					; _ures_getByKeyWithFallback_56+90j
		mov	eax, [ebp+Str]
		push	eax		; char *
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+80h]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		add	eax, 14h
		push	eax		; int
		call	?getTableItemByKeyPath@@YAIPBUResourceData@@IPBD@Z ; getTableItemByKeyPath(ResourceData	const *,uint,char const	*)
		add	esp, 0Ch
		mov	[ebp+var_C], eax
		mov	eax, [ebp+Str]
		mov	[ebp+var_3C], eax
		cmp	[ebp+var_C], 0FFFFFFFFh
		jnz	loc_712E
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	[ebp+var_48], ecx
		lea	ecx, [ebp+var_88] ; this
		call	??0CharString@icu_56@@QAE@XZ ; icu_56::CharString::CharString(void)
		mov	[ebp+var_94], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		mov	[ebp+var_A0], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+7Ch]
		mov	[ebp+var_AC], ecx

loc_6F0A:				; CODE XREF: _ures_getByKeyWithFallback_56:loc_709Aj
		cmp	[ebp+var_C], 0FFFFFFFFh
		jnz	loc_709F
		mov	eax, [ebp+var_48]
		cmp	dword ptr [eax+8], 0
		jz	loc_709F
		mov	eax, [ebp+var_48]
		mov	ecx, [eax+8]
		mov	[ebp+var_48], ecx
		mov	eax, [ebp+var_48]
		mov	ecx, [eax+24h]
		mov	[ebp+var_18], ecx
		mov	eax, [ebp+var_48]
		cmp	dword ptr [eax+44h], 0
		jnz	loc_709A
		lea	ecx, [ebp+var_88] ; this
		call	?clear@CharString@icu_56@@QAEAAV12@XZ ;	icu_56::CharString::clear(void)
		cmp	[ebp+var_AC], 0
		jle	short loc_6F71
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_AC]
		push	ecx		; int
		mov	edx, [ebp+var_A0]
		push	edx		; char *
		lea	ecx, [ebp+var_88] ; this
		call	?append@CharString@icu_56@@QAEAAV12@PBDHAAW4UErrorCode@@@Z ; icu_56::CharString::append(char const *,int,UErrorCode &)

loc_6F71:				; CODE XREF: _ures_getByKeyWithFallback_56+14Aj
		mov	eax, [ebp+Str]
		push	eax		; char *
		lea	ecx, [ebp+var_188] ; this
		call	??0StringPiece@icu_56@@QAE@PBD@Z ; icu_56::StringPiece::StringPiece(char const *)
		mov	ecx, [ebp+arg_C]
		push	ecx		; enum UErrorCode *
		lea	edx, [ebp+var_188]
		push	edx		; struct icu_56::StringPiece *
		lea	ecx, [ebp+var_88] ; this
		call	?append@CharString@icu_56@@QAEAAV12@ABVStringPiece@2@AAW4UErrorCode@@@Z	; icu_56::CharString::append(icu_56::StringPiece const &,UErrorCode &)
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_6FD6
		mov	eax, [ebp+var_24]
		push	eax
		call	_ures_close_56
		add	esp, 4
		mov	eax, [ebp+arg_8]
		mov	[ebp+var_178], eax
		lea	ecx, [ebp+var_88] ; this
		call	??1CharString@icu_56@@QAE@XZ ; icu_56::CharString::~CharString(void)
		mov	eax, [ebp+var_178]
		jmp	loc_7179
; ---------------------------------------------------------------------------

loc_6FD6:				; CODE XREF: _ures_getByKeyWithFallback_56+1A1j
		lea	ecx, [ebp+var_88] ; this
		call	?data@CharString@icu_56@@QAEPADXZ ; icu_56::CharString::data(void)
		mov	[ebp+var_94], eax
		mov	eax, [ebp+Str]
		mov	[ebp+var_3C], eax

loc_6FED:				; CODE XREF: _ures_getByKeyWithFallback_56+28Cj
		lea	eax, [ebp+var_3C]
		push	eax
		lea	ecx, [ebp+var_94]
		push	ecx
		mov	edx, [ebp+var_18]
		push	edx
		mov	eax, [ebp+var_48]
		add	eax, 14h
		push	eax
		call	_res_findResource_56
		add	esp, 10h
		mov	[ebp+var_C], eax
		mov	eax, [ebp+var_C]
		shr	eax, 1Ch
		cmp	eax, 3
		jnz	short loc_7089
		mov	eax, [ebp+var_94]
		movsx	ecx, byte ptr [eax]
		test	ecx, ecx
		jz	short loc_7089
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+var_24]
		push	ecx		; int
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	eax, [ebp+var_48]
		push	eax		; int
		push	0FFFFFFFFh	; int
		push	0		; Str
		mov	ecx, [ebp+var_C]
		push	ecx		; int
		mov	edx, [ebp+var_48]
		add	edx, 14h
		push	edx		; Src
		call	?init_resb_result@@YAPAUUResourceBundle@@PBUResourceData@@IPBDHPAUUResourceDataEntry@@PBU1@HPAU1@PAW4UErrorCode@@@Z ; init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode	*)
		add	esp, 24h
		mov	[ebp+var_24], eax
		cmp	[ebp+var_24], 0
		jz	short loc_7087
		mov	eax, [ebp+var_24]
		mov	ecx, [eax+4]
		mov	[ebp+var_48], ecx
		mov	eax, [ebp+var_24]
		mov	ecx, [eax+80h]
		mov	[ebp+var_18], ecx
		mov	eax, [ebp+var_24]
		mov	ecx, [eax+10h]
		mov	[ebp+var_A0], ecx
		mov	eax, [ebp+var_24]
		mov	ecx, [eax+7Ch]
		mov	[ebp+var_AC], ecx
		jmp	short loc_7089
; ---------------------------------------------------------------------------

loc_7087:				; CODE XREF: _ures_getByKeyWithFallback_56+24Ej
		jmp	short loc_709A
; ---------------------------------------------------------------------------

loc_7089:				; CODE XREF: _ures_getByKeyWithFallback_56+20Fj
					; _ures_getByKeyWithFallback_56+21Cj ...
		mov	eax, [ebp+var_94]
		movsx	ecx, byte ptr [eax]
		test	ecx, ecx
		jnz	loc_6FED

loc_709A:				; CODE XREF: _ures_getByKeyWithFallback_56+132j
					; _ures_getByKeyWithFallback_56:loc_7087j
		jmp	loc_6F0A
; ---------------------------------------------------------------------------

loc_709F:				; CODE XREF: _ures_getByKeyWithFallback_56+106j
					; _ures_getByKeyWithFallback_56+113j
		cmp	[ebp+var_C], 0FFFFFFFFh
		jz	short loc_7118
		call	_uloc_getDefault_56
		push	eax		; Str2
		mov	eax, [ebp+var_48]
		mov	ecx, [eax]
		push	ecx		; Str1
		call	_strcmp
		add	esp, 8
		test	eax, eax
		jz	short loc_70D4
		push	offset ??_C@_04NBFCGMPH@root?$AA@ ; "root"
		mov	eax, [ebp+var_48]
		mov	ecx, [eax]
		push	ecx		; Str1
		call	_strcmp
		add	esp, 8
		test	eax, eax
		jnz	short loc_70DF

loc_70D4:				; CODE XREF: _ures_getByKeyWithFallback_56+2B3j
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 0FFFFFF81h
		jmp	short loc_70E8
; ---------------------------------------------------------------------------

loc_70DF:				; CODE XREF: _ures_getByKeyWithFallback_56+2CAj
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 0FFFFFF80h

loc_70E8:				; CODE XREF: _ures_getByKeyWithFallback_56+2D5j
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	eax, [ebp+var_48]
		push	eax		; int
		push	0FFFFFFFFh	; int
		mov	ecx, [ebp+Str]
		push	ecx		; Str
		mov	edx, [ebp+var_C]
		push	edx		; int
		mov	eax, [ebp+var_48]
		add	eax, 14h
		push	eax		; Src
		call	?init_resb_result@@YAPAUUResourceBundle@@PBUResourceData@@IPBDHPAUUResourceDataEntry@@PBU1@HPAU1@PAW4UErrorCode@@@Z ; init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode	*)
		add	esp, 24h
		mov	[ebp+arg_8], eax
		jmp	short loc_7121
; ---------------------------------------------------------------------------

loc_7118:				; CODE XREF: _ures_getByKeyWithFallback_56+29Bj
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 2

loc_7121:				; CODE XREF: _ures_getByKeyWithFallback_56+30Ej
		lea	ecx, [ebp+var_88] ; this
		call	??1CharString@icu_56@@QAE@XZ ; icu_56::CharString::~CharString(void)
		jmp	short loc_715F
; ---------------------------------------------------------------------------

loc_712E:				; CODE XREF: _ures_getByKeyWithFallback_56+C6j
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		push	ecx		; int
		push	0FFFFFFFFh	; int
		mov	edx, [ebp+var_3C]
		push	edx		; Str
		mov	eax, [ebp+var_C]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		add	ecx, 14h
		push	ecx		; Src
		call	?init_resb_result@@YAPAUUResourceBundle@@PBUResourceData@@IPBDHPAUUResourceDataEntry@@PBU1@HPAU1@PAW4UErrorCode@@@Z ; init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode	*)
		add	esp, 24h
		mov	[ebp+arg_8], eax

loc_715F:				; CODE XREF: _ures_getByKeyWithFallback_56+324j
		jmp	short loc_716A
; ---------------------------------------------------------------------------

loc_7161:				; CODE XREF: _ures_getByKeyWithFallback_56+96j
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 11h

loc_716A:				; CODE XREF: _ures_getByKeyWithFallback_56:loc_715Fj
		mov	eax, [ebp+var_24]
		push	eax
		call	_ures_close_56
		add	esp, 4
		mov	eax, [ebp+arg_8]

loc_7179:				; CODE XREF: _ures_getByKeyWithFallback_56+5Bj
					; _ures_getByKeyWithFallback_56+72j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN31
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 18Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_ures_getByKeyWithFallback_56 endp

; ---------------------------------------------------------------------------
$LN31		dd 3			; DATA XREF: _ures_getByKeyWithFallback_56+375o
		dd offset $LN30
$LN30		dd 0FFFFFFC4h, 4	; DATA XREF: .text:000071ACo
		dd offset $LN27		; "key"
		dd 0FFFFFF78h, 38h
		dd offset $LN28		; "path"
		dd 0FFFFFF6Ch, 4
		dd offset $LN29		; "myPath"
$LN29		db 'myPath',0           ; DATA XREF: .text:000071D0o
$LN28		db 'path',0             ; DATA XREF: .text:000071C4o
$LN27		db 'key',0              ; DATA XREF: .text:000071B8o
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 71E4h
		public ??_C@_04NBFCGMPH@root?$AA@
; char `string'[]
??_C@_04NBFCGMPH@root?$AA@ db 'root',0  ; DATA XREF: _ures_getByKeyWithFallback_56+2B5o
					; getFallbackData(UResourceBundle const	*,char const * *,UResourceDataEntry * *,uint *,UErrorCode *)+103o ...
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 71ECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl getTableItemByKeyPath(int, int, char *)
?getTableItemByKeyPath@@YAIPBUResourceData@@IPBD@Z proc	near
					; CODE XREF: _ures_getByKeyWithFallback_56+B1p

var_198		= byte ptr -198h
var_194		= byte ptr -194h
var_184		= dword	ptr -184h
var_178		= dword	ptr -178h
var_16C		= dword	ptr -16Ch
var_A0		= dword	ptr -0A0h
var_94		= byte ptr -94h
var_88		= dword	ptr -88h
var_7C		= dword	ptr -7Ch
Str		= dword	ptr -70h
var_64		= dword	ptr -64h
var_58		= byte ptr -58h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?getTableItemByKeyPath@@YAIPBUResourceData@@IPBD@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 18Ch
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_198]
		mov	ecx, 63h ; 'c'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_18], eax
		lea	ecx, [ebp+var_58] ; this
		call	??0CharString@icu_56@@QAE@XZ ; icu_56::CharString::CharString(void)
		mov	[ebp+var_4], 0
		mov	[ebp+var_64], 0
		mov	eax, [ebp+arg_8]
		push	eax		; char *
		lea	ecx, [ebp+var_194] ; this
		call	??0StringPiece@icu_56@@QAE@PBD@Z ; icu_56::StringPiece::StringPiece(char const *)
		lea	ecx, [ebp+var_64]
		push	ecx		; enum UErrorCode *
		lea	edx, [ebp+var_194]
		push	edx		; struct icu_56::StringPiece *
		lea	ecx, [ebp+var_58] ; this
		call	?append@CharString@icu_56@@QAEAAV12@ABVStringPiece@2@AAW4UErrorCode@@@Z	; icu_56::CharString::append(icu_56::StringPiece const &,UErrorCode &)
		mov	eax, [ebp+var_64]
		push	eax
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_72A1
		mov	[ebp+var_184], 0FFFFFFFFh
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_58] ; this
		call	??1CharString@icu_56@@QAE@XZ ; icu_56::CharString::~CharString(void)
		mov	eax, [ebp+var_184]
		jmp	loc_73C4
; ---------------------------------------------------------------------------

loc_72A1:				; CODE XREF: getTableItemByKeyPath(ResourceData	const *,uint,char const	*)+8Fj
		lea	ecx, [ebp+var_58] ; this
		call	?data@CharString@icu_56@@QAEPADXZ ; icu_56::CharString::data(void)
		mov	[ebp+Str], eax
		mov	eax, [ebp+var_18]
		shr	eax, 1Ch
		mov	[ebp+var_7C], eax

loc_72B5:				; CODE XREF: getTableItemByKeyPath(ResourceData	const *,uint,char const	*)+18Aj
		mov	eax, [ebp+Str]
		movsx	ecx, byte ptr [eax]
		test	ecx, ecx
		jz	loc_737B
		cmp	[ebp+var_18], 0FFFFFFFFh
		jz	loc_737B
		cmp	[ebp+var_7C], 2
		jz	short loc_72EF
		cmp	[ebp+var_7C], 5
		jz	short loc_72EF
		cmp	[ebp+var_7C], 4
		jz	short loc_72EF
		cmp	[ebp+var_7C], 8
		jz	short loc_72EF
		cmp	[ebp+var_7C], 9
		jnz	loc_737B

loc_72EF:				; CODE XREF: getTableItemByKeyPath(ResourceData	const *,uint,char const	*)+E5j
					; getTableItemByKeyPath(ResourceData const *,uint,char const *)+EBj ...
		push	2Fh ; '/'       ; Val
		mov	eax, [ebp+Str]
		push	eax		; Str
		call	?strchr@@YAPADPADH@Z ; strchr(char *,int)
		add	esp, 8
		mov	[ebp+var_88], eax
		cmp	[ebp+var_88], 0
		jz	short loc_7326
		mov	eax, [ebp+var_88]
		mov	byte ptr [eax],	0
		mov	eax, [ebp+var_88]
		add	eax, 1
		mov	[ebp+var_88], eax
		jmp	short loc_733A
; ---------------------------------------------------------------------------

loc_7326:				; CODE XREF: getTableItemByKeyPath(ResourceData	const *,uint,char const	*)+11Ej
		push	0		; Val
		mov	eax, [ebp+Str]
		push	eax		; Str
		call	?strchr@@YAPADPADH@Z ; strchr(char *,int)
		add	esp, 8
		mov	[ebp+var_88], eax

loc_733A:				; CODE XREF: getTableItemByKeyPath(ResourceData	const *,uint,char const	*)+138j
		mov	eax, [ebp+Str]
		mov	[ebp+var_A0], eax
		lea	eax, [ebp+var_A0]
		push	eax
		lea	ecx, [ebp+var_94]
		push	ecx
		mov	edx, [ebp+var_18]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		call	_res_getTableItemByKey_56
		add	esp, 10h
		mov	[ebp+var_18], eax
		mov	eax, [ebp+var_18]
		shr	eax, 1Ch
		mov	[ebp+var_7C], eax
		mov	eax, [ebp+var_88]
		mov	[ebp+Str], eax
		jmp	loc_72B5
; ---------------------------------------------------------------------------

loc_737B:				; CODE XREF: getTableItemByKeyPath(ResourceData	const *,uint,char const	*)+D1j
					; getTableItemByKeyPath(ResourceData const *,uint,char const *)+DBj ...
		mov	eax, [ebp+Str]
		movsx	ecx, byte ptr [eax]
		test	ecx, ecx
		jz	short loc_73A6
		mov	[ebp+var_178], 0FFFFFFFFh
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_58] ; this
		call	??1CharString@icu_56@@QAE@XZ ; icu_56::CharString::~CharString(void)
		mov	eax, [ebp+var_178]
		jmp	short loc_73C4
; ---------------------------------------------------------------------------

loc_73A6:				; CODE XREF: getTableItemByKeyPath(ResourceData	const *,uint,char const	*)+197j
		mov	eax, [ebp+var_18]
		mov	[ebp+var_16C], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_58] ; this
		call	??1CharString@icu_56@@QAE@XZ ; icu_56::CharString::~CharString(void)
		mov	eax, [ebp+var_16C]

loc_73C4:				; CODE XREF: getTableItemByKeyPath(ResourceData	const *,uint,char const	*)+B0j
					; getTableItemByKeyPath(ResourceData const *,uint,char const *)+1B8j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN18_3
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 198h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getTableItemByKeyPath@@YAIPBUResourceData@@IPBD@Z endp

; ---------------------------------------------------------------------------
		align 10h
$LN18_3		dd 4			; DATA XREF: getTableItemByKeyPath(ResourceData	const *,uint,char const	*)+1DCo
		dd offset $LN17_1
$LN17_1		dd 0FFFFFFA8h, 38h	; DATA XREF: .text:00007404o
		dd offset $LN12_0	; "path"
		dd 0FFFFFF9Ch, 4
		dd offset $LN13		; "errorCode"
		dd 0FFFFFF6Ch, 4
		dd offset $LN14		; "t"
		dd 0FFFFFF60h, 4
		dd offset $LN15		; "pathP"
$LN15		db 'pathP',0            ; DATA XREF: .text:00007434o
$LN14		db 't',0                ; DATA XREF: .text:00007428o
$LN13		db 'errorCode',0        ; DATA XREF: .text:0000741Co
$LN12_0		db 'path',0             ; DATA XREF: .text:00007410o
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 7450h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getTableItemByKeyPath@@YAIPBUResourceData@@IPBD@Z$0 proc near
					; DATA XREF: .xdata$x:00007484o
		lea	ecx, [ebp-58h]	; this
		jmp	??1CharString@icu_56@@QAE@XZ ; icu_56::CharString::~CharString(void)
__unwindfunclet$?getTableItemByKeyPath@@YAIPBUResourceData@@IPBD@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?getTableItemByKeyPath@@YAIPBUResourceData@@IPBD@Z proc near
					; DATA XREF: getTableItemByKeyPath(ResourceData	const *,uint,char const	*)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-19Ch]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?getTableItemByKeyPath@@YAIPBUResourceData@@IPBD@Z
		jmp	___CxxFrameHandler3
__ehhandler$?getTableItemByKeyPath@@YAIPBUResourceData@@IPBD@Z endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 7480h
__unwindtable$?getTableItemByKeyPath@@YAIPBUResourceData@@IPBD@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00007490o
		dd offset __unwindfunclet$?getTableItemByKeyPath@@YAIPBUResourceData@@IPBD@Z$0
__ehfuncinfo$?getTableItemByKeyPath@@YAIPBUResourceData@@IPBD@Z	dd 19930522h, 1
					; DATA XREF: __ehhandler$?getTableItemByKeyPath@@YAIPBUResourceData@@IPBD@Z+1Eo
		dd offset __unwindtable$?getTableItemByKeyPath@@YAIPBUResourceData@@IPBD@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 74ACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _ures_getByKey_56
_ures_getByKey_56 proc near		; CODE XREF: _ures_getStringByKey_56+16Cp
					; _ures_getStringByKey_56+21Dp	...

var_108		= byte ptr -108h
Src		= dword	ptr -44h
var_38		= byte ptr -38h
var_2C		= dword	ptr -2Ch
Str		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 108h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_108]
		mov	ecx, 42h ; 'B'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0FFFFFFFFh
		mov	[ebp+var_14], 0
		mov	eax, [ebp+arg_4]
		mov	[ebp+Str], eax
		cmp	[ebp+arg_C], 0
		jz	short loc_74F9
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_7501

loc_74F9:				; CODE XREF: _ures_getByKey_56+36j
		mov	eax, [ebp+arg_8]
		jmp	loc_7634
; ---------------------------------------------------------------------------

loc_7501:				; CODE XREF: _ures_getByKey_56+4Bj
		cmp	[ebp+arg_0], 0
		jnz	short loc_7518
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 1
		mov	eax, [ebp+arg_8]
		jmp	loc_7634
; ---------------------------------------------------------------------------

loc_7518:				; CODE XREF: _ures_getByKey_56+59j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+80h]
		shr	ecx, 1Ch
		mov	[ebp+var_2C], ecx
		cmp	[ebp+var_2C], 2
		jz	short loc_753D
		cmp	[ebp+var_2C], 5
		jz	short loc_753D
		cmp	[ebp+var_2C], 4
		jnz	loc_7628

loc_753D:				; CODE XREF: _ures_getByKey_56+7Fj
					; _ures_getByKey_56+85j
		lea	eax, [ebp+Str]
		push	eax
		lea	ecx, [ebp+var_38]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+80h]
		push	eax
		mov	ecx, [ebp+arg_0]
		add	ecx, 14h
		push	ecx
		call	_res_getTableItemByKey_56
		add	esp, 10h
		mov	[ebp+var_8], eax
		cmp	[ebp+var_8], 0FFFFFFFFh
		jnz	loc_75F6
		mov	eax, [ebp+arg_4]
		mov	[ebp+Str], eax
		mov	eax, [ebp+arg_0]
		movsx	ecx, byte ptr [eax+84h]
		cmp	ecx, 1
		jnz	short loc_75EB
		mov	eax, [ebp+arg_C]
		push	eax
		lea	ecx, [ebp+var_8]
		push	ecx
		lea	edx, [ebp+var_14]
		push	edx
		lea	eax, [ebp+Str]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?getFallbackData@@YAPBUResourceData@@PBUUResourceBundle@@PAPBDPAPAUUResourceDataEntry@@PAIPAW4UErrorCode@@@Z ; getFallbackData(UResourceBundle const *,char const * *,UResourceDataEntry * *,uint *,UErrorCode *)
		add	esp, 14h
		mov	[ebp+Src], eax
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_75E0
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	eax, [ebp+var_14]
		push	eax		; int
		push	0FFFFFFFFh	; int
		mov	ecx, [ebp+Str]
		push	ecx		; Str
		mov	edx, [ebp+var_8]
		push	edx		; int
		mov	eax, [ebp+Src]
		push	eax		; Src
		call	?init_resb_result@@YAPAUUResourceBundle@@PBUResourceData@@IPBDHPAUUResourceDataEntry@@PBU1@HPAU1@PAW4UErrorCode@@@Z ; init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode	*)
		add	esp, 24h
		jmp	short loc_7634
; ---------------------------------------------------------------------------
		jmp	short loc_75E9
; ---------------------------------------------------------------------------

loc_75E0:				; CODE XREF: _ures_getByKey_56+106j
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 2

loc_75E9:				; CODE XREF: _ures_getByKey_56+132j
		jmp	short loc_75F4
; ---------------------------------------------------------------------------

loc_75EB:				; CODE XREF: _ures_getByKey_56+D2j
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 2

loc_75F4:				; CODE XREF: _ures_getByKey_56:loc_75E9j
		jmp	short loc_7626
; ---------------------------------------------------------------------------

loc_75F6:				; CODE XREF: _ures_getByKey_56+B9j
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		push	ecx		; int
		push	0FFFFFFFFh	; int
		mov	edx, [ebp+Str]
		push	edx		; Str
		mov	eax, [ebp+var_8]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		add	ecx, 14h
		push	ecx		; Src
		call	?init_resb_result@@YAPAUUResourceBundle@@PBUResourceData@@IPBDHPAUUResourceDataEntry@@PBU1@HPAU1@PAW4UErrorCode@@@Z ; init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode	*)
		add	esp, 24h
		jmp	short loc_7634
; ---------------------------------------------------------------------------

loc_7626:				; CODE XREF: _ures_getByKey_56:loc_75F4j
		jmp	short loc_7631
; ---------------------------------------------------------------------------

loc_7628:				; CODE XREF: _ures_getByKey_56+8Bj
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 11h

loc_7631:				; CODE XREF: _ures_getByKey_56:loc_7626j
		mov	eax, [ebp+arg_8]

loc_7634:				; CODE XREF: _ures_getByKey_56+50j
					; _ures_getByKey_56+67j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN20_2
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 108h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_ures_getByKey_56 endp

; ---------------------------------------------------------------------------
		align 4
$LN20_2		dd 4			; DATA XREF: _ures_getByKey_56+18Co
		dd offset $LN19_3
$LN19_3		dd 0FFFFFFF8h, 4	; DATA XREF: .text:00007660o
		dd offset $LN15_0	; "res"
		dd 0FFFFFFECh, 4
		dd offset $LN16_1	; "realData"
		dd 0FFFFFFE0h, 4
		dd offset $LN17_2
		dd 0FFFFFFC8h, 4
		dd offset $LN18_4
$LN18_4		db 74h,	0		; DATA XREF: .text:00007690o
$LN17_2		dw 656Bh		; DATA XREF: .text:00007684o
		db 79h,	0
$LN16_1		db 'realData',0         ; DATA XREF: .text:00007678o
$LN15_0		db 'res',0              ; DATA XREF: .text:0000766Co
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 76A8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct ResourceData const * __cdecl getFallbackData(struct UResourceBundle const *, char const * *, struct UResourceDataEntry	* *, unsigned int *, enum  UErrorCode *)
?getFallbackData@@YAPBUResourceData@@PBUUResourceBundle@@PAPBDPAPAUUResourceDataEntry@@PAIPAW4UErrorCode@@@Z proc near
					; CODE XREF: _ures_getByKey_56+E8p
					; _ures_getStringByKey_56+F1p

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	[ebp+var_8], ecx
		mov	[ebp+var_14], 0FFFFFFFFh
		mov	[ebp+var_20], 0
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 0FFFFFFFFh
		cmp	[ebp+var_8], 0
		jz	loc_77F7
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+44h], 0
		jnz	short loc_7725
		mov	eax, [ebp+arg_4]
		push	eax
		lea	ecx, [ebp+var_14]
		push	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx+24h]
		push	eax
		mov	ecx, [ebp+var_8]
		add	ecx, 14h
		push	ecx
		call	_res_getTableItemByKey_56
		add	esp, 10h
		mov	edx, [ebp+arg_C]
		mov	[edx], eax
		mov	eax, [ebp+var_20]
		add	eax, 1
		mov	[ebp+var_20], eax

loc_7725:				; CODE XREF: getFallbackData(UResourceBundle const *,char const	* *,UResourceDataEntry * *,uint	*,UErrorCode *)+4Fj
		mov	eax, [ebp+arg_0]
		movsx	ecx, byte ptr [eax+84h]
		cmp	ecx, 1
		jnz	short loc_7785

loc_7734:				; CODE XREF: getFallbackData(UResourceBundle const *,char const	* *,UResourceDataEntry * *,uint	*,UErrorCode *):loc_7783j
		mov	eax, [ebp+arg_C]
		cmp	dword ptr [eax], 0FFFFFFFFh
		jnz	short loc_7785
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+8], 0
		jz	short loc_7785
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+44h], 0
		jnz	short loc_7783
		mov	eax, [ebp+var_20]
		add	eax, 1
		mov	[ebp+var_20], eax
		mov	eax, [ebp+arg_4]
		push	eax
		lea	ecx, [ebp+var_14]
		push	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx+24h]
		push	eax
		mov	ecx, [ebp+var_8]
		add	ecx, 14h
		push	ecx
		call	_res_getTableItemByKey_56
		add	esp, 10h
		mov	edx, [ebp+arg_C]
		mov	[edx], eax

loc_7783:				; CODE XREF: getFallbackData(UResourceBundle const *,char const	* *,UResourceDataEntry * *,uint	*,UErrorCode *)+ADj
		jmp	short loc_7734
; ---------------------------------------------------------------------------

loc_7785:				; CODE XREF: getFallbackData(UResourceBundle const *,char const	* *,UResourceDataEntry * *,uint	*,UErrorCode *)+8Aj
					; getFallbackData(UResourceBundle const	*,char const * *,UResourceDataEntry * *,uint *,UErrorCode *)+92j ...
		mov	eax, [ebp+arg_C]
		cmp	dword ptr [eax], 0FFFFFFFFh
		jz	short loc_77E8
		cmp	[ebp+var_20], 1
		jle	short loc_77D6
		call	_uloc_getDefault_56
		push	eax		; Str2
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		push	ecx		; Str1
		call	_strcmp
		add	esp, 8
		test	eax, eax
		jz	short loc_77C2
		push	offset ??_C@_04NBFCGMPH@root?$AA@ ; "root"
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		push	ecx		; Str1
		call	_strcmp
		add	esp, 8
		test	eax, eax
		jnz	short loc_77CD

loc_77C2:				; CODE XREF: getFallbackData(UResourceBundle const *,char const	* *,UResourceDataEntry * *,uint	*,UErrorCode *)+101j
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 0FFFFFF81h
		jmp	short loc_77D6
; ---------------------------------------------------------------------------

loc_77CD:				; CODE XREF: getFallbackData(UResourceBundle const *,char const	* *,UResourceDataEntry * *,uint	*,UErrorCode *)+118j
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 0FFFFFF80h

loc_77D6:				; CODE XREF: getFallbackData(UResourceBundle const *,char const	* *,UResourceDataEntry * *,uint	*,UErrorCode *)+E9j
					; getFallbackData(UResourceBundle const	*,char const * *,UResourceDataEntry * *,uint *,UErrorCode *)+123j
		mov	eax, [ebp+arg_8]
		mov	ecx, [ebp+var_8]
		mov	[eax], ecx
		mov	eax, [ebp+var_8]
		add	eax, 14h
		jmp	short loc_7802
; ---------------------------------------------------------------------------
		jmp	short loc_77F5
; ---------------------------------------------------------------------------

loc_77E8:				; CODE XREF: getFallbackData(UResourceBundle const *,char const	* *,UResourceDataEntry * *,uint	*,UErrorCode *)+E3j
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 2
		xor	eax, eax
		jmp	short loc_7802
; ---------------------------------------------------------------------------

loc_77F5:				; CODE XREF: getFallbackData(UResourceBundle const *,char const	* *,UResourceDataEntry * *,uint	*,UErrorCode *)+13Ej
		jmp	short loc_7802
; ---------------------------------------------------------------------------

loc_77F7:				; CODE XREF: getFallbackData(UResourceBundle const *,char const	* *,UResourceDataEntry * *,uint	*,UErrorCode *)+42j
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 2
		xor	eax, eax

loc_7802:				; CODE XREF: getFallbackData(UResourceBundle const *,char const	* *,UResourceDataEntry * *,uint	*,UErrorCode *)+13Cj
					; getFallbackData(UResourceBundle const	*,char const * *,UResourceDataEntry * *,uint *,UErrorCode *)+14Bj ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN18_5
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getFallbackData@@YAPBUResourceData@@PBUUResourceBundle@@PAPBDPAPAUUResourceDataEntry@@PAIPAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN18_5		dd 1			; DATA XREF: getFallbackData(UResourceBundle const *,char const	* *,UResourceDataEntry * *,uint	*,UErrorCode *)+15Eo
		dd offset $LN17_3
$LN17_3		dd 0FFFFFFECh, 4	; DATA XREF: .text:0000782Co
		dd offset $LN16_2	; "indexR"
$LN16_2		db 'indexR',0           ; DATA XREF: .text:00007838o
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7844h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _ures_getStringByKey_56
_ures_getStringByKey_56	proc near	; CODE XREF: _ures_getUTF8StringByKey_56+2Ep
					; _ures_getVersionNumberInternal_56+57p ...

var_13C		= dword	ptr -13Ch
var_74		= dword	ptr -74h
var_68		= dword	ptr -68h
var_5C		= dword	ptr -5Ch
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 13Ch
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_13C]
		mov	ecx, 4Fh ; 'O'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0FFFFFFFFh
		mov	[ebp+var_14], 0
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_20], eax
		cmp	[ebp+arg_C], 0
		jz	short loc_7891
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_7898

loc_7891:				; CODE XREF: _ures_getStringByKey_56+36j
		xor	eax, eax
		jmp	loc_7AAA
; ---------------------------------------------------------------------------

loc_7898:				; CODE XREF: _ures_getStringByKey_56+4Bj
		cmp	[ebp+arg_0], 0
		jnz	short loc_78AE
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	loc_7AAA
; ---------------------------------------------------------------------------

loc_78AE:				; CODE XREF: _ures_getStringByKey_56+58j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+80h]
		shr	ecx, 1Ch
		mov	[ebp+var_2C], ecx
		cmp	[ebp+var_2C], 2
		jz	short loc_78D3
		cmp	[ebp+var_2C], 5
		jz	short loc_78D3
		cmp	[ebp+var_2C], 4
		jnz	loc_7A9F

loc_78D3:				; CODE XREF: _ures_getStringByKey_56+7Dj
					; _ures_getStringByKey_56+83j
		mov	[ebp+var_38], 0
		lea	eax, [ebp+var_20]
		push	eax
		lea	ecx, [ebp+var_38]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+80h]
		push	eax
		mov	ecx, [ebp+arg_0]
		add	ecx, 14h
		push	ecx
		call	_res_getTableItemByKey_56
		add	esp, 10h
		mov	[ebp+var_8], eax
		cmp	[ebp+var_8], 0FFFFFFFFh
		jnz	loc_7A0A
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_20], eax
		mov	eax, [ebp+arg_0]
		movsx	ecx, byte ptr [eax+84h]
		cmp	ecx, 1
		jnz	loc_79FC
		mov	eax, [ebp+arg_C]
		push	eax
		lea	ecx, [ebp+var_8]
		push	ecx
		lea	edx, [ebp+var_14]
		push	edx
		lea	eax, [ebp+var_20]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?getFallbackData@@YAPBUResourceData@@PBUUResourceBundle@@PAPBDPAPAUUResourceDataEntry@@PAIPAW4UErrorCode@@@Z ; getFallbackData(UResourceBundle const *,char const * *,UResourceDataEntry * *,uint *,UErrorCode *)
		add	esp, 14h
		mov	[ebp+var_44], eax
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	loc_79F1
		mov	eax, [ebp+var_8]
		shr	eax, 1Ch
		mov	[ebp+var_13C], eax
		cmp	[ebp+var_13C], 0
		jz	short loc_7982
		cmp	[ebp+var_13C], 3
		jz	short loc_799B
		cmp	[ebp+var_13C], 6
		jz	short loc_7982
		jmp	short loc_79E6
; ---------------------------------------------------------------------------

loc_7982:				; CODE XREF: _ures_getStringByKey_56+128j
					; _ures_getStringByKey_56+13Aj
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+var_8]
		push	ecx
		mov	edx, [ebp+var_44]
		push	edx
		call	_res_getString_56
		add	esp, 0Ch
		jmp	loc_7AAA
; ---------------------------------------------------------------------------

loc_799B:				; CODE XREF: _ures_getStringByKey_56+131j
		mov	[ebp+var_50], 0
		mov	eax, [ebp+arg_C]
		push	eax
		push	0
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	_ures_getByKey_56
		add	esp, 10h
		mov	[ebp+var_5C], eax
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+var_5C]
		push	edx
		call	_ures_getString_56
		add	esp, 0Ch
		mov	[ebp+var_50], eax
		mov	eax, [ebp+var_5C]
		push	eax
		call	_ures_close_56
		add	esp, 4
		mov	eax, [ebp+var_50]
		jmp	loc_7AAA
; ---------------------------------------------------------------------------

loc_79E6:				; CODE XREF: _ures_getStringByKey_56+13Cj
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 11h
		jmp	short loc_79FA
; ---------------------------------------------------------------------------

loc_79F1:				; CODE XREF: _ures_getStringByKey_56+10Fj
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 2

loc_79FA:				; CODE XREF: _ures_getStringByKey_56+1ABj
		jmp	short loc_7A05
; ---------------------------------------------------------------------------

loc_79FC:				; CODE XREF: _ures_getStringByKey_56+D7j
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 2

loc_7A05:				; CODE XREF: _ures_getStringByKey_56:loc_79FAj
		jmp	loc_7A9D
; ---------------------------------------------------------------------------

loc_7A0A:				; CODE XREF: _ures_getStringByKey_56+BEj
		mov	eax, [ebp+var_8]
		shr	eax, 1Ch
		mov	[ebp+var_13C], eax
		cmp	[ebp+var_13C], 0
		jz	short loc_7A33
		cmp	[ebp+var_13C], 3
		jz	short loc_7A4C
		cmp	[ebp+var_13C], 6
		jz	short loc_7A33
		jmp	short loc_7A94
; ---------------------------------------------------------------------------

loc_7A33:				; CODE XREF: _ures_getStringByKey_56+1D9j
					; _ures_getStringByKey_56+1EBj
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+var_8]
		push	ecx
		mov	edx, [ebp+arg_0]
		add	edx, 14h
		push	edx
		call	_res_getString_56
		add	esp, 0Ch
		jmp	short loc_7AAA
; ---------------------------------------------------------------------------

loc_7A4C:				; CODE XREF: _ures_getStringByKey_56+1E2j
		mov	[ebp+var_68], 0
		mov	eax, [ebp+arg_C]
		push	eax
		push	0
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	_ures_getByKey_56
		add	esp, 10h
		mov	[ebp+var_74], eax
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+var_74]
		push	edx
		call	_ures_getString_56
		add	esp, 0Ch
		mov	[ebp+var_68], eax
		mov	eax, [ebp+var_74]
		push	eax
		call	_ures_close_56
		add	esp, 4
		mov	eax, [ebp+var_68]
		jmp	short loc_7AAA
; ---------------------------------------------------------------------------

loc_7A94:				; CODE XREF: _ures_getStringByKey_56+1EDj
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 11h

loc_7A9D:				; CODE XREF: _ures_getStringByKey_56:loc_7A05j
		jmp	short loc_7AA8
; ---------------------------------------------------------------------------

loc_7A9F:				; CODE XREF: _ures_getStringByKey_56+89j
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 11h

loc_7AA8:				; CODE XREF: _ures_getStringByKey_56:loc_7A9Dj
		xor	eax, eax

loc_7AAA:				; CODE XREF: _ures_getStringByKey_56+4Fj
					; _ures_getStringByKey_56+65j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN30_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 13Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_ures_getStringByKey_56	endp

; ---------------------------------------------------------------------------
		align 10h
$LN30_0		dd 4			; DATA XREF: _ures_getStringByKey_56+26Ao
		dd offset $LN29_0
$LN29_0		dd 0FFFFFFF8h, 4	; DATA XREF: .text:00007AD4o
		dd offset $LN25		; "res"
		dd 0FFFFFFECh, 4
		dd offset $LN26		; "realData"
		dd 0FFFFFFE0h, 4
		dd offset $LN27_0
		dd 0FFFFFFC8h, 4
		dd offset $LN28_0
$LN28_0		db 74h,	0		; DATA XREF: .text:00007B04o
$LN27_0		dw 656Bh		; DATA XREF: .text:00007AF8o
		db 79h,	0
$LN26		db 'realData',0         ; DATA XREF: .text:00007AECo
$LN25		db 'res',0              ; DATA XREF: .text:00007AE0o
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7B1Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _ures_getUTF8StringByKey_56
_ures_getUTF8StringByKey_56 proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= byte ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_14]
		push	eax
		lea	ecx, [ebp+var_8]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		call	_ures_getStringByKey_56
		add	esp, 10h
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_14]
		push	eax
		movzx	ecx, [ebp+arg_10]
		push	ecx
		mov	edx, [ebp+arg_C]
		push	edx
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+var_8]
		push	ecx
		mov	edx, [ebp+var_14]
		push	edx
		call	?ures_toUTF8String@@YAPBDPB_WHPADPAHCPAW4UErrorCode@@@Z	; ures_toUTF8String(wchar_t const *,int,char *,int *,signed char,UErrorCode *)
		add	esp, 18h
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN5_3
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_ures_getUTF8StringByKey_56 endp

; ---------------------------------------------------------------------------
		align 4
$LN5_3		dd 1			; DATA XREF: _ures_getUTF8StringByKey_56+5Eo
		dd offset $LN4_3
$LN4_3		dd 0FFFFFFF8h, 4	; DATA XREF: .text:00007BA0o
		dd offset $LN3_4	; "length16"
$LN3_4		db 'length16',0         ; DATA XREF: .text:00007BACo
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7BBCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _ures_getLocaleInternal_56
_ures_getLocaleInternal_56 proc	near	; CODE XREF: _ures_getLocale_56+26p

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_4], 0
		jz	short loc_7BF5
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_7BF9

loc_7BF5:				; CODE XREF: _ures_getLocaleInternal_56+22j
		xor	eax, eax
		jmp	short loc_7C16
; ---------------------------------------------------------------------------

loc_7BF9:				; CODE XREF: _ures_getLocaleInternal_56+37j
		cmp	[ebp+arg_0], 0
		jnz	short loc_7C0E
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	short loc_7C16
; ---------------------------------------------------------------------------
		jmp	short loc_7C16
; ---------------------------------------------------------------------------

loc_7C0E:				; CODE XREF: _ures_getLocaleInternal_56+41j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	eax, [ecx]

loc_7C16:				; CODE XREF: _ures_getLocaleInternal_56+3Bj
					; _ures_getLocaleInternal_56+4Ej ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_ures_getLocaleInternal_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7C2Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _ures_getLocale_56
_ures_getLocale_56 proc	near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	_ures_getLocaleInternal_56
		add	esp, 8
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_ures_getLocale_56 endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7C70h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _ures_getLocaleByType_56
_ures_getLocaleByType_56 proc near	; CODE XREF: _ures_getFunctionalEquivalent_56+3C1p

var_C4		= dword	ptr -0C4h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C4]
		mov	ecx, 31h ; '1'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_8], 0
		jz	short loc_7CA9
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_7CAD

loc_7CA9:				; CODE XREF: _ures_getLocaleByType_56+22j
		xor	eax, eax
		jmp	short loc_7CFE
; ---------------------------------------------------------------------------

loc_7CAD:				; CODE XREF: _ures_getLocaleByType_56+37j
		cmp	[ebp+arg_0], 0
		jnz	short loc_7CC2
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	short loc_7CFE
; ---------------------------------------------------------------------------
		jmp	short loc_7CFE
; ---------------------------------------------------------------------------

loc_7CC2:				; CODE XREF: _ures_getLocaleByType_56+41j
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_C4], eax
		cmp	[ebp+var_C4], 0
		jz	short loc_7CDF
		cmp	[ebp+var_C4], 1
		jz	short loc_7CE9
		jmp	short loc_7CF3
; ---------------------------------------------------------------------------

loc_7CDF:				; CODE XREF: _ures_getLocaleByType_56+62j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	eax, [ecx]
		jmp	short loc_7CFE
; ---------------------------------------------------------------------------

loc_7CE9:				; CODE XREF: _ures_getLocaleByType_56+6Bj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+0Ch]
		mov	eax, [ecx]
		jmp	short loc_7CFE
; ---------------------------------------------------------------------------

loc_7CF3:				; CODE XREF: _ures_getLocaleByType_56+6Dj
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 1
		xor	eax, eax

loc_7CFE:				; CODE XREF: _ures_getLocaleByType_56+3Bj
					; _ures_getLocaleByType_56+4Ej	...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_ures_getLocaleByType_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7D14h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _ures_getName_56
_ures_getName_56 proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		jnz	short loc_7D3C
		xor	eax, eax
		jmp	short loc_7D44
; ---------------------------------------------------------------------------

loc_7D3C:				; CODE XREF: _ures_getName_56+22j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	eax, [ecx]

loc_7D44:				; CODE XREF: _ures_getName_56+26j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
_ures_getName_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7D4Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _ures_open_56
_ures_open_56	proc near		; CODE XREF: _ures_findResource_56+14Bp
					; _ures_getFunctionalEquivalent_56+266p ...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_8]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		push	0		; Dst
		call	?ures_openWithType@@YAPAUUResourceBundle@@PAU1@PBD1W4UResOpenType@@PAW4UErrorCode@@@Z ;	ures_openWithType(UResourceBundle *,char const *,char const *,UResOpenType,UErrorCode *)
		add	esp, 14h
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_ures_open_56	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7D98h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl ures_openWithType(void *Dst, int,	int, int, int)
?ures_openWithType@@YAPAUUResourceBundle@@PAU1@PBD1W4UResOpenType@@PAW4UErrorCode@@@Z proc near
					; CODE XREF: _ures_open_56+2Ep
					; _ures_openNoDefault_56+2Ep ...

var_188		= byte ptr -188h
var_185		= byte ptr -185h
var_BD		= byte ptr -0BDh
Source		= byte ptr -0B4h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
Dst		= dword	ptr  8
arg_4		= dword	ptr  0Ch
Str1		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 188h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_188]
		mov	ecx, 62h ; 'b'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_7DDC
		xor	eax, eax
		jmp	loc_7FD2
; ---------------------------------------------------------------------------

loc_7DDC:				; CODE XREF: ures_openWithType(UResourceBundle *,char const *,char const *,UResOpenType,UErrorCode *)+3Bj
		cmp	[ebp+arg_C], 2
		jz	short loc_7E4B
		mov	eax, [ebp+arg_10]
		push	eax
		push	9Dh ; ''
		lea	ecx, [ebp+Source]
		push	ecx
		mov	edx, [ebp+Str1]
		push	edx
		call	_uloc_getBaseName_56
		add	esp, 10h
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jnz	short loc_7E1B
		mov	eax, [ebp+arg_10]
		cmp	dword ptr [eax], 0FFFFFF84h
		jnz	short loc_7E2B

loc_7E1B:				; CODE XREF: ures_openWithType(UResourceBundle *,char const *,char const *,UResOpenType,UErrorCode *)+79j
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	loc_7FD2
; ---------------------------------------------------------------------------

loc_7E2B:				; CODE XREF: ures_openWithType(UResourceBundle *,char const *,char const *,UResOpenType,UErrorCode *)+81j
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		lea	edx, [ebp+Source]
		push	edx		; Source
		mov	eax, [ebp+arg_4]
		push	eax		; char *
		call	?entryOpen@@YAPAUUResourceDataEntry@@PBD0W4UResOpenType@@PAW4UErrorCode@@@Z ; entryOpen(char const *,char const	*,UResOpenType,UErrorCode *)
		add	esp, 10h
		mov	[ebp+var_C], eax
		jmp	short loc_7E62
; ---------------------------------------------------------------------------

loc_7E4B:				; CODE XREF: ures_openWithType(UResourceBundle *,char const *,char const *,UResOpenType,UErrorCode *)+48j
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+Str1]
		push	ecx		; Str1
		mov	edx, [ebp+arg_4]
		push	edx		; int
		call	?entryOpenDirect@@YAPAUUResourceDataEntry@@PBD0PAW4UErrorCode@@@Z ; entryOpenDirect(char const *,char const *,UErrorCode *)
		add	esp, 0Ch
		mov	[ebp+var_C], eax

loc_7E62:				; CODE XREF: ures_openWithType(UResourceBundle *,char const *,char const *,UResOpenType,UErrorCode *)+B1j
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_7E7E
		xor	eax, eax
		jmp	loc_7FD2
; ---------------------------------------------------------------------------

loc_7E7E:				; CODE XREF: ures_openWithType(UResourceBundle *,char const *,char const *,UResOpenType,UErrorCode *)+DDj
		cmp	[ebp+var_C], 0
		jnz	short loc_7E94
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 2
		xor	eax, eax
		jmp	loc_7FD2
; ---------------------------------------------------------------------------

loc_7E94:				; CODE XREF: ures_openWithType(UResourceBundle *,char const *,char const *,UResOpenType,UErrorCode *)+EAj
		cmp	[ebp+Dst], 0
		jnz	short loc_7ED5
		push	98h ; ''
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+Dst], eax
		cmp	[ebp+Dst], 0
		jnz	short loc_7ECC
		mov	eax, [ebp+var_C]
		push	eax
		call	?entryClose@@YAXPAUUResourceDataEntry@@@Z ; entryClose(UResourceDataEntry *)
		add	esp, 4
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 7
		xor	eax, eax
		jmp	loc_7FD2
; ---------------------------------------------------------------------------

loc_7ECC:				; CODE XREF: ures_openWithType(UResourceBundle *,char const *,char const *,UResOpenType,UErrorCode *)+116j
		mov	[ebp+var_BD], 0
		jmp	short loc_7EF5
; ---------------------------------------------------------------------------

loc_7ED5:				; CODE XREF: ures_openWithType(UResourceBundle *,char const *,char const *,UResOpenType,UErrorCode *)+100j
		mov	eax, [ebp+Dst]
		push	eax
		call	?ures_isStackObject@@YACPBUUResourceBundle@@@Z ; ures_isStackObject(UResourceBundle const *)
		add	esp, 4
		mov	[ebp+var_BD], al
		push	0
		mov	eax, [ebp+Dst]
		push	eax
		call	?ures_closeBundle@@YAXPAUUResourceBundle@@C@Z ;	ures_closeBundle(UResourceBundle *,signed char)
		add	esp, 8

loc_7EF5:				; CODE XREF: ures_openWithType(UResourceBundle *,char const *,char const *,UResOpenType,UErrorCode *)+13Bj
		push	98h ; ''       ; Size
		push	0		; Val
		mov	eax, [ebp+Dst]
		push	eax		; Dst
		call	_memset
		add	esp, 0Ch
		movzx	eax, [ebp+var_BD]
		push	eax
		mov	ecx, [ebp+Dst]
		push	ecx
		call	?ures_setIsStackObject@@YAXPAUUResourceBundle@@C@Z ; ures_setIsStackObject(UResourceBundle *,signed char)
		add	esp, 8
		mov	eax, [ebp+Dst]
		mov	ecx, [ebp+var_C]
		mov	[eax+4], ecx
		mov	edx, [ebp+Dst]
		mov	eax, [ebp+var_C]
		mov	[edx+0Ch], eax
		push	1
		mov	eax, [ebp+var_C]
		add	eax, 14h
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		push	28h ; '('       ; Size
		mov	ecx, [ebp+var_C]
		add	ecx, 14h
		push	ecx		; Src
		mov	edx, [ebp+Dst]
		add	edx, 14h
		push	edx		; Dst
		call	_memcpy
		add	esp, 0Ch
		cmp	[ebp+arg_C], 2
		jz	short loc_7F71
		mov	eax, [ebp+Dst]
		movsx	ecx, byte ptr [eax+38h]
		test	ecx, ecx
		jnz	short loc_7F71
		mov	[ebp+var_185], 1
		jmp	short loc_7F78
; ---------------------------------------------------------------------------

loc_7F71:				; CODE XREF: ures_openWithType(UResourceBundle *,char const *,char const *,UResOpenType,UErrorCode *)+1C3j
					; ures_openWithType(UResourceBundle *,char const *,char	const *,UResOpenType,UErrorCode	*)+1CEj
		mov	[ebp+var_185], 0

loc_7F78:				; CODE XREF: ures_openWithType(UResourceBundle *,char const *,char const *,UResOpenType,UErrorCode *)+1D7j
		mov	edx, [ebp+Dst]
		mov	al, [ebp+var_185]
		mov	[edx+84h], al
		mov	eax, [ebp+Dst]
		mov	byte ptr [eax+85h], 1
		mov	eax, [ebp+Dst]
		mov	ecx, [ebp+Dst]
		mov	edx, [ecx+24h]
		mov	[eax+80h], edx
		mov	eax, [ebp+Dst]
		mov	ecx, [eax+80h]
		push	ecx
		mov	edx, [ebp+Dst]
		add	edx, 14h
		push	edx
		call	_res_countArrayItems_56
		add	esp, 8
		mov	ecx, [ebp+Dst]
		mov	[ecx+94h], eax
		mov	eax, [ebp+Dst]
		mov	dword ptr [eax+90h], 0FFFFFFFFh
		mov	eax, [ebp+Dst]

loc_7FD2:				; CODE XREF: ures_openWithType(UResourceBundle *,char const *,char const *,UResOpenType,UErrorCode *)+3Fj
					; ures_openWithType(UResourceBundle *,char const *,char	const *,UResOpenType,UErrorCode	*)+8Ej	...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN17_4
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 188h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp

locret_8000:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::_Stdioo
		retn
?ures_openWithType@@YAPAUUResourceBundle@@PAU1@PBD1W4UResOpenType@@PAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN17_4		dd 1			; DATA XREF: ures_openWithType(UResourceBundle *,char const *,char const *,UResOpenType,UErrorCode *)+23Eo
		dd offset $LN16_3
$LN16_3		dd 0FFFFFF4Ch, 9Dh	; DATA XREF: .text:00008008o
		dd offset $LN15_1	; "canonLocaleID"
$LN15_1		db 'canonLocaleID',0    ; DATA XREF: .text:00008014o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8028h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl entryOpen(char *,	char *Source, int, int)
?entryOpen@@YAPAUUResourceDataEntry@@PBD0W4UResOpenType@@PAW4UErrorCode@@@Z proc near
					; CODE XREF: ures_openWithType(UResourceBundle *,char const *,char const *,UResOpenType,UErrorCode *)+A6p

var_24C		= byte ptr -24Ch
var_188		= dword	ptr -188h
var_17C		= dword	ptr -17Ch
var_170		= byte ptr -170h
var_16F		= byte ptr -16Fh
var_16E		= byte ptr -16Eh
var_111		= byte ptr -111h
Dest		= byte ptr -108h
var_6C		= byte ptr -6Ch
var_5D		= byte ptr -5Dh
var_51		= dword	ptr -51h
var_45		= byte ptr -45h
var_39		= dword	ptr -39h
var_2D		= dword	ptr -2Dh
var_24		= dword	ptr -24h
var_18		= dword	ptr -18h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
Source		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 24Ch
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_24C]
		mov	ecx, 93h ; ''
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		cmp	[ebp+arg_8], 2
		jnz	short loc_807B
		mov	eax, ds:?__LINE__Var@?1??entryOpen@@YAPAUUResourceDataEntry@@PBD0W4UResOpenType@@PAW4UErrorCode@@@Z@4JA@8166c1fe
		add	eax, 1
		mov	esi, esp
		push	eax		; Line
		push	offset ??_C@_1FO@EGODLIOL@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@ ; "d:\\mozilla\\intl\\icu\\source\\common\"...
		push	offset ??_C@_1DK@GEKGCHJK@?$AAo?$AAp?$AAe?$AAn?$AAT?$AAy?$AAp?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAU?$AAR?$AAE?$AAS?$AA_?$AAO?$AAP?$AAE?$AAN?$AA_?$AAD?$AAI?$AAR?$AAE?$AAC?$AAT?$AA?$AA@	; "openType != URES_OPEN_DIRECT"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_807B:				; CODE XREF: entryOpen(char const *,char const *,UResOpenType,UErrorCode *)+2Cj
		mov	[ebp+var_C], 0
		mov	[ebp+var_18], 0
		mov	[ebp+var_24], 0
		mov	byte ptr [ebp+var_2D], 0
		mov	byte ptr [ebp+var_39], 0
		mov	[ebp+var_45], 0
		mov	byte ptr [ebp+var_51], 1
		mov	[ebp+var_5D], 0
		mov	eax, [ebp+arg_C]
		push	eax
		call	?initCache@@YAXPAW4UErrorCode@@@Z ; initCache(UErrorCode *)
		add	esp, 4
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_80CC
		xor	eax, eax
		jmp	loc_8473
; ---------------------------------------------------------------------------

loc_80CC:				; CODE XREF: entryOpen(char const *,char const *,UResOpenType,UErrorCode *)+9Bj
		push	1
		mov	eax, [ebp+Source]
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	esi, esp
		push	9Ch ; ''       ; Count
		mov	ecx, [ebp+Source]
		push	ecx		; Source
		lea	edx, [ebp+Dest]
		push	edx		; Dest
		call	dword ptr ds:__imp__strncpy
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_6C], 0
		movsx	eax, [ebp+var_5D]
		test	eax, eax
		jz	short loc_816D
		cmp	[ebp+arg_0], 0
		jnz	short loc_8124
		push	offset ??_C@_08ELIGIEOD@usrdt56l?$AA@ ;	"usrdt56l"
		lea	eax, [ebp+var_170]
		push	eax		; Dest
		call	_strcpy
		add	esp, 8
		jmp	short loc_816D
; ---------------------------------------------------------------------------

loc_8124:				; CODE XREF: entryOpen(char const *,char const *,UResOpenType,UErrorCode *)+E4j
		push	1
		mov	eax, [ebp+arg_0]
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	esi, esp
		push	5Fh ; '_'       ; Count
		mov	ecx, [ebp+arg_0]
		push	ecx		; Source
		lea	edx, [ebp+var_170]
		push	edx		; Dest
		call	dword ptr ds:__imp__strncpy
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_170], 75h ; 'u'
		mov	[ebp+var_16F], 73h ; 's'
		mov	[ebp+var_16E], 72h ; 'r'
		mov	[ebp+var_111], 0

loc_816D:				; CODE XREF: entryOpen(char const *,char const *,UResOpenType,UErrorCode *)+DEj
					; entryOpen(char const *,char const *,UResOpenType,UErrorCode *)+FAj
		push	offset _resbMutex
		call	_umtx_lock_56
		add	esp, 4
		lea	eax, [ebp+var_C]
		push	eax		; int
		lea	ecx, [ebp+var_2D]
		push	ecx		; int
		lea	edx, [ebp+var_51]
		push	edx		; int
		lea	eax, [ebp+var_39]
		push	eax		; int
		lea	ecx, [ebp+Dest]
		push	ecx		; Str
		mov	edx, [ebp+arg_0]
		push	edx		; int
		call	?findFirstExisting@@YAPAUUResourceDataEntry@@PBDPADPAC22PAW4UErrorCode@@@Z ; findFirstExisting(char const *,char *,signed char *,signed	char *,signed char *,UErrorCode	*)
		add	esp, 18h
		mov	[ebp+var_18], eax
		cmp	[ebp+var_18], 0
		jz	loc_826A
		mov	eax, [ebp+var_18]
		mov	[ebp+var_24], eax
		mov	[ebp+var_45], 1
		movsx	eax, [ebp+var_5D]
		test	eax, eax
		jz	short loc_8221
		mov	[ebp+var_17C], 0
		lea	eax, [ebp+var_17C]
		push	eax
		lea	ecx, [ebp+var_170]
		push	ecx
		mov	edx, [ebp+var_24]
		mov	eax, [edx]
		push	eax
		call	?init_entry@@YAPAUUResourceDataEntry@@PBD0PAW4UErrorCode@@@Z ; init_entry(char const *,char const *,UErrorCode *)
		add	esp, 0Ch
		mov	[ebp+var_188], eax
		cmp	[ebp+var_188], 0
		jz	short loc_8221
		mov	eax, [ebp+var_188]
		cmp	dword ptr [eax+44h], 0
		jnz	short loc_8214
		mov	eax, [ebp+var_188]
		mov	ecx, [ebp+var_24]
		mov	[eax+8], ecx
		mov	eax, [ebp+var_188]
		mov	[ebp+var_18], eax
		jmp	short loc_8221
; ---------------------------------------------------------------------------

loc_8214:				; CODE XREF: entryOpen(char const *,char const *,UResOpenType,UErrorCode *)+1D3j
		mov	eax, [ebp+var_188]
		mov	dword ptr [eax+40h], 0

loc_8221:				; CODE XREF: entryOpen(char const *,char const *,UResOpenType,UErrorCode *)+192j
					; entryOpen(char const *,char const *,UResOpenType,UErrorCode *)+1C7j ...
		movsx	eax, byte ptr [ebp+var_51]
		test	eax, eax
		jz	short loc_826A
		movsx	eax, byte ptr [ebp+var_39]
		test	eax, eax
		jnz	short loc_826A
		mov	eax, [ebp+arg_C]
		push	eax		; int
		lea	ecx, [ebp+var_170]
		push	ecx		; int
		movzx	edx, [ebp+var_5D]
		push	edx		; char
		push	9Dh ; ''       ; int
		lea	eax, [ebp+Dest]
		push	eax		; Str1
		lea	ecx, [ebp+var_24]
		push	ecx		; int
		call	?loadParentsExceptRoot@@YACAAPAUUResourceDataEntry@@QADHC1PAW4UErrorCode@@@Z ; loadParentsExceptRoot(UResourceDataEntry	* &,char * const,int,signed char,char *	const,UErrorCode *)
		add	esp, 18h
		movsx	edx, al
		test	edx, edx
		jnz	short loc_826A
		jmp	$finishUnlock$71485
; ---------------------------------------------------------------------------
		jmp	$finishUnlock$71485
; ---------------------------------------------------------------------------

loc_826A:				; CODE XREF: entryOpen(char const *,char const *,UResOpenType,UErrorCode *)+17Cj
					; entryOpen(char const *,char const *,UResOpenType,UErrorCode *)+1FFj ...
		cmp	[ebp+var_18], 0
		jnz	loc_8335
		cmp	[ebp+arg_8], 0
		jnz	loc_8335
		movsx	eax, byte ptr [ebp+var_2D]
		test	eax, eax
		jnz	loc_8335
		movsx	eax, byte ptr [ebp+var_39]
		test	eax, eax
		jnz	loc_8335
		call	_uloc_getDefault_56
		push	eax		; Source
		lea	eax, [ebp+Dest]
		push	eax		; Dest
		call	_strcpy
		add	esp, 8
		lea	eax, [ebp+var_C]
		push	eax		; int
		lea	ecx, [ebp+var_2D]
		push	ecx		; int
		lea	edx, [ebp+var_51]
		push	edx		; int
		lea	eax, [ebp+var_39]
		push	eax		; int
		lea	ecx, [ebp+Dest]
		push	ecx		; Str
		mov	edx, [ebp+arg_0]
		push	edx		; int
		call	?findFirstExisting@@YAPAUUResourceDataEntry@@PBDPADPAC22PAW4UErrorCode@@@Z ; findFirstExisting(char const *,char *,signed char *,signed	char *,signed char *,UErrorCode	*)
		add	esp, 18h
		mov	[ebp+var_18], eax
		mov	[ebp+var_C], 0FFFFFF81h
		cmp	[ebp+var_18], 0
		jz	short loc_8335
		mov	eax, [ebp+var_18]
		mov	[ebp+var_24], eax
		mov	[ebp+var_45], 1
		mov	byte ptr [ebp+var_2D], 1
		movsx	eax, byte ptr [ebp+var_51]
		test	eax, eax
		jz	short loc_8335
		movsx	eax, byte ptr [ebp+var_39]
		test	eax, eax
		jnz	short loc_8335
		mov	eax, [ebp+arg_C]
		push	eax		; int
		lea	ecx, [ebp+var_170]
		push	ecx		; int
		movzx	edx, [ebp+var_5D]
		push	edx		; char
		push	9Dh ; ''       ; int
		lea	eax, [ebp+Dest]
		push	eax		; Str1
		lea	ecx, [ebp+var_24]
		push	ecx		; int
		call	?loadParentsExceptRoot@@YACAAPAUUResourceDataEntry@@QADHC1PAW4UErrorCode@@@Z ; loadParentsExceptRoot(UResourceDataEntry	* &,char * const,int,signed char,char *	const,UErrorCode *)
		add	esp, 18h
		movsx	edx, al
		test	edx, edx
		jnz	short loc_8335
		jmp	$finishUnlock$71485
; ---------------------------------------------------------------------------
		jmp	$finishUnlock$71485
; ---------------------------------------------------------------------------

loc_8335:				; CODE XREF: entryOpen(char const *,char const *,UResOpenType,UErrorCode *)+246j
					; entryOpen(char const *,char const *,UResOpenType,UErrorCode *)+250j ...
		cmp	[ebp+var_18], 0
		jnz	short loc_83A3
		push	offset ??_C@_04NBFCGMPH@root?$AA@ ; "root"
		lea	eax, [ebp+Dest]
		push	eax		; Dest
		call	_strcpy
		add	esp, 8
		lea	eax, [ebp+var_C]
		push	eax		; int
		lea	ecx, [ebp+var_2D]
		push	ecx		; int
		lea	edx, [ebp+var_51]
		push	edx		; int
		lea	eax, [ebp+var_39]
		push	eax		; int
		lea	ecx, [ebp+Dest]
		push	ecx		; Str
		mov	edx, [ebp+arg_0]
		push	edx		; int
		call	?findFirstExisting@@YAPAUUResourceDataEntry@@PBDPADPAC22PAW4UErrorCode@@@Z ; findFirstExisting(char const *,char *,signed char *,signed	char *,signed char *,UErrorCode	*)
		add	esp, 18h
		mov	[ebp+var_18], eax
		cmp	[ebp+var_18], 0
		jz	short loc_838E
		mov	eax, [ebp+var_18]
		mov	[ebp+var_24], eax
		mov	[ebp+var_C], 0FFFFFF81h
		mov	[ebp+var_45], 1
		jmp	short loc_83A1
; ---------------------------------------------------------------------------

loc_838E:				; CODE XREF: entryOpen(char const *,char const *,UResOpenType,UErrorCode *)+351j
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 2
		jmp	$finishUnlock$71485
; ---------------------------------------------------------------------------
		jmp	$finishUnlock$71485
; ---------------------------------------------------------------------------

loc_83A1:				; CODE XREF: entryOpen(char const *,char const *,UResOpenType,UErrorCode *)+364j
		jmp	short loc_8403
; ---------------------------------------------------------------------------

loc_83A3:				; CODE XREF: entryOpen(char const *,char const *,UResOpenType,UErrorCode *)+311j
		movsx	eax, byte ptr [ebp+var_39]
		test	eax, eax
		jnz	short loc_8403
		push	offset ??_C@_04NBFCGMPH@root?$AA@ ; "root"
		mov	eax, [ebp+var_24]
		mov	ecx, [eax]
		push	ecx		; Str1
		call	_strcmp
		add	esp, 8
		test	eax, eax
		jz	short loc_8403
		mov	eax, [ebp+var_24]
		cmp	dword ptr [eax+8], 0
		jnz	short loc_8403
		mov	eax, [ebp+var_18]
		movsx	ecx, byte ptr [eax+38h]
		test	ecx, ecx
		jnz	short loc_8403
		mov	eax, [ebp+arg_C]
		push	eax
		lea	ecx, [ebp+var_24]
		push	ecx
		call	?insertRootBundle@@YACAAPAUUResourceDataEntry@@PAW4UErrorCode@@@Z ; insertRootBundle(UResourceDataEntry	* &,UErrorCode *)
		add	esp, 8
		movsx	edx, al
		test	edx, edx
		jnz	short loc_83F1
		jmp	short $finishUnlock$71485
; ---------------------------------------------------------------------------
		jmp	short $finishUnlock$71485
; ---------------------------------------------------------------------------

loc_83F1:				; CODE XREF: entryOpen(char const *,char const *,UResOpenType,UErrorCode *)+3C3j
		movsx	eax, [ebp+var_45]
		test	eax, eax
		jnz	short loc_8403
		mov	eax, [ebp+var_18]
		mov	dword ptr [eax+44h], 0FFFFFF81h

loc_8403:				; CODE XREF: entryOpen(char const *,char const *,UResOpenType,UErrorCode *):loc_83A1j
					; entryOpen(char const *,char const *,UResOpenType,UErrorCode *)+381j ...
		cmp	[ebp+var_18], 0
		jz	short $finishUnlock$71485
		movsx	eax, byte ptr [ebp+var_39]
		test	eax, eax
		jnz	short $finishUnlock$71485
		mov	eax, [ebp+var_24]
		cmp	dword ptr [eax+8], 0
		jz	short $finishUnlock$71485
		mov	eax, [ebp+var_24]
		mov	ecx, [eax+8]
		mov	edx, [ecx+40h]
		add	edx, 1
		mov	eax, [ebp+var_24]
		mov	ecx, [eax+8]
		mov	[ecx+40h], edx
		mov	eax, [ebp+var_24]
		mov	ecx, [eax+8]
		mov	[ebp+var_24], ecx
		jmp	short loc_8403
; ---------------------------------------------------------------------------

$finishUnlock$71485:			; CODE XREF: entryOpen(char const *,char const *,UResOpenType,UErrorCode *)+238j
					; entryOpen(char const *,char const *,UResOpenType,UErrorCode *)+23Dj ...
		push	offset _resbMutex
		call	_umtx_unlock_56
		add	esp, 4
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_8471
		cmp	[ebp+var_C], 0
		jz	short loc_846A
		mov	eax, [ebp+arg_C]
		mov	ecx, [ebp+var_C]
		mov	[eax], ecx

loc_846A:				; CODE XREF: entryOpen(char const *,char const *,UResOpenType,UErrorCode *)+438j
		mov	eax, [ebp+var_18]
		jmp	short loc_8473
; ---------------------------------------------------------------------------
		jmp	short loc_8473
; ---------------------------------------------------------------------------

loc_8471:				; CODE XREF: entryOpen(char const *,char const *,UResOpenType,UErrorCode *)+432j
		xor	eax, eax

loc_8473:				; CODE XREF: entryOpen(char const *,char const *,UResOpenType,UErrorCode *)+9Fj
					; entryOpen(char const *,char const *,UResOpenType,UErrorCode *)+445j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN44
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 24Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?entryOpen@@YAPAUUResourceDataEntry@@PBD0W4UResOpenType@@PAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN44		dd 8			; DATA XREF: entryOpen(char const *,char const *,UResOpenType,UErrorCode *)+44Fo
		dd offset $LN43
$LN43		dd 0FFFFFFF4h, 4	; DATA XREF: .text:000084A8o
		dd offset $LN35		; "intStatus"
		dd 0FFFFFFDCh, 4
		dd offset $LN36		; "t1"
		dd 0FFFFFFD3h, 1
		dd offset $LN37		; "isDefault"
		dd 0FFFFFFC7h, 1
		dd offset $LN38		; "isRoot"
		dd 0FFFFFFAFh, 1
		dd offset $LN39		; "hasChopped"
		dd 0FFFFFEF8h, 9Dh
		dd offset $LN40		; "name"
		db 90h
		db 0FEh, 2 dup(0FFh)
		dd offset ?all@?$_Locbase@H@std@@2HB ; int const std::_Locbase<int>::all
		dd offset $LN41		; "usrDataPath"
		dd 0FFFFFE84h, 4
		dd offset $LN42		; "usrStatus"
$LN42		db 'usrStatus',0        ; DATA XREF: .text:00008508o
$LN41		db 'usrDataPath',0      ; DATA XREF: .text:000084FCo
$LN40		db 'name',0             ; DATA XREF: .text:000084F0o
$LN39		db 'hasChopped',0       ; DATA XREF: .text:000084E4o
$LN38		db 'isRoot',0           ; DATA XREF: .text:000084D8o
$LN37		db 'isDefault',0        ; DATA XREF: .text:000084CCo
$LN36		db 't1',0               ; DATA XREF: .text:000084C0o
$LN35		db 'intStatus',0        ; DATA XREF: .text:000084B4o
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8550h
		public ??_C@_08ELIGIEOD@usrdt56l?$AA@
; char `string'[]
??_C@_08ELIGIEOD@usrdt56l?$AA@ db 'usrdt56l',0
					; DATA XREF: entryOpen(char const *,char const *,UResOpenType,UErrorCode *)+E6o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 855Ch
		public ??_C@_1DK@GEKGCHJK@?$AAo?$AAp?$AAe?$AAn?$AAT?$AAy?$AAp?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAU?$AAR?$AAE?$AAS?$AA_?$AAO?$AAP?$AAE?$AAN?$AA_?$AAD?$AAI?$AAR?$AAE?$AAC?$AAT?$AA?$AA@
; wchar_t `string'
??_C@_1DK@GEKGCHJK@?$AAo?$AAp?$AAe?$AAn?$AAT?$AAy?$AAp?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAU?$AAR?$AAE?$AAS?$AA_?$AAO?$AAP?$AAE?$AAN?$AA_?$AAD?$AAI?$AAR?$AAE?$AAC?$AAT?$AA?$AA@:
					; DATA XREF: entryOpen(char const *,char const *,UResOpenType,UErrorCode *)+3Eo
		unicode	0, <openType !=	URES_OPEN_DIRECT>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 8598h
		public ??_C@_1FO@EGODLIOL@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@
; wchar_t `string'
??_C@_1FO@EGODLIOL@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@:
					; DATA XREF: entryOpen(char const *,char const *,UResOpenType,UErrorCode *)+39o
					; createCache(UErrorCode &)+32o
		unicode	0, <d:\mozilla\intl\icu\source\common\uresbund.cpp>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 85F8h
		public ?__LINE__Var@?1??entryOpen@@YAPAUUResourceDataEntry@@PBD0W4UResOpenType@@PAW4UErrorCode@@@Z@4JA@8166c1fe
?__LINE__Var@?1??entryOpen@@YAPAUUResourceDataEntry@@PBD0W4UResOpenType@@PAW4UErrorCode@@@Z@4JA@8166c1fe dd 25Bh
					; DATA XREF: entryOpen(char const *,char const *,UResOpenType,UErrorCode *)+2Er
_data		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 85FCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl initCache(enum  UErrorCode *)
?initCache@@YAXPAW4UErrorCode@@@Z proc near
					; CODE XREF: entryOpen(char const *,char const *,UResOpenType,UErrorCode *)+80p
					; entryOpenDirect(char const *,char const *,UErrorCode *)+2Cp

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi		; enum UErrorCode *
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		push	eax		; void (__cdecl	*)(enum	UErrorCode *)
		push	offset ?createCache@@YAXAAW4UErrorCode@@@Z ; struct icu_56::UInitOnce *
		push	offset _gCacheInitOnce ; this
		call	?umtx_initOnce@icu_56@@YAXAAUUInitOnce@1@P6AXAAW4UErrorCode@@@Z1@Z ; icu_56::umtx_initOnce(icu_56::UInitOnce &,void (*)(UErrorCode &),UErrorCode &)
		add	esp, 0Ch
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?initCache@@YAXPAW4UErrorCode@@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8644h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl icu_56::umtx_initOnce(icu_56 *__hidden this, struct icu_56::UInitOnce *,	void (__cdecl *)(enum UErrorCode *), enum UErrorCode *)
		public ?umtx_initOnce@icu_56@@YAXAAUUInitOnce@1@P6AXAAW4UErrorCode@@@Z1@Z
?umtx_initOnce@icu_56@@YAXAAUUInitOnce@1@P6AXAAW4UErrorCode@@@Z1@Z proc	near
					; CODE XREF: initCache(UErrorCode *)+2Cp

var_C0		= byte ptr -0C0h
Destination	= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi		; struct icu_56::UInitOnce *
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_8679
		jmp	short loc_86EA
; ---------------------------------------------------------------------------

loc_8679:				; CODE XREF: icu_56::umtx_initOnce(icu_56::UInitOnce &,void (*)(UErrorCode &),UErrorCode &)+31j
		mov	eax, [ebp+Destination]
		push	eax		; Destination
		call	?umtx_loadAcquire@icu_56@@YAHACJ@Z ; icu_56::umtx_loadAcquire(long volatile &)
		add	esp, 4
		cmp	eax, 2
		jz	short loc_86C9
		mov	eax, [ebp+Destination]
		push	eax		; this
		call	?umtx_initImplPreInit@icu_56@@YACAAUUInitOnce@1@@Z ; icu_56::umtx_initImplPreInit(icu_56::UInitOnce &)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_86C9
		mov	esi, esp
		mov	eax, [ebp+arg_8]
		push	eax
		call	[ebp+arg_4]
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+Destination]
		mov	ecx, [ebp+arg_8]
		mov	edx, [ecx]
		mov	[eax+4], edx
		mov	eax, [ebp+Destination]
		push	eax		; this
		call	?umtx_initImplPostInit@icu_56@@YAXAAUUInitOnce@1@@Z ; icu_56::umtx_initImplPostInit(icu_56::UInitOnce &)
		add	esp, 4
		jmp	short loc_86EA
; ---------------------------------------------------------------------------

loc_86C9:				; CODE XREF: icu_56::umtx_initOnce(icu_56::UInitOnce &,void (*)(UErrorCode &),UErrorCode &)+44j
					; icu_56::umtx_initOnce(icu_56::UInitOnce &,void (*)(UErrorCode	&),UErrorCode &)+57j
		mov	eax, [ebp+Destination]
		mov	ecx, [eax+4]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_86EA
		mov	eax, [ebp+arg_8]
		mov	ecx, [ebp+Destination]
		mov	edx, [ecx+4]
		mov	[eax], edx

loc_86EA:				; CODE XREF: icu_56::umtx_initOnce(icu_56::UInitOnce &,void (*)(UErrorCode &),UErrorCode &)+33j
					; icu_56::umtx_initOnce(icu_56::UInitOnce &,void (*)(UErrorCode	&),UErrorCode &)+83j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?umtx_initOnce@icu_56@@YAXAAUUInitOnce@1@P6AXAAW4UErrorCode@@@Z1@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8700h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl icu_56::umtx_loadAcquire(volatile	LONG *Destination, volatile __int32 *)
		public ?umtx_loadAcquire@icu_56@@YAHACJ@Z
?umtx_loadAcquire@icu_56@@YAHACJ@Z proc	near
					; CODE XREF: icu_56::umtx_initOnce(icu_56::UInitOnce &,void (*)(UErrorCode &),UErrorCode &)+39p

var_C0		= byte ptr -0C0h
Destination	= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	esi, esp
		push	0		; Comperand
		push	0		; Exchange
		mov	eax, [ebp+Destination]
		push	eax		; Destination
		call	dword ptr ds:__imp__InterlockedCompareExchange@12 ; InterlockedCompareExchange(x,x,x)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?umtx_loadAcquire@icu_56@@YAHACJ@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 874Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UInitOnce createCache
?createCache@@YAXAAW4UErrorCode@@@Z proc near ;	DATA XREF: initCache(UErrorCode	*)+22o

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	ds:_cache, 0
		jz	short loc_8798
		mov	eax, ds:?__LINE__Var@?1??createCache@@YAXAAW4UErrorCode@@@Z@4JA@8166c1fe
		add	eax, 1
		mov	esi, esp
		push	eax		; Line
		push	offset ??_C@_1FO@EGODLIOL@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@ ; "d:\\mozilla\\intl\\icu\\source\\common\"...
		push	offset ??_C@_1BG@EFAOBGPF@?$AAc?$AAa?$AAc?$AAh?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ;	"cache == 0"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_8798:				; CODE XREF: createCache(UErrorCode &)+25j
		mov	eax, [ebp+arg_0]
		push	eax
		push	0
		push	offset ?compareEntries@@YACTUElement@@0@Z ; compareEntries(UElement,UElement)
		push	offset ?hashEntry@@YAHTUElement@@@Z ; hashEntry(UElement)
		call	_uhash_open_56
		add	esp, 10h
		mov	ds:_cache, eax
		push	offset ?ures_cleanup@@YACXZ ; ures_cleanup(void)
		push	14h
		call	_ucln_common_registerCleanup_56
		add	esp, 8
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?createCache@@YAXAAW4UErrorCode@@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 87D8h
		public ??_C@_1BG@EFAOBGPF@?$AAc?$AAa?$AAc?$AAh?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
; wchar_t `string'
??_C@_1BG@EFAOBGPF@?$AAc?$AAa?$AAc?$AAh?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@:
					; DATA XREF: createCache(UErrorCode &)+37o
		unicode	0, <cache == 0>,0
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 87F0h
		public ?__LINE__Var@?1??createCache@@YAXAAW4UErrorCode@@@Z@4JA@8166c1fe
?__LINE__Var@?1??createCache@@YAXAAW4UErrorCode@@@Z@4JA@8166c1fe dd offset word_10E
					; DATA XREF: createCache(UErrorCode &)+27r
_data		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 87F4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl hashEntry(union UElement)
?hashEntry@@YAHTUElement@@@Z proc near	; DATA XREF: createCache(UErrorCode &)+57o

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	[ebp+var_20], ecx
		mov	eax, [ebp+var_14]
		push	eax
		call	_uhash_hashChars_56
		add	esp, 4
		mov	esi, eax
		mov	ecx, [ebp+var_20]
		push	ecx
		call	_uhash_hashChars_56
		add	esp, 4
		imul	eax, 25h
		add	eax, esi
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN6_3
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?hashEntry@@YAHTUElement@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
$LN6_3		dd 2			; DATA XREF: hashEntry(UElement)+58o
		dd offset $LN5_4
$LN5_4		dd 0FFFFFFECh, 4	; DATA XREF: .text:00008874o
		dd offset $LN3_5	; "namekey"
		dd 0FFFFFFE0h, 4
		dd offset $LN4_4	; "pathkey"
$LN4_4		db 'pathkey',0          ; DATA XREF: .text:0000888Co
$LN3_5		db 'namekey',0          ; DATA XREF: .text:00008880o
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 88A0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl compareEntries(union UElement, union UElement)
?compareEntries@@YACTUElement@@0@Z proc	near ; DATA XREF: createCache(UErrorCode &)+52o

var_10C		= byte ptr -10Ch
var_109		= byte ptr -109h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 10Ch
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_10C]
		mov	ecx, 43h ; 'C'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		mov	[ebp+var_20], ecx
		mov	eax, [ebp+var_14]
		mov	ecx, [eax]
		mov	[ebp+var_2C], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	[ebp+var_38], ecx
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+4]
		mov	[ebp+var_44], ecx
		mov	eax, [ebp+var_2C]
		push	eax
		mov	ecx, [ebp+var_20]
		push	ecx
		call	_uhash_compareChars_56
		add	esp, 8
		movsx	edx, al
		test	edx, edx
		jz	short loc_8923
		mov	eax, [ebp+var_44]
		push	eax
		mov	ecx, [ebp+var_38]
		push	ecx
		call	_uhash_compareChars_56
		add	esp, 8
		movsx	edx, al
		test	edx, edx
		jz	short loc_8923
		mov	[ebp+var_109], 1
		jmp	short loc_892A
; ---------------------------------------------------------------------------

loc_8923:				; CODE XREF: compareEntries(UElement,UElement)+61j
					; compareEntries(UElement,UElement)+78j
		mov	[ebp+var_109], 0

loc_892A:				; CODE XREF: compareEntries(UElement,UElement)+81j
		mov	al, [ebp+var_109]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN10_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 10Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?compareEntries@@YACTUElement@@0@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN10_0		dd 4			; DATA XREF: compareEntries(UElement,UElement)+94o
		dd offset $LN9_1
$LN9_1		dd 0FFFFFFE0h, 4	; DATA XREF: .text:0000895Co
		dd offset $LN5_5	; "name1"
		dd 0FFFFFFD4h, 4
		dd offset $LN6_4	; "name2"
		dd 0FFFFFFC8h, 4
		dd offset $LN7_2	; "path1"
		dd 0FFFFFFBCh, 4
		dd offset $LN8_2	; "path2"
$LN8_2		db 'path2',0            ; DATA XREF: .text:0000898Co
$LN7_2		db 'path1',0            ; DATA XREF: .text:00008980o
$LN6_4		db 'name2',0            ; DATA XREF: .text:00008974o
$LN5_5		db 'name1',0            ; DATA XREF: .text:00008968o
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 89A8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl ures_cleanup(void)
?ures_cleanup@@YACXZ proc near		; DATA XREF: createCache(UErrorCode &)+69o

var_C0		= byte ptr -0C0h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	ds:_cache, 0
		jz	short loc_89EC
		call	?ures_flushCache@@YAHXZ	; ures_flushCache(void)
		mov	eax, ds:_cache
		push	eax
		call	_uhash_close_56
		add	esp, 4
		mov	ds:_cache, 0

loc_89EC:				; CODE XREF: ures_cleanup(void)+25j
		mov	ecx, offset _gCacheInitOnce ; this
		call	?reset@UInitOnce@icu_56@@QAEXXZ	; icu_56::UInitOnce::reset(void)
		mov	al, 1
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?ures_cleanup@@YACXZ endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8A0Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UInitOnce::reset(icu_56::UInitOnce *__hidden this)
		public ?reset@UInitOnce@icu_56@@QAEXXZ
?reset@UInitOnce@icu_56@@QAEXXZ	proc near ; CODE XREF: ures_cleanup(void)+49p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], 0
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?reset@UInitOnce@icu_56@@QAEXXZ	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8A40h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl ures_flushCache(void)
?ures_flushCache@@YAHXZ	proc near	; CODE XREF: ures_cleanup(void)+27p

var_FC		= byte ptr -0FCh
var_35		= byte ptr -35h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0FCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_FC]
		mov	ecx, 3Fh ; '?'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_20], 0
		push	offset _resbMutex
		call	_umtx_lock_56
		add	esp, 4
		cmp	ds:_cache, 0
		jnz	short loc_8A8C
		push	offset _resbMutex
		call	_umtx_unlock_56
		add	esp, 4
		xor	eax, eax
		jmp	short loc_8B0B
; ---------------------------------------------------------------------------

loc_8A8C:				; CODE XREF: ures_flushCache(void)+39j
					; ures_flushCache(void)+B9j
		mov	[ebp+var_35], 0
		mov	[ebp+var_14], 0FFFFFFFFh

loc_8A97:				; CODE XREF: ures_flushCache(void):loc_8AF1j
		lea	eax, [ebp+var_14]
		push	eax
		mov	ecx, ds:_cache
		push	ecx
		call	_uhash_nextElement_56
		add	esp, 8
		mov	[ebp+var_2C], eax
		cmp	[ebp+var_2C], 0
		jz	short loc_8AF3
		mov	eax, [ebp+var_2C]
		mov	ecx, [eax+4]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+40h], 0
		jnz	short loc_8AF1
		mov	eax, [ebp+var_20]
		add	eax, 1
		mov	[ebp+var_20], eax
		mov	[ebp+var_35], 1
		mov	eax, [ebp+var_2C]
		push	eax
		mov	ecx, ds:_cache
		push	ecx
		call	_uhash_removeElement_56
		add	esp, 8
		mov	eax, [ebp+var_8]
		push	eax
		call	?free_entry@@YAXPAUUResourceDataEntry@@@Z ; free_entry(UResourceDataEntry *)
		add	esp, 4

loc_8AF1:				; CODE XREF: ures_flushCache(void)+83j
		jmp	short loc_8A97
; ---------------------------------------------------------------------------

loc_8AF3:				; CODE XREF: ures_flushCache(void)+71j
		movsx	eax, [ebp+var_35]
		test	eax, eax
		jnz	short loc_8A8C
		push	offset _resbMutex
		call	_umtx_unlock_56
		add	esp, 4
		mov	eax, [ebp+var_20]

loc_8B0B:				; CODE XREF: ures_flushCache(void)+4Aj
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN12_1
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0FCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?ures_flushCache@@YAHXZ	endp

; ---------------------------------------------------------------------------
$LN12_1		dd 1			; DATA XREF: ures_flushCache(void)+CFo
		dd offset $LN11_0
$LN11_0		dd 0FFFFFFECh, 4	; DATA XREF: .text:00008B34o
		dd offset $LN10_1
$LN10_1		dd 736F70h		; DATA XREF: .text:00008B40o
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8B48h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl free_entry(struct UResourceDataEntry *)
?free_entry@@YAXPAUUResourceDataEntry@@@Z proc near ; CODE XREF: ures_flushCache(void)+A9p
					; init_entry(char const	*,char const *,UErrorCode *)+394p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		add	eax, 14h
		push	eax
		call	_res_unload_56
		add	esp, 4
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax], 0
		jz	short loc_8B98
		mov	eax, [ebp+arg_0]
		add	eax, 3Ch ; '<'
		mov	ecx, [ebp+arg_0]
		cmp	[ecx], eax
		jz	short loc_8B98
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		call	_uprv_free_56
		add	esp, 4

loc_8B98:				; CODE XREF: free_entry(UResourceDataEntry *)+33j
					; free_entry(UResourceDataEntry	*)+40j
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+4], 0
		jz	short loc_8BB0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		push	ecx
		call	_uprv_free_56
		add	esp, 4

loc_8BB0:				; CODE XREF: free_entry(UResourceDataEntry *)+57j
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+10h], 0
		jz	short loc_8BCE
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		mov	edx, [ecx+40h]
		sub	edx, 1
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		mov	[ecx+40h], edx

loc_8BCE:				; CODE XREF: free_entry(UResourceDataEntry *)+6Fj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+0Ch]
		mov	[ebp+var_8], ecx
		cmp	[ebp+var_8], 0
		jz	short loc_8C00

loc_8BDD:				; CODE XREF: free_entry(UResourceDataEntry *)+A7j
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+0Ch], 0
		jz	short loc_8BF1
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		mov	[ebp+var_8], ecx
		jmp	short loc_8BDD
; ---------------------------------------------------------------------------

loc_8BF1:				; CODE XREF: free_entry(UResourceDataEntry *)+9Cj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+40h]
		sub	ecx, 1
		mov	edx, [ebp+var_8]
		mov	[edx+40h], ecx

loc_8C00:				; CODE XREF: free_entry(UResourceDataEntry *)+93j
		mov	eax, [ebp+arg_0]
		push	eax
		call	_uprv_free_56
		add	esp, 4
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?free_entry@@YAXPAUUResourceDataEntry@@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8C20h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct UResourceDataEntry * __cdecl init_entry(char const *, char const *, enum  UErrorCode *)
?init_entry@@YAPAUUResourceDataEntry@@PBD0PAW4UErrorCode@@@Z proc near
					; CODE XREF: entryOpen(char const *,char const *,UResOpenType,UErrorCode *)+1B2p
					; init_entry(char const	*,char const *,UErrorCode *)+30Ep ...

var_1E0		= byte ptr -1E0h
var_11C		= dword	ptr -11Ch
var_110		= dword	ptr -110h
var_104		= dword	ptr -104h
var_F8		= dword	ptr -0F8h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_D4		= byte ptr -0D4h
Dst		= byte ptr -0D3h
Str		= dword	ptr -68h
var_5C		= dword	ptr -5Ch
var_58		= dword	ptr -58h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 1E0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_1E0]
		mov	ecx, 78h ; 'x'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	[ebp+var_C], 0
		mov	[ebp+var_D4], 0
		push	63h ; 'c'       ; Size
		push	0		; Val
		lea	eax, [ebp+Dst]
		push	eax		; Dst
		call	_memset_0
		add	esp, 0Ch
		mov	[ebp+var_E0], 0
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_8C8F
		xor	eax, eax
		jmp	loc_902F
; ---------------------------------------------------------------------------

loc_8C8F:				; CODE XREF: init_entry(char const *,char const	*,UErrorCode *)+66j
		cmp	[ebp+arg_0], 0
		jnz	short loc_8C9F
		call	_uloc_getDefault_56
		mov	[ebp+Str], eax
		jmp	short loc_8CB8
; ---------------------------------------------------------------------------

loc_8C9F:				; CODE XREF: init_entry(char const *,char const	*,UErrorCode *)+73j
		mov	eax, [ebp+arg_0]
		movsx	ecx, byte ptr [eax]
		test	ecx, ecx
		jnz	short loc_8CB2
		mov	[ebp+Str], offset ??_C@_04NBFCGMPH@root?$AA@ ; "root"
		jmp	short loc_8CB8
; ---------------------------------------------------------------------------

loc_8CB2:				; CODE XREF: init_entry(char const *,char const	*,UErrorCode *)+87j
		mov	eax, [ebp+arg_0]
		mov	[ebp+Str], eax

loc_8CB8:				; CODE XREF: init_entry(char const *,char const	*,UErrorCode *)+7Dj
					; init_entry(char const	*,char const *,UErrorCode *)+90j
		mov	eax, [ebp+Str]
		mov	[ebp+var_5C], eax
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_58], eax
		lea	eax, [ebp+var_5C]
		push	eax
		mov	ecx, ds:_cache
		push	ecx
		call	_uhash_get_56
		add	esp, 8
		mov	[ebp+var_C], eax
		cmp	[ebp+var_C], 0
		jnz	loc_8FDA
		push	48h ; 'H'
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+var_C], eax
		cmp	[ebp+var_C], 0
		jnz	short loc_8D07
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 7
		xor	eax, eax
		jmp	loc_902F
; ---------------------------------------------------------------------------

loc_8D07:				; CODE XREF: init_entry(char const *,char const	*,UErrorCode *)+D5j
		push	48h ; 'H'       ; Size
		push	0		; Val
		mov	eax, [ebp+var_C]
		push	eax		; Dst
		call	_memset
		add	esp, 0Ch
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+Str]
		push	ecx		; Str
		mov	edx, [ebp+var_C]
		push	edx		; int
		call	?setEntryName@@YAXPAUUResourceDataEntry@@PBDPAW4UErrorCode@@@Z ; setEntryName(UResourceDataEntry *,char	const *,UErrorCode *)
		add	esp, 0Ch
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_8D53
		mov	eax, [ebp+var_C]
		push	eax
		call	_uprv_free_56
		add	esp, 4
		xor	eax, eax
		jmp	loc_902F
; ---------------------------------------------------------------------------

loc_8D53:				; CODE XREF: init_entry(char const *,char const	*,UErrorCode *)+11Ej
		cmp	[ebp+arg_4], 0
		jz	short loc_8D90
		mov	eax, [ebp+arg_4]
		push	eax
		call	_uprv_strdup_56
		add	esp, 4
		mov	ecx, [ebp+var_C]
		mov	[ecx+4], eax
		mov	eax, [ebp+var_C]
		cmp	dword ptr [eax+4], 0
		jnz	short loc_8D90
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 7
		mov	eax, [ebp+var_C]
		push	eax
		call	_uprv_free_56
		add	esp, 4
		xor	eax, eax
		jmp	loc_902F
; ---------------------------------------------------------------------------

loc_8D90:				; CODE XREF: init_entry(char const *,char const	*,UErrorCode *)+137j
					; init_entry(char const	*,char const *,UErrorCode *)+152j
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+var_C]
		mov	edx, [ecx]
		push	edx
		mov	eax, [ebp+var_C]
		mov	ecx, [eax+4]
		push	ecx
		mov	edx, [ebp+var_C]
		add	edx, 14h
		push	edx
		call	_res_load_56
		add	esp, 10h
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_8DDD
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 0FFFFFF80h
		mov	eax, [ebp+var_C]
		mov	dword ptr [eax+44h], 0FFFFFF80h
		jmp	loc_8F3C
; ---------------------------------------------------------------------------

loc_8DDD:				; CODE XREF: init_entry(char const *,char const	*,UErrorCode *)+1A3j
		mov	eax, [ebp+var_C]
		movsx	ecx, byte ptr [eax+3Ah]
		test	ecx, ecx
		jz	loc_8E8E
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+var_C]
		mov	edx, [ecx+4]
		push	edx
		call	?getPoolEntry@@YAPAUUResourceDataEntry@@PBDPAW4UErrorCode@@@Z ;	getPoolEntry(char const	*,UErrorCode *)
		add	esp, 8
		mov	ecx, [ebp+var_C]
		mov	[ecx+10h], eax
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_8E83
		mov	eax, [ebp+var_C]
		mov	ecx, [eax+10h]
		mov	edx, [ecx+18h]
		add	edx, 4
		mov	[ebp+var_F8], edx
		mov	eax, [ebp+var_C]
		mov	ecx, [eax+18h]
		mov	edx, [ebp+var_F8]
		mov	eax, [ecx+20h]
		cmp	eax, [edx+1Ch]
		jnz	short loc_8E6E
		mov	eax, [ebp+var_F8]
		mov	ecx, [eax]
		and	ecx, 0FFh
		mov	edx, [ebp+var_F8]
		lea	eax, [edx+ecx*4]
		mov	ecx, [ebp+var_C]
		mov	[ecx+20h], eax
		mov	eax, [ebp+var_C]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_C]
		mov	eax, [ecx+1Ch]
		mov	[edx+2Ch], eax
		jmp	short loc_8E81
; ---------------------------------------------------------------------------

loc_8E6E:				; CODE XREF: init_entry(char const *,char const	*,UErrorCode *)+21Ej
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 3
		mov	ecx, [ebp+var_C]
		mov	dword ptr [ecx+44h], 3

loc_8E81:				; CODE XREF: init_entry(char const *,char const	*,UErrorCode *)+24Cj
		jmp	short loc_8E8E
; ---------------------------------------------------------------------------

loc_8E83:				; CODE XREF: init_entry(char const *,char const	*,UErrorCode *)+1F8j
		mov	eax, [ebp+var_C]
		mov	ecx, [ebp+arg_8]
		mov	edx, [ecx]
		mov	[eax+44h], edx

loc_8E8E:				; CODE XREF: init_entry(char const *,char const	*,UErrorCode *)+1C6j
					; init_entry(char const	*,char const *,UErrorCode *):loc_8E81j
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	loc_8F3C
		push	offset ??_C@_07OJBLMIMJ@?$CF?$CFALIAS?$AA@ ; "%%ALIAS"
		mov	eax, [ebp+var_C]
		add	eax, 14h
		push	eax
		call	_res_getResource_56
		add	esp, 8
		mov	[ebp+var_EC], eax
		cmp	[ebp+var_EC], 0FFFFFFFFh
		jz	short loc_8F3C
		lea	eax, [ebp+var_E0]
		push	eax
		mov	ecx, [ebp+var_EC]
		push	ecx
		mov	edx, [ebp+var_C]
		add	edx, 14h
		push	edx
		call	_res_getString_56
		add	esp, 0Ch
		mov	[ebp+var_104], eax
		cmp	[ebp+var_104], 0
		jz	short loc_8F3C
		cmp	[ebp+var_E0], 0
		jle	short loc_8F3C
		mov	eax, [ebp+var_E0]
		add	eax, 1
		push	eax
		lea	ecx, [ebp+var_D4]
		push	ecx
		mov	edx, [ebp+var_104]
		push	edx
		call	_u_UCharsToChars_56
		add	esp, 0Ch
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		lea	edx, [ebp+var_D4]
		push	edx
		call	?init_entry@@YAPAUUResourceDataEntry@@PBD0PAW4UErrorCode@@@Z ; init_entry(char const *,char const *,UErrorCode *)
		add	esp, 0Ch
		mov	ecx, [ebp+var_C]
		mov	[ecx+0Ch], eax

loc_8F3C:				; CODE XREF: init_entry(char const *,char const	*,UErrorCode *)+1B8j
					; init_entry(char const	*,char const *,UErrorCode *)+281j ...
		mov	[ebp+var_110], 0
		mov	eax, [ebp+var_C]
		push	eax
		mov	ecx, ds:_cache
		push	ecx
		call	_uhash_get_56
		add	esp, 8
		mov	[ebp+var_110], eax
		cmp	[ebp+var_110], 0
		jnz	short loc_8FC5
		mov	[ebp+var_11C], 0
		lea	eax, [ebp+var_11C]
		push	eax
		mov	ecx, [ebp+var_C]
		push	ecx
		mov	edx, [ebp+var_C]
		push	edx
		mov	eax, ds:_cache
		push	eax
		call	_uhash_put_56
		add	esp, 10h
		mov	eax, [ebp+var_11C]
		push	eax
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_8FC3
		mov	eax, [ebp+arg_8]
		mov	ecx, [ebp+var_11C]
		mov	[eax], ecx
		mov	eax, [ebp+var_C]
		push	eax
		call	?free_entry@@YAXPAUUResourceDataEntry@@@Z ; free_entry(UResourceDataEntry *)
		add	esp, 4
		mov	[ebp+var_C], 0

loc_8FC3:				; CODE XREF: init_entry(char const *,char const	*,UErrorCode *)+383j
		jmp	short loc_8FDA
; ---------------------------------------------------------------------------

loc_8FC5:				; CODE XREF: init_entry(char const *,char const	*,UErrorCode *)+346j
		mov	eax, [ebp+var_C]
		push	eax
		call	?free_entry@@YAXPAUUResourceDataEntry@@@Z ; free_entry(UResourceDataEntry *)
		add	esp, 4
		mov	eax, [ebp+var_110]
		mov	[ebp+var_C], eax

loc_8FDA:				; CODE XREF: init_entry(char const *,char const	*,UErrorCode *)+BEj
					; init_entry(char const	*,char const *,UErrorCode *):loc_8FC3j
		cmp	[ebp+var_C], 0
		jz	short loc_902C

loc_8FE0:				; CODE XREF: init_entry(char const *,char const	*,UErrorCode *)+3D2j
		mov	eax, [ebp+var_C]
		cmp	dword ptr [eax+0Ch], 0
		jz	short loc_8FF4
		mov	eax, [ebp+var_C]
		mov	ecx, [eax+0Ch]
		mov	[ebp+var_C], ecx
		jmp	short loc_8FE0
; ---------------------------------------------------------------------------

loc_8FF4:				; CODE XREF: init_entry(char const *,char const	*,UErrorCode *)+3C7j
		mov	eax, [ebp+var_C]
		mov	ecx, [eax+40h]
		add	ecx, 1
		mov	edx, [ebp+var_C]
		mov	[edx+40h], ecx
		mov	eax, [ebp+var_C]
		cmp	dword ptr [eax+44h], 0
		jz	short loc_902C
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_902C
		mov	eax, [ebp+arg_8]
		mov	ecx, [ebp+var_C]
		mov	edx, [ecx+44h]
		mov	[eax], edx

loc_902C:				; CODE XREF: init_entry(char const *,char const	*,UErrorCode *)+3BEj
					; init_entry(char const	*,char const *,UErrorCode *)+3EAj ...
		mov	eax, [ebp+var_C]

loc_902F:				; CODE XREF: init_entry(char const *,char const	*,UErrorCode *)+6Aj
					; init_entry(char const	*,char const *,UErrorCode *)+E2j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN35_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 1E0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?init_entry@@YAPAUUResourceDataEntry@@PBD0PAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
$LN35_0		dd 4			; DATA XREF: init_entry(char const *,char const	*,UErrorCode *)+413o
		dd offset $LN34
$LN34		dd 0FFFFFFA4h, 48h	; DATA XREF: .text:00009064o
		dd offset $LN30_1	; "find"
		dd 0FFFFFF2Ch, 64h
		dd offset $LN31_0	; "aliasName"
		dd 0FFFFFF20h, 4
		dd offset $LN32		; "aliasLen"
		dd 0FFFFFEE4h, 4
		dd offset $LN33		; "cacheStatus"
$LN33		db 'cacheStatus',0      ; DATA XREF: .text:00009094o
$LN32		db 'aliasLen',0         ; DATA XREF: .text:00009088o
$LN31_0		db 'aliasName',0        ; DATA XREF: .text:0000907Co
$LN30_1		db 'find',0             ; DATA XREF: .text:00009070o
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 90BCh
		public ??_C@_07OJBLMIMJ@?$CF?$CFALIAS?$AA@
; `string'
??_C@_07OJBLMIMJ@?$CF?$CFALIAS?$AA@ db '%%ALIAS',0
					; DATA XREF: init_entry(char const *,char const	*,UErrorCode *)+287o
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 90C4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl setEntryName(int,	char *Str, int)
?setEntryName@@YAXPAUUResourceDataEntry@@PBDPAW4UErrorCode@@@Z proc near
					; CODE XREF: init_entry(char const *,char const	*,UErrorCode *)+103p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
Str		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+Str]
		push	eax		; Str
		call	_strlen
		add	esp, 4
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax], 0
		jz	short loc_9114
		mov	eax, [ebp+arg_0]
		add	eax, 3Ch ; '<'
		mov	ecx, [ebp+arg_0]
		cmp	[ecx], eax
		jz	short loc_9114
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		call	_uprv_free_56
		add	esp, 4

loc_9114:				; CODE XREF: setEntryName(UResourceDataEntry *,char const *,UErrorCode *)+33j
					; setEntryName(UResourceDataEntry *,char const *,UErrorCode *)+40j
		cmp	[ebp+var_8], 3
		jge	short loc_9127
		mov	eax, [ebp+arg_0]
		add	eax, 3Ch ; '<'
		mov	ecx, [ebp+arg_0]
		mov	[ecx], eax
		jmp	short loc_913B
; ---------------------------------------------------------------------------

loc_9127:				; CODE XREF: setEntryName(UResourceDataEntry *,char const *,UErrorCode *)+54j
		mov	eax, [ebp+var_8]
		add	eax, 1
		push	eax
		call	_uprv_malloc_56
		add	esp, 4
		mov	ecx, [ebp+arg_0]
		mov	[ecx], eax

loc_913B:				; CODE XREF: setEntryName(UResourceDataEntry *,char const *,UErrorCode *)+61j
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax], 0
		jnz	short loc_914E
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 7
		jmp	short loc_9160
; ---------------------------------------------------------------------------

loc_914E:				; CODE XREF: setEntryName(UResourceDataEntry *,char const *,UErrorCode *)+7Dj
		mov	eax, [ebp+Str]
		push	eax		; Source
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		push	edx		; Dest
		call	_strcpy
		add	esp, 8

loc_9160:				; CODE XREF: setEntryName(UResourceDataEntry *,char const *,UErrorCode *)+88j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?setEntryName@@YAXPAUUResourceDataEntry@@PBDPAW4UErrorCode@@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9174h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct UResourceDataEntry * __cdecl getPoolEntry(char	const *, enum  UErrorCode *)
?getPoolEntry@@YAPAUUResourceDataEntry@@PBDPAW4UErrorCode@@@Z proc near
					; CODE XREF: init_entry(char const *,char const	*,UErrorCode *)+1D7p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		push	offset ??_C@_04CJIJKHMO@pool?$AA@ ; "pool"
		call	?init_entry@@YAPAUUResourceDataEntry@@PBD0PAW4UErrorCode@@@Z ; init_entry(char const *,char const *,UErrorCode *)
		add	esp, 0Ch
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_91E2
		cmp	[ebp+var_8], 0
		jz	short loc_91D9
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+44h], 0
		jnz	short loc_91D9
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+39h]
		test	ecx, ecx
		jnz	short loc_91E2

loc_91D9:				; CODE XREF: getPoolEntry(char const *,UErrorCode *)+4Fj
					; getPoolEntry(char const *,UErrorCode *)+58j
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 3

loc_91E2:				; CODE XREF: getPoolEntry(char const *,UErrorCode *)+49j
					; getPoolEntry(char const *,UErrorCode *)+63j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getPoolEntry@@YAPAUUResourceDataEntry@@PBDPAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 91FCh
		public ??_C@_04CJIJKHMO@pool?$AA@
; `string'
??_C@_04CJIJKHMO@pool?$AA@ db 'pool',0  ; DATA XREF: getPoolEntry(char const *,UErrorCode *)+26o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9204h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl findFirstExisting(int, char *Str,	int, int, int, int)
?findFirstExisting@@YAPAUUResourceDataEntry@@PBDPADPAC22PAW4UErrorCode@@@Z proc	near
					; CODE XREF: entryOpen(char const *,char const *,UResOpenType,UErrorCode *)+16Dp
					; entryOpen(char const *,char const *,UResOpenType,UErrorCode *)+29Ep ...

var_E4		= byte ptr -0E4h
Str2		= dword	ptr -20h
var_11		= byte ptr -11h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
Str		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	[ebp+var_11], 0
		call	_uloc_getDefault_56
		mov	[ebp+Str2], eax
		mov	eax, [ebp+arg_C]
		mov	byte ptr [eax],	1

loc_923B:				; CODE XREF: findFirstExisting(char const *,char *,signed char *,signed	char *,signed char *,UErrorCode	*)+145j
		mov	eax, [ebp+arg_C]
		movsx	ecx, byte ptr [eax]
		test	ecx, ecx
		jz	loc_934E
		movsx	eax, [ebp+var_11]
		test	eax, eax
		jnz	loc_934E
		mov	eax, [ebp+arg_14]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	edx, [ebp+Str]
		push	edx
		call	?init_entry@@YAPAUUResourceDataEntry@@PBD0PAW4UErrorCode@@@Z ; init_entry(char const *,char const *,UErrorCode *)
		add	esp, 0Ch
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_14]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_9288
		xor	eax, eax
		jmp	loc_9351
; ---------------------------------------------------------------------------

loc_9288:				; CODE XREF: findFirstExisting(char const *,char *,signed char *,signed	char *,signed char *,UErrorCode	*)+7Bj
		push	1
		mov	eax, [ebp+Str]
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		push	1
		mov	ecx, [ebp+Str2]
		push	ecx
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	edx, [ebp+Str]
		push	edx		; Str
		call	_strlen
		add	esp, 4
		mov	esi, esp
		push	eax		; MaxCount
		mov	eax, [ebp+Str2]
		push	eax		; Str2
		mov	ecx, [ebp+Str]
		push	ecx		; Str1
		call	dword ptr ds:__imp__strncmp
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		setz	dl
		mov	eax, [ebp+arg_10]
		mov	[eax], dl
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+44h], 0
		setz	cl
		mov	[ebp+var_11], cl
		movsx	eax, [ebp+var_11]
		test	eax, eax
		jnz	short loc_930B
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+40h]
		sub	ecx, 1
		mov	edx, [ebp+var_8]
		mov	[edx+40h], ecx
		mov	[ebp+var_8], 0
		mov	eax, [ebp+arg_14]
		mov	dword ptr [eax], 0FFFFFF80h
		jmp	short loc_931D
; ---------------------------------------------------------------------------

loc_930B:				; CODE XREF: findFirstExisting(char const *,char *,signed char *,signed	char *,signed char *,UErrorCode	*)+E4j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		push	ecx		; Source
		mov	edx, [ebp+Str]
		push	edx		; Dest
		call	_strcpy
		add	esp, 8

loc_931D:				; CODE XREF: findFirstExisting(char const *,char *,signed char *,signed	char *,signed char *,UErrorCode	*)+105j
		push	offset ??_C@_04NBFCGMPH@root?$AA@ ; "root"
		mov	eax, [ebp+Str]
		push	eax		; Str1
		call	_strcmp
		add	esp, 8
		test	eax, eax
		setz	cl
		mov	edx, [ebp+arg_8]
		mov	[edx], cl
		mov	eax, [ebp+Str]
		push	eax		; Str
		call	?chopLocale@@YACPAD@Z ;	chopLocale(char	*)
		add	esp, 4
		mov	ecx, [ebp+arg_C]
		mov	[ecx], al
		jmp	loc_923B
; ---------------------------------------------------------------------------

loc_934E:				; CODE XREF: findFirstExisting(char const *,char *,signed char *,signed	char *,signed char *,UErrorCode	*)+3Fj
					; findFirstExisting(char const *,char *,signed char *,signed char *,signed char	*,UErrorCode *)+4Bj
		mov	eax, [ebp+var_8]

loc_9351:				; CODE XREF: findFirstExisting(char const *,char *,signed char *,signed	char *,signed char *,UErrorCode	*)+7Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?findFirstExisting@@YAPAUUResourceDataEntry@@PBDPADPAC22PAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9368h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl chopLocale(char *Str)
?chopLocale@@YACPAD@Z proc near		; CODE XREF: findFirstExisting(char const *,char *,signed char *,signed	char *,signed char *,UErrorCode	*)+138p
					; loadParentsExceptRoot(UResourceDataEntry * &,char * const,int,signed char,char * const,UErrorCode *)+1E7p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
Str		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		push	5Fh ; '_'       ; int
		mov	eax, [ebp+Str]
		push	eax		; Str
		call	?strrchr@@YAPADPADH@Z ;	strrchr(char *,int)
		add	esp, 8
		mov	[ebp+var_8], eax
		cmp	[ebp+var_8], 0
		jz	short loc_93A7
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	0
		mov	al, 1
		jmp	short loc_93A9
; ---------------------------------------------------------------------------

loc_93A7:				; CODE XREF: chopLocale(char *)+33j
		xor	al, al

loc_93A9:				; CODE XREF: chopLocale(char *)+3Dj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?chopLocale@@YACPAD@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 93C0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; char *__cdecl	strrchr(char *Str, int)
		public ?strrchr@@YAPADPADH@Z
?strrchr@@YAPADPADH@Z proc near		; CODE XREF: chopLocale(char *)+24p

var_C0		= byte ptr -0C0h
Str		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax		; Ch
		mov	ecx, [ebp+Str]
		push	ecx		; Str
		call	dword ptr ds:__imp__strrchr
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?strrchr@@YAPADPADH@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 940Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl loadParentsExceptRoot(int, char *Str1, int, char,	int, int)
?loadParentsExceptRoot@@YACAAPAUUResourceDataEntry@@QADHC1PAW4UErrorCode@@@Z proc near
					; CODE XREF: entryOpen(char const *,char const *,UResOpenType,UErrorCode *)+229p
					; entryOpen(char const *,char const *,UResOpenType,UErrorCode *)+2F4p ...

var_120		= byte ptr -120h
var_5C		= dword	ptr -5Ch
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_5		= byte ptr -5
arg_0		= dword	ptr  8
Str1		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= byte ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 120h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_120]
		mov	ecx, 48h ; 'H'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_14]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_9446
		xor	al, al
		jmp	loc_9605
; ---------------------------------------------------------------------------

loc_9446:				; CODE XREF: loadParentsExceptRoot(UResourceDataEntry *	&,char * const,int,signed char,char * const,UErrorCode *)+31j
		mov	[ebp+var_5], 1

loc_944A:				; CODE XREF: loadParentsExceptRoot(UResourceDataEntry *	&,char * const,int,signed char,char * const,UErrorCode *)+1F2j
		movsx	eax, [ebp+var_5]
		test	eax, eax
		jz	loc_9603
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		cmp	dword ptr [ecx+8], 0
		jnz	loc_9603
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		movsx	edx, byte ptr [ecx+38h]
		test	edx, edx
		jnz	loc_9603
		push	offset ??_C@_0P@DIIEJICA@?$CF?$CFParentIsRoot?$AA@ ; "%%ParentIsRoot"
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		add	ecx, 14h
		push	ecx
		call	_res_getResource_56
		add	esp, 8
		cmp	eax, 0FFFFFFFFh
		jnz	loc_9603
		push	offset ??_C@_08GILJLIB@?$CF?$CFParent?$AA@ ; "%%Parent"
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		add	ecx, 14h
		push	ecx
		call	_res_getResource_56
		add	esp, 8
		mov	[ebp+var_14], eax
		cmp	[ebp+var_14], 0FFFFFFFFh
		jz	short loc_951E
		mov	[ebp+var_20], 0
		lea	eax, [ebp+var_20]
		push	eax
		mov	ecx, [ebp+var_14]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx]
		add	eax, 14h
		push	eax
		call	_res_getString_56
		add	esp, 0Ch
		mov	[ebp+var_2C], eax
		cmp	[ebp+var_2C], 0
		jz	short loc_951E
		cmp	[ebp+var_20], 0
		jle	short loc_951E
		mov	eax, [ebp+var_20]
		cmp	eax, [ebp+arg_8]
		jge	short loc_951E
		mov	eax, [ebp+var_20]
		add	eax, 1
		push	eax
		mov	ecx, [ebp+Str1]
		push	ecx
		mov	edx, [ebp+var_2C]
		push	edx
		call	_u_UCharsToChars_56
		add	esp, 0Ch
		push	offset ??_C@_04NBFCGMPH@root?$AA@ ; "root"
		mov	eax, [ebp+Str1]
		push	eax		; Str1
		call	_strcmp
		add	esp, 8
		test	eax, eax
		jnz	short loc_951E
		mov	al, 1
		jmp	loc_9605
; ---------------------------------------------------------------------------

loc_951E:				; CODE XREF: loadParentsExceptRoot(UResourceDataEntry *	&,char * const,int,signed char,char * const,UErrorCode *)+A6j
					; loadParentsExceptRoot(UResourceDataEntry * &,char * const,int,signed char,char * const,UErrorCode *)+CFj ...
		mov	[ebp+var_38], 0
		lea	eax, [ebp+var_38]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	eax, [edx+4]
		push	eax
		mov	ecx, [ebp+Str1]
		push	ecx
		call	?init_entry@@YAPAUUResourceDataEntry@@PBD0PAW4UErrorCode@@@Z ; init_entry(char const *,char const *,UErrorCode *)
		add	esp, 0Ch
		mov	[ebp+var_44], eax
		mov	eax, [ebp+var_38]
		push	eax
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_9563
		mov	eax, [ebp+arg_14]
		mov	ecx, [ebp+var_38]
		mov	[eax], ecx
		xor	al, al
		jmp	loc_9605
; ---------------------------------------------------------------------------

loc_9563:				; CODE XREF: loadParentsExceptRoot(UResourceDataEntry *	&,char * const,int,signed char,char * const,UErrorCode *)+146j
		mov	[ebp+var_50], 0
		mov	[ebp+var_5C], 0
		movsx	eax, [ebp+arg_C]
		test	eax, eax
		jz	short loc_9590
		lea	eax, [ebp+var_5C]
		push	eax
		mov	ecx, [ebp+arg_10]
		push	ecx
		mov	edx, [ebp+Str1]
		push	edx
		call	?init_entry@@YAPAUUResourceDataEntry@@PBD0PAW4UErrorCode@@@Z ; init_entry(char const *,char const *,UErrorCode *)
		add	esp, 0Ch
		mov	[ebp+var_50], eax

loc_9590:				; CODE XREF: loadParentsExceptRoot(UResourceDataEntry *	&,char * const,int,signed char,char * const,UErrorCode *)+16Bj
		movsx	eax, [ebp+arg_C]
		test	eax, eax
		jz	short loc_95CA
		mov	eax, [ebp+var_5C]
		push	eax
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_95CA
		mov	eax, [ebp+var_50]
		cmp	dword ptr [eax+44h], 0
		jnz	short loc_95CA
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ebp+var_50]
		mov	[ecx+8], edx
		mov	eax, [ebp+var_50]
		mov	ecx, [ebp+var_44]
		mov	[eax+8], ecx
		jmp	short loc_95E7
; ---------------------------------------------------------------------------

loc_95CA:				; CODE XREF: loadParentsExceptRoot(UResourceDataEntry *	&,char * const,int,signed char,char * const,UErrorCode *)+18Aj
					; loadParentsExceptRoot(UResourceDataEntry * &,char * const,int,signed char,char * const,UErrorCode *)+19Dj ...
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ebp+var_44]
		mov	[ecx+8], edx
		movsx	eax, [ebp+arg_C]
		test	eax, eax
		jz	short loc_95E7
		mov	eax, [ebp+var_50]
		mov	dword ptr [eax+40h], 0

loc_95E7:				; CODE XREF: loadParentsExceptRoot(UResourceDataEntry *	&,char * const,int,signed char,char * const,UErrorCode *)+1BCj
					; loadParentsExceptRoot(UResourceDataEntry * &,char * const,int,signed char,char * const,UErrorCode *)+1CFj
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_44]
		mov	[eax], ecx
		mov	eax, [ebp+Str1]
		push	eax		; Str
		call	?chopLocale@@YACPAD@Z ;	chopLocale(char	*)
		add	esp, 4
		mov	[ebp+var_5], al
		jmp	loc_944A
; ---------------------------------------------------------------------------

loc_9603:				; CODE XREF: loadParentsExceptRoot(UResourceDataEntry *	&,char * const,int,signed char,char * const,UErrorCode *)+44j
					; loadParentsExceptRoot(UResourceDataEntry * &,char * const,int,signed char,char * const,UErrorCode *)+53j ...
		mov	al, 1

loc_9605:				; CODE XREF: loadParentsExceptRoot(UResourceDataEntry *	&,char * const,int,signed char,char * const,UErrorCode *)+35j
					; loadParentsExceptRoot(UResourceDataEntry * &,char * const,int,signed char,char * const,UErrorCode *)+10Dj ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN18_6
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 120h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?loadParentsExceptRoot@@YACAAPAUUResourceDataEntry@@QADHC1PAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN18_6		dd 3			; DATA XREF: loadParentsExceptRoot(UResourceDataEntry *	&,char * const,int,signed char,char * const,UErrorCode *)+1FDo
		dd offset $LN17_5
$LN17_5		dd 0FFFFFFE0h, 4	; DATA XREF: .text:00009630o
		dd offset $LN14_0	; "parentLocaleLen"
		dd 0FFFFFFC8h, 4
		dd offset $LN15_2	; "parentStatus"
		dd 0FFFFFFA4h, 4
		dd offset $LN16_4	; "usrStatus"
$LN16_4		db 'usrStatus',0        ; DATA XREF: .text:00009654o
$LN15_2		db 'parentStatus',0     ; DATA XREF: .text:00009648o
$LN14_0		db 'parentLocaleLen',0  ; DATA XREF: .text:0000963Co
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 9680h
		public ??_C@_08GILJLIB@?$CF?$CFParent?$AA@
; `string'
??_C@_08GILJLIB@?$CF?$CFParent?$AA@ db '%%Parent',0
					; DATA XREF: loadParentsExceptRoot(UResourceDataEntry *	&,char * const,int,signed char,char * const,UErrorCode *)+89o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 968Ch
		public ??_C@_0P@DIIEJICA@?$CF?$CFParentIsRoot?$AA@
; `string'
??_C@_0P@DIIEJICA@?$CF?$CFParentIsRoot?$AA@ db '%%ParentIsRoot',0
					; DATA XREF: loadParentsExceptRoot(UResourceDataEntry *	&,char * const,int,signed char,char * const,UErrorCode *)+6Ao
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 969Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl insertRootBundle(struct UResourceDataEntry * &, enum  UErrorCode *)
?insertRootBundle@@YACAAPAUUResourceDataEntry@@PAW4UErrorCode@@@Z proc near
					; CODE XREF: entryOpen(char const *,char const *,UResOpenType,UErrorCode *)+3B6p
					; entryOpenDirect(char const *,char const *,UErrorCode *)+19Dp

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_96D3
		xor	al, al
		jmp	short loc_972B
; ---------------------------------------------------------------------------

loc_96D3:				; CODE XREF: insertRootBundle(UResourceDataEntry * &,UErrorCode	*)+31j
		mov	[ebp+var_8], 0
		lea	eax, [ebp+var_8]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	eax, [edx+4]
		push	eax
		push	offset ??_C@_04NBFCGMPH@root?$AA@ ; "root"
		call	?init_entry@@YAPAUUResourceDataEntry@@PBD0PAW4UErrorCode@@@Z ; init_entry(char const *,char const *,UErrorCode *)
		add	esp, 0Ch
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_8]
		push	eax
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_9716
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+var_8]
		mov	[eax], ecx
		xor	al, al
		jmp	short loc_972B
; ---------------------------------------------------------------------------

loc_9716:				; CODE XREF: insertRootBundle(UResourceDataEntry * &,UErrorCode	*)+6Cj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ebp+var_14]
		mov	[ecx+8], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		mov	[eax], ecx
		mov	al, 1

loc_972B:				; CODE XREF: insertRootBundle(UResourceDataEntry * &,UErrorCode	*)+35j
					; insertRootBundle(UResourceDataEntry *	&,UErrorCode *)+78j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN7_3
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?insertRootBundle@@YACAAPAUUResourceDataEntry@@PAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
$LN7_3		dd 1			; DATA XREF: insertRootBundle(UResourceDataEntry * &,UErrorCode	*)+93o
		dd offset $LN6_5
$LN6_5		dd 0FFFFFFF8h, 4	; DATA XREF: .text:00009754o
		dd offset $LN5_6	; "parentStatus"
$LN5_6		db 'parentStatus',0     ; DATA XREF: .text:00009760o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9774h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl entryOpenDirect(int, char	*Str1, int)
?entryOpenDirect@@YAPAUUResourceDataEntry@@PBD0PAW4UErrorCode@@@Z proc near
					; CODE XREF: ures_openWithType(UResourceBundle *,char const *,char const *,UResOpenType,UErrorCode *)+BFp

var_184		= byte ptr -184h
Dest		= byte ptr -0C0h
var_18		= dword	ptr -18h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
Str1		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 184h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_184]
		mov	ecx, 61h ; 'a'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	eax, [ebp+arg_8]
		push	eax
		call	?initCache@@YAXPAW4UErrorCode@@@Z ; initCache(UErrorCode *)
		add	esp, 4
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_97C4
		xor	eax, eax
		jmp	loc_9974
; ---------------------------------------------------------------------------

loc_97C4:				; CODE XREF: entryOpenDirect(char const	*,char const *,UErrorCode *)+47j
		push	offset _resbMutex
		call	_umtx_lock_56
		add	esp, 4
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	edx, [ebp+Str1]
		push	edx
		call	?init_entry@@YAPAUUResourceDataEntry@@PBD0PAW4UErrorCode@@@Z ; init_entry(char const *,char const *,UErrorCode *)
		add	esp, 0Ch
		mov	[ebp+var_C], eax
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_981E
		mov	eax, [ebp+var_C]
		cmp	dword ptr [eax+44h], 0
		jz	short loc_981C
		mov	eax, [ebp+var_C]
		mov	ecx, [eax+40h]
		sub	ecx, 1
		mov	edx, [ebp+var_C]
		mov	[edx+40h], ecx
		mov	[ebp+var_C], 0

loc_981C:				; CODE XREF: entryOpenDirect(char const	*,char const *,UErrorCode *)+90j
		jmp	short loc_9825
; ---------------------------------------------------------------------------

loc_981E:				; CODE XREF: entryOpenDirect(char const	*,char const *,UErrorCode *)+87j
		mov	[ebp+var_C], 0

loc_9825:				; CODE XREF: entryOpenDirect(char const	*,char const *,UErrorCode *):loc_981Cj
		mov	eax, [ebp+var_C]
		mov	[ebp+var_18], eax
		cmp	[ebp+var_C], 0
		jz	loc_9935
		push	offset ??_C@_04NBFCGMPH@root?$AA@ ; "root"
		mov	eax, [ebp+Str1]
		push	eax		; Str1
		call	_strcmp
		add	esp, 8
		test	eax, eax
		jz	loc_9935
		mov	eax, [ebp+var_C]
		cmp	dword ptr [eax+8], 0
		jnz	loc_9935
		mov	eax, [ebp+var_C]
		movsx	ecx, byte ptr [eax+38h]
		test	ecx, ecx
		jnz	loc_9935
		mov	eax, [ebp+Str1]
		push	eax		; Str
		call	_strlen
		add	esp, 4
		cmp	eax, 9Dh ; ''
		jnb	loc_9935
		mov	eax, [ebp+Str1]
		push	eax		; Source
		lea	ecx, [ebp+Dest]
		push	ecx		; Dest
		call	_strcpy
		add	esp, 8
		lea	eax, [ebp+Dest]
		push	eax		; Str
		call	?chopLocale@@YACPAD@Z ;	chopLocale(char	*)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_98E9
		push	offset ??_C@_04NBFCGMPH@root?$AA@ ; "root"
		lea	eax, [ebp+Dest]
		push	eax		; Str1
		call	_strcmp
		add	esp, 8
		test	eax, eax
		jz	short loc_98E9
		mov	eax, [ebp+arg_8]
		push	eax		; int
		push	0		; int
		push	0		; char
		push	9Dh ; ''       ; int
		lea	ecx, [ebp+Dest]
		push	ecx		; Str1
		lea	edx, [ebp+var_18]
		push	edx		; int
		call	?loadParentsExceptRoot@@YACAAPAUUResourceDataEntry@@QADHC1PAW4UErrorCode@@@Z ; loadParentsExceptRoot(UResourceDataEntry	* &,char * const,int,signed char,char *	const,UErrorCode *)
		add	esp, 18h
		movsx	eax, al
		test	eax, eax
		jz	short loc_9919

loc_98E9:				; CODE XREF: entryOpenDirect(char const	*,char const *,UErrorCode *)+134j
					; entryOpenDirect(char const *,char const *,UErrorCode *)+14Cj
		push	offset ??_C@_04NBFCGMPH@root?$AA@ ; "root"
		mov	eax, [ebp+var_18]
		mov	ecx, [eax]
		push	ecx		; Str1
		call	_strcmp
		add	esp, 8
		test	eax, eax
		jz	short loc_9919
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+8], 0
		jnz	short loc_9919
		mov	eax, [ebp+arg_8]
		push	eax
		lea	ecx, [ebp+var_18]
		push	ecx
		call	?insertRootBundle@@YACAAPAUUResourceDataEntry@@PAW4UErrorCode@@@Z ; insertRootBundle(UResourceDataEntry	* &,UErrorCode *)
		add	esp, 8

loc_9919:				; CODE XREF: entryOpenDirect(char const	*,char const *,UErrorCode *)+173j
					; entryOpenDirect(char const *,char const *,UErrorCode *)+18Aj	...
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_9935
		mov	[ebp+var_C], 0

loc_9935:				; CODE XREF: entryOpenDirect(char const	*,char const *,UErrorCode *)+BBj
					; entryOpenDirect(char const *,char const *,UErrorCode *)+D4j ...
		cmp	[ebp+var_C], 0
		jz	short loc_9964

loc_993B:				; CODE XREF: entryOpenDirect(char const	*,char const *,UErrorCode *)+1EEj
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+8], 0
		jz	short loc_9964
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+8]
		mov	edx, [ecx+40h]
		add	edx, 1
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+8]
		mov	[ecx+40h], edx
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+8]
		mov	[ebp+var_18], ecx
		jmp	short loc_993B
; ---------------------------------------------------------------------------

loc_9964:				; CODE XREF: entryOpenDirect(char const	*,char const *,UErrorCode *)+1C5j
					; entryOpenDirect(char const *,char const *,UErrorCode *)+1CEj
		push	offset _resbMutex
		call	_umtx_unlock_56
		add	esp, 4
		mov	eax, [ebp+var_C]

loc_9974:				; CODE XREF: entryOpenDirect(char const	*,char const *,UErrorCode *)+4Bj
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN18_7
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 184h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?entryOpenDirect@@YAPAUUResourceDataEntry@@PBD0PAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN18_7		dd 2			; DATA XREF: entryOpenDirect(char const	*,char const *,UErrorCode *)+204o
		dd offset $LN17_6
$LN17_6		dd 0FFFFFFE8h, 4	; DATA XREF: .text:000099A8o
		dd offset $LN15_3	; "t1"
		dd 0FFFFFF40h, 9Dh
		dd offset $LN16_5	; "name"
$LN16_5		db 'name',0             ; DATA XREF: .text:000099C0o
$LN15_3		db 't1',0               ; DATA XREF: .text:000099B4o
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 99CCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _ures_openNoDefault_56
_ures_openNoDefault_56 proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_8]
		push	eax		; int
		push	1		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		push	0		; Dst
		call	?ures_openWithType@@YAPAUUResourceBundle@@PAU1@PBD1W4UResOpenType@@PAW4UErrorCode@@@Z ;	ures_openWithType(UResourceBundle *,char const *,char const *,UResOpenType,UErrorCode *)
		add	esp, 14h
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_ures_openNoDefault_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9A18h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _ures_openDirect_56
_ures_openDirect_56 proc near		; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+313p
					; _ures_openAvailableLocales_56+ECp ...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_8]
		push	eax		; int
		push	2		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		push	0		; Dst
		call	?ures_openWithType@@YAPAUUResourceBundle@@PAU1@PBD1W4UResOpenType@@PAW4UErrorCode@@@Z ;	ures_openWithType(UResourceBundle *,char const *,char const *,UResOpenType,UErrorCode *)
		add	esp, 14h
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_ures_openDirect_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9A64h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl ures_openFillIn_56(void *Dst, int, int, int)
		public _ures_openFillIn_56
_ures_openFillIn_56 proc near

var_C0		= byte ptr -0C0h
Dst		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_9AA8
		cmp	[ebp+Dst], 0
		jnz	short loc_9AA8
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 1
		jmp	short loc_9AC2
; ---------------------------------------------------------------------------

loc_9AA8:				; CODE XREF: _ures_openFillIn_56+31j
					; _ures_openFillIn_56+37j
		mov	eax, [ebp+arg_C]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+Dst]
		push	eax		; Dst
		call	?ures_openWithType@@YAPAUUResourceBundle@@PAU1@PBD1W4UResOpenType@@PAW4UErrorCode@@@Z ;	ures_openWithType(UResourceBundle *,char const *,char const *,UResOpenType,UErrorCode *)
		add	esp, 14h

loc_9AC2:				; CODE XREF: _ures_openFillIn_56+42j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_ures_openFillIn_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9AD8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _ures_countArrayItems_56
_ures_countArrayItems_56 proc near

var_170		= byte ptr -170h
var_AC		= dword	ptr -0ACh
Dst		= byte ptr -0A0h
var_8C		= dword	ptr -8Ch
var_20		= dword	ptr -20h
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 170h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_170]
		mov	ecx, 5Ch ; '\'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		lea	eax, [ebp+Dst]
		push	eax		; Dst
		call	_ures_initStackObject_56
		add	esp, 4
		cmp	[ebp+arg_8], 0
		jz	short loc_9B2A
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_9B31

loc_9B2A:				; CODE XREF: _ures_countArrayItems_56+3Bj
		xor	eax, eax
		jmp	loc_9BB4
; ---------------------------------------------------------------------------

loc_9B31:				; CODE XREF: _ures_countArrayItems_56+50j
		cmp	[ebp+arg_0], 0
		jnz	short loc_9B44
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	short loc_9BB4
; ---------------------------------------------------------------------------

loc_9B44:				; CODE XREF: _ures_countArrayItems_56+5Dj
		mov	eax, [ebp+arg_8]
		push	eax
		lea	ecx, [ebp+Dst]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		call	_ures_getByKey_56
		add	esp, 10h
		cmp	[ebp+var_8C], 0
		jz	short loc_9B9A
		mov	eax, [ebp+var_20]
		push	eax
		lea	ecx, [ebp+var_8C]
		push	ecx
		call	_res_countArrayItems_56
		add	esp, 8
		mov	[ebp+var_AC], eax
		lea	eax, [ebp+Dst]
		push	eax
		call	_ures_close_56
		add	esp, 4
		mov	eax, [ebp+var_AC]
		jmp	short loc_9BB4
; ---------------------------------------------------------------------------
		jmp	short loc_9BB4
; ---------------------------------------------------------------------------

loc_9B9A:				; CODE XREF: _ures_countArrayItems_56+8Ej
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 2
		lea	eax, [ebp+Dst]
		push	eax
		call	_ures_close_56
		add	esp, 4
		xor	eax, eax

loc_9BB4:				; CODE XREF: _ures_countArrayItems_56+54j
					; _ures_countArrayItems_56+6Aj	...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN10_2
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 170h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_ures_countArrayItems_56 endp

; ---------------------------------------------------------------------------
		align 4
$LN10_2		dd 1			; DATA XREF: _ures_countArrayItems_56+E0o
		dd offset $LN9_2
$LN9_2		dd 0FFFFFF60h, 98h	; DATA XREF: .text:00009BE8o
		dd offset $LN8_3	; "resData"
$LN8_3		db 'resData',0          ; DATA XREF: .text:00009BF4o
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9C00h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _ures_getVersionNumberInternal_56
_ures_getVersionNumberInternal_56 proc near ; CODE XREF: _ures_getVersionNumber_56+22p
					; _ures_getVersion_56+2Ap

var_F4		= dword	ptr -0F4h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0F4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Dh ; '='
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		jnz	short loc_9C2B
		xor	eax, eax
		jmp	loc_9CEE
; ---------------------------------------------------------------------------

loc_9C2B:				; CODE XREF: _ures_getVersionNumberInternal_56+22j
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+8], 0
		jnz	loc_9CE8
		mov	[ebp+var_8], 0
		mov	[ebp+var_14], 0
		lea	eax, [ebp+var_8]
		push	eax
		lea	ecx, [ebp+var_14]
		push	ecx
		push	offset ??_C@_07NGFJPNPN@Version?$AA@ ; "Version"
		mov	edx, [ebp+arg_0]
		push	edx
		call	_ures_getStringByKey_56
		add	esp, 10h
		mov	[ebp+var_2C], eax
		cmp	[ebp+var_14], 0
		jle	short loc_9C73
		mov	eax, [ebp+var_14]
		mov	[ebp+var_F4], eax
		jmp	short loc_9C7D
; ---------------------------------------------------------------------------

loc_9C73:				; CODE XREF: _ures_getVersionNumberInternal_56+66j
		mov	[ebp+var_F4], 1

loc_9C7D:				; CODE XREF: _ures_getVersionNumberInternal_56+71j
		mov	ecx, [ebp+var_F4]
		mov	[ebp+var_20], ecx
		mov	eax, [ebp+var_20]
		add	eax, 1
		push	eax
		call	_uprv_malloc_56
		add	esp, 4
		mov	ecx, [ebp+arg_0]
		mov	[ecx+8], eax
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+8], 0
		jnz	short loc_9CA8
		xor	eax, eax
		jmp	short loc_9CEE
; ---------------------------------------------------------------------------

loc_9CA8:				; CODE XREF: _ures_getVersionNumberInternal_56+A2j
		cmp	[ebp+var_14], 0
		jle	short loc_9CD4
		mov	eax, [ebp+var_14]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+8]
		push	edx
		mov	eax, [ebp+var_2C]
		push	eax
		call	_u_UCharsToChars_56
		add	esp, 0Ch
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		mov	edx, [ebp+var_20]
		mov	byte ptr [ecx+edx], 0
		jmp	short loc_9CE8
; ---------------------------------------------------------------------------

loc_9CD4:				; CODE XREF: _ures_getVersionNumberInternal_56+ACj
		push	offset ??_C@_01GBGANLPD@0?$AA@ ; "0"
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		push	ecx		; Dest
		call	_strcpy
		add	esp, 8

loc_9CE8:				; CODE XREF: _ures_getVersionNumberInternal_56+32j
					; _ures_getVersionNumberInternal_56+D2j
		mov	eax, [ebp+arg_0]
		mov	eax, [eax+8]

loc_9CEE:				; CODE XREF: _ures_getVersionNumberInternal_56+26j
					; _ures_getVersionNumberInternal_56+A6j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN13_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_ures_getVersionNumberInternal_56 endp

; ---------------------------------------------------------------------------
		align 4
$LN13_0		dd 2			; DATA XREF: _ures_getVersionNumberInternal_56+F2o
		dd offset $LN12_2
$LN12_2		dd 0FFFFFFF8h, 4	; DATA XREF: .text:00009D18o
		dd offset $LN10_3	; "status"
		dd 0FFFFFFECh, 4
		dd offset $LN11_1	; "minor_len"
$LN11_1		db 'minor_len',0        ; DATA XREF: .text:00009D30o
$LN10_3		db 'status',0           ; DATA XREF: .text:00009D24o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 9D48h
		public ??_C@_01GBGANLPD@0?$AA@
; char `string'[2]
??_C@_01GBGANLPD@0?$AA@	db '0',0        ; DATA XREF: _ures_getVersionNumberInternal_56:loc_9CD4o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 9D4Ch
		public ??_C@_07NGFJPNPN@Version?$AA@
; `string'
??_C@_07NGFJPNPN@Version?$AA@ db 'Version',0
					; DATA XREF: _ures_getVersionNumberInternal_56+4Eo
_rdata		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9D54h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _ures_getVersionNumber_56
_ures_getVersionNumber_56 proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		push	eax
		call	_ures_getVersionNumberInternal_56
		add	esp, 4
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_ures_getVersionNumber_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9D94h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _ures_getVersion_56
_ures_getVersion_56 proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		jnz	short loc_9DBA
		jmp	short loc_9DD3
; ---------------------------------------------------------------------------

loc_9DBA:				; CODE XREF: _ures_getVersion_56+22j
		mov	eax, [ebp+arg_0]
		push	eax
		call	_ures_getVersionNumberInternal_56
		add	esp, 4
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		call	_u_versionFromString_56
		add	esp, 8

loc_9DD3:				; CODE XREF: _ures_getVersion_56+24j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_ures_getVersion_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9DE8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl ures_loc_closeLocales(struct UEnumeration *)
?ures_loc_closeLocales@@YAXPAUUEnumeration@@@Z proc near ; DATA	XREF: .rdata:0000012Co

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		add	eax, 98h ; ''
		push	eax
		call	_ures_close_56
		add	esp, 4
		mov	eax, [ebp+var_8]
		push	eax
		call	_ures_close_56
		add	esp, 4
		mov	eax, [ebp+var_8]
		push	eax
		call	_uprv_free_56
		add	esp, 4
		mov	eax, [ebp+arg_0]
		push	eax
		call	_uprv_free_56
		add	esp, 4
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?ures_loc_closeLocales@@YAXPAUUEnumeration@@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9E58h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl ures_loc_countLocales(struct UEnumeration	*, enum	 UErrorCode *)
?ures_loc_countLocales@@YAHPAUUEnumeration@@PAW4UErrorCode@@@Z proc near
					; DATA XREF: .rdata:00000130o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		push	eax
		call	_ures_getSize_56
		add	esp, 4
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?ures_loc_countLocales@@YAHPAUUEnumeration@@PAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9EA0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; char const * __cdecl ures_loc_nextLocale(struct UEnumeration *, int *, enum  UErrorCode *)
?ures_loc_nextLocale@@YAPBDPAUUEnumeration@@PAHPAW4UErrorCode@@@Z proc near
					; DATA XREF: .rdata:00000138o

var_FC		= byte ptr -0FCh
var_38		= dword	ptr -38h
Str		= dword	ptr -2Ch
var_20		= dword	ptr -20h
Src		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0FCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_FC]
		mov	ecx, 3Fh ; '?'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	[ebp+Src], eax
		mov	[ebp+var_20], 0
		mov	[ebp+Str], 0
		mov	[ebp+var_38], 0
		mov	eax, [ebp+Src]
		push	eax
		call	_ures_hasNext_56
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_9F36
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+var_8]
		add	ecx, 98h ; ''
		push	ecx		; Dst
		mov	edx, [ebp+Src]
		push	edx		; Src
		call	_ures_getNextResource_56
		add	esp, 0Ch
		mov	[ebp+var_20], eax
		cmp	[ebp+var_20], 0
		jz	short loc_9F36
		mov	eax, [ebp+var_20]
		push	eax
		call	_ures_getKey_56
		add	esp, 4
		mov	[ebp+Str], eax
		mov	eax, [ebp+Str]
		push	eax		; Str
		call	_strlen
		add	esp, 4
		mov	[ebp+var_38], eax

loc_9F36:				; CODE XREF: ures_loc_nextLocale(UEnumeration *,int *,UErrorCode *)+53j
					; ures_loc_nextLocale(UEnumeration *,int *,UErrorCode *)+76j
		cmp	[ebp+arg_4], 0
		jz	short loc_9F44
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+var_38]
		mov	[eax], ecx

loc_9F44:				; CODE XREF: ures_loc_nextLocale(UEnumeration *,int *,UErrorCode *)+9Aj
		mov	eax, [ebp+Str]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0FCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?ures_loc_nextLocale@@YAPBDPAUUEnumeration@@PAHPAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9F5Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl ures_loc_resetLocales(struct UEnumeration *, enum  UErrorCode *)
?ures_loc_resetLocales@@YAXPAUUEnumeration@@PAW4UErrorCode@@@Z proc near
					; DATA XREF: .rdata:0000013Co

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		push	eax
		call	_ures_resetIterator_56
		add	esp, 4
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?ures_loc_resetLocales@@YAXPAUUEnumeration@@PAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9FA4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _ures_openAvailableLocales_56
_ures_openAvailableLocales_56 proc near	; CODE XREF: _ures_getFunctionalEquivalent_56+1C7p
					; _ures_getKeywordValues_56+70p

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
Dst		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	[ebp+Dst], 0
		mov	[ebp+var_20], 0
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_9FF3
		xor	eax, eax
		jmp	loc_A10E
; ---------------------------------------------------------------------------

loc_9FF3:				; CODE XREF: _ures_openAvailableLocales_56+46j
		push	130h
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+var_20], eax
		push	1Ch
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+Dst], eax
		cmp	[ebp+Dst], 0
		jz	short loc_A01C
		cmp	[ebp+var_20], 0
		jnz	short loc_A044

loc_A01C:				; CODE XREF: _ures_openAvailableLocales_56+70j
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 7
		mov	eax, [ebp+Dst]
		push	eax
		call	_uprv_free_56
		add	esp, 4
		mov	eax, [ebp+var_20]
		push	eax
		call	_uprv_free_56
		add	esp, 4
		xor	eax, eax
		jmp	loc_A10E
; ---------------------------------------------------------------------------

loc_A044:				; CODE XREF: _ures_openAvailableLocales_56+76j
		push	1
		push	offset _gLocalesEnum
		call	_uprv_checkValidMemory
		add	esp, 8
		push	1Ch		; Size
		push	offset _gLocalesEnum ; Src
		mov	eax, [ebp+Dst]
		push	eax		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	eax, [ebp+var_20]
		push	eax		; Dst
		call	_ures_initStackObject_56
		add	esp, 4
		mov	eax, [ebp+var_20]
		add	eax, 98h ; ''
		push	eax		; Dst
		call	_ures_initStackObject_56
		add	esp, 4
		mov	eax, [ebp+arg_4]
		push	eax
		push	offset ??_C@_09BLDIAEDF@res_index?$AA@ ; "res_index"
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	_ures_openDirect_56
		add	esp, 0Ch
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_20]
		push	ecx
		push	offset ??_C@_0BB@HHHDICBP@InstalledLocales?$AA@	; "InstalledLocales"
		mov	edx, [ebp+var_8]
		push	edx
		call	_ures_getByKey_56
		add	esp, 10h
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_A0D4
		mov	eax, [ebp+Dst]
		mov	ecx, [ebp+var_20]
		mov	[eax+4], ecx
		jmp	short loc_A0FF
; ---------------------------------------------------------------------------

loc_A0D4:				; CODE XREF: _ures_openAvailableLocales_56+123j
		mov	eax, [ebp+var_20]
		push	eax
		call	_ures_close_56
		add	esp, 4
		mov	eax, [ebp+var_20]
		push	eax
		call	_uprv_free_56
		add	esp, 4
		mov	eax, [ebp+Dst]
		push	eax
		call	_uprv_free_56
		add	esp, 4
		mov	[ebp+Dst], 0

loc_A0FF:				; CODE XREF: _ures_openAvailableLocales_56+12Ej
		mov	eax, [ebp+var_8]
		push	eax
		call	_ures_close_56
		add	esp, 4
		mov	eax, [ebp+Dst]

loc_A10E:				; CODE XREF: _ures_openAvailableLocales_56+4Aj
					; _ures_openAvailableLocales_56+9Bj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_ures_openAvailableLocales_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A124h
		public ??_C@_0BB@HHHDICBP@InstalledLocales?$AA@
; `string'
??_C@_0BB@HHHDICBP@InstalledLocales?$AA@ db 'InstalledLocales',0
					; DATA XREF: _ures_openAvailableLocales_56+FFo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A138h
		public ??_C@_09BLDIAEDF@res_index?$AA@
; `string'
??_C@_09BLDIAEDF@res_index?$AA@	db 'res_index',0
					; DATA XREF: _ures_openAvailableLocales_56+E3o
		align 4
_rdata		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A144h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl ures_getFunctionalEquivalent_56(char *, int, int,	int, char *, int, int, char, int)
		public _ures_getFunctionalEquivalent_56
_ures_getFunctionalEquivalent_56 proc near

var_1EC0	= byte ptr -1EC0h
Count		= dword	ptr -1DFCh
var_1DF0	= dword	ptr -1DF0h
var_1DE4	= dword	ptr -1DE4h
var_1DD8	= dword	ptr -1DD8h
var_1DCC	= dword	ptr -1DCCh
var_1DC0	= dword	ptr -1DC0h
var_1DB4	= dword	ptr -1DB4h
var_1DA8	= dword	ptr -1DA8h
var_1D9C	= dword	ptr -1D9Ch
var_1D90	= dword	ptr -1D90h
var_1D84	= dword	ptr -1D84h
var_1D78	= byte ptr -1D78h
var_1CD8	= byte ptr -1CD8h
var_1C38	= byte ptr -1C38h
var_1C37	= byte ptr -1C37h
Dest		= byte ptr -1830h
var_1428	= byte ptr -1428h
Source		= byte ptr -1020h
var_101F	= byte ptr -101Fh
Str		= byte ptr -0C18h
var_C17		= byte ptr -0C17h
Str2		= byte ptr -810h
var_80F		= byte ptr -80Fh
Str1		= byte ptr -408h
Dst		= byte ptr -407h
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h
arg_1C		= byte ptr  24h
arg_20		= dword	ptr  28h

		push	ebp
		mov	ebp, esp
		mov	eax, 1EC0h
		call	__chkstk
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_1EC0]
		mov	ecx, 7B0h
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	al, ds:??_C@_00CNPNBAHC@?$AA@ ;	`string'
		mov	[ebp+Str1], al
		push	3FFh		; Size
		push	0		; Val
		lea	eax, [ebp+Dst]
		push	eax		; Dst
		call	_memset_0
		add	esp, 0Ch
		mov	al, ds:??_C@_00CNPNBAHC@?$AA@ ;	`string'
		mov	[ebp+Str2], al
		push	3FFh		; Size
		push	0		; Val
		lea	eax, [ebp+var_80F]
		push	eax		; Dst
		call	_memset_0
		add	esp, 0Ch
		mov	al, ds:??_C@_00CNPNBAHC@?$AA@ ;	`string'
		mov	[ebp+Str], al
		push	3FFh		; Size
		push	0		; Val
		lea	eax, [ebp+var_C17]
		push	eax		; Dst
		call	_memset_0
		add	esp, 0Ch
		mov	al, ds:??_C@_00CNPNBAHC@?$AA@ ;	`string'
		mov	[ebp+Source], al
		push	3FFh		; Size
		push	0		; Val
		lea	eax, [ebp+var_101F]
		push	eax		; Dst
		call	_memset_0
		add	esp, 0Ch
		mov	al, ds:??_C@_00CNPNBAHC@?$AA@ ;	`string'
		mov	[ebp+var_1C38],	al
		push	3FFh		; Size
		push	0		; Val
		lea	eax, [ebp+var_1C37]
		push	eax		; Dst
		call	_memset_0
		add	esp, 0Ch
		mov	[ebp+var_1D84],	0
		mov	[ebp+var_1D90],	0
		mov	[ebp+var_1D9C],	0
		mov	eax, [ebp+arg_20]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_A24F
		xor	eax, eax
		jmp	loc_ACC7
; ---------------------------------------------------------------------------

loc_A24F:				; CODE XREF: _ures_getFunctionalEquivalent_56+102j
		lea	eax, [ebp+var_1D90]
		push	eax
		push	3FFh
		lea	ecx, [ebp+Str1]
		push	ecx
		mov	edx, [ebp+arg_10]
		push	edx
		mov	eax, [ebp+arg_14]
		push	eax
		call	_uloc_getKeywordValue_56
		add	esp, 14h
		push	offset ??_C@_07DLHCIBDH@default?$AA@ ; "default"
		lea	eax, [ebp+Str1]
		push	eax		; Str1
		call	_strcmp
		add	esp, 8
		test	eax, eax
		jnz	short loc_A291
		mov	[ebp+Str1], 0

loc_A291:				; CODE XREF: _ures_getFunctionalEquivalent_56+144j
		lea	eax, [ebp+var_1D90]
		push	eax
		push	3FFh
		lea	ecx, [ebp+Source]
		push	ecx
		mov	edx, [ebp+arg_14]
		push	edx
		call	_uloc_getBaseName_56
		add	esp, 10h
		lea	eax, [ebp+var_1CD8]
		push	eax		; Dst
		call	_ures_initStackObject_56
		add	esp, 4
		lea	eax, [ebp+var_1D78]
		push	eax		; Dst
		call	_ures_initStackObject_56
		add	esp, 4
		lea	eax, [ebp+Source]
		push	eax		; Source
		lea	ecx, [ebp+Dest]
		push	ecx		; Dest
		call	_strcpy
		add	esp, 8
		lea	eax, [ebp+Source]
		push	eax		; Source
		lea	ecx, [ebp+var_1428]
		push	ecx		; Dest
		call	_strcpy
		add	esp, 8
		cmp	[ebp+arg_18], 0
		jz	short loc_A366
		lea	eax, [ebp+var_1D90]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		call	_ures_openAvailableLocales_56
		add	esp, 8
		mov	[ebp+var_1DA8],	eax
		mov	eax, [ebp+arg_18]
		mov	byte ptr [eax],	1
		mov	eax, [ebp+var_1D90]
		push	eax
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_A357
		lea	eax, [ebp+var_1D90]
		push	eax		; int
		lea	ecx, [ebp+Dest]
		push	ecx		; Str2
		mov	edx, [ebp+var_1DA8]
		push	edx		; int
		call	?isLocaleInList@@YACPAUUEnumeration@@PBDPAW4UErrorCode@@@Z ; isLocaleInList(UEnumeration *,char	const *,UErrorCode *)
		add	esp, 0Ch
		mov	ecx, [ebp+arg_18]
		mov	[ecx], al

loc_A357:				; CODE XREF: _ures_getFunctionalEquivalent_56+1EFj
		mov	eax, [ebp+var_1DA8]
		push	eax
		call	_uenum_close_56
		add	esp, 4

loc_A366:				; CODE XREF: _ures_getFunctionalEquivalent_56+1BAj
		mov	eax, [ebp+var_1D90]
		push	eax
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_A38E
		mov	eax, [ebp+arg_20]
		mov	ecx, [ebp+var_1D90]
		mov	[eax], ecx
		xor	eax, eax
		jmp	loc_ACC7
; ---------------------------------------------------------------------------

loc_A38E:				; CODE XREF: _ures_getFunctionalEquivalent_56+236j
					; _ures_getFunctionalEquivalent_56+44Bj
		mov	[ebp+var_1D90],	0
		lea	eax, [ebp+var_1D90]
		push	eax
		lea	ecx, [ebp+Dest]
		push	ecx
		mov	edx, [ebp+arg_8]
		push	edx
		call	_ures_open_56
		add	esp, 0Ch
		mov	[ebp+var_1D84],	eax
		cmp	[ebp+var_1D90],	0FFFFFF80h
		jz	short loc_A3CA
		cmp	[ebp+var_1D90],	0FFFFFF81h
		jnz	short loc_A3D6

loc_A3CA:				; CODE XREF: _ures_getFunctionalEquivalent_56+27Bj
		cmp	[ebp+arg_18], 0
		jz	short loc_A3D6
		mov	eax, [ebp+arg_18]
		mov	byte ptr [eax],	0

loc_A3D6:				; CODE XREF: _ures_getFunctionalEquivalent_56+284j
					; _ures_getFunctionalEquivalent_56+28Aj
		mov	[ebp+arg_18], 0
		mov	eax, [ebp+var_1D90]
		push	eax
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_A403
		mov	eax, [ebp+arg_20]
		mov	ecx, [ebp+var_1D90]
		mov	[eax], ecx
		jmp	loc_A4E2
; ---------------------------------------------------------------------------

loc_A403:				; CODE XREF: _ures_getFunctionalEquivalent_56+2ADj
		cmp	[ebp+var_1D90],	0
		jnz	loc_A4E2
		lea	eax, [ebp+var_1D90]
		push	eax
		lea	ecx, [ebp+var_1CD8]
		push	ecx
		mov	edx, [ebp+arg_C]
		push	edx
		mov	eax, [ebp+var_1D84]
		push	eax
		call	_ures_getByKey_56
		add	esp, 10h
		cmp	[ebp+var_1D90],	0
		jnz	loc_A4E2
		lea	eax, [ebp+var_1D90]
		push	eax
		lea	ecx, [ebp+var_1DC0]
		push	ecx
		push	offset ??_C@_07DLHCIBDH@default?$AA@ ; "default"
		lea	edx, [ebp+var_1CD8]
		push	edx
		call	_ures_getStringByKey_56
		add	esp, 10h
		mov	[ebp+var_1DB4],	eax
		mov	eax, [ebp+var_1D90]
		push	eax
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_A4E2
		cmp	[ebp+var_1DC0],	0
		jz	short loc_A4E2
		mov	eax, [ebp+var_1DB4]
		push	eax
		call	_u_strlen_56
		add	esp, 4
		push	eax
		lea	ecx, [ebp+Str2]
		push	ecx
		mov	edx, [ebp+var_1DB4]
		push	edx
		call	_u_UCharsToChars_56
		add	esp, 0Ch
		lea	eax, [ebp+Dest]
		push	eax		; Source
		lea	ecx, [ebp+Str]
		push	ecx		; Dest
		call	_strcpy
		add	esp, 8
		movsx	eax, [ebp+Str1]
		test	eax, eax
		jnz	short loc_A4E2
		lea	eax, [ebp+Str2]
		push	eax		; Source
		lea	ecx, [ebp+Str1]
		push	ecx		; Dest
		call	_strcpy
		add	esp, 8

loc_A4E2:				; CODE XREF: _ures_getFunctionalEquivalent_56+2BAj
					; _ures_getFunctionalEquivalent_56+2C6j ...
		mov	[ebp+var_1D90],	0
		cmp	[ebp+var_1D84],	0
		jz	short loc_A51D
		lea	eax, [ebp+var_1D90]
		push	eax
		push	1
		mov	ecx, [ebp+var_1D84]
		push	ecx
		call	_ures_getLocaleByType_56
		add	esp, 0Ch
		push	eax		; Source
		lea	edx, [ebp+var_1428]
		push	edx		; Dest
		call	_strcpy
		add	esp, 8

loc_A51D:				; CODE XREF: _ures_getFunctionalEquivalent_56+3AFj
		lea	eax, [ebp+var_1D90]
		push	eax
		push	400h
		lea	ecx, [ebp+Dest]
		push	ecx
		lea	edx, [ebp+var_1428]
		push	edx
		call	_uloc_getParent_56
		add	esp, 10h
		mov	eax, [ebp+var_1D84]
		push	eax
		call	_ures_close_56
		add	esp, 4
		movsx	eax, [ebp+Str2]
		test	eax, eax
		jnz	short loc_A595
		movsx	eax, [ebp+var_1428]
		test	eax, eax
		jz	short loc_A595
		push	offset ??_C@_04NBFCGMPH@root?$AA@ ; "root"
		lea	eax, [ebp+var_1428]
		push	eax		; Str1
		call	_strcmp
		add	esp, 8
		test	eax, eax
		jz	short loc_A595
		mov	eax, [ebp+arg_20]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jnz	loc_A38E

loc_A595:				; CODE XREF: _ures_getFunctionalEquivalent_56+413j
					; _ures_getFunctionalEquivalent_56+41Ej ...
		lea	eax, [ebp+Source]
		push	eax		; Source
		lea	ecx, [ebp+Dest]
		push	ecx		; Dest
		call	_strcpy
		add	esp, 8
		lea	eax, [ebp+Source]
		push	eax		; Source
		lea	ecx, [ebp+var_1428]
		push	ecx		; Dest
		call	_strcpy
		add	esp, 8

loc_A5C1:				; CODE XREF: _ures_getFunctionalEquivalent_56+6AFj
		mov	[ebp+var_1D90],	0
		lea	eax, [ebp+var_1D90]
		push	eax
		lea	ecx, [ebp+Dest]
		push	ecx
		mov	edx, [ebp+arg_8]
		push	edx
		call	_ures_open_56
		add	esp, 0Ch
		mov	[ebp+var_1D84],	eax
		cmp	[ebp+var_1D90],	0FFFFFF80h
		jnz	short loc_A600
		cmp	[ebp+arg_18], 0
		jz	short loc_A600
		mov	eax, [ebp+arg_18]
		mov	byte ptr [eax],	0

loc_A600:				; CODE XREF: _ures_getFunctionalEquivalent_56+4AEj
					; _ures_getFunctionalEquivalent_56+4B4j
		mov	[ebp+arg_18], 0
		mov	eax, [ebp+var_1D90]
		push	eax
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_A62D
		mov	eax, [ebp+arg_20]
		mov	ecx, [ebp+var_1D90]
		mov	[eax], ecx
		jmp	loc_A779
; ---------------------------------------------------------------------------

loc_A62D:				; CODE XREF: _ures_getFunctionalEquivalent_56+4D7j
		cmp	[ebp+var_1D90],	0
		jnz	loc_A779
		lea	eax, [ebp+var_1D90]
		push	eax
		lea	ecx, [ebp+var_1CD8]
		push	ecx
		mov	edx, [ebp+arg_C]
		push	edx
		mov	eax, [ebp+var_1D84]
		push	eax
		call	_ures_getByKey_56
		add	esp, 10h
		cmp	[ebp+var_1D90],	0
		jnz	loc_A779
		lea	eax, [ebp+var_1D90]
		push	eax
		lea	ecx, [ebp+var_1D78]
		push	ecx
		lea	edx, [ebp+Str1]
		push	edx
		lea	eax, [ebp+var_1CD8]
		push	eax
		call	_ures_getByKey_56
		add	esp, 10h
		cmp	[ebp+var_1D90],	0
		jnz	loc_A779
		lea	eax, [ebp+Dest]
		push	eax		; Source
		lea	ecx, [ebp+var_1C38]
		push	ecx		; Dest
		call	_strcpy
		add	esp, 8
		movsx	eax, [ebp+var_1C38]
		test	eax, eax
		jnz	short loc_A6CE
		push	offset ??_C@_04NBFCGMPH@root?$AA@ ; "root"
		lea	eax, [ebp+var_1C38]
		push	eax		; Dest
		call	_strcpy
		add	esp, 8

loc_A6CE:				; CODE XREF: _ures_getFunctionalEquivalent_56+574j
		lea	eax, [ebp+Str]
		push	eax		; Str
		call	_strlen
		add	esp, 4
		mov	esi, eax
		lea	ecx, [ebp+var_1C38]
		push	ecx		; Str
		call	_strlen
		add	esp, 4
		cmp	esi, eax
		jbe	loc_A779
		lea	eax, [ebp+var_1D90]
		push	eax
		lea	ecx, [ebp+var_1DD8]
		push	ecx
		push	offset ??_C@_07DLHCIBDH@default?$AA@ ; "default"
		lea	edx, [ebp+var_1CD8]
		push	edx
		call	_ures_getStringByKey_56
		add	esp, 10h
		mov	[ebp+var_1DCC],	eax
		mov	eax, [ebp+var_1D90]
		push	eax
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_A779
		cmp	[ebp+var_1DD8],	0
		jz	short loc_A779
		mov	eax, [ebp+var_1DCC]
		push	eax
		call	_u_strlen_56
		add	esp, 4
		push	eax
		lea	ecx, [ebp+Str2]
		push	ecx
		mov	edx, [ebp+var_1DCC]
		push	edx
		call	_u_UCharsToChars_56
		add	esp, 0Ch
		lea	eax, [ebp+var_1C38]
		push	eax		; Source
		lea	ecx, [ebp+Str]
		push	ecx		; Dest
		call	_strcpy
		add	esp, 8

loc_A779:				; CODE XREF: _ures_getFunctionalEquivalent_56+4E4j
					; _ures_getFunctionalEquivalent_56+4F0j ...
		mov	[ebp+var_1D90],	0
		lea	eax, [ebp+Dest]
		push	eax		; Source
		lea	ecx, [ebp+var_1428]
		push	ecx		; Dest
		call	_strcpy
		add	esp, 8
		lea	eax, [ebp+var_1D90]
		push	eax
		push	3FFh
		lea	ecx, [ebp+Dest]
		push	ecx
		lea	edx, [ebp+var_1428]
		push	edx
		call	_uloc_getParent_56
		add	esp, 10h
		mov	eax, [ebp+var_1D84]
		push	eax
		call	_ures_close_56
		add	esp, 4
		movsx	eax, [ebp+var_1C38]
		test	eax, eax
		jnz	short loc_A7F9
		movsx	eax, [ebp+var_1428]
		test	eax, eax
		jz	short loc_A7F9
		mov	eax, [ebp+arg_20]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jnz	loc_A5C1

loc_A7F9:				; CODE XREF: _ures_getFunctionalEquivalent_56+68Fj
					; _ures_getFunctionalEquivalent_56+69Aj
		movsx	eax, [ebp+var_1C38]
		test	eax, eax
		jnz	loc_AAA0
		lea	eax, [ebp+Str2]
		push	eax		; Str2
		lea	ecx, [ebp+Str1]
		push	ecx		; Str1
		call	_strcmp
		add	esp, 8
		test	eax, eax
		jz	loc_AAA0
		lea	eax, [ebp+Str2]
		push	eax		; Source
		lea	ecx, [ebp+Str1]
		push	ecx		; Dest
		call	_strcpy
		add	esp, 8
		lea	eax, [ebp+Source]
		push	eax		; Source
		lea	ecx, [ebp+Dest]
		push	ecx		; Dest
		call	_strcpy
		add	esp, 8
		lea	eax, [ebp+Source]
		push	eax		; Source
		lea	ecx, [ebp+var_1428]
		push	ecx		; Dest
		call	_strcpy
		add	esp, 8

loc_A868:				; CODE XREF: _ures_getFunctionalEquivalent_56+956j
		mov	[ebp+var_1D90],	0
		lea	eax, [ebp+var_1D90]
		push	eax
		lea	ecx, [ebp+Dest]
		push	ecx
		mov	edx, [ebp+arg_8]
		push	edx
		call	_ures_open_56
		add	esp, 0Ch
		mov	[ebp+var_1D84],	eax
		cmp	[ebp+var_1D90],	0FFFFFF80h
		jnz	short loc_A8A7
		cmp	[ebp+arg_18], 0
		jz	short loc_A8A7
		mov	eax, [ebp+arg_18]
		mov	byte ptr [eax],	0

loc_A8A7:				; CODE XREF: _ures_getFunctionalEquivalent_56+755j
					; _ures_getFunctionalEquivalent_56+75Bj
		mov	[ebp+arg_18], 0
		mov	eax, [ebp+var_1D90]
		push	eax
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_A8D4
		mov	eax, [ebp+arg_20]
		mov	ecx, [ebp+var_1D90]
		mov	[eax], ecx
		jmp	loc_AA20
; ---------------------------------------------------------------------------

loc_A8D4:				; CODE XREF: _ures_getFunctionalEquivalent_56+77Ej
		cmp	[ebp+var_1D90],	0
		jnz	loc_AA20
		lea	eax, [ebp+var_1D90]
		push	eax
		lea	ecx, [ebp+var_1CD8]
		push	ecx
		mov	edx, [ebp+arg_C]
		push	edx
		mov	eax, [ebp+var_1D84]
		push	eax
		call	_ures_getByKey_56
		add	esp, 10h
		cmp	[ebp+var_1D90],	0
		jnz	loc_AA20
		lea	eax, [ebp+var_1D90]
		push	eax
		lea	ecx, [ebp+var_1D78]
		push	ecx
		lea	edx, [ebp+Str1]
		push	edx
		lea	eax, [ebp+var_1CD8]
		push	eax
		call	_ures_getByKey_56
		add	esp, 10h
		cmp	[ebp+var_1D90],	0
		jnz	loc_AA20
		lea	eax, [ebp+Dest]
		push	eax		; Source
		lea	ecx, [ebp+var_1C38]
		push	ecx		; Dest
		call	_strcpy
		add	esp, 8
		movsx	eax, [ebp+var_1C38]
		test	eax, eax
		jnz	short loc_A975
		push	offset ??_C@_04NBFCGMPH@root?$AA@ ; "root"
		lea	eax, [ebp+var_1C38]
		push	eax		; Dest
		call	_strcpy
		add	esp, 8

loc_A975:				; CODE XREF: _ures_getFunctionalEquivalent_56+81Bj
		lea	eax, [ebp+Str]
		push	eax		; Str
		call	_strlen
		add	esp, 4
		mov	esi, eax
		lea	ecx, [ebp+var_1C38]
		push	ecx		; Str
		call	_strlen
		add	esp, 4
		cmp	esi, eax
		jbe	loc_AA20
		lea	eax, [ebp+var_1D90]
		push	eax
		lea	ecx, [ebp+var_1DF0]
		push	ecx
		push	offset ??_C@_07DLHCIBDH@default?$AA@ ; "default"
		lea	edx, [ebp+var_1CD8]
		push	edx
		call	_ures_getStringByKey_56
		add	esp, 10h
		mov	[ebp+var_1DE4],	eax
		mov	eax, [ebp+var_1D90]
		push	eax
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_AA20
		cmp	[ebp+var_1DF0],	0
		jz	short loc_AA20
		mov	eax, [ebp+var_1DE4]
		push	eax
		call	_u_strlen_56
		add	esp, 4
		push	eax
		lea	ecx, [ebp+Str2]
		push	ecx
		mov	edx, [ebp+var_1DE4]
		push	edx
		call	_u_UCharsToChars_56
		add	esp, 0Ch
		lea	eax, [ebp+var_1C38]
		push	eax		; Source
		lea	ecx, [ebp+Str]
		push	ecx		; Dest
		call	_strcpy
		add	esp, 8

loc_AA20:				; CODE XREF: _ures_getFunctionalEquivalent_56+78Bj
					; _ures_getFunctionalEquivalent_56+797j ...
		mov	[ebp+var_1D90],	0
		lea	eax, [ebp+Dest]
		push	eax		; Source
		lea	ecx, [ebp+var_1428]
		push	ecx		; Dest
		call	_strcpy
		add	esp, 8
		lea	eax, [ebp+var_1D90]
		push	eax
		push	3FFh
		lea	ecx, [ebp+Dest]
		push	ecx
		lea	edx, [ebp+var_1428]
		push	edx
		call	_uloc_getParent_56
		add	esp, 10h
		mov	eax, [ebp+var_1D84]
		push	eax
		call	_ures_close_56
		add	esp, 4
		movsx	eax, [ebp+var_1C38]
		test	eax, eax
		jnz	short loc_AAA0
		movsx	eax, [ebp+var_1428]
		test	eax, eax
		jz	short loc_AAA0
		mov	eax, [ebp+arg_20]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jnz	loc_A868

loc_AAA0:				; CODE XREF: _ures_getFunctionalEquivalent_56+6BEj
					; _ures_getFunctionalEquivalent_56+6DCj ...
		mov	eax, [ebp+arg_20]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	loc_ABE9
		movsx	eax, [ebp+var_1C38]
		test	eax, eax
		jnz	short loc_AACF
		mov	eax, [ebp+arg_20]
		mov	dword ptr [eax], 2
		jmp	short loc_AB1C
; ---------------------------------------------------------------------------

loc_AACF:				; CODE XREF: _ures_getFunctionalEquivalent_56+97Ej
		movsx	eax, [ebp+arg_1C]
		test	eax, eax
		jz	short loc_AB1C
		lea	eax, [ebp+Str]
		push	eax		; Str
		call	_strlen
		add	esp, 4
		mov	esi, eax
		lea	ecx, [ebp+var_1C38]
		push	ecx		; Str
		call	_strlen
		add	esp, 4
		cmp	esi, eax
		ja	short loc_AB1C
		lea	eax, [ebp+Str2]
		push	eax		; Str2
		lea	ecx, [ebp+Str1]
		push	ecx		; Str1
		call	_strcmp
		add	esp, 8
		test	eax, eax
		jnz	short loc_AB1C
		mov	[ebp+Str1], 0

loc_AB1C:				; CODE XREF: _ures_getFunctionalEquivalent_56+989j
					; _ures_getFunctionalEquivalent_56+991j ...
		lea	eax, [ebp+var_1C38]
		push	eax		; Source
		lea	ecx, [ebp+var_1428]
		push	ecx		; Dest
		call	_strcpy
		add	esp, 8
		movsx	eax, [ebp+Str1]
		test	eax, eax
		jz	short loc_AB90
		push	offset ??_C@_01EOFPKCAF@?$EA?$AA@ ; "@"
		lea	eax, [ebp+var_1428]
		push	eax		; Dest
		call	_strcat
		add	esp, 8
		mov	eax, [ebp+arg_10]
		push	eax		; Source
		lea	ecx, [ebp+var_1428]
		push	ecx		; Dest
		call	_strcat
		add	esp, 8
		push	offset ??_C@_01NEMOKFLO@?$DN?$AA@ ; "="
		lea	eax, [ebp+var_1428]
		push	eax		; Dest
		call	_strcat
		add	esp, 8
		lea	eax, [ebp+Str1]
		push	eax		; Source
		lea	ecx, [ebp+var_1428]
		push	ecx		; Dest
		call	_strcat
		add	esp, 8
		jmp	short loc_ABE9
; ---------------------------------------------------------------------------

loc_AB90:				; CODE XREF: _ures_getFunctionalEquivalent_56+9F7j
		movsx	eax, [ebp+arg_1C]
		test	eax, eax
		jnz	short loc_ABE9
		push	offset ??_C@_01EOFPKCAF@?$EA?$AA@ ; "@"
		lea	eax, [ebp+var_1428]
		push	eax		; Dest
		call	_strcat
		add	esp, 8
		mov	eax, [ebp+arg_10]
		push	eax		; Source
		lea	ecx, [ebp+var_1428]
		push	ecx		; Dest
		call	_strcat
		add	esp, 8
		push	offset ??_C@_01NEMOKFLO@?$DN?$AA@ ; "="
		lea	eax, [ebp+var_1428]
		push	eax		; Dest
		call	_strcat
		add	esp, 8
		lea	eax, [ebp+Str2]
		push	eax		; Source
		lea	ecx, [ebp+var_1428]
		push	ecx		; Dest
		call	_strcat
		add	esp, 8

loc_ABE9:				; CODE XREF: _ures_getFunctionalEquivalent_56+96Fj
					; _ures_getFunctionalEquivalent_56+A4Aj ...
		lea	eax, [ebp+var_1CD8]
		push	eax
		call	_ures_close_56
		add	esp, 4
		lea	eax, [ebp+var_1D78]
		push	eax
		call	_ures_close_56
		add	esp, 4
		lea	eax, [ebp+var_1428]
		push	eax		; Str
		call	_strlen
		add	esp, 4
		mov	[ebp+var_1D9C],	eax
		mov	eax, [ebp+arg_20]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_AC9C
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_1D9C]
		push	ecx
		call	_uprv_min_56
		add	esp, 8
		mov	[ebp+Count], eax
		cmp	[ebp+Count], 0
		jle	short loc_AC88
		push	1
		lea	eax, [ebp+var_1428]
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	esi, esp
		mov	ecx, [ebp+Count]
		push	ecx		; Count
		lea	edx, [ebp+var_1428]
		push	edx		; Source
		mov	eax, [ebp+arg_0]
		push	eax		; Dest
		call	dword ptr ds:__imp__strncpy
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_AC88:				; CODE XREF: _ures_getFunctionalEquivalent_56+B0Dj
		cmp	[ebp+var_1D9C],	0
		jnz	short loc_AC9A
		mov	eax, [ebp+arg_20]
		mov	dword ptr [eax], 2

loc_AC9A:				; CODE XREF: _ures_getFunctionalEquivalent_56+B4Bj
		jmp	short loc_ACAC
; ---------------------------------------------------------------------------

loc_AC9C:				; CODE XREF: _ures_getFunctionalEquivalent_56+AEBj
		mov	[ebp+var_1D9C],	0
		mov	eax, [ebp+arg_0]
		mov	byte ptr [eax],	0

loc_ACAC:				; CODE XREF: _ures_getFunctionalEquivalent_56:loc_AC9Aj
		mov	eax, [ebp+arg_20]
		push	eax
		mov	ecx, [ebp+var_1D9C]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		call	_u_terminateChars_56
		add	esp, 10h

loc_ACC7:				; CODE XREF: _ures_getFunctionalEquivalent_56+106j
					; _ures_getFunctionalEquivalent_56+245j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN76_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 1EC0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_ures_getFunctionalEquivalent_56 endp

; ---------------------------------------------------------------------------
		align 4
$LN76_0		dd 0Dh			; DATA XREF: _ures_getFunctionalEquivalent_56+B87o
		dd offset $LN75_0
$LN75_0		dd 0FFFFFBF8h, 400h	; DATA XREF: .text:0000ACFCo
		dd offset $LN62		; "kwVal"
		dd 0FFFFF7F0h, 400h
		dd offset $LN63		; "defVal"
		dd 0FFFFF3E8h, 400h
		dd offset $LN64		; "defLoc"
		dd 0FFFFEFE0h, 400h
		dd offset $LN65		; "base"
		dd 0FFFFEBD8h, 400h
		dd offset $LN66		; "found"
		dd 0FFFFE7D0h, 400h
		dd offset $LN67		; "parent"
		dd 0FFFFE3C8h, 400h
		dd offset $LN68		; "full"
		dd 0FFFFE328h, 98h
		dd offset $LN69		; "bund1"
		dd 0FFFFE288h, 98h
		dd offset $LN70		; "bund2"
		dd 0FFFFE270h, 4
		dd offset $LN71		; "subStatus"
		dd 0FFFFE240h, 4
		dd offset $LN72		; "defLen"
		dd 0FFFFE228h, 4
		dd offset $LN73_0	; "defLen"
		dd 0FFFFE210h, 4
		dd offset $LN74_0	; "defLen"
$LN74_0		db 'defLen',0           ; DATA XREF: .text:0000AD98o
$LN73_0		db 'defLen',0           ; DATA XREF: .text:0000AD8Co
$LN72		db 'defLen',0           ; DATA XREF: .text:0000AD80o
$LN71		db 'subStatus',0        ; DATA XREF: .text:0000AD74o
$LN70		db 'bund2',0            ; DATA XREF: .text:0000AD68o
$LN69		db 'bund1',0            ; DATA XREF: .text:0000AD5Co
$LN68		db 'full',0             ; DATA XREF: .text:0000AD50o
$LN67		db 'parent',0           ; DATA XREF: .text:0000AD44o
$LN66		db 'found',0            ; DATA XREF: .text:0000AD38o
$LN65		db 'base',0             ; DATA XREF: .text:0000AD2Co
$LN64		db 'defLoc',0           ; DATA XREF: .text:0000AD20o
$LN63		db 'defVal',0           ; DATA XREF: .text:0000AD14o
$LN62		db 'kwVal',0            ; DATA XREF: .text:0000AD08o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0ADF4h
		public ??_C@_01NEMOKFLO@?$DN?$AA@
; char `string'[2]
??_C@_01NEMOKFLO@?$DN?$AA@ db '=',0     ; DATA XREF: _ures_getFunctionalEquivalent_56+A20o
					; _ures_getFunctionalEquivalent_56+A7Bo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0ADF8h
		public ??_C@_01EOFPKCAF@?$EA?$AA@
; char `string'[2]
??_C@_01EOFPKCAF@?$EA?$AA@ db '@',0     ; DATA XREF: _ures_getFunctionalEquivalent_56+9F9o
					; _ures_getFunctionalEquivalent_56+A54o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0ADFCh
		public ??_C@_07DLHCIBDH@default?$AA@
; char `string'[]
??_C@_07DLHCIBDH@default?$AA@ db 'default',0
					; DATA XREF: _ures_getFunctionalEquivalent_56+12Eo
					; _ures_getFunctionalEquivalent_56+308o ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0AE04h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl isLocaleInList(int, char *Str2, int)
?isLocaleInList@@YACPAUUEnumeration@@PBDPAW4UErrorCode@@@Z proc	near
					; CODE XREF: _ures_getFunctionalEquivalent_56+206p

var_CC		= byte ptr -0CCh
Str1		= dword	ptr -8
arg_0		= dword	ptr  8
Str2		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd

loc_AE22:				; CODE XREF: isLocaleInList(UEnumeration *,char	const *,UErrorCode *):loc_AE55j
		mov	eax, [ebp+arg_8]
		push	eax
		push	0
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	_uenum_next_56
		add	esp, 0Ch
		mov	[ebp+Str1], eax
		cmp	[ebp+Str1], 0
		jz	short loc_AE57
		mov	eax, [ebp+Str2]
		push	eax		; Str2
		mov	ecx, [ebp+Str1]
		push	ecx		; Str1
		call	_strcmp
		add	esp, 8
		test	eax, eax
		jnz	short loc_AE55
		mov	al, 1
		jmp	short loc_AE59
; ---------------------------------------------------------------------------

loc_AE55:				; CODE XREF: isLocaleInList(UEnumeration *,char	const *,UErrorCode *)+4Bj
		jmp	short loc_AE22
; ---------------------------------------------------------------------------

loc_AE57:				; CODE XREF: isLocaleInList(UEnumeration *,char	const *,UErrorCode *)+37j
		xor	al, al

loc_AE59:				; CODE XREF: isLocaleInList(UEnumeration *,char	const *,UErrorCode *)+4Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?isLocaleInList@@YACPAUUEnumeration@@PBDPAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0AE70h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _ures_getKeywordValues_56
_ures_getKeywordValues_56 proc near

var_1298	= byte ptr -1298h
var_11D4	= dword	ptr -11D4h
var_11C8	= dword	ptr -11C8h
Str1		= dword	ptr -11BCh
var_11B0	= dword	ptr -11B0h
var_11A4	= dword	ptr -11A4h
var_1198	= dword	ptr -1198h
var_118C	= byte ptr -118Ch
Dst		= byte ptr -10ECh
var_104C	= dword	ptr -104Ch
var_1040	= byte ptr -1040h
var_1034	= dword	ptr -1034h
var_1028	= dword	ptr -1028h
var_101C	= dword	ptr -101Ch
var_814		= dword	ptr -814h
Dest		= byte ptr -808h
var_807		= byte ptr -807h
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		mov	eax, 1298h
		call	__chkstk
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_1298]
		mov	ecx, 4A6h
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	[ebp+var_814], 0
		mov	[ebp+var_1028],	0
		mov	[ebp+var_104C],	0
		lea	eax, [ebp+Dst]
		push	eax		; Dst
		call	_ures_initStackObject_56
		add	esp, 4
		lea	eax, [ebp+var_118C]
		push	eax		; Dst
		call	_ures_initStackObject_56
		add	esp, 4
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	_ures_openAvailableLocales_56
		add	esp, 8
		mov	[ebp+var_104C],	eax
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_AF28
		lea	eax, [ebp+Dst]
		push	eax
		call	_ures_close_56
		add	esp, 4
		lea	eax, [ebp+var_118C]
		push	eax
		call	_ures_close_56
		add	esp, 4
		xor	eax, eax
		jmp	loc_B270
; ---------------------------------------------------------------------------

loc_AF28:				; CODE XREF: _ures_getKeywordValues_56+91j
		mov	[ebp+Dest], 0
		mov	[ebp+var_807], 0

loc_AF36:				; CODE XREF: _ures_getKeywordValues_56+18Aj
					; _ures_getKeywordValues_56+397j
		mov	eax, [ebp+arg_8]
		push	eax
		lea	ecx, [ebp+var_1040]
		push	ecx
		mov	edx, [ebp+var_104C]
		push	edx
		call	_uenum_next_56
		add	esp, 0Ch
		mov	[ebp+var_1034],	eax
		cmp	[ebp+var_1034],	0
		jz	loc_B20C
		mov	[ebp+var_1198],	0
		mov	[ebp+var_11A4],	0
		mov	[ebp+var_11B0],	0
		lea	eax, [ebp+var_11B0]
		push	eax
		mov	ecx, [ebp+var_1034]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	_ures_openDirect_56
		add	esp, 0Ch
		mov	[ebp+var_1198],	eax
		lea	eax, [ebp+var_11B0]
		push	eax
		lea	ecx, [ebp+Dst]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+var_1198]
		push	eax
		call	_ures_getByKey_56
		add	esp, 10h
		cmp	[ebp+var_1198],	0
		jz	short loc_AFE1
		mov	eax, [ebp+var_11B0]
		push	eax
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_AFFF

loc_AFE1:				; CODE XREF: _ures_getKeywordValues_56+159j
		mov	eax, [ebp+var_1198]
		push	eax
		call	_ures_close_56
		add	esp, 4
		mov	[ebp+var_1198],	0
		jmp	loc_AF36
; ---------------------------------------------------------------------------

loc_AFFF:				; CODE XREF: _ures_getKeywordValues_56+16Fj
					; _ures_getKeywordValues_56:loc_B0D0j ...
		lea	eax, [ebp+var_11B0]
		push	eax		; int
		lea	ecx, [ebp+var_118C]
		push	ecx		; Dst
		lea	edx, [ebp+Dst]
		push	edx		; Src
		call	_ures_getNextResource_56
		add	esp, 0Ch
		mov	[ebp+var_11A4],	eax
		cmp	[ebp+var_11A4],	0
		jz	loc_B1F8
		mov	eax, [ebp+var_11B0]
		push	eax
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	loc_B1F8
		mov	eax, [ebp+var_11A4]
		push	eax
		call	_ures_getKey_56
		add	esp, 4
		mov	[ebp+Str1], eax
		cmp	[ebp+Str1], 0
		jz	short loc_B0D0
		mov	eax, [ebp+Str1]
		movsx	ecx, byte ptr [eax]
		test	ecx, ecx
		jz	short loc_B0D0
		push	offset ??_C@_07DLHCIBDH@default?$AA@ ; "default"
		mov	eax, [ebp+Str1]
		push	eax		; Str1
		call	_strcmp
		add	esp, 8
		test	eax, eax
		jz	short loc_B0D0
		push	1
		mov	eax, [ebp+Str1]
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		push	1
		push	offset ??_C@_08OKEMGDJB@private?9?$AA@ ; "private-"
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	esi, esp
		push	8		; MaxCount
		push	offset ??_C@_08OKEMGDJB@private?9?$AA@ ; "private-"
		mov	ecx, [ebp+Str1]
		push	ecx		; Str1
		call	dword ptr ds:__imp__strncmp
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jnz	short loc_B0D5

loc_B0D0:				; CODE XREF: _ures_getKeywordValues_56+1F5j
					; _ures_getKeywordValues_56+202j ...
		jmp	loc_AFFF
; ---------------------------------------------------------------------------

loc_B0D5:				; CODE XREF: _ures_getKeywordValues_56+25Ej
		mov	[ebp+var_11C8],	0
		jmp	short loc_B0F0
; ---------------------------------------------------------------------------

loc_B0E1:				; CODE XREF: _ures_getKeywordValues_56:loc_B12Bj
		mov	eax, [ebp+var_11C8]
		add	eax, 1
		mov	[ebp+var_11C8],	eax

loc_B0F0:				; CODE XREF: _ures_getKeywordValues_56+26Fj
		mov	eax, [ebp+var_11C8]
		cmp	eax, [ebp+var_1028]
		jge	short loc_B12D
		mov	eax, [ebp+Str1]
		push	eax		; Str2
		mov	ecx, [ebp+var_11C8]
		mov	edx, [ebp+ecx*4+var_101C]
		push	edx		; Str1
		call	_strcmp
		add	esp, 8
		test	eax, eax
		jnz	short loc_B12B
		mov	[ebp+Str1], 0
		jmp	short loc_B12D
; ---------------------------------------------------------------------------

loc_B12B:				; CODE XREF: _ures_getKeywordValues_56+2ADj
		jmp	short loc_B0E1
; ---------------------------------------------------------------------------

loc_B12D:				; CODE XREF: _ures_getKeywordValues_56+28Cj
					; _ures_getKeywordValues_56+2B9j
		cmp	[ebp+Str1], 0
		jz	loc_B1F3
		mov	eax, [ebp+Str1]
		push	eax		; Str
		call	_strlen
		add	esp, 4
		mov	[ebp+var_11D4],	eax
		cmp	[ebp+var_1028],	1FFh
		jge	short loc_B173
		mov	eax, [ebp+var_11D4]
		mov	ecx, [ebp+var_814]
		lea	edx, [ecx+eax+2]
		cmp	edx, 800h
		jl	short loc_B17E

loc_B173:				; CODE XREF: _ures_getKeywordValues_56+2E9j
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 1
		jmp	short loc_B1F3
; ---------------------------------------------------------------------------

loc_B17E:				; CODE XREF: _ures_getKeywordValues_56+301j
		mov	eax, [ebp+Str1]
		push	eax		; Source
		mov	ecx, [ebp+var_814]
		lea	edx, [ebp+ecx+Dest]
		push	edx		; Dest
		call	_strcpy
		add	esp, 8
		mov	eax, [ebp+var_814]
		lea	ecx, [ebp+eax+Dest]
		mov	edx, [ebp+var_1028]
		mov	[ebp+edx*4+var_101C], ecx
		mov	eax, [ebp+var_1028]
		add	eax, 1
		mov	[ebp+var_1028],	eax
		mov	eax, [ebp+var_814]
		add	eax, [ebp+var_11D4]
		mov	[ebp+var_814], eax
		mov	eax, [ebp+var_814]
		mov	[ebp+eax+Dest],	0
		mov	ecx, [ebp+var_814]
		add	ecx, 1
		mov	[ebp+var_814], ecx

loc_B1F3:				; CODE XREF: _ures_getKeywordValues_56+2C4j
					; _ures_getKeywordValues_56+30Cj
		jmp	loc_AFFF
; ---------------------------------------------------------------------------

loc_B1F8:				; CODE XREF: _ures_getKeywordValues_56+1B9j
					; _ures_getKeywordValues_56+1D3j
		mov	eax, [ebp+var_1198]
		push	eax
		call	_ures_close_56
		add	esp, 4
		jmp	loc_AF36
; ---------------------------------------------------------------------------

loc_B20C:				; CODE XREF: _ures_getKeywordValues_56+EDj
		mov	eax, [ebp+var_814]
		mov	[ebp+eax+Dest],	0
		mov	ecx, [ebp+var_814]
		add	ecx, 1
		mov	[ebp+var_814], ecx
		lea	eax, [ebp+Dst]
		push	eax
		call	_ures_close_56
		add	esp, 4
		lea	eax, [ebp+var_118C]
		push	eax
		call	_ures_close_56
		add	esp, 4
		mov	eax, [ebp+var_104C]
		push	eax
		call	_uenum_close_56
		add	esp, 4
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+var_814]
		push	ecx
		lea	edx, [ebp+Dest]
		push	edx
		call	_uloc_openKeywordList_56
		add	esp, 0Ch

loc_B270:				; CODE XREF: _ures_getKeywordValues_56+B3j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN29_1
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 1298h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_ures_getKeywordValues_56 endp

; ---------------------------------------------------------------------------
		align 10h
$LN29_1		dd 6			; DATA XREF: _ures_getKeywordValues_56+404o
		dd offset $LN28_1
$LN28_1		dd 0FFFFF7F8h, 800h	; DATA XREF: .text:0000B2A4o
		dd offset $LN22_0	; "valuesBuf"
		dd 0FFFFEFE4h, 800h
		dd offset $LN23		; "valuesList"
		dd 0FFFFEFC0h, 4
		dd offset $LN24		; "locLen"
		dd 0FFFFEF14h, 98h
		dd offset $LN25_0	; "item"
		dd 0FFFFEE74h, 98h
		dd offset $LN26_0	; "subItem"
		dd 0FFFFEE50h, 4
		dd offset $LN27_1	; "subStatus"
$LN27_1		db 'subStatus',0        ; DATA XREF: .text:0000B2ECo
$LN26_0		db 'subItem',0          ; DATA XREF: .text:0000B2E0o
$LN25_0		db 'item',0             ; DATA XREF: .text:0000B2D4o
$LN24		db 'locLen',0           ; DATA XREF: .text:0000B2C8o
$LN23		db 'valuesList',0       ; DATA XREF: .text:0000B2BCo
$LN22_0		db 'valuesBuf',0        ; DATA XREF: .text:0000B2B0o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B324h
		public ??_C@_08OKEMGDJB@private?9?$AA@
; char `string'[]
??_C@_08OKEMGDJB@private?9?$AA@	db 'private-',0 ; DATA XREF: _ures_getKeywordValues_56+22Fo
					; _ures_getKeywordValues_56+240o
		align 10h
_rdata		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B330h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _ures_getVersionByKey_56
_ures_getVersionByKey_56 proc near

var_D8		= byte ptr -0D8h
var_14		= byte ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_C]
		push	eax
		lea	ecx, [ebp+var_14]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		call	_ures_getStringByKey_56
		add	esp, 10h
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_B38E
		mov	eax, [ebp+var_8]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		call	_u_versionFromUString_56
		add	esp, 8

loc_B38E:				; CODE XREF: _ures_getVersionByKey_56+4Cj
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN6_6
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_ures_getVersionByKey_56 endp

; ---------------------------------------------------------------------------
		align 4
$LN6_6		dd 1			; DATA XREF: _ures_getVersionByKey_56+62o
		dd offset $LN5_7
$LN5_7		dd 0FFFFFFECh, 4	; DATA XREF: .text:0000B3B8o
		dd offset $LN4_5
$LN4_5		dd 6E656Ch		; DATA XREF: .text:0000B3C4o
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B3CCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char const * __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::data(void)const
		public ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ proc near
					; CODE XREF: icu_56::StringPiece::StringPiece(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::c_str(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B40Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char const * __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::c_str(void)const
		public ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::data(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ;	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Myptr(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B44Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
		public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
					; CODE XREF: icu_56::StringPiece::StringPiece(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&)+33p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+14h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B47Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::MaybeStackArray<char, 40>::MaybeStackArray<char, 40>(void)
		public ??0?$MaybeStackArray@D$0CI@@icu_56@@QAE@XZ
??0?$MaybeStackArray@D$0CI@@icu_56@@QAE@XZ proc	near
					; CODE XREF: icu_56::CharString::CharString(void)+45p
					; icu_56::CharString::CharString(icu_56::StringPiece const &,UErrorCode	&)+45p	...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		add	eax, 9
		mov	ecx, [ebp+var_8]
		mov	[ecx], eax
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 28h ; '('
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+8], 0
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0?$MaybeStackArray@D$0CI@@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B4C8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::MaybeStackArray<char, 40>::~MaybeStackArray<char, 40>(void)
		public ??1?$MaybeStackArray@D$0CI@@icu_56@@QAE@XZ
??1?$MaybeStackArray@D$0CI@@icu_56@@QAE@XZ proc	near
					; CODE XREF: __unwindfunclet$??0CharString@icu_56@@QAE@XZ$0+3j
					; __unwindfunclet$??0CharString@icu_56@@QAE@ABVStringPiece@1@AAW4UErrorCode@@@Z$0+3j ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		call	?releaseArray@?$MaybeStackArray@D$0CI@@icu_56@@AAEXXZ ;	icu_56::MaybeStackArray<char,40>::releaseArray(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$MaybeStackArray@D$0CI@@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B508h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: int __thiscall icu_56::MaybeStackArray<char, 40>::getCapacity(void)const
		public ?getCapacity@?$MaybeStackArray@D$0CI@@icu_56@@QBEHXZ
?getCapacity@?$MaybeStackArray@D$0CI@@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getCapacity@?$MaybeStackArray@D$0CI@@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B538h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char * __thiscall icu_56::MaybeStackArray<char, 40>::getAlias(void)const
		public ?getAlias@?$MaybeStackArray@D$0CI@@icu_56@@QBEPADXZ
?getAlias@?$MaybeStackArray@D$0CI@@icu_56@@QBEPADXZ proc near
					; CODE XREF: icu_56::CharString::toStringPiece(void)+2Dp
					; icu_56::CharString::data(void)+26p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getAlias@?$MaybeStackArray@D$0CI@@icu_56@@QBEPADXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B568h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char * __thiscall icu_56::MaybeStackArray<char, 40>::getArrayLimit(void)const
		public ?getArrayLimit@?$MaybeStackArray@D$0CI@@icu_56@@QBEPADXZ
?getArrayLimit@?$MaybeStackArray@D$0CI@@icu_56@@QBEPADXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		call	?getAlias@?$MaybeStackArray@D$0CI@@icu_56@@QBEPADXZ ; icu_56::MaybeStackArray<char,40>::getAlias(void)
		mov	ecx, [ebp+var_8]
		add	eax, [ecx+4]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getArrayLimit@?$MaybeStackArray@D$0CI@@icu_56@@QBEPADXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B5B0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char const & __thiscall icu_56::MaybeStackArray<char,	40>::operator[](int)const
		public ??A?$MaybeStackArray@D$0CI@@icu_56@@QBEABDH@Z
??A?$MaybeStackArray@D$0CI@@icu_56@@QBEABDH@Z proc near
					; CODE XREF: icu_56::CharString::operator[](int)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax]
		add	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??A?$MaybeStackArray@D$0CI@@icu_56@@QBEABDH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B5E4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char & __thiscall icu_56::MaybeStackArray<char, 40>::operator[](int)
		public ??A?$MaybeStackArray@D$0CI@@icu_56@@QAEAADH@Z
??A?$MaybeStackArray@D$0CI@@icu_56@@QAEAADH@Z proc near
					; CODE XREF: icu_56::CharString::CharString(void)+60p
					; icu_56::CharString::CharString(icu_56::StringPiece const &,UErrorCode	&)+60p	...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax]
		add	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??A?$MaybeStackArray@D$0CI@@icu_56@@QAEAADH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B618h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall icu_56::MaybeStackArray<char,	40>::aliasInstead(char *, int)
		public ?aliasInstead@?$MaybeStackArray@D$0CI@@icu_56@@QAEXPADH@Z
?aliasInstead@?$MaybeStackArray@D$0CI@@icu_56@@QAEXPADH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jz	short loc_B667
		cmp	[ebp+arg_4], 0
		jle	short loc_B667
		mov	ecx, [ebp+var_8]
		call	?releaseArray@?$MaybeStackArray@D$0CI@@icu_56@@AAEXXZ ;	icu_56::MaybeStackArray<char,40>::releaseArray(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		mov	[eax+4], ecx
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+8], 0

loc_B667:				; CODE XREF: icu_56::MaybeStackArray<char,40>::aliasInstead(char *,int)+27j
					; icu_56::MaybeStackArray<char,40>::aliasInstead(char *,int)+2Dj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?aliasInstead@?$MaybeStackArray@D$0CI@@icu_56@@QAEXPADH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B680h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: void	__thiscall icu_56::MaybeStackArray<char, 40>::releaseArray(void)
		public ?releaseArray@?$MaybeStackArray@D$0CI@@icu_56@@AAEXXZ
?releaseArray@?$MaybeStackArray@D$0CI@@icu_56@@AAEXXZ proc near
					; CODE XREF: icu_56::MaybeStackArray<char,40>::~MaybeStackArray<char,40>(void)+26p
					; icu_56::MaybeStackArray<char,40>::aliasInstead(char *,int)+32p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+8]
		test	ecx, ecx
		jz	short loc_B6BC
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		push	ecx
		call	_uprv_free_56
		add	esp, 4

loc_B6BC:				; CODE XREF: icu_56::MaybeStackArray<char,40>::releaseArray(void)+2Cj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?releaseArray@?$MaybeStackArray@D$0CI@@icu_56@@AAEXXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B6D0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: bool	__thiscall icu_56::MaybeStackArray<char, 40>::operator==(class icu_56::MaybeStackArray<char, 40> const &)
		public ??8?$MaybeStackArray@D$0CI@@icu_56@@AAE_NABV01@@Z
??8?$MaybeStackArray@D$0CI@@icu_56@@AAE_NABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		xor	al, al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??8?$MaybeStackArray@D$0CI@@icu_56@@AAE_NABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B700h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: bool	__thiscall icu_56::MaybeStackArray<char, 40>::operator!=(class icu_56::MaybeStackArray<char, 40> const &)
		public ??9?$MaybeStackArray@D$0CI@@icu_56@@AAE_NABV01@@Z
??9?$MaybeStackArray@D$0CI@@icu_56@@AAE_NABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	al, 1
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??9?$MaybeStackArray@D$0CI@@icu_56@@AAE_NABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B730h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: __thiscall icu_56::MaybeStackArray<char, 40>::MaybeStackArray<char, 40>(class icu_56::MaybeStackArray<char, 40> const &)
		public ??0?$MaybeStackArray@D$0CI@@icu_56@@AAE@ABV01@@Z
??0?$MaybeStackArray@D$0CI@@icu_56@@AAE@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$MaybeStackArray@D$0CI@@icu_56@@AAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B760h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: void	__thiscall icu_56::MaybeStackArray<char, 40>::operator=(class icu_56::MaybeStackArray<char, 40>	const &)
		public ??4?$MaybeStackArray@D$0CI@@icu_56@@AAEXABV01@@Z
??4?$MaybeStackArray@D$0CI@@icu_56@@AAEXABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4?$MaybeStackArray@D$0CI@@icu_56@@AAEXABV01@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B78Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char const * __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Myptr(void)const
		public ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::c_str(void)+26p

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+18h], 10h
		jb	short loc_B7C6
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+4]
		mov	[ebp+var_D0], edx
		jmp	short loc_B7D2
; ---------------------------------------------------------------------------

loc_B7C6:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Myptr(void)+2Aj
		mov	eax, [ebp+var_8]
		add	eax, 4
		mov	[ebp+var_D0], eax

loc_B7D2:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Myptr(void)+38j
		mov	eax, [ebp+var_D0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B7E0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::MaybeStackArray<char,40>::resize(int, size_t Size)
		public ?resize@?$MaybeStackArray@D$0CI@@icu_56@@QAEPADHH@Z
?resize@?$MaybeStackArray@D$0CI@@icu_56@@QAEPADHH@Z proc near

var_D8		= byte ptr -0D8h
Dst		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
Size		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jle	loc_B897
		mov	eax, [ebp+arg_0]
		push	eax
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+Dst], eax
		cmp	[ebp+Dst], 0
		jz	short loc_B890
		cmp	[ebp+Size], 0
		jle	short loc_B870
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+Size]
		cmp	ecx, [eax+4]
		jle	short loc_B83C
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	[ebp+Size], ecx

loc_B83C:				; CODE XREF: icu_56::MaybeStackArray<char,40>::resize(int,int)+51j
		mov	eax, [ebp+Size]
		cmp	eax, [ebp+arg_0]
		jle	short loc_B84A
		mov	eax, [ebp+arg_0]
		mov	[ebp+Size], eax

loc_B84A:				; CODE XREF: icu_56::MaybeStackArray<char,40>::resize(int,int)+62j
		push	1
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		push	ecx
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	edx, [ebp+Size]
		push	edx		; Size
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		push	ecx		; Src
		mov	edx, [ebp+Dst]
		push	edx		; Dst
		call	_memcpy
		add	esp, 0Ch

loc_B870:				; CODE XREF: icu_56::MaybeStackArray<char,40>::resize(int,int)+46j
		mov	ecx, [ebp+var_8]
		call	?releaseArray@?$MaybeStackArray@D$0CI@@icu_56@@AAEXXZ ;	icu_56::MaybeStackArray<char,40>::releaseArray(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+Dst]
		mov	[eax], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+4], ecx
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+8], 1

loc_B890:				; CODE XREF: icu_56::MaybeStackArray<char,40>::resize(int,int)+40j
		mov	eax, [ebp+Dst]
		jmp	short loc_B899
; ---------------------------------------------------------------------------
		jmp	short loc_B899
; ---------------------------------------------------------------------------

loc_B897:				; CODE XREF: icu_56::MaybeStackArray<char,40>::resize(int,int)+27j
		xor	eax, eax

loc_B899:				; CODE XREF: icu_56::MaybeStackArray<char,40>::resize(int,int)+B3j
					; icu_56::MaybeStackArray<char,40>::resize(int,int)+B5j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?resize@?$MaybeStackArray@D$0CI@@icu_56@@QAEPADHH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B8B0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::MaybeStackArray<char,40>::orphanOrClone(size_t Size, int)
		public ?orphanOrClone@?$MaybeStackArray@D$0CI@@icu_56@@QAEPADHAAH@Z
?orphanOrClone@?$MaybeStackArray@D$0CI@@icu_56@@QAEPADHAAH@Z proc near

var_D8		= byte ptr -0D8h
Dst		= dword	ptr -14h
var_8		= dword	ptr -8
Size		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+8]
		test	ecx, ecx
		jz	short loc_B8E8
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		mov	[ebp+Dst], ecx
		jmp	short loc_B947
; ---------------------------------------------------------------------------

loc_B8E8:				; CODE XREF: icu_56::MaybeStackArray<char,40>::orphanOrClone(int,int &)+2Cj
		cmp	[ebp+Size], 0
		jg	short loc_B8F4
		xor	eax, eax
		jmp	short loc_B96E
; ---------------------------------------------------------------------------
		jmp	short loc_B947
; ---------------------------------------------------------------------------

loc_B8F4:				; CODE XREF: icu_56::MaybeStackArray<char,40>::orphanOrClone(int,int &)+3Cj
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+Size]
		cmp	ecx, [eax+4]
		jle	short loc_B908
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	[ebp+Size], ecx

loc_B908:				; CODE XREF: icu_56::MaybeStackArray<char,40>::orphanOrClone(int,int &)+4Dj
		mov	eax, [ebp+Size]
		push	eax
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+Dst], eax
		cmp	[ebp+Dst], 0
		jnz	short loc_B921
		xor	eax, eax
		jmp	short loc_B96E
; ---------------------------------------------------------------------------

loc_B921:				; CODE XREF: icu_56::MaybeStackArray<char,40>::orphanOrClone(int,int &)+6Bj
		push	1
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		push	ecx
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	edx, [ebp+Size]
		push	edx		; Size
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		push	ecx		; Src
		mov	edx, [ebp+Dst]
		push	edx		; Dst
		call	_memcpy
		add	esp, 0Ch

loc_B947:				; CODE XREF: icu_56::MaybeStackArray<char,40>::orphanOrClone(int,int &)+36j
					; icu_56::MaybeStackArray<char,40>::orphanOrClone(int,int &)+42j
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+Size]
		mov	[eax], ecx
		mov	eax, [ebp+var_8]
		add	eax, 9
		mov	ecx, [ebp+var_8]
		mov	[ecx], eax
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 28h ; '('
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+8], 0
		mov	eax, [ebp+Dst]

loc_B96E:				; CODE XREF: icu_56::MaybeStackArray<char,40>::orphanOrClone(int,int &)+40j
					; icu_56::MaybeStackArray<char,40>::orphanOrClone(int,int &)+6Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?orphanOrClone@?$MaybeStackArray@D$0CI@@icu_56@@QAEPADHAAH@Z endp

_text		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn _uenum_unextDefault_56:near ; DATA XREF: .rdata:00000134o
		extrn __RTC_Shutdown:near ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
		extrn __RTC_InitBase:near ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
; const	type_info::`vftable'
		extrn ??_7type_info@@6B@:near
					; DATA XREF: .data:icu_56::UObject `RTTI Type Descriptor'o
					; .data:icu_56::UMemory	`RTTI Type Descriptor'o ...
; public: virtual void * __thiscall icu_56::UObject::getDynamicClassID(void)const
		extrn ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ:near
					; DATA XREF: .rdata:00000274o
					; .rdata:00000528o ...
; void __cdecl icu_56::UMemory::operator delete(void *)
		extrn ??3UMemory@icu_56@@SAXPAX@Z:near
					; CODE XREF: icu_56::UObject::`scalar deleting destructor'(uint)+37p
					; icu_56::UObject::`vector deleting destructor'(uint)+75p ...
; _DWORD __thiscall icu_56::UObject::~UObject(icu_56::UObject *__hidden	this)
		extrn ??1UObject@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::UObject::`scalar deleting destructor'(uint)+26p
					; icu_56::UObject::`vector deleting destructor'(uint)+64p ...
		extrn __RTC_CheckEsp:near
					; CODE XREF: icu_56::UObject::`scalar deleting destructor'(uint)+4Dp
					; icu_56::UObject::`vector deleting destructor'(uint)+8Bp ...
; void __cdecl icu_56::UMemory::operator delete[](void *)
		extrn ??_VUMemory@icu_56@@SAXPAX@Z:near
					; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+51p
					; icu_56::Replaceable::`vector deleting	destructor'(uint)+51p ...
; void __stdcall `eh vector destructor iterator'(void *, unsigned int, int, void (__thiscall *)(void *))
		extrn ??_M@YGXPAXIHP6EX0@Z@Z:near
					; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+3Dp
					; icu_56::Replaceable::`vector deleting	destructor'(uint)+3Dp ...
		extrn __purecall:near	; DATA XREF: .rdata:0000052Co
					; .rdata:00000530o ...
; public: virtual signed char __thiscall icu_56::Replaceable::hasMetaData(void)const
		extrn ?hasMetaData@Replaceable@icu_56@@UBECXZ:near
					; DATA XREF: .rdata:00000538o
; public: virtual class	icu_56::Replaceable * __thiscall icu_56::Replaceable::clone(void)const
		extrn ?clone@Replaceable@icu_56@@UBEPAV12@XZ:near
					; DATA XREF: .rdata:0000053Co
; _DWORD __thiscall icu_56::Replaceable::~Replaceable(icu_56::Replaceable *__hidden this)
		extrn ??1Replaceable@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::Replaceable::`scalar deleting destructor'(uint)+26p
					; icu_56::Replaceable::`vector deleting	destructor'(uint)+64p
					; DATA XREF: ...
; _DWORD __thiscall icu_56::StringPiece::StringPiece(icu_56::StringPiece *__hidden this, const struct icu_56::StringPiece *, int, int)
		extrn ??0StringPiece@icu_56@@QAE@ABV01@HH@Z:near
					; CODE XREF: icu_56::StringPiece::substr(int,int)+32p
; public: virtual char * __thiscall icu_56::ByteSink::GetAppendBuffer(int, int,	char *,	int, int *)
		extrn ?GetAppendBuffer@ByteSink@icu_56@@UAEPADHHPADHPAH@Z:near
					; DATA XREF: .rdata:00000BE8o
; public: virtual void __thiscall icu_56::ByteSink::Flush(void)
		extrn ?Flush@ByteSink@icu_56@@UAEXXZ:near ; DATA XREF: .rdata:00000BECo
; _DWORD __thiscall icu_56::ByteSink::~ByteSink(icu_56::ByteSink *__hidden this)
		extrn ??1ByteSink@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::ByteSink::`scalar deleting	destructor'(uint)+26p
					; icu_56::ByteSink::`vector deleting destructor'(uint)+64p
					; DATA XREF: ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::moveFrom(icu_56::UnicodeString *__hidden this, struct	icu_56::UnicodeString *)
		extrn ?moveFrom@UnicodeString@icu_56@@QAEAAV12@AAV12@@Z:near
					; CODE XREF: icu_56::UnicodeString::operator=(icu_56::UnicodeString &&)+2Ap
; void __thiscall icu_56::UnicodeString::swap(icu_56::UnicodeString *__hidden this, struct icu_56::UnicodeString *)
		extrn ?swap@UnicodeString@icu_56@@QAEXAAV12@@Z:near
					; CODE XREF: icu_56::swap(icu_56::UnicodeString	&,icu_56::UnicodeString	&)+25p
; _DWORD __thiscall icu_56::UnicodeString::~UnicodeString(icu_56::UnicodeString	*__hidden this)
		extrn ??1UnicodeString@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::UnicodeString::`scalar deleting destructor'(uint)+26p
					; icu_56::UnicodeString::`vector deleting destructor'(uint)+64p
					; DATA XREF: ...
; public: virtual void * __thiscall icu_56::UnicodeString::getDynamicClassID(void)const
		extrn ?getDynamicClassID@UnicodeString@icu_56@@UBEPAXXZ:near
					; DATA XREF: .rdata:00001164o
; public: virtual void __thiscall icu_56::UnicodeString::extractBetween(int, int, class	icu_56::UnicodeString &)const
		extrn ?extractBetween@UnicodeString@icu_56@@UBEXHHAAV12@@Z:near
					; DATA XREF: .rdata:00001168o
; public: virtual void __thiscall icu_56::UnicodeString::handleReplaceBetween(int, int,	class icu_56::UnicodeString const &)
		extrn ?handleReplaceBetween@UnicodeString@icu_56@@UAEXHHABV12@@Z:near
					; DATA XREF: .rdata:0000116Co
; public: virtual void __thiscall icu_56::UnicodeString::copy(int, int,	int)
		extrn ?copy@UnicodeString@icu_56@@UAEXHHH@Z:near
					; DATA XREF: .rdata:00001170o
; public: virtual signed char __thiscall icu_56::UnicodeString::hasMetaData(void)const
		extrn ?hasMetaData@UnicodeString@icu_56@@UBECXZ:near
					; DATA XREF: .rdata:00001174o
; public: virtual class	icu_56::Replaceable * __thiscall icu_56::UnicodeString::clone(void)const
		extrn ?clone@UnicodeString@icu_56@@UBEPAVReplaceable@2@XZ:near
					; DATA XREF: .rdata:00001178o
; protected: virtual int __thiscall icu_56::UnicodeString::getLength(void)const
		extrn ?getLength@UnicodeString@icu_56@@MBEHXZ:near
					; DATA XREF: .rdata:0000117Co
; protected: virtual wchar_t __thiscall	icu_56::UnicodeString::getCharAt(int)const
		extrn ?getCharAt@UnicodeString@icu_56@@MBE_WH@Z:near
					; DATA XREF: .rdata:00001180o
; protected: virtual int __thiscall icu_56::UnicodeString::getChar32At(int)const
		extrn ?getChar32At@UnicodeString@icu_56@@MBEHH@Z:near
					; DATA XREF: .rdata:00001184o
; int __thiscall icu_56::UnicodeString::doHashCode(icu_56::UnicodeString *__hidden this)
		extrn ?doHashCode@UnicodeString@icu_56@@ABEHXZ:near
					; CODE XREF: icu_56::UnicodeString::hashCode(void)+26p
; int __thiscall icu_56::UnicodeString::refCount(icu_56::UnicodeString *__hidden this)
		extrn ?refCount@UnicodeString@icu_56@@ABEHXZ:near
					; CODE XREF: icu_56::UnicodeString::isBufferWritable(void)+3Ep
; signed __int8	__thiscall icu_56::UnicodeString::doCompare(icu_56::UnicodeString *__hidden this, int, int, const wchar_t *, int, int)
		extrn ?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z:near
					; CODE XREF: icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+72p
					; icu_56::UnicodeString::compare(wchar_t const *,int)+3Bp ...
; signed __int8	__thiscall icu_56::UnicodeString::doEquals(icu_56::UnicodeString *__hidden this, const struct icu_56::UnicodeString *, int)
		extrn ?doEquals@UnicodeString@icu_56@@ABECABV12@H@Z:near
					; CODE XREF: icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)+76p
; signed __int8	__thiscall icu_56::UnicodeString::doCompareCodePointOrder(icu_56::UnicodeString	*__hidden this,	int, int, const	wchar_t	*, int,	int)
		extrn ?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHPB_WHH@Z:near
					; CODE XREF: icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const	&,int,int)+72p
					; icu_56::UnicodeString::compareCodePointOrder(wchar_t const *,int)+3Bp ...
; signed __int8	__thiscall icu_56::UnicodeString::doCaseCompare(icu_56::UnicodeString *__hidden	this, int, int,	const wchar_t *, int, int, unsigned int)
		extrn ?doCaseCompare@UnicodeString@icu_56@@ABECHHPB_WHHI@Z:near
					; CODE XREF: icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString	const &,int,int,uint)+76p
					; icu_56::UnicodeString::caseCompare(wchar_t const *,int,uint)+3Fp ...
; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *__hidden	this, const wchar_t *, int, int, int, int)
		extrn ?indexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z:near
					; CODE XREF: icu_56::UnicodeString::indexOf(icu_56::UnicodeString const	&,int,int,int,int)+64p
					; icu_56::UnicodeString::indexOf(wchar_t const *,int,int)+4Cp ...
; int __thiscall icu_56::UnicodeString::doIndexOf(icu_56::UnicodeString	*__hidden this,	wchar_t, int, int)
		extrn ?doIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z:near
					; CODE XREF: icu_56::UnicodeString::indexOf(wchar_t,int,int)+33p
					; icu_56::UnicodeString::indexOf(wchar_t)+36p ...
; int __thiscall icu_56::UnicodeString::doIndexOf(icu_56::UnicodeString	*__hidden this,	int, int, int)
		extrn ?doIndexOf@UnicodeString@icu_56@@ABEHHHH@Z:near
					; CODE XREF: icu_56::UnicodeString::indexOf(int,int,int)+32p
; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *__hidden this, const	wchar_t	*, int,	int, int, int)
		extrn ?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z:near
					; CODE XREF: icu_56::UnicodeString::lastIndexOf(wchar_t	const *,int,int,int)+38p
					; icu_56::UnicodeString::lastIndexOf(wchar_t const *,int,int)+4Cp ...
; int __thiscall icu_56::UnicodeString::doLastIndexOf(icu_56::UnicodeString *__hidden this, wchar_t, int, int)
		extrn ?doLastIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z:near
					; CODE XREF: icu_56::UnicodeString::lastIndexOf(wchar_t,int,int)+33p
					; icu_56::UnicodeString::lastIndexOf(wchar_t)+36p ...
; int __thiscall icu_56::UnicodeString::doLastIndexOf(icu_56::UnicodeString *__hidden this, int, int, int)
		extrn ?doLastIndexOf@UnicodeString@icu_56@@ABEHHHH@Z:near
					; CODE XREF: icu_56::UnicodeString::lastIndexOf(int,int,int)+32p
		extrn _u_strlen_56:near	; CODE XREF: icu_56::UnicodeString::startsWith(wchar_t const *,int)+2Dp
					; icu_56::UnicodeString::startsWith(wchar_t const *,int,int)+2Dp ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::doReplace(icu_56::UnicodeString *__hidden this, int, int, const struct icu_56::UnicodeString *, int, int)
		extrn ?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z:near
					; CODE XREF: icu_56::UnicodeString::replace(int,int,icu_56::UnicodeString const	&)+3Dp
					; icu_56::UnicodeString::replace(int,int,icu_56::UnicodeString const &,int,int)+3Ap ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::doReplace(icu_56::UnicodeString *__hidden this, int, int, const wchar_t *, int, int)
		extrn ?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z:near
					; CODE XREF: icu_56::UnicodeString::replace(int,int,wchar_t const *,int)+38p
					; icu_56::UnicodeString::replace(int,int,wchar_t const *,int,int)+3Ap ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::findAndReplace(icu_56::UnicodeString *__hidden this, int, int, const struct icu_56::UnicodeString *, int, int, const struct icu_56::UnicodeString *, int, int)
		extrn ?findAndReplace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH0HH@Z:near
					; CODE XREF: icu_56::UnicodeString::findAndReplace(icu_56::UnicodeString const &,icu_56::UnicodeString const &)+4Fp
					; icu_56::UnicodeString::findAndReplace(int,int,icu_56::UnicodeString const &,icu_56::UnicodeString const &)+4Cp
; void __thiscall icu_56::UnicodeString::doExtract(icu_56::UnicodeString *__hidden this, int, int, wchar_t *, int)
		extrn ?doExtract@UnicodeString@icu_56@@ABEXHHPA_WH@Z:near
					; CODE XREF: icu_56::UnicodeString::extract(int,int,wchar_t *,int)+36p
					; icu_56::UnicodeString::extractBetween(int,int,wchar_t	*,int)+51p
; int __thiscall icu_56::UnicodeString::extract(icu_56::UnicodeString *__hidden	this, int, int,	char *,	unsigned int, const char *)
		extrn ?extract@UnicodeString@icu_56@@QBEHHHPADIPBD@Z:near
					; CODE XREF: icu_56::UnicodeString::extract(int,int,char *,char	const *)+3Ep
; struct icu_56::UnicodeString __thiscall __high icu_56::UnicodeString::tempSubString(int, int)
		extrn ?tempSubString@UnicodeString@icu_56@@QBE?AV12@HH@Z:near
					; CODE XREF: icu_56::UnicodeString::tempSubStringBetween(int,int)+3Fp
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replace(icu_56::UnicodeString	*__hidden this,	int, int, int)
		extrn ?replace@UnicodeString@icu_56@@QAEAAV12@HHH@Z:near
					; CODE XREF: icu_56::UnicodeString::operator=(int)+35p
					; icu_56::UnicodeString::setTo(int)+3Dp ...
; void __thiscall icu_56::UnicodeString::unBogus(icu_56::UnicodeString *__hidden this)
		extrn ?unBogus@UnicodeString@icu_56@@AAEXXZ:near
					; CODE XREF: icu_56::UnicodeString::setTo(icu_56::UnicodeString	const &,int,int)+26p
					; icu_56::UnicodeString::setTo(icu_56::UnicodeString const &,int)+26p ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::copyFrom(icu_56::UnicodeString *__hidden this, const struct icu_56::UnicodeString *, signed __int8)
		extrn ?copyFrom@UnicodeString@icu_56@@AAEAAV12@ABV12@C@Z:near
					; CODE XREF: icu_56::UnicodeString::setTo(icu_56::UnicodeString	const &)+2Cp
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::doAppend(icu_56::UnicodeString *__hidden this, const struct icu_56::UnicodeString *, int, int)
		extrn ?doAppend@UnicodeString@icu_56@@AAEAAV12@ABV12@HH@Z:near
					; CODE XREF: icu_56::UnicodeString::append(icu_56::UnicodeString const &,int,int)+32p
					; icu_56::UnicodeString::append(icu_56::UnicodeString const &)+35p ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::doAppend(icu_56::UnicodeString *__hidden this, const wchar_t *, int, int)
		extrn ?doAppend@UnicodeString@icu_56@@AAEAAV12@PB_WHH@Z:near
					; CODE XREF: icu_56::UnicodeString::append(wchar_t const *,int,int)+32p
					; icu_56::UnicodeString::append(wchar_t	const *,int)+30p ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *__hidden this, int)
		extrn ?append@UnicodeString@icu_56@@QAEAAV12@H@Z:near
					; CODE XREF: icu_56::UnicodeString::operator+=(int)+2Ap
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::doReverse(icu_56::UnicodeString *__hidden this, int, int)
		extrn ?doReverse@UnicodeString@icu_56@@AAEAAV12@HH@Z:near
					; CODE XREF: icu_56::UnicodeString::reverse(void)+31p
					; icu_56::UnicodeString::reverse(int,int)+2Ep
; _DWORD __thiscall icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString *__hidden this, const struct icu_56::UnicodeString *)
		extrn ??0UnicodeString@icu_56@@QAE@ABV01@@Z:near
					; CODE XREF: icu_56::StringEnumeration::StringEnumeration(icu_56::StringEnumeration const &)+6Bp
		extrn ___security_cookie:near
					; DATA XREF: icu_56::StringEnumeration::StringEnumeration(icu_56::StringEnumeration const &)+2Er
					; icu_56::CharString::CharString(void)+2Er ...
		extrn ___CxxFrameHandler3:near
					; CODE XREF: __ehhandler$??0StringEnumeration@icu_56@@QAE@ABV01@@Z+19j
					; __ehhandler$??0CharString@icu_56@@QAE@XZ+19j	...
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near
					; CODE XREF: __ehhandler$??0StringEnumeration@icu_56@@QAE@ABV01@@Z+Fp
					; __ehhandler$??0CharString@icu_56@@QAE@XZ+Fp ...
; public: virtual class	icu_56::StringEnumeration * __thiscall icu_56::StringEnumeration::clone(void)const
		extrn ?clone@StringEnumeration@icu_56@@UBEPAV12@XZ:near
					; DATA XREF: .rdata:00003F78o
; public: virtual char const * __thiscall icu_56::StringEnumeration::next(int *, enum  UErrorCode &)
		extrn ?next@StringEnumeration@icu_56@@UAEPBDPAHAAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:00003F80o
; public: virtual wchar_t const	* __thiscall icu_56::StringEnumeration::unext(int *, enum  UErrorCode &)
		extrn ?unext@StringEnumeration@icu_56@@UAEPB_WPAHAAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:00003F84o
; public: virtual class	icu_56::UnicodeString const * __thiscall icu_56::StringEnumeration::snext(enum	UErrorCode &)
		extrn ?snext@StringEnumeration@icu_56@@UAEPBVUnicodeString@2@AAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:00003F88o
; public: virtual signed char __thiscall icu_56::StringEnumeration::operator==(class icu_56::StringEnumeration const &)const
		extrn ??8StringEnumeration@icu_56@@UBECABV01@@Z:near
					; DATA XREF: .rdata:00003F90o
; public: virtual signed char __thiscall icu_56::StringEnumeration::operator!=(class icu_56::StringEnumeration const &)const
		extrn ??9StringEnumeration@icu_56@@UBECABV01@@Z:near
					; DATA XREF: .rdata:00003F94o
; public: class	icu_56::UnicodeString &	__thiscall icu_56::UnicodeString::operator=(class icu_56::UnicodeString	const &)
		extrn ??4UnicodeString@icu_56@@QAEAAV01@ABV01@@Z:near
					; CODE XREF: icu_56::StringEnumeration::operator=(icu_56::StringEnumeration const &)+3Cp
; _DWORD __thiscall icu_56::StringEnumeration::~StringEnumeration(icu_56::StringEnumeration *__hidden this)
		extrn ??1StringEnumeration@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::StringEnumeration::`scalar	deleting destructor'(uint)+26p
					; icu_56::StringEnumeration::`vector deleting destructor'(uint)+64p
					; DATA XREF: ...
; struct icu_56::CharString *__thiscall	icu_56::CharString::append(icu_56::CharString *__hidden	this, const char *, int, enum UErrorCode *)
		extrn ?append@CharString@icu_56@@QAEAAV12@PBDHAAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::CharString::CharString(char const *,int,UErrorCode	&)+77p
					; icu_56::CharString::append(icu_56::StringPiece const &,UErrorCode &)+3Cp ...
; void *__cdecl	memset(void *Dst, int Val, size_t Size)
		extrn _memset:near	; CODE XREF: _ures_initStackObject_56+29p
					; init_resb_result(ResourceData	const *,uint,char const	*,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+A12p ...
		extrn _uprv_free_56:near
					; CODE XREF: ures_closeBundle(UResourceBundle *,signed char)+4Cp
					; ures_closeBundle(UResourceBundle *,signed char)+7Fp ...
		extrn _umtx_unlock_56:near ; CODE XREF:	entryClose(UResourceDataEntry *)+3Cp
					; entryIncrease(UResourceDataEntry *)+62p ...
		extrn _umtx_lock_56:near ; CODE	XREF: entryClose(UResourceDataEntry *)+23p
					; entryIncrease(UResourceDataEntry *)+23p ...
; void *__cdecl	memcpy(void *Dst, const	void *Src, size_t Size)
		extrn _memcpy:near	; CODE XREF: _ures_copyResb_56+B7p
					; init_resb_result(ResourceData	const *,uint,char const	*,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+478p ...
		extrn _uprv_checkValidMemory:near ; CODE XREF: _ures_copyResb_56+A2p
					; init_resb_result(ResourceData	const *,uint,char const	*,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+461p ...
		extrn _uprv_malloc_56:near ; CODE XREF:	_ures_copyResb_56+5Cp
					; ures_appendResPath(UResourceBundle *,char const *,int,UErrorCode *)+88p ...
		extrn _uprv_realloc_56:near
					; CODE XREF: ures_appendResPath(UResourceBundle	*,char const *,int,UErrorCode *)+D3p
					; init_resb_result(ResourceData	const *,uint,char const	*,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+425p
; char *__cdecl	strcpy(char *Dest, const char *Source)
		extrn _strcpy:near	; CODE XREF: ures_appendResPath(UResourceBundle	*,char const *,int,UErrorCode *)+B8p
					; ures_appendResPath(UResourceBundle *,char const *,int,UErrorCode *)+106p ...
		extrn _res_getString_56:near ; CODE XREF: _ures_getString_56+65p
					; _ures_getNextString_56+DFp ...
; __fastcall _RTC_CheckStackVars(x, x)
		extrn @_RTC_CheckStackVars@8:near ; CODE XREF: _ures_getUTF8String_56+60p
					; _ures_getNextResource_56+1BEp ...
		extrn _u_strToUTF8_56:near
					; CODE XREF: ures_toUTF8String(wchar_t const *,int,char	*,int *,signed char,UErrorCode *)+D5p
					; ures_toUTF8String(wchar_t const *,int,char *,int *,signed char,UErrorCode *)+12Ep
		extrn _u_terminateChars_56:near
					; CODE XREF: ures_toUTF8String(wchar_t const *,int,char	*,int *,signed char,UErrorCode *)+9Ep
					; _ures_getFunctionalEquivalent_56+B7Bp
		extrn _res_getBinary_56:near ; CODE XREF: _ures_getBinary_56+65p
		extrn _res_getIntVector_56:near	; CODE XREF: _ures_getIntVector_56+65p
		extrn _res_getPublicType_56:near ; CODE	XREF: _ures_getType_56+33p
		extrn _res_getArrayItem_56:near	; CODE XREF: _ures_getNextString_56+158p
					; _ures_getNextResource_56+169p ...
		extrn _res_getTableItemByIndex_56:near
					; CODE XREF: _ures_getNextString_56+10Bp
					; _ures_getNextResource_56+10Bp ...
		extrn _res_countArrayItems_56:near
					; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+A6Ep
					; ures_openWithType(UResourceBundle *,char const *,char	const *,UResOpenType,UErrorCode	*)+219p ...
; void *__cdecl	_memmove(void *Dst, const void *Src, size_t Size)
		extrn __imp__memmove:near
					; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+A4Dp
					; DATA XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+A4Dr
		extrn _T_CString_integerToString_56:near
					; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+96Bp
		extrn _res_findResource_56:near
					; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+3A4p
					; init_resb_result(ResourceData	const *,uint,char const	*,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+4A8p ...
; int __cdecl strcmp(const char	*Str1, const char *Str2)
		extrn _strcmp:near	; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+201p
					; init_resb_result(ResourceData	const *,uint,char const	*,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+241p ...
		extrn _u_UCharsToChars_56:near
					; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+178p
					; init_entry(char const	*,char const *,UErrorCode *)+2F7p ...
; size_t __cdecl strlen(const char *Str)
		extrn _strlen:near	; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+E6p
					; init_resb_result(ResourceData	const *,uint,char const	*,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+3CEp ...
		extrn _res_getAlias_56:near
					; CODE XREF: init_resb_result(ResourceData const *,uint,char const *,int,UResourceDataEntry *,UResourceBundle const *,int,UResourceBundle *,UErrorCode *)+90p
; char *__cdecl	_strchr(const char *Str, int Val)
		extrn __imp__strchr:near ; CODE	XREF: strchr(char *,int)+28p
					; DATA XREF: strchr(char *,int)+28r
		extrn _uloc_getDefault_56:near
					; CODE XREF: _ures_getByKeyWithFallback_56+29Dp
					; getFallbackData(UResourceBundle const	*,char const * *,UResourceDataEntry * *,uint *,UErrorCode *)+EBp ...
; _DWORD __thiscall icu_56::StringPiece::StringPiece(icu_56::StringPiece *__hidden this, const char *)
		extrn ??0StringPiece@icu_56@@QAE@PBD@Z:near
					; CODE XREF: _ures_getByKeyWithFallback_56+173p
					; getTableItemByKeyPath(ResourceData const *,uint,char const *)+66p
		extrn _res_getTableItemByKey_56:near
					; CODE XREF: getTableItemByKeyPath(ResourceData	const *,uint,char const	*)+16Dp
					; _ures_getByKey_56+AAp ...
		extrn _uloc_getBaseName_56:near
					; CODE XREF: ures_openWithType(UResourceBundle *,char const *,char const *,UResOpenType,UErrorCode *)+5Ep
					; _ures_getFunctionalEquivalent_56+164p
; char *__cdecl	_strncpy(char *Dest, const char	*Source, size_t	Count)
		extrn __imp__strncpy:near
					; CODE XREF: entryOpen(char const *,char const *,UResOpenType,UErrorCode *)+C4p
					; entryOpen(char const *,char const *,UResOpenType,UErrorCode *)+119p ...
; void __cdecl __wassert(const wchar_t *Message, const wchar_t *File, unsigned int Line)
		extrn __imp___wassert:near
					; CODE XREF: entryOpen(char const *,char const *,UResOpenType,UErrorCode *)+43p
					; createCache(UErrorCode &)+3Cp
					; DATA XREF: ...
; void __cdecl icu_56::umtx_initImplPostInit(icu_56 *__hidden this, struct icu_56::UInitOnce *)
		extrn ?umtx_initImplPostInit@icu_56@@YAXAAUUInitOnce@1@@Z:near
					; CODE XREF: icu_56::umtx_initOnce(icu_56::UInitOnce &,void (*)(UErrorCode &),UErrorCode &)+7Bp
; signed __int8	__cdecl	icu_56::umtx_initImplPreInit(icu_56 *__hidden this, struct icu_56::UInitOnce *)
		extrn ?umtx_initImplPreInit@icu_56@@YACAAUUInitOnce@1@@Z:near
					; CODE XREF: icu_56::umtx_initOnce(icu_56::UInitOnce &,void (*)(UErrorCode &),UErrorCode &)+4Ap
; LONG __stdcall InterlockedCompareExchange(volatile LONG *Destination,	LONG Exchange, LONG Comperand)
		extrn __imp__InterlockedCompareExchange@12:near
					; CODE XREF: icu_56::umtx_loadAcquire(long volatile &)+28p
					; DATA XREF: icu_56::umtx_loadAcquire(long volatile &)+28r
		extrn _ucln_common_registerCleanup_56:near
					; CODE XREF: createCache(UErrorCode &)+70p
		extrn _uhash_open_56:near ; CODE XREF: createCache(UErrorCode &)+5Cp
		extrn _uhash_hashChars_56:near ; CODE XREF: hashEntry(UElement)+39p
					; hashEntry(UElement)+47p
		extrn _uhash_compareChars_56:near
					; CODE XREF: compareEntries(UElement,UElement)+54p
					; compareEntries(UElement,UElement)+6Bp
		extrn _uhash_close_56:near ; CODE XREF:	ures_cleanup(void)+32p
		extrn _uhash_removeElement_56:near ; CODE XREF:	ures_flushCache(void)+9Dp
		extrn _uhash_nextElement_56:near ; CODE	XREF: ures_flushCache(void)+62p
		extrn _res_unload_56:near ; CODE XREF: free_entry(UResourceDataEntry *)+25p
		extrn _uhash_put_56:near
					; CODE XREF: init_entry(char const *,char const	*,UErrorCode *)+367p
		extrn _res_getResource_56:near
					; CODE XREF: init_entry(char const *,char const	*,UErrorCode *)+293p
					; loadParentsExceptRoot(UResourceDataEntry * &,char * const,int,signed char,char * const,UErrorCode *)+78p ...
		extrn _res_load_56:near	; CODE XREF: init_entry(char const *,char const	*,UErrorCode *)+188p
		extrn _uprv_strdup_56:near
					; CODE XREF: init_entry(char const *,char const	*,UErrorCode *)+13Dp
		extrn _uhash_get_56:near
					; CODE XREF: init_entry(char const *,char const	*,UErrorCode *)+AFp
					; init_entry(char const	*,char const *,UErrorCode *)+331p
; void *__cdecl	memset_0(void *Dst, int	Val, size_t Size)
		extrn _memset_0:near	; CODE XREF: init_entry(char const *,char const	*,UErrorCode *)+41p
					; _ures_getFunctionalEquivalent_56+45p	...
; int __cdecl _strncmp(const char *Str1, const char *Str2, size_t MaxCount)
		extrn __imp__strncmp:near
					; CODE XREF: findFirstExisting(char const *,char *,signed char *,signed	char *,signed char *,UErrorCode	*)+B7p
					; _ures_getKeywordValues_56+24Cp
					; DATA XREF: ...
; char *__cdecl	_strrchr(const char *Str, int Ch)
		extrn __imp__strrchr:near ; CODE XREF: strrchr(char *,int)+28p
					; DATA XREF: strrchr(char *,int)+28r
		extrn _u_versionFromString_56:near ; CODE XREF:	_ures_getVersion_56+37p
		extrn _uprv_min_56:near	; CODE XREF: _ures_getFunctionalEquivalent_56+AF8p
; char *__cdecl	strcat(char *Dest, const char *Source)
		extrn _strcat:near	; CODE XREF: _ures_getFunctionalEquivalent_56+A05p
					; _ures_getFunctionalEquivalent_56+A18p ...
		extrn _uloc_getParent_56:near
					; CODE XREF: _ures_getFunctionalEquivalent_56+3F3p
					; _ures_getFunctionalEquivalent_56+66Fp ...
		extrn _uenum_close_56:near
					; CODE XREF: _ures_getFunctionalEquivalent_56+21Ap
					; _ures_getKeywordValues_56+3DEp
		extrn _uloc_getKeywordValue_56:near
					; CODE XREF: _ures_getFunctionalEquivalent_56+126p
		extrn __chkstk:near	; CODE XREF: _ures_getFunctionalEquivalent_56+8p
					; _ures_getKeywordValues_56+8p
		extrn _uenum_next_56:near
					; CODE XREF: isLocaleInList(UEnumeration *,char	const *,UErrorCode *)+28p
					; _ures_getKeywordValues_56+D8p
		extrn _uloc_openKeywordList_56:near
					; CODE XREF: _ures_getKeywordValues_56+3F8p
		extrn _u_versionFromUString_56:near
					; CODE XREF: _ures_getVersionByKey_56+56p


		end
