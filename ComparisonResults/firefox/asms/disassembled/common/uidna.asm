;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	8DB2847E020846DA2BBC9D9338B23888
; Input	CRC32 :	78BC0830

; File Name   :	D:\compspace\objfiles\firefox\common\uidna.obj
; Format      :	COFF (X386MAGIC)
; includelib "msvcprtd"
; includelib "MSVCRTD"
; includelib "OLDNAMES"

		include	uni.inc	; see unicode subdir of	ida for	info on	unicode

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
_ACE_PREFIX:				; DATA XREF: _internal_toASCII(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile	*,UParseError *,UErrorCode *)+5A7o
					; _internal_toASCII(wchar_t const *,int,wchar_t	*,int,int,UStringPrepProfile *,UParseError *,UErrorCode	*)+5B6o ...
		unicode	0, <xn-->
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	operator new(unsigned int)
		public ??2@YAPAXI@Z
??2@YAPAXI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??2@YAPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$TMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$TMZ
		;org 40h
__RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
_rtc$TMZ	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$IMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$IMZ
		;org 44h
__RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
_rtc$IMZ	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 48h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl operator	delete(void *)
		public ??3@YAXPAX@Z
??3@YAXPAX@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??3@YAXPAX@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl uidna_toASCII_56(int, int, void *Dst, int, int, int, int)
		public _uidna_toASCII_56
_uidna_toASCII_56 proc near		; CODE XREF: _internal_toUnicode(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile *,UParseError	*,UErrorCode *)+339p
					; _internal_toUnicode(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile *,UParseError *,UErrorCode *)+3B3p

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
Dst		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_18], 0
		jz	short loc_B5
		mov	eax, [ebp+arg_18]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_BC

loc_B5:					; CODE XREF: _uidna_toASCII_56+22j
		xor	eax, eax
		jmp	loc_14C
; ---------------------------------------------------------------------------

loc_BC:					; CODE XREF: _uidna_toASCII_56+37j
		cmp	[ebp+arg_0], 0
		jz	short loc_DA
		cmp	[ebp+arg_4], 0FFFFFFFFh
		jl	short loc_DA
		cmp	[ebp+arg_C], 0
		jl	short loc_DA
		cmp	[ebp+Dst], 0
		jnz	short loc_E7
		cmp	[ebp+arg_C], 0
		jle	short loc_E7

loc_DA:					; CODE XREF: _uidna_toASCII_56+44j
					; _uidna_toASCII_56+4Aj ...
		mov	eax, [ebp+arg_18]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	short loc_14C
; ---------------------------------------------------------------------------

loc_E7:					; CODE XREF: _uidna_toASCII_56+56j
					; _uidna_toASCII_56+5Cj
		mov	eax, [ebp+arg_18]
		push	eax
		push	0
		call	_usprep_openByType_56
		add	esp, 8
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_18]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_112
		or	eax, 0FFFFFFFFh
		jmp	short loc_14C
; ---------------------------------------------------------------------------

loc_112:				; CODE XREF: _uidna_toASCII_56+8Fj
		mov	eax, [ebp+arg_18]
		push	eax		; int
		mov	ecx, [ebp+arg_14]
		push	ecx		; int
		mov	edx, [ebp+var_8]
		push	edx		; int
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+Dst]
		push	edx		; Dst
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		call	?_internal_toASCII@@YAHPB_WHPA_WHHPAUUStringPrepProfile@@PAUUParseError@@PAW4UErrorCode@@@Z ; _internal_toASCII(wchar_t	const *,int,wchar_t *,int,int,UStringPrepProfile *,UParseError *,UErrorCode *)
		add	esp, 20h
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_8]
		push	eax
		call	_usprep_close_56
		add	esp, 4
		mov	eax, [ebp+var_14]

loc_14C:				; CODE XREF: _uidna_toASCII_56+3Bj
					; _uidna_toASCII_56+69j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uidna_toASCII_56 endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 160h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl U_FAILURE(enum  UErrorCode)
?U_FAILURE@@YACW4UErrorCode@@@Z	proc near ; CODE XREF: _uidna_toASCII_56+2Ap
					; _uidna_toASCII_56+82p ...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		setnle	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?U_FAILURE@@YACW4UErrorCode@@@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 18Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl _internal_toASCII(int, int, void *Dst, int, int, int, int, int)
?_internal_toASCII@@YAHPB_WHPA_WHHPAUUStringPrepProfile@@PAUUParseError@@PAW4UErrorCode@@@Z proc near
					; CODE XREF: _uidna_toASCII_56+B6p
					; _uidna_IDNToASCII_56+122p

var_310		= dword	ptr -310h
var_248		= dword	ptr -248h
var_239		= byte ptr -239h
var_230		= dword	ptr -230h
var_221		= byte ptr -221h
var_215		= byte ptr -215h
var_20C		= dword	ptr -20Ch
var_200		= dword	ptr -200h
var_1F4		= dword	ptr -1F4h
var_1E8		= dword	ptr -1E8h
var_1DC		= dword	ptr -1DCh
var_1D0		= dword	ptr -1D0h
var_1C4		= dword	ptr -1C4h
var_1B8		= dword	ptr -1B8h
Src		= dword	ptr -1ACh
var_1A0		= byte ptr -1A0h
var_D0		= byte ptr -0D0h
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
Dst		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h
arg_1C		= dword	ptr  24h

		push	ebp
		mov	ebp, esp
		sub	esp, 310h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_310]
		mov	ecx, 0C4h ; 'Ä'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		lea	eax, [ebp+var_D0]
		mov	[ebp+Src], eax
		lea	eax, [ebp+var_1A0]
		mov	[ebp+var_1B8], eax
		mov	[ebp+var_1C4], 0
		mov	[ebp+var_1DC], 64h ; 'd'
		mov	[ebp+var_1E8], 64h ; 'd'
		mov	[ebp+var_1F4], 0
		mov	eax, [ebp+arg_10]
		and	eax, 1
		neg	eax
		sbb	eax, eax
		neg	eax
		mov	[ebp+var_200], eax
		mov	[ebp+var_20C], 0
		mov	[ebp+var_215], 1
		mov	[ebp+var_221], 1
		mov	[ebp+var_230], 0
		mov	eax, [ebp+arg_10]
		and	eax, 2
		setnz	cl
		mov	[ebp+var_239], cl
		mov	[ebp+var_248], 0FFFFFFFFh
		cmp	[ebp+arg_4], 0FFFFFFFFh
		jnz	short loc_256
		mov	eax, [ebp+arg_0]
		push	eax
		call	_u_strlen_56
		add	esp, 4
		mov	[ebp+arg_4], eax

loc_256:				; CODE XREF: _internal_toASCII(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile	*,UParseError *,UErrorCode *)+B9j
		mov	eax, [ebp+arg_4]
		cmp	eax, [ebp+var_1DC]
		jle	short loc_29A
		mov	eax, [ebp+arg_4]
		shl	eax, 1
		push	eax
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+Src], eax
		cmp	[ebp+Src], 0
		jnz	short loc_291
		mov	eax, [ebp+arg_1C]
		mov	dword ptr [eax], 7
		jmp	$CLEANUP$10532
; ---------------------------------------------------------------------------
		jmp	$CLEANUP$10532
; ---------------------------------------------------------------------------

loc_291:				; CODE XREF: _internal_toASCII(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile	*,UParseError *,UErrorCode *)+F0j
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_1DC], eax

loc_29A:				; CODE XREF: _internal_toASCII(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile	*,UParseError *,UErrorCode *)+D3j
		mov	[ebp+var_230], 0
		jmp	short loc_2B5
; ---------------------------------------------------------------------------

loc_2A6:				; CODE XREF: _internal_toASCII(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile	*,UParseError *,UErrorCode *)+179j
		mov	eax, [ebp+var_230]
		add	eax, 1
		mov	[ebp+var_230], eax

loc_2B5:				; CODE XREF: _internal_toASCII(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile	*,UParseError *,UErrorCode *)+118j
		mov	eax, [ebp+var_230]
		cmp	eax, [ebp+arg_4]
		jge	short loc_307
		mov	eax, [ebp+var_230]
		mov	ecx, [ebp+arg_0]
		movzx	edx, word ptr [ecx+eax*2]
		cmp	edx, 7Fh ; ''
		jle	short loc_2D9
		mov	[ebp+var_215], 0

loc_2D9:				; CODE XREF: _internal_toASCII(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile	*,UParseError *,UErrorCode *)+144j
		mov	eax, [ebp+var_1C4]
		mov	ecx, [ebp+Src]
		mov	edx, [ebp+var_230]
		mov	esi, [ebp+arg_0]
		mov	dx, [esi+edx*2]
		mov	[ecx+eax*2], dx
		mov	eax, [ebp+var_1C4]
		add	eax, 1
		mov	[ebp+var_1C4], eax
		jmp	short loc_2A6
; ---------------------------------------------------------------------------

loc_307:				; CODE XREF: _internal_toASCII(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile	*,UParseError *,UErrorCode *)+132j
		movsx	eax, [ebp+var_215]
		test	eax, eax
		jnz	loc_3EB
		mov	eax, [ebp+arg_1C]
		push	eax
		mov	ecx, [ebp+arg_18]
		push	ecx
		mov	edx, [ebp+var_200]
		push	edx
		mov	eax, [ebp+var_1DC]
		push	eax
		mov	ecx, [ebp+Src]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+arg_14]
		push	ecx
		call	_usprep_prepare_56
		add	esp, 20h
		mov	[ebp+var_1C4], eax
		mov	eax, [ebp+arg_1C]
		cmp	dword ptr [eax], 0Fh
		jnz	loc_3EB
		mov	eax, [ebp+Src]
		lea	ecx, [ebp+var_D0]
		cmp	eax, ecx
		jz	short loc_378
		mov	eax, [ebp+Src]
		push	eax
		call	_uprv_free_56
		add	esp, 4

loc_378:				; CODE XREF: _internal_toASCII(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile	*,UParseError *,UErrorCode *)+1DBj
		mov	eax, [ebp+var_1C4]
		shl	eax, 1
		push	eax
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+Src], eax
		cmp	[ebp+Src], 0
		jnz	short loc_3AB
		mov	eax, [ebp+arg_1C]
		mov	dword ptr [eax], 7
		jmp	$CLEANUP$10532
; ---------------------------------------------------------------------------
		jmp	$CLEANUP$10532
; ---------------------------------------------------------------------------

loc_3AB:				; CODE XREF: _internal_toASCII(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile	*,UParseError *,UErrorCode *)+20Aj
		mov	eax, [ebp+arg_1C]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+arg_1C]
		push	eax
		mov	ecx, [ebp+arg_18]
		push	ecx
		mov	edx, [ebp+var_200]
		push	edx
		mov	eax, [ebp+var_1C4]
		push	eax
		mov	ecx, [ebp+Src]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+arg_14]
		push	ecx
		call	_usprep_prepare_56
		add	esp, 20h
		mov	[ebp+var_1C4], eax

loc_3EB:				; CODE XREF: _internal_toASCII(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile	*,UParseError *,UErrorCode *)+184j
					; _internal_toASCII(wchar_t const *,int,wchar_t	*,int,int,UStringPrepProfile *,UParseError *,UErrorCode	*)+1C7j
		mov	eax, [ebp+arg_1C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_40A
		jmp	$CLEANUP$10532
; ---------------------------------------------------------------------------
		jmp	$CLEANUP$10532
; ---------------------------------------------------------------------------

loc_40A:				; CODE XREF: _internal_toASCII(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile	*,UParseError *,UErrorCode *)+272j
		cmp	[ebp+var_1C4], 0
		jnz	short loc_426
		mov	eax, [ebp+arg_1C]
		mov	dword ptr [eax], 10407h
		jmp	$CLEANUP$10532
; ---------------------------------------------------------------------------
		jmp	$CLEANUP$10532
; ---------------------------------------------------------------------------

loc_426:				; CODE XREF: _internal_toASCII(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile	*,UParseError *,UErrorCode *)+285j
		mov	[ebp+var_215], 1
		mov	[ebp+var_230], 0
		jmp	short loc_448
; ---------------------------------------------------------------------------

loc_439:				; CODE XREF: _internal_toASCII(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile	*,UParseError *,UErrorCode *):loc_4A7j
		mov	eax, [ebp+var_230]
		add	eax, 1
		mov	[ebp+var_230], eax

loc_448:				; CODE XREF: _internal_toASCII(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile	*,UParseError *,UErrorCode *)+2ABj
		mov	eax, [ebp+var_230]
		cmp	eax, [ebp+var_1C4]
		jge	short loc_4A9
		mov	eax, [ebp+var_230]
		mov	ecx, [ebp+Src]
		movzx	edx, word ptr [ecx+eax*2]
		cmp	edx, 7Fh ; ''
		jle	short loc_474
		mov	[ebp+var_215], 0
		jmp	short loc_4A7
; ---------------------------------------------------------------------------

loc_474:				; CODE XREF: _internal_toASCII(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile	*,UParseError *,UErrorCode *)+2DDj
		mov	eax, [ebp+var_230]
		mov	ecx, [ebp+Src]
		movzx	edx, word ptr [ecx+eax*2]
		push	edx
		call	?isLDHChar@@YAC_W@Z ; isLDHChar(wchar_t)
		add	esp, 4
		movsx	eax, al
		test	eax, eax
		jnz	short loc_4A7
		mov	[ebp+var_221], 0
		mov	eax, [ebp+var_230]
		mov	[ebp+var_248], eax

loc_4A7:				; CODE XREF: _internal_toASCII(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile	*,UParseError *,UErrorCode *)+2E6j
					; _internal_toASCII(wchar_t const *,int,wchar_t	*,int,int,UStringPrepProfile *,UParseError *,UErrorCode	*)+306j
		jmp	short loc_439
; ---------------------------------------------------------------------------

loc_4A9:				; CODE XREF: _internal_toASCII(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile	*,UParseError *,UErrorCode *)+2C8j
		movsx	eax, [ebp+var_239]
		cmp	eax, 1
		jnz	loc_5A0
		movsx	eax, [ebp+var_221]
		test	eax, eax
		jz	short loc_4EC
		mov	eax, [ebp+Src]
		movzx	ecx, word ptr [eax]
		cmp	ecx, 2Dh ; '-'
		jz	short loc_4EC
		mov	eax, [ebp+var_1C4]
		mov	ecx, [ebp+Src]
		movzx	edx, word ptr [ecx+eax*2-2]
		cmp	edx, 2Dh ; '-'
		jnz	loc_5A0

loc_4EC:				; CODE XREF: _internal_toASCII(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile	*,UParseError *,UErrorCode *)+336j
					; _internal_toASCII(wchar_t const *,int,wchar_t	*,int,int,UStringPrepProfile *,UParseError *,UErrorCode	*)+344j
		mov	eax, [ebp+arg_1C]
		mov	dword ptr [eax], 10403h
		movsx	eax, [ebp+var_221]
		test	eax, eax
		jnz	short loc_523
		mov	eax, [ebp+arg_18]
		push	eax
		mov	ecx, [ebp+var_1C4]
		push	ecx
		mov	edx, [ebp+var_248]
		push	edx
		mov	eax, [ebp+Src]
		push	eax
		call	_uprv_syntaxError_56
		add	esp, 10h
		jmp	short loc_596
; ---------------------------------------------------------------------------

loc_523:				; CODE XREF: _internal_toASCII(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile	*,UParseError *,UErrorCode *)+372j
		mov	eax, [ebp+Src]
		movzx	ecx, word ptr [eax]
		cmp	ecx, 2Dh ; '-'
		jnz	short loc_54F
		mov	eax, [ebp+arg_18]
		push	eax
		mov	ecx, [ebp+var_1C4]
		push	ecx
		push	0
		mov	edx, [ebp+Src]
		push	edx
		call	_uprv_syntaxError_56
		add	esp, 10h
		jmp	short loc_596
; ---------------------------------------------------------------------------

loc_54F:				; CODE XREF: _internal_toASCII(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile	*,UParseError *,UErrorCode *)+3A3j
		cmp	[ebp+var_1C4], 0
		jle	short loc_569
		mov	eax, [ebp+var_1C4]
		sub	eax, 1
		mov	[ebp+var_310], eax
		jmp	short loc_575
; ---------------------------------------------------------------------------

loc_569:				; CODE XREF: _internal_toASCII(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile	*,UParseError *,UErrorCode *)+3CAj
		mov	ecx, [ebp+var_1C4]
		mov	[ebp+var_310], ecx

loc_575:				; CODE XREF: _internal_toASCII(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile	*,UParseError *,UErrorCode *)+3DBj
		mov	edx, [ebp+arg_18]
		push	edx
		mov	eax, [ebp+var_1C4]
		push	eax
		mov	ecx, [ebp+var_310]
		push	ecx
		mov	edx, [ebp+Src]
		push	edx
		call	_uprv_syntaxError_56
		add	esp, 10h

loc_596:				; CODE XREF: _internal_toASCII(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile	*,UParseError *,UErrorCode *)+395j
					; _internal_toASCII(wchar_t const *,int,wchar_t	*,int,int,UStringPrepProfile *,UParseError *,UErrorCode	*)+3C1j
		jmp	$CLEANUP$10532
; ---------------------------------------------------------------------------
		jmp	$CLEANUP$10532
; ---------------------------------------------------------------------------

loc_5A0:				; CODE XREF: _internal_toASCII(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile	*,UParseError *,UErrorCode *)+327j
					; _internal_toASCII(wchar_t const *,int,wchar_t	*,int,int,UStringPrepProfile *,UParseError *,UErrorCode	*)+35Aj
		movsx	eax, [ebp+var_215]
		test	eax, eax
		jz	short loc_616
		mov	eax, [ebp+var_1C4]
		cmp	eax, [ebp+arg_C]
		jg	short loc_5FB
		push	1
		mov	eax, [ebp+Src]
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	ecx, [ebp+var_1C4]
		shl	ecx, 1
		mov	esi, esp
		push	ecx		; Size
		mov	edx, [ebp+Src]
		push	edx		; Src
		mov	eax, [ebp+Dst]
		push	eax		; Dst
		call	dword ptr ds:__imp__memmove
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_1C4]
		mov	[ebp+var_1F4], eax
		jmp	short loc_611
; ---------------------------------------------------------------------------

loc_5FB:				; CODE XREF: _internal_toASCII(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile	*,UParseError *,UErrorCode *)+428j
		mov	eax, [ebp+var_1C4]
		mov	[ebp+var_1F4], eax
		jmp	$CLEANUP$10532
; ---------------------------------------------------------------------------
		jmp	$CLEANUP$10532
; ---------------------------------------------------------------------------

loc_611:				; CODE XREF: _internal_toASCII(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile	*,UParseError *,UErrorCode *)+46Dj
		jmp	loc_7AE
; ---------------------------------------------------------------------------

loc_616:				; CODE XREF: _internal_toASCII(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile	*,UParseError *,UErrorCode *)+41Dj
		mov	eax, [ebp+var_1C4]
		push	eax
		mov	ecx, [ebp+Src]
		push	ecx
		call	?startsWithPrefix@@YACPB_WH@Z ;	startsWithPrefix(wchar_t const *,int)
		add	esp, 8
		movsx	edx, al
		test	edx, edx
		jnz	loc_785
		mov	eax, [ebp+arg_1C]
		push	eax
		mov	ecx, [ebp+var_20C]
		push	ecx
		mov	edx, [ebp+var_1E8]
		push	edx
		mov	eax, [ebp+var_1B8]
		push	eax
		mov	ecx, [ebp+var_1C4]
		push	ecx
		mov	edx, [ebp+Src]
		push	edx
		call	_u_strToPunycode_56
		add	esp, 18h
		mov	[ebp+var_1D0], eax
		mov	eax, [ebp+arg_1C]
		cmp	dword ptr [eax], 0Fh
		jnz	short loc_6E5
		mov	eax, [ebp+var_1D0]
		shl	eax, 1
		push	eax
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+var_1B8], eax
		cmp	[ebp+var_1B8], 0
		jnz	short loc_6A7
		mov	eax, [ebp+arg_1C]
		mov	dword ptr [eax], 7
		jmp	$CLEANUP$10532
; ---------------------------------------------------------------------------
		jmp	$CLEANUP$10532
; ---------------------------------------------------------------------------

loc_6A7:				; CODE XREF: _internal_toASCII(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile	*,UParseError *,UErrorCode *)+506j
		mov	eax, [ebp+arg_1C]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+arg_1C]
		push	eax
		mov	ecx, [ebp+var_20C]
		push	ecx
		mov	edx, [ebp+var_1D0]
		push	edx
		mov	eax, [ebp+var_1B8]
		push	eax
		mov	ecx, [ebp+var_1C4]
		push	ecx
		mov	edx, [ebp+Src]
		push	edx
		call	_u_strToPunycode_56
		add	esp, 18h
		mov	[ebp+var_1D0], eax

loc_6E5:				; CODE XREF: _internal_toASCII(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile	*,UParseError *,UErrorCode *)+4E6j
		mov	eax, [ebp+arg_1C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_704
		jmp	$CLEANUP$10532
; ---------------------------------------------------------------------------
		jmp	$CLEANUP$10532
; ---------------------------------------------------------------------------

loc_704:				; CODE XREF: _internal_toASCII(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile	*,UParseError *,UErrorCode *)+56Cj
		mov	eax, [ebp+var_1D0]
		add	eax, 4
		mov	[ebp+var_1F4], eax
		mov	eax, [ebp+var_1F4]
		cmp	eax, [ebp+arg_C]
		jle	short loc_731
		mov	eax, [ebp+arg_1C]
		mov	dword ptr [eax], 0Fh
		jmp	$CLEANUP$10532
; ---------------------------------------------------------------------------
		jmp	$CLEANUP$10532
; ---------------------------------------------------------------------------

loc_731:				; CODE XREF: _internal_toASCII(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile	*,UParseError *,UErrorCode *)+590j
		push	1
		push	offset _ACE_PREFIX ; "xn--"
		call	_uprv_checkValidMemory
		add	esp, 8
		push	8		; Size
		push	offset _ACE_PREFIX ; "xn--"
		mov	eax, [ebp+Dst]
		push	eax		; Dst
		call	_memcpy
		add	esp, 0Ch
		push	1
		mov	eax, [ebp+var_1B8]
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	ecx, [ebp+var_1D0]
		shl	ecx, 1
		push	ecx		; Size
		mov	edx, [ebp+var_1B8]
		push	edx		; Src
		mov	eax, [ebp+Dst]
		add	eax, 8
		push	eax		; Dst
		call	_memcpy
		add	esp, 0Ch
		jmp	short loc_7AE
; ---------------------------------------------------------------------------

loc_785:				; CODE XREF: _internal_toASCII(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile	*,UParseError *,UErrorCode *)+4A5j
		mov	eax, [ebp+arg_1C]
		mov	dword ptr [eax], 10404h
		mov	eax, [ebp+arg_18]
		push	eax
		mov	ecx, [ebp+var_1C4]
		push	ecx
		push	0
		mov	edx, [ebp+Src]
		push	edx
		call	_uprv_syntaxError_56
		add	esp, 10h
		jmp	short $CLEANUP$10532
; ---------------------------------------------------------------------------
		jmp	short $CLEANUP$10532
; ---------------------------------------------------------------------------

loc_7AE:				; CODE XREF: _internal_toASCII(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile	*,UParseError *,UErrorCode *):loc_611j
					; _internal_toASCII(wchar_t const *,int,wchar_t	*,int,int,UStringPrepProfile *,UParseError *,UErrorCode	*)+5F7j
		cmp	[ebp+var_1F4], 3Fh ; '?'
		jle	short $CLEANUP$10532
		mov	eax, [ebp+arg_1C]
		mov	dword ptr [eax], 10406h

$CLEANUP$10532:				; CODE XREF: _internal_toASCII(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile	*,UParseError *,UErrorCode *)+FBj
					; _internal_toASCII(wchar_t const *,int,wchar_t	*,int,int,UStringPrepProfile *,UParseError *,UErrorCode	*)+100j ...
		mov	eax, [ebp+Src]
		lea	ecx, [ebp+var_D0]
		cmp	eax, ecx
		jz	short loc_7DF
		mov	eax, [ebp+Src]
		push	eax
		call	_uprv_free_56
		add	esp, 4

loc_7DF:				; CODE XREF: _internal_toASCII(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile	*,UParseError *,UErrorCode *)+642j
		mov	eax, [ebp+var_1B8]
		lea	ecx, [ebp+var_1A0]
		cmp	eax, ecx
		jz	short loc_7FE
		mov	eax, [ebp+var_1B8]
		push	eax
		call	_uprv_free_56
		add	esp, 4

loc_7FE:				; CODE XREF: _internal_toASCII(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile	*,UParseError *,UErrorCode *)+661j
		mov	eax, [ebp+var_20C]
		push	eax
		call	_uprv_free_56
		add	esp, 4
		mov	eax, [ebp+arg_1C]
		push	eax
		mov	ecx, [ebp+var_1F4]
		push	ecx
		mov	edx, [ebp+arg_C]
		push	edx
		mov	eax, [ebp+Dst]
		push	eax
		call	_u_terminateUChars_56
		add	esp, 10h
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN57
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 310h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?_internal_toASCII@@YAHPB_WHPA_WHHPAUUStringPrepProfile@@PAUUParseError@@PAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN57		dd 2			; DATA XREF: _internal_toASCII(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile	*,UParseError *,UErrorCode *)+6A0o
		dd offset $LN56
$LN56		dd 0FFFFFF30h, 0C8h	; DATA XREF: .text:0000085Co
		dd offset $LN54		; "b1Stack"
		dd 0FFFFFE60h, 0C8h
		dd offset $LN55		; "b2Stack"
$LN55		db 'b2Stack',0          ; DATA XREF: .text:00000874o
$LN54		db 'b1Stack',0          ; DATA XREF: .text:00000868o
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 888h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl startsWithPrefix(wchar_t const *,	int)
?startsWithPrefix@@YACPB_WH@Z proc near	; CODE XREF: _internal_toASCII(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile	*,UParseError *,UErrorCode *)+498p
					; _internal_toUnicode(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile *,UParseError *,UErrorCode *)+232p

var_D8		= byte ptr -0D8h
var_11		= byte ptr -11h
var_5		= byte ptr -5
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_5], 1
		cmp	[ebp+arg_4], 4
		jge	short loc_8B4
		xor	al, al
		jmp	short loc_8FB
; ---------------------------------------------------------------------------

loc_8B4:				; CODE XREF: startsWithPrefix(wchar_t const *,int)+26j
		mov	[ebp+var_11], 0
		jmp	short loc_8C2
; ---------------------------------------------------------------------------

loc_8BA:				; CODE XREF: startsWithPrefix(wchar_t const *,int):loc_8F6j
		mov	al, [ebp+var_11]
		add	al, 1
		mov	[ebp+var_11], al

loc_8C2:				; CODE XREF: startsWithPrefix(wchar_t const *,int)+30j
		movsx	eax, [ebp+var_11]
		cmp	eax, 4
		jge	short loc_8F8
		movsx	eax, [ebp+var_11]
		mov	ecx, [ebp+arg_0]
		movzx	edx, word ptr [ecx+eax*2]
		push	edx
		call	?toASCIILower@@YA_W_W@Z	; toASCIILower(wchar_t)
		add	esp, 4
		movzx	eax, ax
		movsx	ecx, [ebp+var_11]
		movzx	edx, word ptr _ACE_PREFIX[ecx*2] ; "xn--"
		cmp	eax, edx
		jz	short loc_8F6
		mov	[ebp+var_5], 0

loc_8F6:				; CODE XREF: startsWithPrefix(wchar_t const *,int)+68j
		jmp	short loc_8BA
; ---------------------------------------------------------------------------

loc_8F8:				; CODE XREF: startsWithPrefix(wchar_t const *,int)+41j
		mov	al, [ebp+var_5]

loc_8FB:				; CODE XREF: startsWithPrefix(wchar_t const *,int)+2Aj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?startsWithPrefix@@YACPB_WH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 910h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; wchar_t __cdecl toASCIILower(wchar_t)
?toASCIILower@@YA_W_W@Z	proc near	; CODE XREF: startsWithPrefix(wchar_t const *,int)+4Fp
					; compareCaseInsensitiveASCII(wchar_t const *,int,wchar_t const	*,int)+A5p ...

var_C0		= byte ptr -0C0h
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		movzx	eax, [ebp+arg_0]
		cmp	eax, 41h ; 'A'
		jl	short loc_949
		movzx	eax, [ebp+arg_0]
		cmp	eax, 5Ah ; 'Z'
		jg	short loc_949
		movzx	eax, [ebp+arg_0]
		add	eax, 20h ; ' '
		jmp	short loc_94D
; ---------------------------------------------------------------------------

loc_949:				; CODE XREF: toASCIILower(wchar_t)+25j
					; toASCIILower(wchar_t)+2Ej
		mov	ax, [ebp+arg_0]

loc_94D:				; CODE XREF: toASCIILower(wchar_t)+37j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?toASCIILower@@YA_W_W@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 954h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl isLDHChar(wchar_t)
?isLDHChar@@YAC_W@Z proc near		; CODE XREF: _internal_toASCII(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile	*,UParseError *,UErrorCode *)+2F9p

var_C0		= byte ptr -0C0h
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		movzx	eax, [ebp+arg_0]
		cmp	eax, 7Ah ; 'z'
		jle	short loc_97F
		xor	al, al
		jmp	short loc_9C4
; ---------------------------------------------------------------------------

loc_97F:				; CODE XREF: isLDHChar(wchar_t)+25j
		movzx	eax, [ebp+arg_0]
		cmp	eax, 2Dh ; '-'
		jz	short loc_9BE
		movzx	eax, [ebp+arg_0]
		cmp	eax, 30h ; '0'
		jl	short loc_99A
		movzx	eax, [ebp+arg_0]
		cmp	eax, 39h ; '9'
		jle	short loc_9BE

loc_99A:				; CODE XREF: isLDHChar(wchar_t)+3Bj
		movzx	eax, [ebp+arg_0]
		cmp	eax, 41h ; 'A'
		jl	short loc_9AC
		movzx	eax, [ebp+arg_0]
		cmp	eax, 5Ah ; 'Z'
		jle	short loc_9BE

loc_9AC:				; CODE XREF: isLDHChar(wchar_t)+4Dj
		movzx	eax, [ebp+arg_0]
		cmp	eax, 61h ; 'a'
		jl	short loc_9C2
		movzx	eax, [ebp+arg_0]
		cmp	eax, 7Ah ; 'z'
		jg	short loc_9C2

loc_9BE:				; CODE XREF: isLDHChar(wchar_t)+32j
					; isLDHChar(wchar_t)+44j ...
		mov	al, 1
		jmp	short loc_9C4
; ---------------------------------------------------------------------------

loc_9C2:				; CODE XREF: isLDHChar(wchar_t)+5Fj
					; isLDHChar(wchar_t)+68j
		xor	al, al

loc_9C4:				; CODE XREF: isLDHChar(wchar_t)+29j
					; isLDHChar(wchar_t)+6Cj
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isLDHChar@@YAC_W@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9CCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl uidna_toUnicode_56(void *, int, void *Dst, int, int, int,	int)
		public _uidna_toUnicode_56
_uidna_toUnicode_56 proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
Dst		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_18], 0
		jz	short loc_A05
		mov	eax, [ebp+arg_18]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_A0C

loc_A05:				; CODE XREF: _uidna_toUnicode_56+22j
		xor	eax, eax
		jmp	loc_A9C
; ---------------------------------------------------------------------------

loc_A0C:				; CODE XREF: _uidna_toUnicode_56+37j
		cmp	[ebp+arg_0], 0
		jz	short loc_A2A
		cmp	[ebp+arg_4], 0FFFFFFFFh
		jl	short loc_A2A
		cmp	[ebp+arg_C], 0
		jl	short loc_A2A
		cmp	[ebp+Dst], 0
		jnz	short loc_A37
		cmp	[ebp+arg_C], 0
		jle	short loc_A37

loc_A2A:				; CODE XREF: _uidna_toUnicode_56+44j
					; _uidna_toUnicode_56+4Aj ...
		mov	eax, [ebp+arg_18]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	short loc_A9C
; ---------------------------------------------------------------------------

loc_A37:				; CODE XREF: _uidna_toUnicode_56+56j
					; _uidna_toUnicode_56+5Cj
		mov	eax, [ebp+arg_18]
		push	eax
		push	0
		call	_usprep_openByType_56
		add	esp, 8
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_18]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_A62
		or	eax, 0FFFFFFFFh
		jmp	short loc_A9C
; ---------------------------------------------------------------------------

loc_A62:				; CODE XREF: _uidna_toUnicode_56+8Fj
		mov	eax, [ebp+arg_18]
		push	eax		; int
		mov	ecx, [ebp+arg_14]
		push	ecx		; int
		mov	edx, [ebp+var_8]
		push	edx		; int
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+Dst]
		push	edx		; Dst
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; void *
		call	?_internal_toUnicode@@YAHPB_WHPA_WHHPAUUStringPrepProfile@@PAUUParseError@@PAW4UErrorCode@@@Z ;	_internal_toUnicode(wchar_t const *,int,wchar_t	*,int,int,UStringPrepProfile *,UParseError *,UErrorCode	*)
		add	esp, 20h
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_8]
		push	eax
		call	_usprep_close_56
		add	esp, 4
		mov	eax, [ebp+var_14]

loc_A9C:				; CODE XREF: _uidna_toUnicode_56+3Bj
					; _uidna_toUnicode_56+69j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uidna_toUnicode_56 endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0AB0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl _internal_toUnicode(void *, int, void *Dst, int, int, int, int, int)
?_internal_toUnicode@@YAHPB_WHPA_WHHPAUUStringPrepProfile@@PAUUParseError@@PAW4UErrorCode@@@Z proc near
					; CODE XREF: _uidna_toUnicode_56+B6p
					; _uidna_IDNToUnicode_56+10Dp

var_3F4		= byte ptr -3F4h
var_330		= dword	ptr -330h
var_321		= byte ptr -321h
var_318		= dword	ptr -318h
var_30C		= dword	ptr -30Ch
var_300		= dword	ptr -300h
var_2F4		= dword	ptr -2F4h
var_2E8		= dword	ptr -2E8h
var_2DC		= dword	ptr -2DCh
var_2D0		= dword	ptr -2D0h
var_2C4		= dword	ptr -2C4h
var_2B8		= dword	ptr -2B8h
var_2AC		= dword	ptr -2ACh
var_2A0		= dword	ptr -2A0h
Src		= dword	ptr -294h
var_288		= dword	ptr -288h
var_27C		= byte ptr -27Ch
var_1AC		= byte ptr -1ACh
var_DC		= byte ptr -0DCh
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
Dst		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h
arg_1C		= dword	ptr  24h

		push	ebp
		mov	ebp, esp
		sub	esp, 3F4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_3F4]
		mov	ecx, 0FDh ; 'ý'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	eax, [ebp+arg_10]
		and	eax, 1
		neg	eax
		sbb	eax, eax
		neg	eax
		mov	[ebp+var_C], eax
		lea	eax, [ebp+var_DC]
		mov	[ebp+var_288], eax
		lea	eax, [ebp+var_1AC]
		mov	[ebp+Src], eax
		mov	[ebp+var_2A0], 0
		lea	eax, [ebp+var_27C]
		mov	[ebp+var_2AC], eax
		mov	[ebp+var_2B8], 0
		mov	[ebp+var_2E8], 64h ; 'd'
		mov	[ebp+var_2F4], 64h ; 'd'
		mov	[ebp+var_300], 64h ; 'd'
		mov	[ebp+var_30C], 0
		mov	[ebp+var_318], 0
		mov	[ebp+var_321], 1
		cmp	[ebp+arg_4], 0FFFFFFFFh
		jnz	short loc_B96
		mov	[ebp+arg_4], 0

loc_B65:				; CODE XREF: _internal_toUnicode(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile *,UParseError	*,UErrorCode *)+E2j
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+arg_0]
		movzx	edx, word ptr [ecx+eax*2]
		test	edx, edx
		jz	short loc_B94
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+arg_0]
		movzx	edx, word ptr [ecx+eax*2]
		cmp	edx, 7Fh ; ''
		jle	short loc_B89
		mov	[ebp+var_321], 0

loc_B89:				; CODE XREF: _internal_toUnicode(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile *,UParseError	*,UErrorCode *)+D0j
		mov	eax, [ebp+arg_4]
		add	eax, 1
		mov	[ebp+arg_4], eax
		jmp	short loc_B65
; ---------------------------------------------------------------------------

loc_B94:				; CODE XREF: _internal_toUnicode(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile *,UParseError	*,UErrorCode *)+C1j
		jmp	short loc_BE6
; ---------------------------------------------------------------------------

loc_B96:				; CODE XREF: _internal_toUnicode(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile *,UParseError	*,UErrorCode *)+ACj
		cmp	[ebp+arg_4], 0
		jle	short loc_BDF
		mov	[ebp+var_330], 0
		jmp	short loc_BB7
; ---------------------------------------------------------------------------

loc_BA8:				; CODE XREF: _internal_toUnicode(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile *,UParseError	*,UErrorCode *):loc_BDBj
		mov	eax, [ebp+var_330]
		add	eax, 1
		mov	[ebp+var_330], eax

loc_BB7:				; CODE XREF: _internal_toUnicode(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile *,UParseError	*,UErrorCode *)+F6j
		mov	eax, [ebp+var_330]
		cmp	eax, [ebp+arg_4]
		jge	short loc_BDD
		mov	eax, [ebp+var_330]
		mov	ecx, [ebp+arg_0]
		movzx	edx, word ptr [ecx+eax*2]
		cmp	edx, 7Fh ; ''
		jle	short loc_BDB
		mov	[ebp+var_321], 0

loc_BDB:				; CODE XREF: _internal_toUnicode(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile *,UParseError	*,UErrorCode *)+122j
		jmp	short loc_BA8
; ---------------------------------------------------------------------------

loc_BDD:				; CODE XREF: _internal_toUnicode(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile *,UParseError	*,UErrorCode *)+110j
		jmp	short loc_BE6
; ---------------------------------------------------------------------------

loc_BDF:				; CODE XREF: _internal_toUnicode(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile *,UParseError	*,UErrorCode *)+EAj
		xor	eax, eax
		jmp	loc_105D
; ---------------------------------------------------------------------------

loc_BE6:				; CODE XREF: _internal_toUnicode(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile *,UParseError	*,UErrorCode *):loc_B94j
					; _internal_toUnicode(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile *,UParseError *,UErrorCode *):loc_BDDj
		movsx	eax, [ebp+var_321]
		test	eax, eax
		jnz	loc_CC2
		mov	eax, [ebp+arg_1C]
		push	eax
		mov	ecx, [ebp+arg_18]
		push	ecx
		mov	edx, [ebp+var_C]
		push	edx
		mov	eax, [ebp+var_2E8]
		push	eax
		mov	ecx, [ebp+var_288]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+arg_14]
		push	ecx
		call	_usprep_prepare_56
		add	esp, 20h
		mov	[ebp+var_2B8], eax
		mov	eax, [ebp+arg_1C]
		cmp	dword ptr [eax], 0Fh
		jnz	short loc_CA1
		mov	eax, [ebp+var_2B8]
		shl	eax, 1
		push	eax
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+var_288], eax
		cmp	[ebp+var_288], 0
		jnz	short loc_C64
		mov	eax, [ebp+arg_1C]
		mov	dword ptr [eax], 7
		jmp	$CLEANUP$10626
; ---------------------------------------------------------------------------
		jmp	$CLEANUP$10626
; ---------------------------------------------------------------------------

loc_C64:				; CODE XREF: _internal_toUnicode(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile *,UParseError	*,UErrorCode *)+19Fj
		mov	eax, [ebp+arg_1C]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+arg_1C]
		push	eax
		mov	ecx, [ebp+arg_18]
		push	ecx
		mov	edx, [ebp+var_C]
		push	edx
		mov	eax, [ebp+var_2B8]
		push	eax
		mov	ecx, [ebp+var_288]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+arg_14]
		push	ecx
		call	_usprep_prepare_56
		add	esp, 20h
		mov	[ebp+var_2B8], eax

loc_CA1:				; CODE XREF: _internal_toUnicode(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile *,UParseError	*,UErrorCode *)+17Fj
		mov	eax, [ebp+arg_1C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_CC0
		jmp	$CLEANUP$10626
; ---------------------------------------------------------------------------
		jmp	$CLEANUP$10626
; ---------------------------------------------------------------------------

loc_CC0:				; CODE XREF: _internal_toUnicode(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile *,UParseError	*,UErrorCode *)+204j
		jmp	short loc_CD4
; ---------------------------------------------------------------------------

loc_CC2:				; CODE XREF: _internal_toUnicode(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile *,UParseError	*,UErrorCode *)+13Fj
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_288], eax
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_2B8], eax

loc_CD4:				; CODE XREF: _internal_toUnicode(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile *,UParseError	*,UErrorCode *):loc_CC0j
		mov	eax, [ebp+var_2B8]
		push	eax
		mov	ecx, [ebp+var_288]
		push	ecx
		call	?startsWithPrefix@@YACPB_WH@Z ;	startsWithPrefix(wchar_t const *,int)
		add	esp, 8
		movsx	edx, al
		test	edx, edx
		jz	loc_F1B
		mov	eax, [ebp+var_288]
		add	eax, 8
		mov	[ebp+var_2A0], eax
		mov	eax, [ebp+var_2B8]
		sub	eax, 4
		mov	[ebp+var_2D0], eax
		mov	eax, [ebp+arg_1C]
		push	eax
		mov	ecx, [ebp+var_318]
		push	ecx
		mov	edx, [ebp+var_2F4]
		push	edx
		mov	eax, [ebp+Src]
		push	eax
		mov	ecx, [ebp+var_2D0]
		push	ecx
		mov	edx, [ebp+var_2A0]
		push	edx
		call	_u_strFromPunycode_56
		add	esp, 18h
		mov	[ebp+var_2C4], eax
		mov	eax, [ebp+arg_1C]
		cmp	dword ptr [eax], 0Fh
		jnz	short loc_DC1
		mov	eax, [ebp+var_2C4]
		shl	eax, 1
		push	eax
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+Src], eax
		cmp	[ebp+Src], 0
		jnz	short loc_D83
		mov	eax, [ebp+arg_1C]
		mov	dword ptr [eax], 7
		jmp	$CLEANUP$10626
; ---------------------------------------------------------------------------
		jmp	$CLEANUP$10626
; ---------------------------------------------------------------------------

loc_D83:				; CODE XREF: _internal_toUnicode(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile *,UParseError	*,UErrorCode *)+2BEj
		mov	eax, [ebp+arg_1C]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+arg_1C]
		push	eax
		mov	ecx, [ebp+var_318]
		push	ecx
		mov	edx, [ebp+var_2C4]
		push	edx
		mov	eax, [ebp+Src]
		push	eax
		mov	ecx, [ebp+var_2D0]
		push	ecx
		mov	edx, [ebp+var_2A0]
		push	edx
		call	_u_strFromPunycode_56
		add	esp, 18h
		mov	[ebp+var_2C4], eax

loc_DC1:				; CODE XREF: _internal_toUnicode(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile *,UParseError	*,UErrorCode *)+29Ej
		mov	eax, [ebp+arg_1C]
		push	eax		; int
		mov	ecx, [ebp+arg_18]
		push	ecx		; int
		mov	edx, [ebp+arg_10]
		push	edx		; int
		mov	eax, [ebp+var_300]
		push	eax		; int
		mov	ecx, [ebp+var_2AC]
		push	ecx		; Dst
		mov	edx, [ebp+var_2C4]
		push	edx		; int
		mov	eax, [ebp+Src]
		push	eax		; int
		call	_uidna_toASCII_56
		add	esp, 1Ch
		mov	[ebp+var_2DC], eax
		mov	eax, [ebp+arg_1C]
		cmp	dword ptr [eax], 0Fh
		jnz	short loc_E71
		mov	eax, [ebp+var_2DC]
		shl	eax, 1
		push	eax
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+var_2AC], eax
		cmp	[ebp+var_2AC], 0
		jnz	short loc_E32
		mov	eax, [ebp+arg_1C]
		mov	dword ptr [eax], 7
		jmp	$CLEANUP$10626
; ---------------------------------------------------------------------------
		jmp	$CLEANUP$10626
; ---------------------------------------------------------------------------

loc_E32:				; CODE XREF: _internal_toUnicode(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile *,UParseError	*,UErrorCode *)+36Dj
		mov	eax, [ebp+arg_1C]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+arg_1C]
		push	eax		; int
		mov	ecx, [ebp+arg_18]
		push	ecx		; int
		mov	edx, [ebp+arg_10]
		push	edx		; int
		mov	eax, [ebp+var_2DC]
		push	eax		; int
		mov	ecx, [ebp+var_2AC]
		push	ecx		; Dst
		mov	edx, [ebp+var_2C4]
		push	edx		; int
		mov	eax, [ebp+Src]
		push	eax		; int
		call	_uidna_toASCII_56
		add	esp, 1Ch
		mov	[ebp+var_2DC], eax

loc_E71:				; CODE XREF: _internal_toUnicode(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile *,UParseError	*,UErrorCode *)+34Dj
		mov	eax, [ebp+arg_1C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_E90
		jmp	$CLEANUP$10626
; ---------------------------------------------------------------------------
		jmp	$CLEANUP$10626
; ---------------------------------------------------------------------------

loc_E90:				; CODE XREF: _internal_toUnicode(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile *,UParseError	*,UErrorCode *)+3D4j
		mov	eax, [ebp+var_2DC]
		push	eax
		mov	ecx, [ebp+var_2AC]
		push	ecx
		mov	edx, [ebp+var_2B8]
		push	edx
		mov	eax, [ebp+var_288]
		push	eax
		call	?compareCaseInsensitiveASCII@@YAHPB_WH0H@Z ; compareCaseInsensitiveASCII(wchar_t const *,int,wchar_t const *,int)
		add	esp, 10h
		test	eax, eax
		jz	short loc_ECB
		mov	eax, [ebp+arg_1C]
		mov	dword ptr [eax], 10405h
		jmp	$CLEANUP$10626
; ---------------------------------------------------------------------------
		jmp	$CLEANUP$10626
; ---------------------------------------------------------------------------

loc_ECB:				; CODE XREF: _internal_toUnicode(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile *,UParseError	*,UErrorCode *)+406j
		mov	eax, [ebp+var_2C4]
		mov	[ebp+var_30C], eax
		mov	eax, [ebp+var_2C4]
		cmp	eax, [ebp+arg_C]
		jg	short loc_F19
		push	1
		mov	eax, [ebp+Src]
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	ecx, [ebp+var_2C4]
		shl	ecx, 1
		mov	esi, esp
		push	ecx		; Size
		mov	edx, [ebp+Src]
		push	edx		; Src
		mov	eax, [ebp+Dst]
		push	eax		; Dst
		call	dword ptr ds:__imp__memmove
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_F19:				; CODE XREF: _internal_toUnicode(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile *,UParseError	*,UErrorCode *)+430j
		jmp	short $CLEANUP$10626
; ---------------------------------------------------------------------------

loc_F1B:				; CODE XREF: _internal_toUnicode(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile *,UParseError	*,UErrorCode *)+23Fj
		mov	eax, [ebp+arg_4]
		cmp	eax, [ebp+arg_C]
		jg	short loc_F51
		push	1
		mov	eax, [ebp+arg_0]
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	ecx, [ebp+arg_4]
		shl	ecx, 1
		mov	esi, esp
		push	ecx		; Size
		mov	edx, [ebp+arg_0]
		push	edx		; Src
		mov	eax, [ebp+Dst]
		push	eax		; Dst
		call	dword ptr ds:__imp__memmove
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_F51:				; CODE XREF: _internal_toUnicode(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile *,UParseError	*,UErrorCode *)+471j
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_30C], eax

$CLEANUP$10626:				; CODE XREF: _internal_toUnicode(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile *,UParseError	*,UErrorCode *)+1AAj
					; _internal_toUnicode(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile *,UParseError *,UErrorCode *)+1AFj ...
		mov	eax, [ebp+var_288]
		lea	ecx, [ebp+var_DC]
		cmp	eax, ecx
		jz	short loc_F84
		mov	eax, [ebp+var_288]
		cmp	eax, [ebp+arg_0]
		jz	short loc_F84
		mov	eax, [ebp+var_288]
		push	eax
		call	_uprv_free_56
		add	esp, 4

loc_F84:				; CODE XREF: _internal_toUnicode(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile *,UParseError	*,UErrorCode *)+4B8j
					; _internal_toUnicode(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile *,UParseError *,UErrorCode *)+4C3j
		mov	eax, [ebp+Src]
		lea	ecx, [ebp+var_1AC]
		cmp	eax, ecx
		jz	short loc_FA3
		mov	eax, [ebp+Src]
		push	eax
		call	_uprv_free_56
		add	esp, 4

loc_FA3:				; CODE XREF: _internal_toUnicode(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile *,UParseError	*,UErrorCode *)+4E2j
		mov	eax, [ebp+var_318]
		push	eax
		call	_uprv_free_56
		add	esp, 4
		mov	eax, [ebp+arg_1C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_1042
		cmp	[ebp+Dst], 0
		jz	short loc_1030
		mov	eax, [ebp+arg_4]
		cmp	eax, [ebp+arg_C]
		jg	short loc_1030
		cmp	[ebp+arg_4], 0
		jge	short loc_1002
		mov	eax, ds:?__LINE__Var@?1??_internal_toUnicode@@YAHPB_WHPA_WHHPAUUStringPrepProfile@@PAUUParseError@@PAW4UErrorCode@@@Z@4JA@b121f502
		add	eax, 0C7h ; 'Ç'
		mov	esi, esp
		push	eax		; Line
		push	offset ??_C@_1FI@EHNKFCBG@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@ ; "d:\\mozilla\\intl\\icu\\source\\common\"...
		push	offset ??_C@_1BO@FPACHIGK@?$AAs?$AAr?$AAc?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; "srcLength >= 0"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_1002:				; CODE XREF: _internal_toUnicode(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile *,UParseError	*,UErrorCode *)+529j
		push	1
		mov	eax, [ebp+arg_0]
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	ecx, [ebp+arg_4]
		shl	ecx, 1
		mov	esi, esp
		push	ecx		; Size
		mov	edx, [ebp+arg_0]
		push	edx		; Src
		mov	eax, [ebp+Dst]
		push	eax		; Dst
		call	dword ptr ds:__imp__memmove
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_1030:				; CODE XREF: _internal_toUnicode(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile *,UParseError	*,UErrorCode *)+51Bj
					; _internal_toUnicode(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile *,UParseError *,UErrorCode *)+523j
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_30C], eax
		mov	eax, [ebp+arg_1C]
		mov	dword ptr [eax], 0

loc_1042:				; CODE XREF: _internal_toUnicode(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile *,UParseError	*,UErrorCode *)+515j
		mov	eax, [ebp+arg_1C]
		push	eax
		mov	ecx, [ebp+var_30C]
		push	ecx
		mov	edx, [ebp+arg_C]
		push	edx
		mov	eax, [ebp+Dst]
		push	eax
		call	_u_terminateUChars_56
		add	esp, 10h

loc_105D:				; CODE XREF: _internal_toUnicode(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile *,UParseError	*,UErrorCode *)+131j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN44
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 3F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?_internal_toUnicode@@YAHPB_WHPA_WHHPAUUStringPrepProfile@@PAUUParseError@@PAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
$LN44		dd 3			; DATA XREF: _internal_toUnicode(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile *,UParseError	*,UErrorCode *)+5B1o
		dd offset $LN43
$LN43		dd 0FFFFFF24h, 0C8h	; DATA XREF: .text:00001090o
		dd offset $LN40		; "b1Stack"
		dd 0FFFFFE54h, 0C8h
		dd offset $LN41		; "b2Stack"
		dd 0FFFFFD84h, 0C8h
		dd offset $LN42		; "b3Stack"
$LN42		db 'b3Stack',0          ; DATA XREF: .text:000010B4o
$LN41		db 'b2Stack',0          ; DATA XREF: .text:000010A8o
$LN40		db 'b1Stack',0          ; DATA XREF: .text:0000109Co
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 10D0h
		public ??_C@_1BO@FPACHIGK@?$AAs?$AAr?$AAc?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
; wchar_t `string'
??_C@_1BO@FPACHIGK@?$AAs?$AAr?$AAc?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@:
					; DATA XREF: _internal_toUnicode(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile *,UParseError	*,UErrorCode *)+53Do
		unicode	0, <srcLength >
		dw 3Eh
		unicode	0, <= 0>,0
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 10F0h
		public ??_C@_1FI@EHNKFCBG@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@
; wchar_t `string'
??_C@_1FI@EHNKFCBG@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@:
					; DATA XREF: _internal_toUnicode(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile *,UParseError	*,UErrorCode *)+538o
		unicode	0, <d:\mozilla\intl\icu\source\common\uidna.cpp>,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 1148h
		public ?__LINE__Var@?1??_internal_toUnicode@@YAHPB_WHPA_WHHPAUUStringPrepProfile@@PAUUParseError@@PAW4UErrorCode@@@Z@4JA@b121f502
?__LINE__Var@?1??_internal_toUnicode@@YAHPB_WHPA_WHHPAUUStringPrepProfile@@PAUUParseError@@PAW4UErrorCode@@@Z@4JA@b121f502 dd 190h
					; DATA XREF: _internal_toUnicode(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile *,UParseError	*,UErrorCode *)+52Br
_data		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 114Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl compareCaseInsensitiveASCII(wchar_t const	*, int,	wchar_t	const *, int)
?compareCaseInsensitiveASCII@@YAHPB_WH0H@Z proc	near
					; CODE XREF: _internal_toUnicode(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile *,UParseError	*,UErrorCode *)+3FCp
					; _uidna_compare_56+1EBp

var_108		= byte ptr -108h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= word ptr -2Ch
var_20		= word ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 108h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_108]
		mov	ecx, 42h ; 'B'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		cmp	eax, [ebp+arg_C]
		jz	short loc_1198
		mov	eax, [ebp+arg_4]
		cmp	eax, [ebp+arg_C]
		jge	short loc_1189
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_8], eax
		mov	[ebp+var_14], 0FFFFFFFFh
		jmp	short loc_1196
; ---------------------------------------------------------------------------

loc_1189:				; CODE XREF: compareCaseInsensitiveASCII(wchar_t const *,int,wchar_t const *,int)+2Cj
		mov	eax, [ebp+arg_C]
		mov	[ebp+var_8], eax
		mov	[ebp+var_14], 1

loc_1196:				; CODE XREF: compareCaseInsensitiveASCII(wchar_t const *,int,wchar_t const *,int)+3Bj
		jmp	short loc_11A5
; ---------------------------------------------------------------------------

loc_1198:				; CODE XREF: compareCaseInsensitiveASCII(wchar_t const *,int,wchar_t const *,int)+24j
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_8], eax
		mov	[ebp+var_14], 0

loc_11A5:				; CODE XREF: compareCaseInsensitiveASCII(wchar_t const *,int,wchar_t const *,int):loc_1196j
		mov	[ebp+var_44], 0
		jmp	short loc_11B7
; ---------------------------------------------------------------------------

loc_11AE:				; CODE XREF: compareCaseInsensitiveASCII(wchar_t const *,int,wchar_t const *,int):loc_121Bj
		mov	eax, [ebp+var_44]
		add	eax, 1
		mov	[ebp+var_44], eax

loc_11B7:				; CODE XREF: compareCaseInsensitiveASCII(wchar_t const *,int,wchar_t const *,int)+60j
		mov	eax, [ebp+var_44]
		cmp	eax, [ebp+var_8]
		jnz	short loc_11C4
		mov	eax, [ebp+var_14]
		jmp	short loc_1220
; ---------------------------------------------------------------------------

loc_11C4:				; CODE XREF: compareCaseInsensitiveASCII(wchar_t const *,int,wchar_t const *,int)+71j
		mov	eax, [ebp+var_44]
		mov	ecx, [ebp+arg_0]
		mov	dx, [ecx+eax*2]
		mov	[ebp+var_20], dx
		mov	eax, [ebp+var_44]
		mov	ecx, [ebp+arg_8]
		mov	dx, [ecx+eax*2]
		mov	[ebp+var_2C], dx
		movzx	eax, [ebp+var_20]
		movzx	ecx, [ebp+var_2C]
		cmp	eax, ecx
		jz	short loc_121B
		movzx	eax, [ebp+var_20]
		push	eax
		call	?toASCIILower@@YA_W_W@Z	; toASCIILower(wchar_t)
		add	esp, 4
		movzx	esi, ax
		movzx	ecx, [ebp+var_2C]
		push	ecx
		call	?toASCIILower@@YA_W_W@Z	; toASCIILower(wchar_t)
		add	esp, 4
		movzx	edx, ax
		sub	esi, edx
		mov	[ebp+var_38], esi
		jz	short loc_121B
		mov	eax, [ebp+var_38]
		mov	[ebp+var_14], eax
		jmp	short loc_121D
; ---------------------------------------------------------------------------

loc_121B:				; CODE XREF: compareCaseInsensitiveASCII(wchar_t const *,int,wchar_t const *,int)+9Ej
					; compareCaseInsensitiveASCII(wchar_t const *,int,wchar_t const	*,int)+C5j
		jmp	short loc_11AE
; ---------------------------------------------------------------------------

loc_121D:				; CODE XREF: compareCaseInsensitiveASCII(wchar_t const *,int,wchar_t const *,int)+CDj
		mov	eax, [ebp+var_14]

loc_1220:				; CODE XREF: compareCaseInsensitiveASCII(wchar_t const *,int,wchar_t const *,int)+76j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 108h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?compareCaseInsensitiveASCII@@YAHPB_WH0H@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1234h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uidna_IDNToASCII_56
_uidna_IDNToASCII_56 proc near		; CODE XREF: _uidna_compare_56+A6p
					; _uidna_compare_56+11Dp ...

var_138		= byte ptr -138h
var_71		= byte ptr -71h
var_68		= dword	ptr -68h
var_5C		= dword	ptr -5Ch
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
Dst		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h

		push	ebp
		mov	ebp, esp
		sub	esp, 138h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_138]
		mov	ecx, 4Eh ; 'N'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_18], 0
		jz	short loc_126D
		mov	eax, [ebp+arg_18]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_1274

loc_126D:				; CODE XREF: _uidna_IDNToASCII_56+22j
		xor	eax, eax
		jmp	loc_1450
; ---------------------------------------------------------------------------

loc_1274:				; CODE XREF: _uidna_IDNToASCII_56+37j
		cmp	[ebp+arg_0], 0
		jz	short loc_1292
		cmp	[ebp+arg_4], 0FFFFFFFFh
		jl	short loc_1292
		cmp	[ebp+arg_C], 0
		jl	short loc_1292
		cmp	[ebp+arg_8], 0
		jnz	short loc_12A2
		cmp	[ebp+arg_C], 0
		jle	short loc_12A2

loc_1292:				; CODE XREF: _uidna_IDNToASCII_56+44j
					; _uidna_IDNToASCII_56+4Aj ...
		mov	eax, [ebp+arg_18]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	loc_1450
; ---------------------------------------------------------------------------

loc_12A2:				; CODE XREF: _uidna_IDNToASCII_56+56j
					; _uidna_IDNToASCII_56+5Cj
		mov	[ebp+var_8], 0
		mov	eax, [ebp+arg_18]
		push	eax
		push	0
		call	_usprep_openByType_56
		add	esp, 8
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_18]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_12D6
		xor	eax, eax
		jmp	loc_1450
; ---------------------------------------------------------------------------

loc_12D6:				; CODE XREF: _uidna_IDNToASCII_56+99j
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_20], eax
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_2C], eax
		mov	eax, [ebp+arg_8]
		mov	[ebp+Dst], eax
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_44], eax
		mov	eax, [ebp+arg_C]
		mov	[ebp+var_50], eax
		mov	[ebp+var_5C], 0
		mov	[ebp+var_68], 0
		mov	[ebp+var_71], 0

loc_1306:				; CODE XREF: _uidna_IDNToASCII_56:loc_1415j
		lea	eax, [ebp+var_71]
		push	eax
		lea	ecx, [ebp+var_20]
		push	ecx
		mov	edx, [ebp+var_44]
		push	edx
		mov	eax, [ebp+var_2C]
		push	eax
		call	?getNextSeparator@@YAHPA_WHPAPA_WPAC@Z ; getNextSeparator(wchar_t *,int,wchar_t	* *,signed char	*)
		add	esp, 10h
		mov	[ebp+var_5C], eax
		mov	[ebp+var_68], 0
		cmp	[ebp+var_5C], 0
		jnz	short loc_1336
		movsx	eax, [ebp+var_71]
		test	eax, eax
		jnz	short loc_1379

loc_1336:				; CODE XREF: _uidna_IDNToASCII_56+F8j
		mov	eax, [ebp+arg_18]
		push	eax		; int
		mov	ecx, [ebp+arg_14]
		push	ecx		; int
		mov	edx, [ebp+var_14]
		push	edx		; int
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+var_50]
		push	ecx		; int
		mov	edx, [ebp+Dst]
		push	edx		; Dst
		mov	eax, [ebp+var_5C]
		push	eax		; int
		mov	ecx, [ebp+var_2C]
		push	ecx		; int
		call	?_internal_toASCII@@YAHPB_WHPA_WHHPAUUStringPrepProfile@@PAUUParseError@@PAW4UErrorCode@@@Z ; _internal_toASCII(wchar_t	const *,int,wchar_t *,int,int,UStringPrepProfile *,UParseError *,UErrorCode *)
		add	esp, 20h
		mov	[ebp+var_68], eax
		mov	eax, [ebp+arg_18]
		cmp	dword ptr [eax], 0Fh
		jnz	short loc_1379
		mov	eax, [ebp+arg_18]
		mov	dword ptr [eax], 0
		mov	[ebp+var_50], 0

loc_1379:				; CODE XREF: _uidna_IDNToASCII_56+100j
					; _uidna_IDNToASCII_56+133j
		mov	eax, [ebp+arg_18]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_1393
		jmp	loc_141A
; ---------------------------------------------------------------------------

loc_1393:				; CODE XREF: _uidna_IDNToASCII_56+158j
		mov	eax, [ebp+var_8]
		add	eax, [ebp+var_68]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+var_68]
		cmp	eax, [ebp+var_50]
		jge	short loc_13BB
		mov	eax, [ebp+var_68]
		mov	ecx, [ebp+Dst]
		lea	edx, [ecx+eax*2]
		mov	[ebp+Dst], edx
		mov	eax, [ebp+var_50]
		sub	eax, [ebp+var_68]
		mov	[ebp+var_50], eax
		jmp	short loc_13C2
; ---------------------------------------------------------------------------

loc_13BB:				; CODE XREF: _uidna_IDNToASCII_56+16Ej
		mov	[ebp+var_50], 0

loc_13C2:				; CODE XREF: _uidna_IDNToASCII_56+185j
		movsx	eax, [ebp+var_71]
		cmp	eax, 1
		jnz	short loc_13CD
		jmp	short loc_141A
; ---------------------------------------------------------------------------

loc_13CD:				; CODE XREF: _uidna_IDNToASCII_56+195j
		cmp	[ebp+var_50], 0
		jle	short loc_13F0
		mov	eax, 2Eh ; '.'
		mov	ecx, [ebp+Dst]
		mov	[ecx], ax
		mov	edx, [ebp+Dst]
		add	edx, 2
		mov	[ebp+Dst], edx
		mov	eax, [ebp+var_50]
		sub	eax, 1
		mov	[ebp+var_50], eax

loc_13F0:				; CODE XREF: _uidna_IDNToASCII_56+19Dj
		mov	eax, [ebp+var_8]
		add	eax, 1
		mov	[ebp+var_8], eax
		mov	eax, [ebp+var_20]
		mov	[ebp+var_2C], eax
		cmp	[ebp+var_44], 0
		jle	short loc_1415
		mov	eax, [ebp+var_20]
		sub	eax, [ebp+arg_0]
		sar	eax, 1
		mov	ecx, [ebp+arg_4]
		sub	ecx, eax
		mov	[ebp+var_44], ecx

loc_1415:				; CODE XREF: _uidna_IDNToASCII_56+1CFj
		jmp	loc_1306
; ---------------------------------------------------------------------------

loc_141A:				; CODE XREF: _uidna_IDNToASCII_56+15Aj
					; _uidna_IDNToASCII_56+197j
		cmp	[ebp+var_8], 0FFh
		jle	short loc_142C
		mov	eax, [ebp+arg_18]
		mov	dword ptr [eax], 10408h

loc_142C:				; CODE XREF: _uidna_IDNToASCII_56+1EDj
		mov	eax, [ebp+var_14]
		push	eax
		call	_usprep_close_56
		add	esp, 4
		mov	eax, [ebp+arg_18]
		push	eax
		mov	ecx, [ebp+var_8]
		push	ecx
		mov	edx, [ebp+arg_C]
		push	edx
		mov	eax, [ebp+arg_8]
		push	eax
		call	_u_terminateUChars_56
		add	esp, 10h

loc_1450:				; CODE XREF: _uidna_IDNToASCII_56+3Bj
					; _uidna_IDNToASCII_56+69j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN23
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 138h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uidna_IDNToASCII_56 endp

; ---------------------------------------------------------------------------
		align 4
$LN23		dd 2			; DATA XREF: _uidna_IDNToASCII_56+220o
		dd offset $LN22
$LN22		dd 0FFFFFFE0h, 4	; DATA XREF: .text:0000147Co
		dd offset $LN20		; "delimiter"
		dd 0FFFFFF8Fh, 1
		dd offset $LN21		; "done"
$LN21		db 'done',0             ; DATA XREF: .text:00001494o
$LN20		db 'delimiter',0        ; DATA XREF: .text:00001488o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 14A8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl getNextSeparator(wchar_t *, int, wchar_t * *, signed char	*)
?getNextSeparator@@YAHPA_WHPAPA_WPAC@Z proc near ; CODE	XREF: _uidna_IDNToASCII_56+E2p
					; _uidna_IDNToUnicode_56+E2p

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_4], 0FFFFFFFFh
		jnz	short loc_153A
		mov	[ebp+var_8], 0
		jmp	short loc_14DE
; ---------------------------------------------------------------------------

loc_14D5:				; CODE XREF: getNextSeparator(wchar_t *,int,wchar_t * *,signed char *):loc_1536j
		mov	eax, [ebp+var_8]
		add	eax, 1
		mov	[ebp+var_8], eax

loc_14DE:				; CODE XREF: getNextSeparator(wchar_t *,int,wchar_t * *,signed char *)+2Bj
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		movzx	edx, word ptr [ecx+eax*2]
		test	edx, edx
		jnz	short loc_1508
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		lea	edx, [ecx+eax*2]
		mov	eax, [ebp+arg_8]
		mov	[eax], edx
		mov	eax, [ebp+arg_C]
		mov	byte ptr [eax],	1
		mov	eax, [ebp+var_8]
		jmp	loc_159B
; ---------------------------------------------------------------------------

loc_1508:				; CODE XREF: getNextSeparator(wchar_t *,int,wchar_t * *,signed char *)+42j
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		movzx	edx, word ptr [ecx+eax*2]
		push	edx
		call	?isLabelSeparator@@YAC_W@Z ; isLabelSeparator(wchar_t)
		add	esp, 4
		movsx	eax, al
		test	eax, eax
		jz	short loc_1536
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		lea	edx, [ecx+eax*2+2]
		mov	eax, [ebp+arg_8]
		mov	[eax], edx
		mov	eax, [ebp+var_8]
		jmp	short loc_159B
; ---------------------------------------------------------------------------

loc_1536:				; CODE XREF: getNextSeparator(wchar_t *,int,wchar_t * *,signed char *)+78j
		jmp	short loc_14D5
; ---------------------------------------------------------------------------
		jmp	short loc_159B
; ---------------------------------------------------------------------------

loc_153A:				; CODE XREF: getNextSeparator(wchar_t *,int,wchar_t * *,signed char *)+22j
		mov	[ebp+var_14], 0
		jmp	short loc_154C
; ---------------------------------------------------------------------------

loc_1543:				; CODE XREF: getNextSeparator(wchar_t *,int,wchar_t * *,signed char *):loc_1582j
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_154C:				; CODE XREF: getNextSeparator(wchar_t *,int,wchar_t * *,signed char *)+99j
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+arg_4]
		jge	short loc_1584
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		movzx	edx, word ptr [ecx+eax*2]
		push	edx
		call	?isLabelSeparator@@YAC_W@Z ; isLabelSeparator(wchar_t)
		add	esp, 4
		movsx	eax, al
		test	eax, eax
		jz	short loc_1582
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		lea	edx, [ecx+eax*2+2]
		mov	eax, [ebp+arg_8]
		mov	[eax], edx
		mov	eax, [ebp+var_14]
		jmp	short loc_159B
; ---------------------------------------------------------------------------

loc_1582:				; CODE XREF: getNextSeparator(wchar_t *,int,wchar_t * *,signed char *)+C4j
		jmp	short loc_1543
; ---------------------------------------------------------------------------

loc_1584:				; CODE XREF: getNextSeparator(wchar_t *,int,wchar_t * *,signed char *)+AAj
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+arg_0]
		lea	edx, [ecx+eax*2]
		mov	eax, [ebp+arg_8]
		mov	[eax], edx
		mov	eax, [ebp+arg_C]
		mov	byte ptr [eax],	1
		mov	eax, [ebp+var_14]

loc_159B:				; CODE XREF: getNextSeparator(wchar_t *,int,wchar_t * *,signed char *)+5Bj
					; getNextSeparator(wchar_t *,int,wchar_t * *,signed char *)+8Cj ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getNextSeparator@@YAHPA_WHPAPA_WPAC@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 15B0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl isLabelSeparator(wchar_t)
?isLabelSeparator@@YAC_W@Z proc	near	; CODE XREF: getNextSeparator(wchar_t *,int,wchar_t * *,signed char *)+6Bp
					; getNextSeparator(wchar_t *,int,wchar_t * *,signed char *)+B7p

var_C4		= dword	ptr -0C4h
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C4]
		mov	ecx, 31h ; '1'
		mov	eax, 0CCCCCCCCh
		rep stosd
		movzx	eax, [ebp+arg_0]
		mov	[ebp+var_C4], eax
		cmp	[ebp+var_C4], 0FF0Eh
		jg	short loc_1607
		cmp	[ebp+var_C4], 0FF0Eh
		jz	short loc_1615
		cmp	[ebp+var_C4], 2Eh ; '.'
		jz	short loc_1615
		cmp	[ebp+var_C4], 3002h
		jz	short loc_1615
		jmp	short loc_1619
; ---------------------------------------------------------------------------

loc_1607:				; CODE XREF: isLabelSeparator(wchar_t)+32j
		cmp	[ebp+var_C4], 0FF61h
		jz	short loc_1615
		jmp	short loc_1619
; ---------------------------------------------------------------------------

loc_1615:				; CODE XREF: isLabelSeparator(wchar_t)+3Ej
					; isLabelSeparator(wchar_t)+47j ...
		mov	al, 1
		jmp	short loc_161B
; ---------------------------------------------------------------------------

loc_1619:				; CODE XREF: isLabelSeparator(wchar_t)+55j
					; isLabelSeparator(wchar_t)+63j
		xor	al, al

loc_161B:				; CODE XREF: isLabelSeparator(wchar_t)+67j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isLabelSeparator@@YAC_W@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1624h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uidna_IDNToUnicode_56
_uidna_IDNToUnicode_56 proc near

var_138		= byte ptr -138h
var_71		= byte ptr -71h
var_68		= dword	ptr -68h
var_5C		= dword	ptr -5Ch
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
Dst		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h

		push	ebp
		mov	ebp, esp
		sub	esp, 138h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_138]
		mov	ecx, 4Eh ; 'N'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_18], 0
		jz	short loc_165D
		mov	eax, [ebp+arg_18]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_1664

loc_165D:				; CODE XREF: _uidna_IDNToUnicode_56+22j
		xor	eax, eax
		jmp	loc_1830
; ---------------------------------------------------------------------------

loc_1664:				; CODE XREF: _uidna_IDNToUnicode_56+37j
		cmp	[ebp+arg_0], 0
		jz	short loc_1682
		cmp	[ebp+arg_4], 0FFFFFFFFh
		jl	short loc_1682
		cmp	[ebp+arg_C], 0
		jl	short loc_1682
		cmp	[ebp+arg_8], 0
		jnz	short loc_1692
		cmp	[ebp+arg_C], 0
		jle	short loc_1692

loc_1682:				; CODE XREF: _uidna_IDNToUnicode_56+44j
					; _uidna_IDNToUnicode_56+4Aj ...
		mov	eax, [ebp+arg_18]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	loc_1830
; ---------------------------------------------------------------------------

loc_1692:				; CODE XREF: _uidna_IDNToUnicode_56+56j
					; _uidna_IDNToUnicode_56+5Cj
		mov	[ebp+var_8], 0
		mov	eax, [ebp+arg_18]
		push	eax
		push	0
		call	_usprep_openByType_56
		add	esp, 8
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_18]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_16C6
		xor	eax, eax
		jmp	loc_1830
; ---------------------------------------------------------------------------

loc_16C6:				; CODE XREF: _uidna_IDNToUnicode_56+99j
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_20], eax
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_2C], eax
		mov	eax, [ebp+arg_8]
		mov	[ebp+Dst], eax
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_44], eax
		mov	eax, [ebp+arg_C]
		mov	[ebp+var_50], eax
		mov	[ebp+var_5C], 0
		mov	[ebp+var_68], 0
		mov	[ebp+var_71], 0

loc_16F6:				; CODE XREF: _uidna_IDNToUnicode_56:loc_17F5j
		lea	eax, [ebp+var_71]
		push	eax
		lea	ecx, [ebp+var_20]
		push	ecx
		mov	edx, [ebp+var_44]
		push	edx
		mov	eax, [ebp+var_2C]
		push	eax
		call	?getNextSeparator@@YAHPA_WHPAPA_WPAC@Z ; getNextSeparator(wchar_t *,int,wchar_t	* *,signed char	*)
		add	esp, 10h
		mov	[ebp+var_5C], eax
		mov	eax, [ebp+arg_18]
		push	eax		; int
		mov	ecx, [ebp+arg_14]
		push	ecx		; int
		mov	edx, [ebp+var_14]
		push	edx		; int
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+var_50]
		push	ecx		; int
		mov	edx, [ebp+Dst]
		push	edx		; Dst
		mov	eax, [ebp+var_5C]
		push	eax		; int
		mov	ecx, [ebp+var_2C]
		push	ecx		; void *
		call	?_internal_toUnicode@@YAHPB_WHPA_WHHPAUUStringPrepProfile@@PAUUParseError@@PAW4UErrorCode@@@Z ;	_internal_toUnicode(wchar_t const *,int,wchar_t	*,int,int,UStringPrepProfile *,UParseError *,UErrorCode	*)
		add	esp, 20h
		mov	[ebp+var_68], eax
		mov	eax, [ebp+arg_18]
		cmp	dword ptr [eax], 0Fh
		jnz	short loc_1754
		mov	eax, [ebp+arg_18]
		mov	dword ptr [eax], 0
		mov	[ebp+var_50], 0

loc_1754:				; CODE XREF: _uidna_IDNToUnicode_56+11Ej
		mov	eax, [ebp+arg_18]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_176E
		jmp	loc_17FA
; ---------------------------------------------------------------------------

loc_176E:				; CODE XREF: _uidna_IDNToUnicode_56+143j
		mov	eax, [ebp+var_8]
		add	eax, [ebp+var_68]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+var_68]
		cmp	eax, [ebp+var_50]
		jge	short loc_1796
		mov	eax, [ebp+var_68]
		mov	ecx, [ebp+Dst]
		lea	edx, [ecx+eax*2]
		mov	[ebp+Dst], edx
		mov	eax, [ebp+var_50]
		sub	eax, [ebp+var_68]
		mov	[ebp+var_50], eax
		jmp	short loc_179D
; ---------------------------------------------------------------------------

loc_1796:				; CODE XREF: _uidna_IDNToUnicode_56+159j
		mov	[ebp+var_50], 0

loc_179D:				; CODE XREF: _uidna_IDNToUnicode_56+170j
		movsx	eax, [ebp+var_71]
		cmp	eax, 1
		jnz	short loc_17A8
		jmp	short loc_17FA
; ---------------------------------------------------------------------------

loc_17A8:				; CODE XREF: _uidna_IDNToUnicode_56+180j
		cmp	[ebp+var_50], 0
		jle	short loc_17D0
		mov	eax, [ebp+Dst]
		mov	ecx, [ebp+var_5C]
		mov	edx, [ebp+var_2C]
		mov	cx, [edx+ecx*2]
		mov	[eax], cx
		mov	edx, [ebp+Dst]
		add	edx, 2
		mov	[ebp+Dst], edx
		mov	eax, [ebp+var_50]
		sub	eax, 1
		mov	[ebp+var_50], eax

loc_17D0:				; CODE XREF: _uidna_IDNToUnicode_56+188j
		mov	eax, [ebp+var_8]
		add	eax, 1
		mov	[ebp+var_8], eax
		mov	eax, [ebp+var_20]
		mov	[ebp+var_2C], eax
		cmp	[ebp+var_44], 0
		jle	short loc_17F5
		mov	eax, [ebp+var_20]
		sub	eax, [ebp+arg_0]
		sar	eax, 1
		mov	ecx, [ebp+arg_4]
		sub	ecx, eax
		mov	[ebp+var_44], ecx

loc_17F5:				; CODE XREF: _uidna_IDNToUnicode_56+1BFj
		jmp	loc_16F6
; ---------------------------------------------------------------------------

loc_17FA:				; CODE XREF: _uidna_IDNToUnicode_56+145j
					; _uidna_IDNToUnicode_56+182j
		cmp	[ebp+var_8], 0FFh
		jle	short loc_180C
		mov	eax, [ebp+arg_18]
		mov	dword ptr [eax], 10408h

loc_180C:				; CODE XREF: _uidna_IDNToUnicode_56+1DDj
		mov	eax, [ebp+var_14]
		push	eax
		call	_usprep_close_56
		add	esp, 4
		mov	eax, [ebp+arg_18]
		push	eax
		mov	ecx, [ebp+var_8]
		push	ecx
		mov	edx, [ebp+arg_C]
		push	edx
		mov	eax, [ebp+arg_8]
		push	eax
		call	_u_terminateUChars_56
		add	esp, 10h

loc_1830:				; CODE XREF: _uidna_IDNToUnicode_56+3Bj
					; _uidna_IDNToUnicode_56+69j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN21_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 138h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uidna_IDNToUnicode_56 endp

; ---------------------------------------------------------------------------
		align 4
$LN21_0		dd 2			; DATA XREF: _uidna_IDNToUnicode_56+210o
		dd offset $LN20_0
$LN20_0		dd 0FFFFFFE0h, 4	; DATA XREF: .text:0000185Co
		dd offset $LN18		; "delimiter"
		dd 0FFFFFF8Fh, 1
		dd offset $LN19		; "done"
$LN19		db 'done',0             ; DATA XREF: .text:00001874o
$LN18		db 'delimiter',0        ; DATA XREF: .text:00001868o
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1888h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uidna_compare_56
_uidna_compare_56 proc near

var_578		= byte ptr -578h
var_4B4		= byte ptr -4B4h
var_464		= dword	ptr -464h
var_458		= dword	ptr -458h
var_44C		= dword	ptr -44Ch
var_440		= dword	ptr -440h
var_434		= dword	ptr -434h
var_428		= dword	ptr -428h
var_41C		= dword	ptr -41Ch
var_410		= byte ptr -410h
var_208		= byte ptr -208h
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 578h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_578]
		mov	ecx, 15Eh
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		cmp	[ebp+arg_14], 0
		jz	short loc_18CB
		mov	eax, [ebp+arg_14]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_18D3

loc_18CB:				; CODE XREF: _uidna_compare_56+2Cj
		or	eax, 0FFFFFFFFh
		jmp	loc_1AC5
; ---------------------------------------------------------------------------

loc_18D3:				; CODE XREF: _uidna_compare_56+41j
		lea	eax, [ebp+var_208]
		mov	[ebp+var_41C], eax
		lea	eax, [ebp+var_410]
		mov	[ebp+var_428], eax
		mov	[ebp+var_44C], 100h
		mov	[ebp+var_458], 100h
		mov	[ebp+var_464], 0FFFFFFFFh
		mov	eax, [ebp+arg_14]
		push	eax
		lea	ecx, [ebp+var_4B4]
		push	ecx
		mov	edx, [ebp+arg_10]
		push	edx
		mov	eax, [ebp+var_44C]
		push	eax
		mov	ecx, [ebp+var_41C]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		call	_uidna_IDNToASCII_56
		add	esp, 1Ch
		mov	[ebp+var_434], eax
		mov	eax, [ebp+arg_14]
		cmp	dword ptr [eax], 0Fh
		jnz	short loc_19B3
		mov	eax, [ebp+var_434]
		shl	eax, 1
		push	eax
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+var_41C], eax
		cmp	[ebp+var_41C], 0
		jnz	short loc_1977
		mov	eax, [ebp+arg_14]
		mov	dword ptr [eax], 7
		jmp	$CLEANUP$10791
; ---------------------------------------------------------------------------
		jmp	$CLEANUP$10791
; ---------------------------------------------------------------------------

loc_1977:				; CODE XREF: _uidna_compare_56+DAj
		mov	eax, [ebp+arg_14]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+arg_14]
		push	eax
		lea	ecx, [ebp+var_4B4]
		push	ecx
		mov	edx, [ebp+arg_10]
		push	edx
		mov	eax, [ebp+var_434]
		push	eax
		mov	ecx, [ebp+var_41C]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		call	_uidna_IDNToASCII_56
		add	esp, 1Ch
		mov	[ebp+var_434], eax

loc_19B3:				; CODE XREF: _uidna_compare_56+BAj
		mov	eax, [ebp+arg_14]
		push	eax
		lea	ecx, [ebp+var_4B4]
		push	ecx
		mov	edx, [ebp+arg_10]
		push	edx
		mov	eax, [ebp+var_458]
		push	eax
		mov	ecx, [ebp+var_428]
		push	ecx
		mov	edx, [ebp+arg_C]
		push	edx
		mov	eax, [ebp+arg_8]
		push	eax
		call	_uidna_IDNToASCII_56
		add	esp, 1Ch
		mov	[ebp+var_440], eax
		mov	eax, [ebp+arg_14]
		cmp	dword ptr [eax], 0Fh
		jnz	short loc_1A57
		mov	eax, [ebp+var_440]
		shl	eax, 1
		push	eax
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+var_428], eax
		cmp	[ebp+var_428], 0
		jnz	short loc_1A1B
		mov	eax, [ebp+arg_14]
		mov	dword ptr [eax], 7
		jmp	short $CLEANUP$10791
; ---------------------------------------------------------------------------
		jmp	short $CLEANUP$10791
; ---------------------------------------------------------------------------

loc_1A1B:				; CODE XREF: _uidna_compare_56+184j
		mov	eax, [ebp+arg_14]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+arg_14]
		push	eax
		lea	ecx, [ebp+var_4B4]
		push	ecx
		mov	edx, [ebp+arg_10]
		push	edx
		mov	eax, [ebp+var_440]
		push	eax
		mov	ecx, [ebp+var_428]
		push	ecx
		mov	edx, [ebp+arg_C]
		push	edx
		mov	eax, [ebp+arg_8]
		push	eax
		call	_uidna_IDNToASCII_56
		add	esp, 1Ch
		mov	[ebp+var_440], eax

loc_1A57:				; CODE XREF: _uidna_compare_56+164j
		mov	eax, [ebp+var_440]
		push	eax
		mov	ecx, [ebp+var_428]
		push	ecx
		mov	edx, [ebp+var_434]
		push	edx
		mov	eax, [ebp+var_41C]
		push	eax
		call	?compareCaseInsensitiveASCII@@YAHPB_WH0H@Z ; compareCaseInsensitiveASCII(wchar_t const *,int,wchar_t const *,int)
		add	esp, 10h
		mov	[ebp+var_464], eax

$CLEANUP$10791:				; CODE XREF: _uidna_compare_56+E5j
					; _uidna_compare_56+EAj ...
		mov	eax, [ebp+var_41C]
		lea	ecx, [ebp+var_208]
		cmp	eax, ecx
		jz	short loc_1AA0
		mov	eax, [ebp+var_41C]
		push	eax
		call	_uprv_free_56
		add	esp, 4

loc_1AA0:				; CODE XREF: _uidna_compare_56+207j
		mov	eax, [ebp+var_428]
		lea	ecx, [ebp+var_410]
		cmp	eax, ecx
		jz	short loc_1ABF
		mov	eax, [ebp+var_428]
		push	eax
		call	_uprv_free_56
		add	esp, 4

loc_1ABF:				; CODE XREF: _uidna_compare_56+226j
		mov	eax, [ebp+var_464]

loc_1AC5:				; CODE XREF: _uidna_compare_56+46j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN17
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 578h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uidna_compare_56 endp

; ---------------------------------------------------------------------------
$LN17		dd 3			; DATA XREF: _uidna_compare_56+241o
		dd offset $LN16
$LN16		dd 0FFFFFDF8h, 200h	; DATA XREF: .text:00001AF8o
		dd offset $LN13		; "b1Stack"
		dd 0FFFFFBF0h, 200h
		dd offset $LN14		; "b2Stack"
		dd 0FFFFFB4Ch, 48h
		dd offset $LN15		; "parseError"
$LN15		db 'parseError',0       ; DATA XREF: .text:00001B1Co
$LN14		db 'b2Stack',0          ; DATA XREF: .text:00001B10o
$LN13		db 'b1Stack',0          ; DATA XREF: .text:00001B04o
_text		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn __RTC_Shutdown:near ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
		extrn __RTC_InitBase:near ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
		extrn _usprep_close_56:near ; CODE XREF: _uidna_toASCII_56+C5p
					; _uidna_toUnicode_56+C5p ...
		extrn _usprep_openByType_56:near ; CODE	XREF: _uidna_toASCII_56+71p
					; _uidna_toUnicode_56+71p ...
		extrn __RTC_CheckEsp:near ; CODE XREF: _uidna_toASCII_56+DBp
					; _internal_toASCII(wchar_t const *,int,wchar_t	*,int,int,UStringPrepProfile *,UParseError *,UErrorCode	*)+45Cp ...
		extrn _u_terminateUChars_56:near
					; CODE XREF: _internal_toASCII(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile	*,UParseError *,UErrorCode *)+694p
					; _internal_toUnicode(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile *,UParseError *,UErrorCode *)+5A5p ...
; void *__cdecl	memcpy(void *Dst, const	void *Src, size_t Size)
		extrn _memcpy:near	; CODE XREF: _internal_toASCII(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile	*,UParseError *,UErrorCode *)+5BFp
					; _internal_toASCII(wchar_t const *,int,wchar_t	*,int,int,UStringPrepProfile *,UParseError *,UErrorCode	*)+5EFp
		extrn _u_strToPunycode_56:near
					; CODE XREF: _internal_toASCII(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile	*,UParseError *,UErrorCode *)+4D2p
					; _internal_toASCII(wchar_t const *,int,wchar_t	*,int,int,UStringPrepProfile *,UParseError *,UErrorCode	*)+54Bp
; void *__cdecl	_memmove(void *Dst, const void *Src, size_t Size)
		extrn __imp__memmove:near
					; CODE XREF: _internal_toASCII(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile	*,UParseError *,UErrorCode *)+451p
					; _internal_toUnicode(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile *,UParseError *,UErrorCode *)+459p ...
		extrn _uprv_checkValidMemory:near
					; CODE XREF: _internal_toASCII(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile	*,UParseError *,UErrorCode *)+433p
					; _internal_toASCII(wchar_t const *,int,wchar_t	*,int,int,UStringPrepProfile *,UParseError *,UErrorCode	*)+5ACp ...
		extrn _uprv_syntaxError_56:near
					; CODE XREF: _internal_toASCII(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile	*,UParseError *,UErrorCode *)+38Dp
					; _internal_toASCII(wchar_t const *,int,wchar_t	*,int,int,UStringPrepProfile *,UParseError *,UErrorCode	*)+3B9p ...
		extrn _uprv_free_56:near
					; CODE XREF: _internal_toASCII(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile	*,UParseError *,UErrorCode *)+1E4p
					; _internal_toASCII(wchar_t const *,int,wchar_t	*,int,int,UStringPrepProfile *,UParseError *,UErrorCode	*)+64Bp ...
		extrn _usprep_prepare_56:near
					; CODE XREF: _internal_toASCII(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile	*,UParseError *,UErrorCode *)+1B3p
					; _internal_toASCII(wchar_t const *,int,wchar_t	*,int,int,UStringPrepProfile *,UParseError *,UErrorCode	*)+251p ...
		extrn _uprv_malloc_56:near
					; CODE XREF: _internal_toASCII(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile	*,UParseError *,UErrorCode *)+DBp
					; _internal_toASCII(wchar_t const *,int,wchar_t	*,int,int,UStringPrepProfile *,UParseError *,UErrorCode	*)+1F5p ...
		extrn _u_strlen_56:near	; CODE XREF: _internal_toASCII(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile	*,UParseError *,UErrorCode *)+BFp
		extrn ___security_cookie:near
					; DATA XREF: _internal_toASCII(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile	*,UParseError *,UErrorCode *)+1Er
					; _internal_toUnicode(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile *,UParseError *,UErrorCode *)+1Er ...
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near
					; CODE XREF: _internal_toASCII(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile	*,UParseError *,UErrorCode *)+6B5p
					; _internal_toUnicode(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile *,UParseError *,UErrorCode *)+5C6p ...
; __fastcall _RTC_CheckStackVars(x, x)
		extrn @_RTC_CheckStackVars@8:near
					; CODE XREF: _internal_toASCII(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile	*,UParseError *,UErrorCode *)+6A6p
					; _internal_toUnicode(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile *,UParseError *,UErrorCode *)+5B7p ...
; void __cdecl __wassert(const wchar_t *Message, const wchar_t *File, unsigned int Line)
		extrn __imp___wassert:near
					; CODE XREF: _internal_toUnicode(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile *,UParseError	*,UErrorCode *)+542p
					; DATA XREF: _internal_toUnicode(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile *,UParseError	*,UErrorCode *)+542r
		extrn _u_strFromPunycode_56:near
					; CODE XREF: _internal_toUnicode(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile *,UParseError	*,UErrorCode *)+28Ap
					; _internal_toUnicode(wchar_t const *,int,wchar_t *,int,int,UStringPrepProfile *,UParseError *,UErrorCode *)+303p


		end
