;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	F0B69A7EDF984F1AD2EC9B68E77DFAE7
; Input	CRC32 :	ECD9E5BD

; File Name   :	D:\compspace\objfiles\firefox\ctestfw\uperf.obj
; Format      :	COFF (X386MAGIC)
; includelib "msvcprtd"
; includelib "MSVCRTD"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		public ??_C@_06NDGIILMC@locale?$AA@
; `string'
??_C@_06NDGIILMC@locale?$AA@ db	'locale',0 ; DATA XREF: .data:000005BCo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8
		public ??_C@_09JDCHNGOK@bulk?9mode?$AA@
; `string'
??_C@_09JDCHNGOK@bulk?9mode?$AA@ db 'bulk-mode',0 ; DATA XREF: .data:000005A8o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 14h
		public ??_C@_09NFAACLBM@line?9mode?$AA@
; `string'
??_C@_09NFAACLBM@line?9mode?$AA@ db 'line-mode',0 ; DATA XREF: .data:00000594o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 20h
		public ??_C@_04CLCEDBPF@time?$AA@
; `string'
??_C@_04CLCEDBPF@time?$AA@ db 'time',0  ; DATA XREF: .data:00000580o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 28h
		public ??_C@_0L@LEIMKHLK@iterations?$AA@
; `string'
??_C@_0L@LEIMKHLK@iterations?$AA@ db 'iterations',0 ; DATA XREF: .data:0000056Co
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 34h
		public ??_C@_06MAKFJKMG@passes?$AA@
; `string'
??_C@_06MAKFJKMG@passes?$AA@ db	'passes',0 ; DATA XREF: .data:00000558o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3Ch
		public ??_C@_09CIKJIKME@file?9name?$AA@
; `string'
??_C@_09CIKJIKME@file?9name?$AA@ db 'file-name',0 ; DATA XREF: .data:00000544o
					; .rdata$r:00000B54o ...
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 48h
		public ??_C@_06MEDFFPAG@uselen?$AA@
; `string'
??_C@_06MEDFFPAG@uselen?$AA@ db	'uselen',0 ; DATA XREF: .data:00000530o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 50h
		public ??_C@_08MLPGAEIK@encoding?$AA@
; `string'
??_C@_08MLPGAEIK@encoding?$AA@ db 'encoding',0 ; DATA XREF: .data:0000051Co
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5Ch
		public ??_C@_09CMGPLHNH@sourcedir?$AA@
; `string'
??_C@_09CMGPLHNH@sourcedir?$AA@	db 'sourcedir',0 ; DATA XREF: .data:00000508o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 68h
		public ??_C@_07KBAMPNJK@verbose?$AA@
; `string'
??_C@_07KBAMPNJK@verbose?$AA@ db 'verbose',0 ; DATA XREF: .data:000004F4o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 70h
		public ??_C@_04PCJFHION@help?$AA@
; `string'
??_C@_04PCJFHION@help?$AA@ db 'help',0  ; DATA XREF: .data:_optionso
					; .data:000004E0o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
		assume cs:_bss
		;org 78h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
_execCount	dd ?			; DATA XREF: UPerfTest::run(void):loc_1ACFw
					; UPerfTest::run(void)+D4r ...
;
; Exported entry
;
		public ?gTest@UPerfTest@@2PAV1@A
; public: static class UPerfTest * UPerfTest::gTest
?gTest@UPerfTest@@2PAV1@A dd ?		; DATA XREF: UPerfTest::runTestLoop(char *,char	*)+35r
					; UPerfTest::runTestLoop(char *,char *)+40w ...
_bss		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 80h
		public ?gUsageString@UPerfTest@@2QBDB
; char UPerfTest::gUsageString[]
?gUsageString@UPerfTest@@2QBDB db 'Usage: %s [OPTIONS] [FILES]',0Ah
					; DATA XREF: UPerfTest::usage(void)+25o
		db 9,'Reads the input file and prints out time taken in seconds',0Ah
		db 'Options:',0Ah
		db 9,'-h or -? or --help   this usage text',0Ah
		db 9,'-v or --verbose      print extra information when processing fil'
		db 'es',0Ah
		db 9,'-s or --sourcedir    source directory for files followed by path'
		db 0Ah
		db 9,'                     followed by path',0Ah
		db 9,'-e or --encoding     encoding of source files',0Ah
		db 9,'-u or --uselen       perform timing analysis on non-null termina'
		db 'ted buffer using length',0Ah
		db 9,'-f or --file-name    file to be used as input data',0Ah
		db 9,'-p or --passes       Number of passes to be performed. Requires '
		db 'Numeric argument.',0Ah
		db 9,'                     Cannot be used with --time',0Ah
		db 9,'-i or --iterations   Number of iterations to be performed. Requi'
		db 'res Numeric argument',0Ah
		db 9,'-t or --time         Threshold time for looping until in seconds'
		db '. Requires Numeric argument.',0Ah
		db 9,'                     Cannot be used with --iterations',0Ah
		db 9,'-l or --line-mode    The data file should be processed in line m'
		db 'ode',0Ah
		db 9,'-b or --bulk-mode    The data file should be processed in file b'
		db 'ased.',0Ah
		db 9,'                     Cannot be used with --line-mode',0Ah
		db 9,'-L or --locale       Locale for the test',0Ah,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
; Segment alignment 'qword' can not be represented in assembly
_data		segment	para public 'DATA' use32
		assume cs:_data
		;org 4CCh
_options	dd offset ??_C@_04PCJFHION@help?$AA@
					; DATA XREF: UPerfTest::init(UOption * const,int,UErrorCode &)+4Bo
					; UPerfTest::init(UOption * const,int,UErrorCode &):loc_135Bo
					; "help"
		dd 3 dup(0)
		db 68h,	0
byte_4DE	db 0			; DATA XREF: UPerfTest::init(UOption * const,int,UErrorCode &)+AFr
		align 10h
		dd offset ??_C@_04PCJFHION@help?$AA@ ; "help"
		align 10h
		db 3Fh,	0
byte_4F2	db 0			; DATA XREF: UPerfTest::init(UOption * const,int,UErrorCode &)+BAr
		align 4
		dd offset ??_C@_07KBAMPNJK@verbose?$AA@	; "verbose"
		dd 3 dup(0)
		db 76h,	0
byte_506	db 0			; DATA XREF: UPerfTest::init(UOption * const,int,UErrorCode &):loc_13CBr
		align 4
		dd offset ??_C@_09CMGPLHNH@sourcedir?$AA@ ; "sourcedir"
dword_50C	dd 0			; DATA XREF: UPerfTest::init(UOption * const,int,UErrorCode &)+F3r
		dd 2 dup(0)
		db 73h,	1
byte_51A	db 0			; DATA XREF: UPerfTest::init(UOption * const,int,UErrorCode &):loc_13DDr
		align 4
		dd offset ??_C@_08MLPGAEIK@encoding?$AA@ ; "encoding"
dword_520	dd 0			; DATA XREF: UPerfTest::init(UOption * const,int,UErrorCode &)+10Ar
		dd 2 dup(0)
		db 65h,	1
byte_52E	db 0			; DATA XREF: UPerfTest::init(UOption * const,int,UErrorCode &):loc_13F4r
		align 10h
		dd offset ??_C@_06MEDFFPAG@uselen?$AA@ ; "uselen"
		align 10h
		db 75h,	0
byte_542	db 0			; DATA XREF: UPerfTest::init(UOption * const,int,UErrorCode &):loc_140Br
		align 4
		dd offset ??_C@_09CIKJIKME@file?9name?$AA@ ; "file-name"
dword_548	dd 0			; DATA XREF: UPerfTest::init(UOption * const,int,UErrorCode &)+133r
		dd 2 dup(0)
		db 66h,	1
byte_556	db 0			; DATA XREF: UPerfTest::init(UOption * const,int,UErrorCode &):loc_141Dr
		align 4
		dd offset ??_C@_06MAKFJKMG@passes?$AA@ ; "passes"
; char *Str
Str		dd 0			; DATA XREF: UPerfTest::init(UOption * const,int,UErrorCode &)+149r
		dd 2 dup(0)
		db 70h,	1
byte_56A	db 0			; DATA XREF: UPerfTest::init(UOption * const,int,UErrorCode &):loc_1434r
		align 4
		dd offset ??_C@_0L@LEIMKHLK@iterations?$AA@ ; "iterations"
; char *dword_570
dword_570	dd 0			; DATA XREF: UPerfTest::init(UOption * const,int,UErrorCode &)+172r
		dd 2 dup(0)
		db 69h,	1
byte_57E	db 0			; DATA XREF: UPerfTest::init(UOption * const,int,UErrorCode &):loc_145Dr
		align 10h
		dd offset ??_C@_04CLCEDBPF@time?$AA@ ; "time"
; char *dword_584
dword_584	dd 0			; DATA XREF: UPerfTest::init(UOption * const,int,UErrorCode &)+1B6r
		align 10h
		db 74h,	1
byte_592	db 0			; DATA XREF: UPerfTest::init(UOption * const,int,UErrorCode &)+18Er
					; UPerfTest::init(UOption * const,int,UErrorCode &):loc_14A1r
		align 4
		dd offset ??_C@_09NFAACLBM@line?9mode?$AA@ ; "line-mode"
		dd 3 dup(0)
		db 6Ch,	0
byte_5A6	db 0			; DATA XREF: UPerfTest::init(UOption * const,int,UErrorCode &):loc_14D6r
		align 4
		dd offset ??_C@_09JDCHNGOK@bulk?9mode?$AA@ ; "bulk-mode"
		dd 3 dup(0)
		db 62h,	0
byte_5BA	db 0			; DATA XREF: UPerfTest::init(UOption * const,int,UErrorCode &):loc_14EFr
		align 4
		dd offset ??_C@_06NDGIILMC@locale?$AA@ ; "locale"
dword_5C0	dd 0			; DATA XREF: UPerfTest::init(UOption * const,int,UErrorCode &)+21Er
		dd 2 dup(0)
		db 4Ch,	1
byte_5CE	db 0			; DATA XREF: UPerfTest::init(UOption * const,int,UErrorCode &):loc_1508r
		align 10h
dword_5D0	dd 64h dup(0)		; DATA XREF: UPerfTest::init(UOption * const,int,UErrorCode &)+95o
_data		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 760h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; __int32 __thiscall UPerfFunction::getEventsPerIteration(UPerfFunction	*__hidden this)
		public ?getEventsPerIteration@UPerfFunction@@UAEJXZ
?getEventsPerIteration@UPerfFunction@@UAEJXZ proc near ; DATA XREF: .rdata:00000AF0o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		or	eax, 0FFFFFFFFh
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getEventsPerIteration@UPerfFunction@@UAEJXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$TMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$TMZ
		;org 790h
__RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
_rtc$TMZ	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$IMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$IMZ
		;org 794h
__RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
_rtc$IMZ	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 798h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; double __thiscall UPerfFunction::time(UPerfFunction *this, int, enum UErrorCode *)
		public ?time@UPerfFunction@@UAENHPAW4UErrorCode@@@Z
?time@UPerfFunction@@UAENHPAW4UErrorCode@@@Z proc near ; DATA XREF: .rdata:00000AF4o

var_104		= dword	ptr -104h
var_3C		= LARGE_INTEGER	ptr -3Ch
PerformanceCount= LARGE_INTEGER	ptr -24h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 104h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_104]
		mov	ecx, 41h ; 'A'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	[ebp+var_C], ecx
		lea	eax, [ebp+PerformanceCount]
		push	eax		; lpPerformanceCount
		call	?utimer_getTime@@YAXPAUUTimer@@@Z ; utimer_getTime(UTimer *)
		add	esp, 4

loc_7D1:				; CODE XREF: UPerfFunction::time(int,UErrorCode	*)+82j
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_0]
		sub	ecx, 1
		mov	[ebp+arg_0], ecx
		test	eax, eax
		jle	short loc_7ED
		mov	[ebp+var_104], 1
		jmp	short loc_7F7
; ---------------------------------------------------------------------------

loc_7ED:				; CODE XREF: UPerfFunction::time(int,UErrorCode	*)+47j
		mov	[ebp+var_104], 0

loc_7F7:				; CODE XREF: UPerfFunction::time(int,UErrorCode	*)+53j
		cmp	[ebp+var_104], 0
		jz	short loc_81C
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_C]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_C]
		mov	eax, [edx+4]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_7D1
; ---------------------------------------------------------------------------

loc_81C:				; CODE XREF: UPerfFunction::time(int,UErrorCode	*)+66j
		lea	eax, [ebp+var_3C]
		push	eax		; lpPerformanceCount
		call	?utimer_getTime@@YAXPAUUTimer@@@Z ; utimer_getTime(UTimer *)
		add	esp, 4
		lea	eax, [ebp+var_3C]
		push	eax
		lea	ecx, [ebp+PerformanceCount]
		push	ecx
		call	?utimer_getDeltaSeconds@@YANPAUUTimer@@0@Z ; utimer_getDeltaSeconds(UTimer *,UTimer *)
		add	esp, 8
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN10
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 104h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?time@UPerfFunction@@UAENHPAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN10		dd 2			; DATA XREF: UPerfFunction::time(int,UErrorCode	*)+A4o
		dd offset $LN9
$LN9		dd 0FFFFFFDCh, 10h	; DATA XREF: .text:00000870o
		dd offset $LN7		; "start"
		dd 0FFFFFFC4h, 10h
		dd offset $LN8		; "stop"
$LN8		db 'stop',0             ; DATA XREF: .text:00000888o
$LN7		db 'start',0            ; DATA XREF: .text:0000087Co
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 898h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl utimer_getTime(LARGE_INTEGER *lpPerformanceCount)
?utimer_getTime@@YAXPAUUTimer@@@Z proc near
					; CODE XREF: UPerfFunction::time(int,UErrorCode	*)+31p
					; UPerfFunction::time(int,UErrorCode *)+88p

var_C0		= byte ptr -0C0h
lpPerformanceCount= dword ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+lpPerformanceCount]
		push	eax
		call	?uprv_initFrequency@@YAHPAUUTimer@@@Z ;	uprv_initFrequency(UTimer *)
		add	esp, 4
		mov	eax, [ebp+lpPerformanceCount]
		push	eax		; lpPerformanceCount
		call	?uprv_start@@YAXPAUUTimer@@@Z ;	uprv_start(UTimer *)
		add	esp, 4
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?utimer_getTime@@YAXPAUUTimer@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8E4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl uprv_initFrequency(struct	UTimer *)
?uprv_initFrequency@@YAHPAUUTimer@@@Z proc near	; CODE XREF: utimer_getTime(UTimer *)+22p

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		add	eax, 8
		mov	esi, esp
		push	eax		; lpFrequency
		call	dword ptr ds:__imp__QueryPerformanceFrequency@4	; QueryPerformanceFrequency(x)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?uprv_initFrequency@@YAHPAUUTimer@@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 92Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl uprv_start(LARGE_INTEGER *lpPerformanceCount)
?uprv_start@@YAXPAUUTimer@@@Z proc near	; CODE XREF: utimer_getTime(UTimer *)+2Ep

var_C0		= byte ptr -0C0h
lpPerformanceCount= dword ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	esi, esp
		mov	eax, [ebp+lpPerformanceCount]
		push	eax		; lpPerformanceCount
		call	dword ptr ds:__imp__QueryPerformanceCounter@4 ;	QueryPerformanceCounter(x)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?uprv_start@@YAXPAUUTimer@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 974h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; double __cdecl utimer_getDeltaSeconds(struct UTimer *, struct	UTimer *)
?utimer_getDeltaSeconds@@YANPAUUTimer@@0@Z proc	near
					; CODE XREF: UPerfFunction::time(int,UErrorCode	*)+98p

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?uprv_compareFrequency@@YACPAUUTimer@@0@Z ; uprv_compareFrequency(UTimer *,UTimer *)
		add	esp, 8
		movsx	edx, al
		test	edx, edx
		jz	short loc_9BB
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?uprv_delta@@YANPAUUTimer@@0@Z ; uprv_delta(UTimer *,UTimer *)
		add	esp, 8
		jmp	short loc_9C1
; ---------------------------------------------------------------------------

loc_9BB:				; CODE XREF: utimer_getDeltaSeconds(UTimer *,UTimer *)+33j
		fld	ds:__real@bff0000000000000

loc_9C1:				; CODE XREF: utimer_getDeltaSeconds(UTimer *,UTimer *)+45j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?utimer_getDeltaSeconds@@YANPAUUTimer@@0@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 9D8h
		public __real@bff0000000000000
__real@bff0000000000000	dq -1.0		; DATA XREF: utimer_getDeltaSeconds(UTimer *,UTimer *):loc_9BBr
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9E0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; double __cdecl uprv_delta(struct UTimer *, struct UTimer *)
?uprv_delta@@YANPAUUTimer@@0@Z proc near
					; CODE XREF: utimer_getDeltaSeconds(UTimer *,UTimer *)+3Dp

var_C8		= qword	ptr -0C8h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C8]
		mov	ecx, 32h ; '2'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax]
		sub	edx, [ecx]
		mov	eax, [eax+4]
		sbb	eax, [ecx+4]
		mov	dword ptr [ebp+var_C8],	edx
		mov	dword ptr [ebp+var_C8+4], eax
		fild	[ebp+var_C8]
		mov	ecx, [ebp+arg_0]
		fild	qword ptr [ecx+8]
		fdivp	st(1), st
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?uprv_delta@@YANPAUUTimer@@0@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A30h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl uprv_compareFrequency(struct UTimer *, struct UTimer *)
?uprv_compareFrequency@@YACPAUUTimer@@0@Z proc near
					; CODE XREF: utimer_getDeltaSeconds(UTimer *,UTimer *)+26p

var_CC		= byte ptr -0CCh
var_C9		= byte ptr -0C9h
var_C8		= dword	ptr -0C8h
var_C4		= dword	ptr -0C4h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		mov	[ebp+var_C4], eax
		mov	[ebp+var_C8], ecx
		mov	edx, [ebp+var_C4]
		mov	eax, [ebp+var_C8]
		mov	ecx, [edx+8]
		cmp	ecx, [eax+8]
		jnz	short loc_A91
		mov	edx, [ebp+var_C4]
		mov	eax, [ebp+var_C8]
		mov	ecx, [edx+0Ch]
		cmp	ecx, [eax+0Ch]
		jnz	short loc_A91
		mov	[ebp+var_C9], 1
		jmp	short loc_A98
; ---------------------------------------------------------------------------

loc_A91:				; CODE XREF: uprv_compareFrequency(UTimer *,UTimer *)+42j
					; uprv_compareFrequency(UTimer *,UTimer	*)+56j
		mov	[ebp+var_C9], 0

loc_A98:				; CODE XREF: uprv_compareFrequency(UTimer *,UTimer *)+5Fj
		mov	al, [ebp+var_C9]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?uprv_compareFrequency@@YACPAUUTimer@@0@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0AA8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall UPerfFunction::UPerfFunction(void)
		public ??0UPerfFunction@@QAE@XZ
??0UPerfFunction@@QAE@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UPerfFunction@@6B@ ; const UPerfFunction::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0UPerfFunction@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0AE0h
		dd offset ??_R4UPerfFunction@@6B@ ; const UPerfFunction::`RTTI Complete	Object Locator'
;
; Exported entry
;
		public ??_7UPerfFunction@@6B@
; const	UPerfFunction::`vftable'
??_7UPerfFunction@@6B@ dd offset ??_EUPerfFunction@@UAEPAXI@Z
					; DATA XREF: UPerfFunction::UPerfFunction(void)+26o
					; UPerfFunction::UPerfFunction(UPerfFunction const &)+26o ...
					; UPerfFunction::`vector deleting destructor'(uint)
		dd offset __purecall
		dd offset __purecall
		dd offset ?getEventsPerIteration@UPerfFunction@@UAEJXZ ; UPerfFunction::getEventsPerIteration(void)
		dd offset ?time@UPerfFunction@@UAENHPAW4UErrorCode@@@Z ; UPerfFunction::time(int,UErrorCode *)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0AF8h
		public ??_R4UPerfFunction@@6B@
; const	UPerfFunction::`RTTI Complete Object Locator'
??_R4UPerfFunction@@6B@	dd 3 dup(0)	; DATA XREF: .rdata:00000AE0o
		dd offset ??_R0?AVUPerfFunction@@@8 ; UPerfFunction `RTTI Type Descriptor'
		dd offset ??_R3UPerfFunction@@8	; UPerfFunction::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 0B0Ch
		public ??_R0?AVUPerfFunction@@@8
; class	UPerfFunction `RTTI Type Descriptor'
??_R0?AVUPerfFunction@@@8 dd offset ??_7type_info@@6B@ ; DATA XREF: .rdata$r:00000B04o
					; .rdata$r:UPerfFunction::`RTTI	Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avuperffunct	db '.?AVUPerfFunction@@',0
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0B28h
		public ??_R3UPerfFunction@@8
; UPerfFunction::`RTTI Class Hierarchy Descriptor'
??_R3UPerfFunction@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:00000B08o
					; .rdata$r:00000B58o
		dd 1
		dd offset ??_R2UPerfFunction@@8	; UPerfFunction::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0B38h
		public ??_R2UPerfFunction@@8
; UPerfFunction::`RTTI Base Class Array'
??_R2UPerfFunction@@8 dd offset	??_R1A@?0A@EA@UPerfFunction@@8
					; DATA XREF: .rdata$r:00000B34o
					; UPerfFunction::`RTTI Base Class Descriptor at	(0,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0B40h
		public ??_R1A@?0A@EA@UPerfFunction@@8
; UPerfFunction::`RTTI Base Class Descriptor at	(0, -1,	0, 64)'
??_R1A@?0A@EA@UPerfFunction@@8 dd offset ??_R0?AVUPerfFunction@@@8
					; DATA XREF: .rdata$r:UPerfFunction::`RTTI Base	Class Array'o
					; UPerfFunction	`RTTI Type Descriptor'
		dd 2 dup(0)
		dd 0FFFFFFFFh, 0
		dd offset ??_C@_09CIKJIKME@file?9name?$AA@+4 ; "-name"
		dd offset ??_R3UPerfFunction@@8	; UPerfFunction::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B5Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall UPerfFunction::UPerfFunction(class	UPerfFunction const &)
		public ??0UPerfFunction@@QAE@ABV0@@Z
??0UPerfFunction@@QAE@ABV0@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UPerfFunction@@6B@ ; const UPerfFunction::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??0UPerfFunction@@QAE@ABV0@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B94h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	UPerfFunction &	__thiscall UPerfFunction::operator=(class UPerfFunction	const &)
		public ??4UPerfFunction@@QAEAAV0@ABV0@@Z
??4UPerfFunction@@QAEAAV0@ABV0@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4UPerfFunction@@QAEAAV0@ABV0@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0BC4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall UPerfFunction::`scalar deleting destructor'(unsigned int)
		public ??_GUPerfFunction@@UAEPAXI@Z
??_GUPerfFunction@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1UPerfFunction@@UAE@XZ ; UPerfFunction::~UPerfFunction(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_C03
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_C03:				; CODE XREF: UPerfFunction::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GUPerfFunction@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C1Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall UPerfFunction::`vector deleting destructor'(unsigned int)
		public ??_EUPerfFunction@@UAEPAXI@Z
??_EUPerfFunction@@UAEPAXI@Z proc near	; DATA XREF: .rdata:const UPerfFunction::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_C7D
		push	offset ??1UPerfFunction@@UAE@XZ	; UPerfFunction::~UPerfFunction(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	4
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_C75
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_C75:				; CODE XREF: UPerfFunction::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_C9C
; ---------------------------------------------------------------------------

loc_C7D:				; CODE XREF: UPerfFunction::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1UPerfFunction@@UAE@XZ ; UPerfFunction::~UPerfFunction(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_C99
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_C99:				; CODE XREF: UPerfFunction::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_C9C:				; CODE XREF: UPerfFunction::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EUPerfFunction@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0CB4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall UPerfTest::UPerfTest(UPerfTest *this, const	struct UPerfTest *)
		public ??0UPerfTest@@QAE@ABV0@@Z
??0UPerfTest@@QAE@ABV0@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UPerfTest@@6B@ ; const UPerfTest::`vftable'
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	[eax+4], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+8]
		mov	[eax+8], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+0Ch]
		mov	[eax+0Ch], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+10h]
		mov	[eax+10h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+14h]
		mov	[eax+14h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+18h]
		mov	[eax+18h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	dl, [ecx+1Ch]
		mov	[eax+1Ch], dl
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+20h]
		mov	[eax+20h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+24h]
		mov	[eax+24h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+28h]
		mov	[eax+28h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+2Ch]
		mov	[eax+2Ch], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+30h]
		mov	[eax+30h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	dl, [ecx+34h]
		mov	[eax+34h], dl
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+38h]
		mov	[eax+38h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+3Ch]
		mov	[eax+3Ch], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	dl, [ecx+40h]
		mov	[eax+40h], dl
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	dl, [ecx+41h]
		mov	[eax+41h], dl
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+44h]
		mov	[eax+44h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+48h]
		mov	[eax+48h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4Ch]
		mov	[eax+4Ch], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+50h]
		mov	[eax+50h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+54h]
		mov	[eax+54h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+58h]
		mov	[eax+58h], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??0UPerfTest@@QAE@ABV0@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E00h
		dd offset ??_R4UPerfTest@@6B@ ;	const UPerfTest::`RTTI Complete	Object Locator'
;
; Exported entry
;
		public ??_7UPerfTest@@6B@
; const	UPerfTest::`vftable'
??_7UPerfTest@@6B@ dd offset ?usage@UPerfTest@@UAEXXZ
					; DATA XREF: UPerfTest::UPerfTest(UPerfTest const &)+26o
					; UPerfTest::UPerfTest(int,char	const *	* const,UErrorCode &)+26o ...
					; UPerfTest::usage(void)
		dd offset ??_EUPerfTest@@UAEPAXI@Z ; UPerfTest::`vector	deleting destructor'(uint)
		dd offset ?runIndexedTest@UPerfTest@@MAEPAVUPerfFunction@@HCAAPBDPAD@Z ; UPerfTest::runIndexedTest(int,signed char,char	const *	&,char *)
		dd offset ?runTestLoop@UPerfTest@@MAECPAD0@Z ; UPerfTest::runTestLoop(char *,char *)
		dd offset ?callTest@UPerfTest@@MAECAAV1@PAD@Z ;	UPerfTest::callTest(UPerfTest &,char *)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0E18h
		public ??_R4UPerfTest@@6B@
; const	UPerfTest::`RTTI Complete Object Locator'
??_R4UPerfTest@@6B@ dd 3 dup(0)		; DATA XREF: .rdata:00000E00o
		dd offset ??_R0?AVUPerfTest@@@8	; UPerfTest `RTTI Type Descriptor'
		dd offset ??_R3UPerfTest@@8 ; UPerfTest::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 0E2Ch
		public ??_R0?AVUPerfTest@@@8
; class	UPerfTest `RTTI	Type Descriptor'
??_R0?AVUPerfTest@@@8 dd offset	??_7type_info@@6B@ ; DATA XREF:	.rdata$r:00000E24o
					; .rdata$r:UPerfTest::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avuperftest@	db '.?AVUPerfTest@@',0
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0E44h
		public ??_R3UPerfTest@@8
; UPerfTest::`RTTI Class Hierarchy Descriptor'
??_R3UPerfTest@@8 dd 2 dup(0)		; DATA XREF: .rdata$r:00000E28o
					; .rdata$r:00000E74o
		dd 1
		dd offset ??_R2UPerfTest@@8 ; UPerfTest::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0E54h
		public ??_R2UPerfTest@@8
; UPerfTest::`RTTI Base	Class Array'
??_R2UPerfTest@@8 dd offset ??_R1A@?0A@EA@UPerfTest@@8 ; DATA XREF: .rdata$r:00000E50o
					; UPerfTest::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0E5Ch
		public ??_R1A@?0A@EA@UPerfTest@@8
; UPerfTest::`RTTI Base	Class Descriptor at (0,	-1, 0, 64)'
??_R1A@?0A@EA@UPerfTest@@8 dd offset ??_R0?AVUPerfTest@@@8
					; DATA XREF: .rdata$r:UPerfTest::`RTTI Base Class Array'o
					; UPerfTest `RTTI Type Descriptor'
		dd 2 dup(0)
		dd 0FFFFFFFFh, 0
		dd offset ??_C@_09CIKJIKME@file?9name?$AA@+4 ; "-name"
		dd offset ??_R3UPerfTest@@8 ; UPerfTest::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0E78h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	UPerfTest & __thiscall UPerfTest::operator=(class UPerfTest const &)
		public ??4UPerfTest@@QAEAAV0@ABV0@@Z
??4UPerfTest@@QAEAAV0@ABV0@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	[eax+4], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+8]
		mov	[eax+8], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+0Ch]
		mov	[eax+0Ch], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+10h]
		mov	[eax+10h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+14h]
		mov	[eax+14h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+18h]
		mov	[eax+18h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	dl, [ecx+1Ch]
		mov	[eax+1Ch], dl
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+20h]
		mov	[eax+20h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+24h]
		mov	[eax+24h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+28h]
		mov	[eax+28h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+2Ch]
		mov	[eax+2Ch], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+30h]
		mov	[eax+30h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	dl, [ecx+34h]
		mov	[eax+34h], dl
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+38h]
		mov	[eax+38h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+3Ch]
		mov	[eax+3Ch], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	dl, [ecx+40h]
		mov	[eax+40h], dl
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	dl, [ecx+41h]
		mov	[eax+41h], dl
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+44h]
		mov	[eax+44h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+48h]
		mov	[eax+48h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4Ch]
		mov	[eax+4Ch], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+50h]
		mov	[eax+50h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+54h]
		mov	[eax+54h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+58h]
		mov	[eax+58h], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4UPerfTest@@QAEAAV0@ABV0@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0FBCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall UPerfTest::`scalar deleting	destructor'(unsigned int)
		public ??_GUPerfTest@@UAEPAXI@Z
??_GUPerfTest@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1UPerfTest@@UAE@XZ ; UPerfTest::~UPerfTest(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_FFB
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_FFB:				; CODE XREF: UPerfTest::`scalar	deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GUPerfTest@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1014h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall UPerfTest::`vector deleting	destructor'(unsigned int)
		public ??_EUPerfTest@@UAEPAXI@Z
??_EUPerfTest@@UAEPAXI@Z proc near	; DATA XREF: .rdata:00000E08o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_1075
		push	offset ??1UPerfTest@@UAE@XZ ; UPerfTest::~UPerfTest(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	5Ch ; '\'
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_106D
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_106D:				; CODE XREF: UPerfTest::`vector	deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_1094
; ---------------------------------------------------------------------------

loc_1075:				; CODE XREF: UPerfTest::`vector	deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1UPerfTest@@UAE@XZ ; UPerfTest::~UPerfTest(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_1091
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_1091:				; CODE XREF: UPerfTest::`vector	deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_1094:				; CODE XREF: UPerfTest::`vector	deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EUPerfTest@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 10ACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall UPerfFunction::~UPerfFunction(UPerfFunction	*__hidden this)
		public ??1UPerfFunction@@UAE@XZ
??1UPerfFunction@@UAE@XZ proc near	; CODE XREF: UPerfFunction::`scalar deleting destructor'(uint)+26p
					; UPerfFunction::`vector deleting destructor'(uint)+64p
					; DATA XREF: ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UPerfFunction@@6B@ ; const UPerfFunction::`vftable'
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??1UPerfFunction@@UAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 10E0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	UPerfTest::UPerfTest(int, int, enum UErrorCode *)
		public ??0UPerfTest@@IAE@HQAPBDAAW4UErrorCode@@@Z
??0UPerfTest@@IAE@HQAPBDAAW4UErrorCode@@@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UPerfTest@@6B@ ; const UPerfTest::`vftable'
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+4], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		mov	[eax+8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+0Ch], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+14h], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+18h], offset ??_C@_00CNPNBAHC@?$AA@ ; `string'
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+1Ch], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+20h], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+24h], offset ??_C@_01LFCBOECM@?4?$AA@ ; `string'
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+2Ch], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+30h], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+34h], 1
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+38h], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+3Ch], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+40h], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+41h], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+44h], 1
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+48h], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4Ch], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+50h], 0
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		push	0		; int
		push	0		; Src
		mov	ecx, [ebp+var_8] ; this
		call	?init@UPerfTest@@IAEXQAUUOption@@HAAW4UErrorCode@@@Z ; UPerfTest::init(UOption * const,int,UErrorCode &)
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
??0UPerfTest@@IAE@HQAPBDAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 11E8h
		public ??_C@_01LFCBOECM@?4?$AA@
; `string'
??_C@_01LFCBOECM@?4?$AA@ db 2Eh, 0	; DATA XREF: UPerfTest::UPerfTest(int,char const * * const,UErrorCode &)+70o
					; UPerfTest::UPerfTest(int,char	const *	* const,UOption	* const,int,char const *,UErrorCode &)+6Fo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		;org 11ECh
		public ??_C@_00CNPNBAHC@?$AA@
; `string'
??_C@_00CNPNBAHC@?$AA@ db 0		; DATA XREF: UPerfTest::UPerfTest(int,char const * * const,UErrorCode &)+55o
					; UPerfTest::UPerfTest(int,char	const *	* const,UOption	* const,int,char const *,UErrorCode &)+54o
		align 10h
_rdata		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 11F0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	UPerfTest::UPerfTest(int, int, struct UOption *Src, int, int, enum UErrorCode *)
		public ??0UPerfTest@@IAE@HQAPBDQAUUOption@@HPBDAAW4UErrorCode@@@Z
??0UPerfTest@@IAE@HQAPBDQAUUOption@@HPBDAAW4UErrorCode@@@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
Src		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UPerfTest@@6B@ ; const UPerfTest::`vftable'
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+4], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		mov	[eax+8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_10]
		mov	[eax+0Ch], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+14h], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+18h], offset ??_C@_00CNPNBAHC@?$AA@ ; `string'
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+1Ch], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+20h], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+24h], offset ??_C@_01LFCBOECM@?4?$AA@ ; `string'
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+2Ch], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+30h], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+34h], 1
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+38h], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+3Ch], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+40h], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+41h], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+44h], 1
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+48h], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4Ch], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+50h], 0
		mov	eax, [ebp+arg_14]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+Src]
		push	edx		; Src
		mov	ecx, [ebp+var_8] ; this
		call	?init@UPerfTest@@IAEXQAUUOption@@HAAW4UErrorCode@@@Z ; UPerfTest::init(UOption * const,int,UErrorCode &)
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	18h
??0UPerfTest@@IAE@HQAPBDQAUUOption@@HPBDAAW4UErrorCode@@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 12F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall UPerfTest::init(UPerfTest *this, struct UOption *const Src, int, enum	UErrorCode *)
		public ?init@UPerfTest@@IAEXQAUUOption@@HAAW4UErrorCode@@@Z
?init@UPerfTest@@IAEXQAUUOption@@HAAW4UErrorCode@@@Z proc near
					; CODE XREF: UPerfTest::UPerfTest(int,char const * * const,UErrorCode &)+E7p
					; UPerfTest::UPerfTest(int,char	const *	* const,UOption	* const,int,char const *,UErrorCode &)+EAp

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
Src		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+10h], 0
		mov	[ebp+var_14], 0Dh
		cmp	[ebp+arg_4], 0
		jle	short loc_135B
		mov	eax, [ebp+arg_4]
		imul	eax, 14h
		push	eax		; Size
		mov	ecx, [ebp+Src]
		push	ecx		; Src
		mov	edx, [ebp+var_14]
		imul	edx, 14h
		add	edx, offset _options
		push	edx		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	eax, [ebp+var_14]
		add	eax, [ebp+arg_4]
		mov	[ebp+var_14], eax

loc_135B:				; CODE XREF: UPerfTest::init(UOption * const,int,UErrorCode &)+38j
		push	offset _options
		mov	eax, [ebp+var_14]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+8]
		push	edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		push	ecx
		call	_u_parseArgs
		add	esp, 10h
		mov	edx, [ebp+var_8]
		mov	[edx+28h], eax
		cmp	[ebp+arg_4], 0
		jle	short loc_139E
		mov	eax, [ebp+arg_4]
		imul	eax, 14h
		push	eax		; Size
		push	offset dword_5D0 ; Src
		mov	ecx, [ebp+Src]
		push	ecx		; Dst
		call	_memcpy
		add	esp, 0Ch

loc_139E:				; CODE XREF: UPerfTest::init(UOption * const,int,UErrorCode &)+8Cj
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4], 1
		jz	short loc_13BD
		movsx	eax, ds:byte_4DE
		test	eax, eax
		jnz	short loc_13BD
		movsx	eax, ds:byte_4F2
		test	eax, eax
		jz	short loc_13CB

loc_13BD:				; CODE XREF: UPerfTest::init(UOption * const,int,UErrorCode &)+ADj
					; UPerfTest::init(UOption * const,int,UErrorCode &)+B8j
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 1
		jmp	loc_1618
; ---------------------------------------------------------------------------

loc_13CB:				; CODE XREF: UPerfTest::init(UOption * const,int,UErrorCode &)+C3j
		movsx	eax, ds:byte_506
		test	eax, eax
		jz	short loc_13DD
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+40h], 1

loc_13DD:				; CODE XREF: UPerfTest::init(UOption * const,int,UErrorCode &)+DCj
		movsx	eax, ds:byte_51A
		test	eax, eax
		jz	short loc_13F4
		mov	eax, [ebp+var_8]
		mov	ecx, ds:dword_50C
		mov	[eax+24h], ecx

loc_13F4:				; CODE XREF: UPerfTest::init(UOption * const,int,UErrorCode &)+EEj
		movsx	eax, ds:byte_52E
		test	eax, eax
		jz	short loc_140B
		mov	eax, [ebp+var_8]
		mov	ecx, ds:dword_520
		mov	[eax+18h], ecx

loc_140B:				; CODE XREF: UPerfTest::init(UOption * const,int,UErrorCode &)+105j
		movsx	eax, ds:byte_542
		test	eax, eax
		jz	short loc_141D
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+1Ch], 1

loc_141D:				; CODE XREF: UPerfTest::init(UOption * const,int,UErrorCode &)+11Cj
		movsx	eax, ds:byte_556
		test	eax, eax
		jz	short loc_1434
		mov	eax, [ebp+var_8]
		mov	ecx, ds:dword_548
		mov	[eax+20h], ecx

loc_1434:				; CODE XREF: UPerfTest::init(UOption * const,int,UErrorCode &)+12Ej
		movsx	eax, ds:byte_56A
		test	eax, eax
		jz	short loc_145D
		mov	esi, esp
		mov	eax, ds:Str
		push	eax		; Str
		call	dword ptr ds:__imp__atoi
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_8]
		mov	[ecx+44h], eax

loc_145D:				; CODE XREF: UPerfTest::init(UOption * const,int,UErrorCode &)+145j
		movsx	eax, ds:byte_57E
		test	eax, eax
		jz	short loc_14A1
		mov	esi, esp
		mov	eax, ds:dword_570
		push	eax		; Str
		call	dword ptr ds:__imp__atoi
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_8]
		mov	[ecx+48h], eax
		movsx	eax, ds:byte_592
		test	eax, eax
		jz	short loc_149F
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 1
		jmp	loc_1618
; ---------------------------------------------------------------------------

loc_149F:				; CODE XREF: UPerfTest::init(UOption * const,int,UErrorCode &)+197j
		jmp	short loc_14D6
; ---------------------------------------------------------------------------

loc_14A1:				; CODE XREF: UPerfTest::init(UOption * const,int,UErrorCode &)+16Ej
		movsx	eax, ds:byte_592
		test	eax, eax
		jz	short loc_14CC
		mov	esi, esp
		mov	eax, ds:dword_584
		push	eax		; Str
		call	dword ptr ds:__imp__atoi
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_8]
		mov	[ecx+4Ch], eax
		jmp	short loc_14D6
; ---------------------------------------------------------------------------

loc_14CC:				; CODE XREF: UPerfTest::init(UOption * const,int,UErrorCode &)+1B2j
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+48h], 3E8h

loc_14D6:				; CODE XREF: UPerfTest::init(UOption * const,int,UErrorCode &):loc_149Fj
					; UPerfTest::init(UOption * const,int,UErrorCode &)+1D2j
		movsx	eax, ds:byte_5A6
		test	eax, eax
		jz	short loc_14EF
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+34h], 1
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+41h], 0

loc_14EF:				; CODE XREF: UPerfTest::init(UOption * const,int,UErrorCode &)+1E7j
		movsx	eax, ds:byte_5BA
		test	eax, eax
		jz	short loc_1508
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+41h], 1
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+34h], 0

loc_1508:				; CODE XREF: UPerfTest::init(UOption * const,int,UErrorCode &)+200j
		movsx	eax, ds:byte_5CE
		test	eax, eax
		jz	short loc_151F
		mov	eax, [ebp+var_8]
		mov	ecx, ds:dword_5C0
		mov	[eax+50h], ecx

loc_151F:				; CODE XREF: UPerfTest::init(UOption * const,int,UErrorCode &)+219j
		mov	[ebp+var_20], 0
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+20h], 0
		jz	loc_1618
		mov	eax, [ebp+arg_8]
		push	eax
		lea	ecx, [ebp+var_20]
		push	ecx
		push	0
		mov	edx, [ebp+var_8]
		mov	eax, [edx+20h]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+24h]
		push	edx
		call	_ucbuf_resolveFileName
		add	esp, 14h
		mov	eax, [ebp+var_20]
		push	eax
		call	_uprv_malloc_56
		add	esp, 4
		mov	ecx, [ebp+var_8]
		mov	[ecx+10h], eax
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+10h], 0
		jnz	short loc_157C
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 7
		jmp	loc_1618
; ---------------------------------------------------------------------------

loc_157C:				; CODE XREF: UPerfTest::init(UOption * const,int,UErrorCode &)+274j
		mov	eax, [ebp+arg_8]
		cmp	dword ptr [eax], 0Fh
		jnz	short loc_158D
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 0

loc_158D:				; CODE XREF: UPerfTest::init(UOption * const,int,UErrorCode &)+28Aj
		mov	eax, [ebp+arg_8]
		push	eax
		lea	ecx, [ebp+var_20]
		push	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx+10h]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+20h]
		push	edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+24h]
		push	ecx
		call	_ucbuf_resolveFileName
		add	esp, 14h
		mov	eax, [ebp+arg_8]
		push	eax
		push	0
		push	1
		mov	ecx, [ebp+var_8]
		add	ecx, 18h
		push	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx+10h]
		push	eax
		call	_ucbuf_open
		add	esp, 14h
		mov	ecx, [ebp+var_8]
		mov	[ecx+14h], eax
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_1618
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	_u_errorName_56
		add	esp, 4
		mov	esi, esp
		push	eax
		mov	edx, [ebp+var_8]
		mov	eax, [edx+20h]
		push	eax
		push	offset ??_C@_0CN@DHEIFFPJ@Could?5not?5open?5the?5input?5file?5?$CFs@ ; "Could not open the input file %s. Error"...
		call	dword ptr ds:__imp__printf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_1618:				; CODE XREF: UPerfTest::init(UOption * const,int,UErrorCode &)+CEj
					; UPerfTest::init(UOption * const,int,UErrorCode &)+1A2j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN27
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?init@UPerfTest@@IAEXQAUUOption@@HAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
$LN27		dd 1			; DATA XREF: UPerfTest::init(UOption * const,int,UErrorCode &)+324o
		dd offset $LN26
$LN26		dd 0FFFFFFE0h, 4	; DATA XREF: .text:00001644o
		dd offset $LN25
$LN25		dd 6E656Ch		; DATA XREF: .text:00001650o
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1658h
		public ??_C@_0CN@DHEIFFPJ@Could?5not?5open?5the?5input?5file?5?$CFs@
; char `string'[]
??_C@_0CN@DHEIFFPJ@Could?5not?5open?5the?5input?5file?5?$CFs@ db 'Could not open the input file %s. Error: %s',0Ah,0
					; DATA XREF: UPerfTest::init(UOption * const,int,UErrorCode &)+30Bo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1688h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl U_FAILURE(enum  UErrorCode)
?U_FAILURE@@YACW4UErrorCode@@@Z	proc near
					; CODE XREF: UPerfTest::init(UOption * const,int,UErrorCode &)+2E4p
					; UPerfTest::getLines(UErrorCode &)+29p ...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		setnle	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?U_FAILURE@@YACW4UErrorCode@@@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 16B4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct ULine *__thiscall UPerfTest::getLines(UPerfTest *this,	enum UErrorCode	*)
		public ?getLines@UPerfTest@@QAEPAUULine@@AAW4UErrorCode@@@Z
?getLines@UPerfTest@@QAEPAUULine@@AAW4UErrorCode@@@Z proc near

var_138		= byte ptr -138h
var_134		= dword	ptr -134h
var_128		= dword	ptr -128h
var_11C		= dword	ptr -11Ch
var_110		= dword	ptr -110h
var_104		= dword	ptr -104h
Dst		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
Src		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 138h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_138]
		mov	ecx, 4Eh ; 'N'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_16F3
		xor	eax, eax
		jmp	loc_18F1
; ---------------------------------------------------------------------------

loc_16F3:				; CODE XREF: UPerfTest::getLines(UErrorCode &)+36j
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+2Ch], 0
		jz	short loc_1707
		mov	eax, [ebp+var_8]
		mov	eax, [eax+2Ch]
		jmp	loc_18F1
; ---------------------------------------------------------------------------

loc_1707:				; CODE XREF: UPerfTest::getLines(UErrorCode &)+46j
		push	4E200h		; unsigned int
		call	??2@YAPAXI@Z	; operator new(uint)
		add	esp, 4
		mov	[ebp+var_134], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_134]
		mov	[eax+2Ch], ecx
		mov	[ebp+var_14], 9C40h
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+30h], 0
		mov	[ebp+Src], 0
		mov	[ebp+var_2C], 0

loc_1745:				; CODE XREF: UPerfTest::getLines(UErrorCode &):loc_18E6j
		mov	eax, [ebp+arg_0]
		push	eax
		lea	ecx, [ebp+var_2C]
		push	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx+14h]
		push	eax
		call	_ucbuf_readline
		add	esp, 0Ch
		mov	[ebp+Src], eax
		cmp	[ebp+Src], 0
		jz	short loc_177A
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_177F

loc_177A:				; CODE XREF: UPerfTest::getLines(UErrorCode &)+AFj
		jmp	loc_18EB
; ---------------------------------------------------------------------------

loc_177F:				; CODE XREF: UPerfTest::getLines(UErrorCode &)+C4j
		xor	ecx, ecx
		mov	eax, [ebp+var_2C]
		mov	edx, 2
		mul	edx
		seto	cl
		neg	ecx
		or	ecx, eax
		push	ecx		; unsigned int
		call	??2@YAPAXI@Z	; operator new(uint)
		add	esp, 4
		mov	[ebp+var_128], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+30h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+2Ch]
		mov	edx, [ebp+var_128]
		mov	[eax+ecx*8], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+30h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+2Ch]
		mov	edx, [ebp+var_2C]
		mov	[eax+ecx*8+4], edx
		mov	eax, [ebp+var_2C]
		shl	eax, 1
		push	eax		; Size
		mov	ecx, [ebp+Src]
		push	ecx		; Src
		mov	edx, [ebp+var_8]
		mov	eax, [edx+30h]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+2Ch]
		mov	eax, [edx+eax*8]
		push	eax		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+30h]
		add	ecx, 1
		mov	edx, [ebp+var_8]
		mov	[edx+30h], ecx
		mov	[ebp+var_2C], 0
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+30h]
		cmp	ecx, [ebp+var_14]
		jl	loc_18E6
		mov	eax, [ebp+var_14]
		add	eax, 9C40h
		mov	[ebp+var_14], eax
		xor	ecx, ecx
		mov	eax, [ebp+var_14]
		mov	edx, 8
		mul	edx
		seto	cl
		neg	ecx
		or	ecx, eax
		push	ecx		; unsigned int
		call	??2@YAPAXI@Z	; operator new(uint)
		add	esp, 4
		mov	[ebp+var_11C], eax
		mov	eax, [ebp+var_11C]
		mov	[ebp+Dst], eax
		cmp	[ebp+Dst], 0
		jnz	short loc_18A5
		mov	esi, esp
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+30h]
		push	ecx
		push	offset ??_C@_0CA@BBPGOECO@Out?5of?5memory?5reading?5line?5?$CFd?4?6?$AA@ ; "Out	of memory reading line %d.\n"
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 7
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+2Ch]
		mov	[ebp+var_110], ecx
		mov	edx, [ebp+var_110]
		push	edx		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4
		xor	eax, eax
		jmp	short loc_18F1
; ---------------------------------------------------------------------------

loc_18A5:				; CODE XREF: UPerfTest::getLines(UErrorCode &)+196j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+30h]
		shl	ecx, 3
		push	ecx		; Size
		mov	edx, [ebp+var_8]
		mov	eax, [edx+2Ch]
		push	eax		; Src
		mov	ecx, [ebp+Dst]
		push	ecx		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+2Ch]
		mov	[ebp+var_104], ecx
		mov	edx, [ebp+var_104]
		push	edx		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+Dst]
		mov	[eax+2Ch], ecx

loc_18E6:				; CODE XREF: UPerfTest::getLines(UErrorCode &)+156j
		jmp	loc_1745
; ---------------------------------------------------------------------------

loc_18EB:				; CODE XREF: UPerfTest::getLines(UErrorCode &):loc_177Aj
		mov	eax, [ebp+var_8]
		mov	eax, [eax+2Ch]

loc_18F1:				; CODE XREF: UPerfTest::getLines(UErrorCode &)+3Aj
					; UPerfTest::getLines(UErrorCode &)+4Ej ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN13
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 138h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?getLines@UPerfTest@@QAEPAUULine@@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
$LN13		dd 1			; DATA XREF: UPerfTest::getLines(UErrorCode &)+241o
		dd offset $LN12
$LN12		dd 0FFFFFFD4h, 4	; DATA XREF: .text:0000191Co
		dd offset $LN11
$LN11		dd 6E656Ch		; DATA XREF: .text:00001928o
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1930h
		public ??_C@_0CA@BBPGOECO@Out?5of?5memory?5reading?5line?5?$CFd?4?6?$AA@
; char `string'[]
??_C@_0CA@BBPGOECO@Out?5of?5memory?5reading?5line?5?$CFd?4?6?$AA@ db 'Out of memory reading line %d.',0Ah,0
					; DATA XREF: UPerfTest::getLines(UErrorCode &)+1A1o
_rdata		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1950h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	wchar_t	*__thiscall UPerfTest::getBuffer(UPerfTest *this, int *, enum UErrorCode *)
		public ?getBuffer@UPerfTest@@QAEPB_WAAHAAW4UErrorCode@@@Z
?getBuffer@UPerfTest@@QAEPB_WAAHAAW4UErrorCode@@@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_198C
		xor	eax, eax
		jmp	short loc_1A0A
; ---------------------------------------------------------------------------

loc_198C:				; CODE XREF: UPerfTest::getBuffer(int &,UErrorCode &)+36j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+14h]
		push	ecx
		call	_ucbuf_size
		add	esp, 4
		mov	edx, [ebp+arg_0]
		mov	[edx], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		lea	edx, [ecx+ecx+2]
		push	edx
		call	_uprv_malloc_56
		add	esp, 4
		mov	ecx, [ebp+var_8]
		mov	[ecx+38h], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+var_8]
		add	eax, 3Ch ; '<'
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+14h]
		push	edx
		call	_ucbuf_getBuffer
		add	esp, 0Ch
		push	eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+38h]
		push	ecx
		call	_u_strncpy_56
		add	esp, 0Ch
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+38h]
		xor	edx, edx
		mov	[eax+ecx*2], dx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+3Ch]
		mov	[eax], edx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+38h]

loc_1A0A:				; CODE XREF: UPerfTest::getBuffer(int &,UErrorCode &)+3Aj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?getBuffer@UPerfTest@@QAEPB_WAAHAAW4UErrorCode@@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1A20h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall UPerfTest::run(UPerfTest *__hidden this)
		public ?run@UPerfTest@@QAECXZ
?run@UPerfTest@@QAECXZ proc near

var_FC		= byte ptr -0FCh
var_38		= dword	ptr -38h
Str		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_11		= byte ptr -11h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0FCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_FC]
		mov	ecx, 3Fh ; '?'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+28h], 1
		jnz	short loc_1A5D
		push	0		; char *
		push	0		; Str1
		mov	ecx, [ebp+var_8] ; this
		call	?runTest@UPerfTest@@QAECPAD0@Z ; UPerfTest::runTest(char *,char	*)
		jmp	loc_1B37
; ---------------------------------------------------------------------------

loc_1A5D:				; CODE XREF: UPerfTest::run(void)+2Aj
		mov	[ebp+var_11], 0
		mov	[ebp+var_20], 1
		jmp	short loc_1A73
; ---------------------------------------------------------------------------

loc_1A6A:				; CODE XREF: UPerfTest::run(void):loc_1B2Fj
		mov	eax, [ebp+var_20]
		add	eax, 1
		mov	[ebp+var_20], eax

loc_1A73:				; CODE XREF: UPerfTest::run(void)+48j
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_20]
		cmp	ecx, [eax+28h]
		jge	loc_1B34
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		mov	edx, [ebp+var_20]
		mov	eax, [ecx+edx*4]
		movsx	ecx, byte ptr [eax]
		cmp	ecx, 2Dh ; '-'
		jz	loc_1B2F
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		mov	edx, [ebp+var_20]
		mov	eax, [ecx+edx*4]
		mov	[ebp+Str], eax
		push	40h ; '@'       ; Val
		mov	eax, [ebp+Str]
		push	eax		; Str
		call	?strchr@@YAPADPADH@Z ; strchr(char *,int)
		add	esp, 8
		mov	[ebp+var_38], eax
		cmp	[ebp+var_38], 0
		jz	short loc_1ACF
		mov	eax, [ebp+var_38]
		mov	byte ptr [eax],	0
		mov	eax, [ebp+var_38]
		add	eax, 1
		mov	[ebp+var_38], eax

loc_1ACF:				; CODE XREF: UPerfTest::run(void)+9Ej
		mov	ds:_execCount, 0
		mov	eax, [ebp+var_38]
		push	eax		; char *
		mov	ecx, [ebp+Str]
		push	ecx		; Str1
		mov	ecx, [ebp+var_8] ; this
		call	?runTest@UPerfTest@@QAECPAD0@Z ; UPerfTest::runTest(char *,char	*)
		mov	[ebp+var_11], al
		movsx	eax, [ebp+var_11]
		test	eax, eax
		jz	short loc_1AFD
		cmp	ds:_execCount, 0
		jg	short loc_1B2F

loc_1AFD:				; CODE XREF: UPerfTest::run(void)+D2j
		mov	esi, esp
		mov	eax, [ebp+Str]
		push	eax
		push	offset ??_C@_0CE@BGDELAFC@?6?9?9?9ERROR?3?5Test?5doesn?8t?5exist?3?5?$CF@ ; "\n---ERROR: Test doesn't exist: %s!\n"
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 20h ; ' '
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		xor	al, al
		jmp	short loc_1B37
; ---------------------------------------------------------------------------

loc_1B2F:				; CODE XREF: UPerfTest::run(void)+74j
					; UPerfTest::run(void)+DBj
		jmp	loc_1A6A
; ---------------------------------------------------------------------------

loc_1B34:				; CODE XREF: UPerfTest::run(void)+5Cj
		mov	al, [ebp+var_11]

loc_1B37:				; CODE XREF: UPerfTest::run(void)+38j
					; UPerfTest::run(void)+10Dj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0FCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?run@UPerfTest@@QAECXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1B4Ch
		public ??_C@_0CE@BGDELAFC@?6?9?9?9ERROR?3?5Test?5doesn?8t?5exist?3?5?$CF@
; char `string'[]
??_C@_0CE@BGDELAFC@?6?9?9?9ERROR?3?5Test?5doesn?8t?5exist?3?5?$CF@ db 0Ah
					; DATA XREF: UPerfTest::run(void)+E3o
		db '---ERROR: Test doesn',27h,'t exist: %s!',0Ah,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1B70h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; char *__cdecl	strchr(char *Str, int Val)
		public ?strchr@@YAPADPADH@Z
?strchr@@YAPADPADH@Z proc near		; CODE XREF: UPerfTest::run(void)+8Fp
					; UPerfTest::runTest(char *,char *)+36p

var_C0		= byte ptr -0C0h
Str		= dword	ptr  8
Val		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	esi, esp
		mov	eax, [ebp+Val]
		push	eax		; Val
		mov	ecx, [ebp+Str]
		push	ecx		; Str
		call	dword ptr ds:__imp__strchr
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?strchr@@YAPADPADH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1BBCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall UPerfTest::runTest(UPerfTest	*this, char *Str1, char	*)
		public ?runTest@UPerfTest@@QAECPAD0@Z
?runTest@UPerfTest@@QAECPAD0@Z proc near ; CODE	XREF: UPerfTest::run(void)+33p
					; UPerfTest::run(void)+C4p ...

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_11		= byte ptr -11h
var_8		= dword	ptr -8
Str1		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_20], 0
		cmp	[ebp+Str1], 0
		jz	short loc_1BFD
		push	2Fh ; '/'       ; Val
		mov	eax, [ebp+Str1]
		push	eax		; Str
		call	?strchr@@YAPADPADH@Z ; strchr(char *,int)
		add	esp, 8
		mov	[ebp+var_20], eax

loc_1BFD:				; CODE XREF: UPerfTest::runTest(char *,char *)+2Ej
		cmp	[ebp+var_20], 0
		jz	short loc_1C17
		mov	eax, [ebp+var_20]
		add	eax, 1
		mov	ecx, [ebp+var_8]
		mov	[ecx+58h], eax
		mov	eax, [ebp+var_20]
		mov	byte ptr [eax],	0
		jmp	short loc_1C21
; ---------------------------------------------------------------------------

loc_1C17:				; CODE XREF: UPerfTest::runTest(char *,char *)+45j
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+58h], 0

loc_1C21:				; CODE XREF: UPerfTest::runTest(char *,char *)+59j
		cmp	[ebp+Str1], 0
		jz	short loc_1C46
		mov	eax, [ebp+Str1]
		movsx	ecx, byte ptr [eax]
		test	ecx, ecx
		jz	short loc_1C46
		push	offset ??_C@_01NBENCBCI@?$CK?$AA@ ; "*"
		mov	eax, [ebp+Str1]
		push	eax		; Str1
		call	_strcmp
		add	esp, 8
		test	eax, eax
		jnz	short loc_1C65

loc_1C46:				; CODE XREF: UPerfTest::runTest(char *,char *)+69j
					; UPerfTest::runTest(char *,char *)+73j
		mov	esi, esp
		push	0
		push	0
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+0Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_11], al
		jmp	short loc_1CB6
; ---------------------------------------------------------------------------

loc_1C65:				; CODE XREF: UPerfTest::runTest(char *,char *)+88j
		push	offset ??_C@_04PCOPKCKE@LIST?$AA@ ; "LIST"
		mov	eax, [ebp+Str1]
		push	eax		; Str1
		call	_strcmp
		add	esp, 8
		test	eax, eax
		jnz	short loc_1C95
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_11], 1
		jmp	short loc_1CB6
; ---------------------------------------------------------------------------

loc_1C95:				; CODE XREF: UPerfTest::runTest(char *,char *)+BCj
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+Str1]
		push	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx]
		mov	ecx, [ebp+var_8]
		mov	edx, [eax+0Ch]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_11], al

loc_1CB6:				; CODE XREF: UPerfTest::runTest(char *,char *)+A7j
					; UPerfTest::runTest(char *,char *)+D7j
		cmp	[ebp+var_20], 0
		jz	short loc_1CC2
		mov	eax, [ebp+var_20]
		mov	byte ptr [eax],	2Fh ; '/'

loc_1CC2:				; CODE XREF: UPerfTest::runTest(char *,char *)+FEj
		mov	al, [ebp+var_11]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?runTest@UPerfTest@@QAECPAD0@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1CDCh
		public ??_C@_04PCOPKCKE@LIST?$AA@
; char `string'[]
??_C@_04PCOPKCKE@LIST?$AA@ db 'LIST',0  ; DATA XREF: UPerfTest::runTest(char *,char *):loc_1C65o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1CE4h
		public ??_C@_01NBENCBCI@?$CK?$AA@
; char `string'[2]
??_C@_01NBENCBCI@?$CK?$AA@ db '*',0     ; DATA XREF: UPerfTest::runTest(char *,char *)+75o
		align 4
_rdata		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1CE8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall UPerfTest::setPath(UPerfTest *this, char *)
		public ?setPath@UPerfTest@@QAEXPAD@Z
?setPath@UPerfTest@@QAEXPAD@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+58h], ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?setPath@UPerfTest@@QAEXPAD@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1D20h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct UPerfFunction *__thiscall UPerfTest::runIndexedTest(UPerfTest *this, int, signed __int8, const	char **, char *)
		public ?runIndexedTest@UPerfTest@@MAEPAVUPerfFunction@@HCAAPBDPAD@Z
?runIndexedTest@UPerfTest@@MAEPAVUPerfFunction@@HCAAPBDPAD@Z proc near
					; DATA XREF: .rdata:00000E0Co

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		push	offset ??_C@_0CO@LMIDGJJA@?$CK?$CK?$CK?5runIndexedTest?5needs?5to?5be?5o@ ; "*** runIndexedTest	needs to be override"...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		xor	eax, eax
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?runIndexedTest@UPerfTest@@MAEPAVUPerfFunction@@HCAAPBDPAD@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1D88h
		public ??_C@_0CO@LMIDGJJA@?$CK?$CK?$CK?5runIndexedTest?5needs?5to?5be?5o@
; char `string'[]
??_C@_0CO@LMIDGJJA@?$CK?$CK?$CK?5runIndexedTest?5needs?5to?5be?5o@ db '*** runIndexedTest needs to be overriden! ***',0
					; DATA XREF: UPerfTest::runIndexedTest(int,signed char,char const * &,char *)+25o
		align 4
_rdata		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1DB8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall UPerfTest::runTestLoop(UPerfTest *this, char	*Str2, char *)
		public ?runTestLoop@UPerfTest@@MAECPAD0@Z
?runTestLoop@UPerfTest@@MAECPAD0@Z proc	near ; DATA XREF: .rdata:00000E10o

var_1F0		= qword	ptr -1F0h
var_1E4		= qword	ptr -1E4h
var_1DC		= qword	ptr -1DCh
var_1C8		= dword	ptr -1C8h
var_1C4		= dword	ptr -1C4h
var_1BC		= dword	ptr -1BCh
var_1B0		= dword	ptr -1B0h
var_E4		= qword	ptr -0E4h
var_D4		= dword	ptr -0D4h
var_C8		= dword	ptr -0C8h
var_BC		= qword	ptr -0BCh
var_AC		= qword	ptr -0ACh
var_9C		= dword	ptr -9Ch
var_90		= dword	ptr -90h
var_84		= dword	ptr -84h
var_78		= dword	ptr -78h
var_6C		= qword	ptr -6Ch
var_5C		= dword	ptr -5Ch
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_35		= byte ptr -35h
var_29		= byte ptr -29h
Str1		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
Str2		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 1C8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_1C8]
		mov	ecx, 72h ; 'r'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_14], 0
		mov	[ebp+var_35], 0
		mov	[ebp+var_44], 0
		mov	eax, ds:?gTest@UPerfTest@@2PAV1@A ; UPerfTest *	UPerfTest::gTest
		mov	[ebp+var_50], eax
		mov	eax, [ebp+var_8]
		mov	ds:?gTest@UPerfTest@@2PAV1@A, eax ; UPerfTest *	UPerfTest::gTest
		mov	[ebp+var_5C], 0
		fldz
		fstp	[ebp+var_6C]
		mov	[ebp+var_78], 1

loc_1E10:				; CODE XREF: UPerfTest::runTestLoop(char *,char	*)+8F7j
		mov	esi, esp
		push	0
		lea	eax, [ebp+Str1]
		push	eax
		push	0
		mov	ecx, [ebp+var_14]
		push	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx]
		mov	ecx, [ebp+var_8]
		mov	edx, [eax+8]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	[ebp+Str1], 0
		jz	short loc_1E42
		mov	eax, [ebp+Str1]
		movsx	ecx, byte ptr [eax]
		test	ecx, ecx
		jnz	short loc_1E47

loc_1E42:				; CODE XREF: UPerfTest::runTestLoop(char *,char	*)+7Ej
		jmp	loc_26B5
; ---------------------------------------------------------------------------

loc_1E47:				; CODE XREF: UPerfTest::runTestLoop(char *,char	*)+88j
		cmp	[ebp+Str2], 0
		jnz	short loc_1E53
		mov	[ebp+var_29], 1
		jmp	short loc_1E6B
; ---------------------------------------------------------------------------

loc_1E53:				; CODE XREF: UPerfTest::runTestLoop(char *,char	*)+93j
		mov	eax, [ebp+Str2]
		push	eax		; Str2
		mov	ecx, [ebp+Str1]
		push	ecx		; Str1
		call	_strcmp
		add	esp, 8
		test	eax, eax
		setz	dl
		mov	[ebp+var_29], dl

loc_1E6B:				; CODE XREF: UPerfTest::runTestLoop(char *,char	*)+99j
		movsx	eax, [ebp+var_29]
		test	eax, eax
		jz	loc_26A2
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax
		lea	ecx, [ebp+Str1]
		push	ecx
		push	1
		mov	edx, [ebp+var_14]
		push	edx
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_90], eax
		mov	eax, ds:_execCount
		add	eax, 1
		mov	ds:_execCount, eax
		mov	[ebp+var_35], 1
		cmp	[ebp+var_90], 0
		jnz	short loc_1EF0
		mov	esi, esp
		mov	eax, [ebp+Str1]
		push	eax
		push	offset ??_C@_0BK@FCJFGPEI@?$CFs?5function?5returned?5NULL?$AA@ ; "%s function returned NULL"
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		xor	al, al
		jmp	loc_26C0
; ---------------------------------------------------------------------------

loc_1EF0:				; CODE XREF: UPerfTest::runTestLoop(char *,char	*)+101j
		mov	eax, [ebp+var_90]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_90]
		mov	eax, [edx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_84], eax
		cmp	[ebp+var_84], 1
		jge	short loc_1F50
		mov	esi, esp
		mov	eax, [ebp+Str1]
		push	eax
		push	offset ??_C@_0CP@NMJIIHCA@?$CFs?5returned?5an?5illegal?5operation@ ; "%s returned an illegal operations/itera"...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		xor	al, al
		jmp	loc_26C0
; ---------------------------------------------------------------------------

loc_1F50:				; CODE XREF: UPerfTest::runTestLoop(char *,char	*)+161j
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+48h], 0
		jnz	loc_20BE
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4Ch]
		mov	[ebp+var_78], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+40h]
		cmp	ecx, 1
		jnz	short loc_1FA4
		mov	esi, esp
		mov	eax, [ebp+var_78]
		push	eax
		mov	ecx, [ebp+Str1]
		push	ecx
		push	offset ??_C@_0BO@DPGPFGBP@?$DN?5?$CFs?5calibrating?5?$CFi?5seconds?5?6?$AA@ ; "= %s calibrating	%i seconds \n"
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 20h ; ' '
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 10h
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_1FA4:				; CODE XREF: UPerfTest::runTestLoop(char *,char	*)+1B8j
		mov	[ebp+var_9C], 1
		fldz
		fstp	[ebp+var_6C]

loc_1FB3:				; CODE XREF: UPerfTest::runTestLoop(char *,char	*):loc_20B7j
		fild	[ebp+var_78]
		fmul	ds:__real@3feccccccccccccd
		call	__ftol2_sse
		mov	[ebp+var_1C4], eax
		fild	[ebp+var_1C4]
		fcomp	[ebp+var_6C]
		fnstsw	ax
		test	ah, 41h
		jnz	loc_20BC
		cmp	[ebp+var_5C], 0
		jz	short loc_1FEF
		fld	[ebp+var_6C]
		fldz
		fucompp
		fnstsw	ax
		test	ah, 44h
		jp	short loc_2009

loc_1FEF:				; CODE XREF: UPerfTest::runTestLoop(char *,char	*)+227j
		mov	eax, [ebp+var_9C]
		mov	[ebp+var_5C], eax
		mov	eax, [ebp+var_9C]
		imul	eax, 0Ah
		mov	[ebp+var_9C], eax
		jmp	short loc_2057
; ---------------------------------------------------------------------------

loc_2009:				; CODE XREF: UPerfTest::runTestLoop(char *,char	*)+235j
		fild	[ebp+var_78]
		fdiv	[ebp+var_6C]
		fimul	[ebp+var_5C]
		fadd	ds:__real@3fe0000000000000
		call	__ftol2_sse
		mov	[ebp+var_5C], eax
		cmp	[ebp+var_5C], 0
		jnz	short loc_2057
		mov	esi, esp
		push	offset ??_C@_0CH@KJLAKLPI@Unable?5to?5converge?5on?5desired?5du@ ; "Unable to converge on desired duration"
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		xor	al, al
		jmp	loc_26C0
; ---------------------------------------------------------------------------

loc_2057:				; CODE XREF: UPerfTest::runTestLoop(char *,char	*)+24Fj
					; UPerfTest::runTestLoop(char *,char *)+26Cj
		mov	esi, esp
		lea	eax, [ebp+var_44]
		push	eax
		mov	ecx, [ebp+var_5C]
		push	ecx
		mov	edx, [ebp+var_90]
		mov	eax, [edx]
		mov	ecx, [ebp+var_90]
		mov	edx, [eax+10h]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		fstp	[ebp+var_6C]
		mov	eax, [ebp+var_44]
		push	eax
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_20B7
		mov	eax, [ebp+var_44]
		push	eax
		call	_u_errorName_56
		add	esp, 4
		mov	esi, esp
		push	eax
		push	offset ??_C@_0CJ@JFALIDEG@Performance?5test?5failed?5with?5err@	; "Performance test failed with	error: %s "...
		call	dword ptr ds:__imp__printf
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_20BC
; ---------------------------------------------------------------------------

loc_20B7:				; CODE XREF: UPerfTest::runTestLoop(char *,char	*)+2D7j
		jmp	loc_1FB3
; ---------------------------------------------------------------------------

loc_20BC:				; CODE XREF: UPerfTest::runTestLoop(char *,char	*)+21Dj
					; UPerfTest::runTestLoop(char *,char *)+2FDj
		jmp	short loc_20C7
; ---------------------------------------------------------------------------

loc_20BE:				; CODE XREF: UPerfTest::runTestLoop(char *,char	*)+19Fj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+48h]
		mov	[ebp+var_5C], ecx

loc_20C7:				; CODE XREF: UPerfTest::runTestLoop(char *,char	*):loc_20BCj
		fld	ds:__real@412e848000000000
		fstp	[ebp+var_AC]
		fldz
		fstp	[ebp+var_BC]
		mov	[ebp+var_C8], 0FFFFFFFFh
		mov	[ebp+var_D4], 0
		jmp	short loc_2100
; ---------------------------------------------------------------------------

loc_20F1:				; CODE XREF: UPerfTest::runTestLoop(char *,char	*):loc_23CDj
		mov	eax, [ebp+var_D4]
		add	eax, 1
		mov	[ebp+var_D4], eax

loc_2100:				; CODE XREF: UPerfTest::runTestLoop(char *,char	*)+337j
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_D4]
		cmp	ecx, [eax+44h]
		jge	loc_23D2
		mov	esi, esp
		mov	eax, [ebp+Str1]
		push	eax
		push	offset ??_C@_0M@OPPNMGAG@?$DN?5?$CFs?5begin?5?$AA@ ; "=	%s begin "
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 20h ; ' '
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+40h]
		cmp	ecx, 1
		jnz	short loc_21B5
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+48h], 0
		jle	short loc_2185
		mov	esi, esp
		mov	eax, [ebp+var_5C]
		push	eax
		push	offset ??_C@_03PELOGHMK@?$CFi?6?$AA@ ; "%i\n"
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 20h ; ' '
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_21B3
; ---------------------------------------------------------------------------

loc_2185:				; CODE XREF: UPerfTest::runTestLoop(char *,char	*)+39Bj
		mov	esi, esp
		mov	eax, [ebp+var_78]
		push	eax
		push	offset ??_C@_03PELOGHMK@?$CFi?6?$AA@ ; "%i\n"
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 20h ; ' '
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_21B3:				; CODE XREF: UPerfTest::runTestLoop(char *,char	*)+3CBj
		jmp	short loc_21DF
; ---------------------------------------------------------------------------

loc_21B5:				; CODE XREF: UPerfTest::runTestLoop(char *,char	*)+392j
		mov	esi, esp
		push	offset ??_C@_01EEMJAFIK@?6?$AA@	; "\n"
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 20h ; ' '
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_21DF:				; CODE XREF: UPerfTest::runTestLoop(char *,char	*):loc_21B3j
		mov	esi, esp
		lea	eax, [ebp+var_44]
		push	eax
		mov	ecx, [ebp+var_5C]
		push	ecx
		mov	edx, [ebp+var_90]
		mov	eax, [edx]
		mov	ecx, [ebp+var_90]
		mov	edx, [eax+10h]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		fstp	[ebp+var_6C]
		mov	eax, [ebp+var_44]
		push	eax
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_2242
		mov	eax, [ebp+var_44]
		push	eax
		call	_u_errorName_56
		add	esp, 4
		mov	esi, esp
		push	eax
		push	offset ??_C@_0CJ@JFALIDEG@Performance?5test?5failed?5with?5err@	; "Performance test failed with	error: %s "...
		call	dword ptr ds:__imp__printf
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	loc_23D2
; ---------------------------------------------------------------------------

loc_2242:				; CODE XREF: UPerfTest::runTestLoop(char *,char	*)+45Fj
		fld	[ebp+var_BC]
		fadd	[ebp+var_6C]
		fstp	[ebp+var_BC]
		fld	[ebp+var_AC]
		fcomp	[ebp+var_6C]
		fnstsw	ax
		test	ah, 41h
		jnz	short loc_226A
		fld	[ebp+var_6C]
		fstp	[ebp+var_AC]

loc_226A:				; CODE XREF: UPerfTest::runTestLoop(char *,char	*)+4A7j
		mov	eax, [ebp+var_90]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_90]
		mov	eax, [edx+0Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_C8], eax
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+40h]
		cmp	ecx, 1
		jnz	loc_2337
		cmp	[ebp+var_C8], 0FFFFFFFFh
		jnz	short loc_22E9
		mov	esi, esp
		mov	eax, [ebp+var_84]
		push	eax
		mov	ecx, [ebp+var_5C]
		push	ecx
		sub	esp, 8
		fld	[ebp+var_6C]
		fstp	[esp+1E4h+var_1E4]
		mov	edx, [ebp+Str1]
		push	edx
		push	offset ??_C@_0CJ@KFLKAPCK@?$DN?5?$CFs?5end?3?5?$CFf?5loops?3?5?$CFi?5operation@	; "= %s	end: %f	loops: %i operations: %li "...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 20h ; ' '
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 1Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_2332
; ---------------------------------------------------------------------------

loc_22E9:				; CODE XREF: UPerfTest::runTestLoop(char *,char	*)+4EBj
		mov	esi, esp
		mov	eax, [ebp+var_C8]
		push	eax
		mov	ecx, [ebp+var_84]
		push	ecx
		mov	edx, [ebp+var_5C]
		push	edx
		sub	esp, 8
		fld	[ebp+var_6C]
		fstp	qword ptr [esp]
		mov	eax, [ebp+Str1]
		push	eax
		push	offset ??_C@_0DE@OHJBABJJ@?$DN?5?$CFs?5end?3?5?$CFf?5loops?3?5?$CFi?5operation@	; "= %s	end: %f	loops: %i operations: %li "...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 20h ; ' '
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 20h
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_2332:				; CODE XREF: UPerfTest::runTestLoop(char *,char	*)+52Fj
		jmp	loc_23CD
; ---------------------------------------------------------------------------

loc_2337:				; CODE XREF: UPerfTest::runTestLoop(char *,char	*)+4DEj
		cmp	[ebp+var_C8], 0FFFFFFFFh
		jnz	short loc_2384
		mov	esi, esp
		mov	eax, [ebp+var_84]
		push	eax
		mov	ecx, [ebp+var_5C]
		push	ecx
		sub	esp, 8
		fld	[ebp+var_6C]
		fstp	[esp+1E4h+var_1E4]
		mov	edx, [ebp+Str1]
		push	edx
		push	offset ??_C@_0BE@CHADNHJA@?$DN?5?$CFs?5end?5?$CFf?5?$CFi?5?$CFli?6?$AA@	; "= %s	end %f %i %li\n"
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 20h ; ' '
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 1Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_23CD
; ---------------------------------------------------------------------------

loc_2384:				; CODE XREF: UPerfTest::runTestLoop(char *,char	*)+586j
		mov	esi, esp
		mov	eax, [ebp+var_C8]
		push	eax
		mov	ecx, [ebp+var_84]
		push	ecx
		mov	edx, [ebp+var_5C]
		push	edx
		sub	esp, 8
		fld	[ebp+var_6C]
		fstp	qword ptr [esp]
		mov	eax, [ebp+Str1]
		push	eax
		push	offset ??_C@_0BI@NIKOPCAD@?$DN?5?$CFs?5end?5?$CFf?5?$CFi?5?$CFli?5?$CFli?6?$AA@	; "= %s	end %f %i %li %li\n"
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 20h ; ' '
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 20h
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_23CD:				; CODE XREF: UPerfTest::runTestLoop(char *,char	*):loc_2332j
					; UPerfTest::runTestLoop(char *,char *)+5CAj
		jmp	loc_20F1
; ---------------------------------------------------------------------------

loc_23D2:				; CODE XREF: UPerfTest::runTestLoop(char *,char	*)+354j
					; UPerfTest::runTestLoop(char *,char *)+485j
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+40h]
		test	ecx, ecx
		jz	loc_2652
		mov	eax, [ebp+var_44]
		push	eax
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	loc_2652
		mov	eax, [ebp+var_8]
		fild	dword ptr [eax+44h]
		fdivr	[ebp+var_BC]
		fstp	[ebp+var_E4]
		cmp	[ebp+var_5C], 0
		jz	short loc_2419
		cmp	[ebp+var_84], 0
		jnz	short loc_244C

loc_2419:				; CODE XREF: UPerfTest::runTestLoop(char *,char	*)+656j
		mov	esi, esp
		mov	eax, [ebp+Str1]
		push	eax
		push	offset ??_C@_0BA@JFDCCOHJ@?$CFs?5did?5not?5run?6?$AA@ ;	"%s did	not run\n"
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	loc_2652
; ---------------------------------------------------------------------------

loc_244C:				; CODE XREF: UPerfTest::runTestLoop(char *,char	*)+65Fj
		cmp	[ebp+var_C8], 0FFFFFFFFh
		jnz	loc_252E
		fld	[ebp+var_E4]
		fmul	ds:__real@41cdcd6500000000
		mov	eax, [ebp+var_5C]
		imul	eax, [ebp+var_84]
		mov	[ebp+var_1C4], eax
		fild	[ebp+var_1C4]
		fdivp	st(1), st
		mov	esi, esp
		sub	esp, 8
		fstp	[esp+1DCh+var_1DC]
		mov	ecx, [ebp+var_5C]
		push	ecx
		sub	esp, 8
		fld	[ebp+var_E4]
		fstp	qword ptr [esp]
		mov	edx, [ebp+Str1]
		push	edx
		push	offset ??_C@_0CM@CAIGJCLE@?$CF?$CF?$DN?5?$CFs?5avg?3?5?$CF?44g?5loops?3?5?$CFi?5avg?1o@	; "%%= %s avg: %.4g loops: %i avg/op: %.4g"...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 20h ; ' '
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 20h
		cmp	esi, esp
		call	__RTC_CheckEsp
		fld	[ebp+var_AC]
		fmul	ds:__real@41cdcd6500000000
		mov	eax, [ebp+var_5C]
		imul	eax, [ebp+var_84]
		mov	[ebp+var_1C4], eax
		fild	[ebp+var_1C4]
		fdivp	st(1), st
		mov	esi, esp
		sub	esp, 8
		fstp	[esp+1DCh+var_1DC]
		mov	ecx, [ebp+var_5C]
		push	ecx
		sub	esp, 8
		fld	[ebp+var_AC]
		fstp	qword ptr [esp]
		mov	edx, [ebp+Str1]
		push	edx
		push	offset ??_C@_0CL@FGKMDIJE@_?$DN?5?$CFs?5min?3?5?$CF?44g?5loops?3?5?$CFi?5min?1op@ ; "_=	%s min:	%.4g loops: %i min/op: %.4g "...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 20h ; ' '
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 20h
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	loc_2652
; ---------------------------------------------------------------------------

loc_252E:				; CODE XREF: UPerfTest::runTestLoop(char *,char	*)+69Bj
		fld	[ebp+var_E4]
		fmul	ds:__real@41cdcd6500000000
		mov	eax, [ebp+var_5C]
		imul	eax, [ebp+var_C8]
		mov	[ebp+var_1C4], eax
		fild	[ebp+var_1C4]
		fdivp	st(1), st
		mov	esi, esp
		sub	esp, 8
		fstp	[esp+1DCh+var_1DC]
		fld	[ebp+var_E4]
		fmul	ds:__real@41cdcd6500000000
		mov	ecx, [ebp+var_5C]
		imul	ecx, [ebp+var_84]
		mov	[ebp+var_1C8], ecx
		fild	[ebp+var_1C8]
		fdivp	st(1), st
		sub	esp, 8
		fstp	[esp+1E4h+var_1E4]
		mov	edx, [ebp+var_5C]
		push	edx
		sub	esp, 8
		fld	[ebp+var_E4]
		fstp	[esp+1F0h+var_1F0]
		mov	eax, [ebp+Str1]
		push	eax
		push	offset ??_C@_0DP@DMEJJKKH@?$CF?$CF?$DN?5?$CFs?5avg?3?5?$CF?44g?5loops?3?5?$CFi?5avg?1o@	; "%%= %s avg: %.4g loops: %i avg/op: %.4g"...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 20h ; ' '
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 28h
		cmp	esi, esp
		call	__RTC_CheckEsp
		fld	[ebp+var_AC]
		fmul	ds:__real@41cdcd6500000000
		mov	eax, [ebp+var_5C]
		imul	eax, [ebp+var_C8]
		mov	[ebp+var_1C4], eax
		fild	[ebp+var_1C4]
		fdivp	st(1), st
		mov	esi, esp
		sub	esp, 8
		fstp	[esp+1DCh+var_1DC]
		fld	[ebp+var_AC]
		fmul	ds:__real@41cdcd6500000000
		mov	ecx, [ebp+var_5C]
		imul	ecx, [ebp+var_84]
		mov	[ebp+var_1C8], ecx
		fild	[ebp+var_1C8]
		fdivp	st(1), st
		sub	esp, 8
		fstp	[esp+1E4h+var_1E4]
		mov	edx, [ebp+var_5C]
		push	edx
		sub	esp, 8
		fld	[ebp+var_AC]
		fstp	[esp+1F0h+var_1F0]
		mov	eax, [ebp+Str1]
		push	eax
		push	offset ??_C@_0DO@BAPFMIBB@_?$DN?5?$CFs?5min?3?5?$CF?44g?5loops?3?5?$CFi?5min?1op@ ; "_=	%s min:	%.4g loops: %i min/op: %.4g "...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 20h ; ' '
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 28h
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_2652:				; CODE XREF: UPerfTest::runTestLoop(char *,char	*)+623j
					; UPerfTest::runTestLoop(char *,char *)+63Aj ...
		mov	eax, [ebp+var_90]
		mov	[ebp+var_1B0], eax
		mov	ecx, [ebp+var_1B0]
		mov	[ebp+var_1BC], ecx
		cmp	[ebp+var_1BC], 0
		jz	short loc_2698
		mov	esi, esp
		push	1
		mov	edx, [ebp+var_1BC]
		mov	eax, [edx]
		mov	ecx, [ebp+var_1BC]
		mov	edx, [eax]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_1C4], eax
		jmp	short loc_26A2
; ---------------------------------------------------------------------------

loc_2698:				; CODE XREF: UPerfTest::runTestLoop(char *,char	*)+8B9j
		mov	[ebp+var_1C4], 0

loc_26A2:				; CODE XREF: UPerfTest::runTestLoop(char *,char	*)+B9j
					; UPerfTest::runTestLoop(char *,char *)+8DEj
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax
		cmp	[ebp+Str1], 0
		jnz	loc_1E10

loc_26B5:				; CODE XREF: UPerfTest::runTestLoop(char *,char	*):loc_1E42j
		mov	eax, [ebp+var_50]
		mov	ds:?gTest@UPerfTest@@2PAV1@A, eax ; UPerfTest *	UPerfTest::gTest
		mov	al, [ebp+var_35]

loc_26C0:				; CODE XREF: UPerfTest::runTestLoop(char *,char	*)+133j
					; UPerfTest::runTestLoop(char *,char *)+193j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN49
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 1C8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?runTestLoop@UPerfTest@@MAECPAD0@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN49		dd 2			; DATA XREF: UPerfTest::runTestLoop(char *,char	*)+90Co
		dd offset $LN48
$LN48		dd 0FFFFFFE0h, 4	; DATA XREF: .text:000026ECo
		dd offset $LN46		; "name"
		dd 0FFFFFFBCh, 4
		dd offset $LN47		; "status"
$LN47		db 'status',0           ; DATA XREF: .text:00002704o
$LN46		db 'name',0             ; DATA XREF: .text:000026F8o
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2714h
		public ??_C@_0DO@BAPFMIBB@_?$DN?5?$CFs?5min?3?5?$CF?44g?5loops?3?5?$CFi?5min?1op@
; char `string'[]
??_C@_0DO@BAPFMIBB@_?$DN?5?$CFs?5min?3?5?$CF?44g?5loops?3?5?$CFi?5min?1op@ db '_= %s min: %.4g loops: %i min/op: %.4g ns min/event: %.4g ns',0Ah,0
					; DATA XREF: UPerfTest::runTestLoop(char *,char	*)+872o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2754h
		public ??_C@_0DP@DMEJJKKH@?$CF?$CF?$DN?5?$CFs?5avg?3?5?$CF?44g?5loops?3?5?$CFi?5avg?1o@
; char `string'[]
??_C@_0DP@DMEJJKKH@?$CF?$CF?$DN?5?$CFs?5avg?3?5?$CF?44g?5loops?3?5?$CFi?5avg?1o@ db '%%= %s avg: %.4g loops: %i avg/op: %.4g ns avg/event: %.4g ns',0Ah,0
					; DATA XREF: UPerfTest::runTestLoop(char *,char	*)+7E0o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2794h
		public ??_C@_0CL@FGKMDIJE@_?$DN?5?$CFs?5min?3?5?$CF?44g?5loops?3?5?$CFi?5min?1op@
; char `string'[]
??_C@_0CL@FGKMDIJE@_?$DN?5?$CFs?5min?3?5?$CF?44g?5loops?3?5?$CFi?5min?1op@ db '_= %s min: %.4g loops: %i min/op: %.4g ns',0Ah,0
					; DATA XREF: UPerfTest::runTestLoop(char *,char	*)+749o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 27C0h
		public ??_C@_0CM@CAIGJCLE@?$CF?$CF?$DN?5?$CFs?5avg?3?5?$CF?44g?5loops?3?5?$CFi?5avg?1o@
; char `string'[]
??_C@_0CM@CAIGJCLE@?$CF?$CF?$DN?5?$CFs?5avg?3?5?$CF?44g?5loops?3?5?$CFi?5avg?1o@ db '%%= %s avg: %.4g loops: %i avg/op: %.4g ns',0Ah,0
					; DATA XREF: UPerfTest::runTestLoop(char *,char	*)+6E1o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 27ECh
		public __real@41cdcd6500000000
__real@41cdcd6500000000	dq 1.0e9	; DATA XREF: UPerfTest::runTestLoop(char *,char	*)+6A7r
					; UPerfTest::runTestLoop(char *,char *)+70Fr ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 27F4h
		public ??_C@_0BA@JFDCCOHJ@?$CFs?5did?5not?5run?6?$AA@
; char `string'[]
??_C@_0BA@JFDCCOHJ@?$CFs?5did?5not?5run?6?$AA@ db '%s did not run',0Ah,0
					; DATA XREF: UPerfTest::runTestLoop(char *,char	*)+667o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2804h
		public ??_C@_0BI@NIKOPCAD@?$DN?5?$CFs?5end?5?$CFf?5?$CFi?5?$CFli?5?$CFli?6?$AA@
; char `string'[]
??_C@_0BI@NIKOPCAD@?$DN?5?$CFs?5end?5?$CFf?5?$CFi?5?$CFli?5?$CFli?6?$AA@ db '= %s end %f %i %li %li',0Ah,0
					; DATA XREF: UPerfTest::runTestLoop(char *,char	*)+5EDo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 281Ch
		public ??_C@_0BE@CHADNHJA@?$DN?5?$CFs?5end?5?$CFf?5?$CFi?5?$CFli?6?$AA@
; char `string'[]
??_C@_0BE@CHADNHJA@?$DN?5?$CFs?5end?5?$CFf?5?$CFi?5?$CFli?6?$AA@ db '= %s end %f %i %li',0Ah,0
					; DATA XREF: UPerfTest::runTestLoop(char *,char	*)+5A2o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2830h
		public ??_C@_0DE@OHJBABJJ@?$DN?5?$CFs?5end?3?5?$CFf?5loops?3?5?$CFi?5operation@
; char `string'[]
??_C@_0DE@OHJBABJJ@?$DN?5?$CFs?5end?3?5?$CFf?5loops?3?5?$CFi?5operation@ db '= %s end: %f loops: %i operations: %li events: %li',0Ah,0
					; DATA XREF: UPerfTest::runTestLoop(char *,char	*)+552o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2864h
		public ??_C@_0CJ@KFLKAPCK@?$DN?5?$CFs?5end?3?5?$CFf?5loops?3?5?$CFi?5operation@
; char `string'[]
??_C@_0CJ@KFLKAPCK@?$DN?5?$CFs?5end?3?5?$CFf?5loops?3?5?$CFi?5operation@ db '= %s end: %f loops: %i operations: %li ',0Ah,0
					; DATA XREF: UPerfTest::runTestLoop(char *,char	*)+507o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2890h
		public ??_C@_01EEMJAFIK@?6?$AA@
; char `string'[2]
??_C@_01EEMJAFIK@?6?$AA@ db 0Ah,0	; DATA XREF: UPerfTest::runTestLoop(char *,char	*)+3FFo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2894h
		public ??_C@_03PELOGHMK@?$CFi?6?$AA@
; char `string'[4]
??_C@_03PELOGHMK@?$CFi?6?$AA@ db '%i',0Ah,0
					; DATA XREF: UPerfTest::runTestLoop(char *,char	*)+3A3o
					; UPerfTest::runTestLoop(char *,char *)+3D3o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2898h
		public ??_C@_0M@OPPNMGAG@?$DN?5?$CFs?5begin?5?$AA@
; char `string'[]
??_C@_0M@OPPNMGAG@?$DN?5?$CFs?5begin?5?$AA@ db '= %s begin ',0
					; DATA XREF: UPerfTest::runTestLoop(char *,char	*)+360o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 28A4h
		public __real@412e848000000000
__real@412e848000000000	dq 1000000.0	; DATA XREF: UPerfTest::runTestLoop(char *,char	*):loc_20C7r
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 28ACh
		public ??_C@_0CJ@JFALIDEG@Performance?5test?5failed?5with?5err@
; char `string'[]
??_C@_0CJ@JFALIDEG@Performance?5test?5failed?5with?5err@ db 'Performance test failed with error: %s ',0Ah,0
					; DATA XREF: UPerfTest::runTestLoop(char *,char	*)+2E8o
					; UPerfTest::runTestLoop(char *,char *)+470o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 28D8h
		public ??_C@_0CH@KJLAKLPI@Unable?5to?5converge?5on?5desired?5du@
; char `string'[]
??_C@_0CH@KJLAKLPI@Unable?5to?5converge?5on?5desired?5du@ db 'Unable to converge on desired duration',0
					; DATA XREF: UPerfTest::runTestLoop(char *,char	*)+270o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 2900h
		public __real@3fe0000000000000
__real@3fe0000000000000	dq 0.5		; DATA XREF: UPerfTest::runTestLoop(char *,char	*)+25Ar
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 2908h
		public __real@3feccccccccccccd
__real@3feccccccccccccd	dq 0.9		; DATA XREF: UPerfTest::runTestLoop(char *,char	*)+1FEr
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2910h
		public ??_C@_0BO@DPGPFGBP@?$DN?5?$CFs?5calibrating?5?$CFi?5seconds?5?6?$AA@
; char `string'[]
??_C@_0BO@DPGPFGBP@?$DN?5?$CFs?5calibrating?5?$CFi?5seconds?5?6?$AA@ db	'= %s calibrating %i seconds ',0Ah,0
					; DATA XREF: UPerfTest::runTestLoop(char *,char	*)+1C4o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2930h
		public ??_C@_0CP@NMJIIHCA@?$CFs?5returned?5an?5illegal?5operation@
; char `string'[]
??_C@_0CP@NMJIIHCA@?$CFs?5returned?5an?5illegal?5operation@ db '%s returned an illegal operations/iteration()',0Ah,0
					; DATA XREF: UPerfTest::runTestLoop(char *,char	*)+169o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2960h
		public ??_C@_0BK@FCJFGPEI@?$CFs?5function?5returned?5NULL?$AA@
; char `string'[]
??_C@_0BK@FCJFGPEI@?$CFs?5function?5returned?5NULL?$AA@	db '%s function returned NULL',0
					; DATA XREF: UPerfTest::runTestLoop(char *,char	*)+109o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 297Ch
		public __real@0000000000000000
__real@0000000000000000	dd 2 dup(0)
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2984h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl U_SUCCESS(enum  UErrorCode)
?U_SUCCESS@@YACW4UErrorCode@@@Z	proc near
					; CODE XREF: UPerfTest::runTestLoop(char *,char	*)+62Dp

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		setle	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?U_SUCCESS@@YACW4UErrorCode@@@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 29B0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall UPerfTest::usage(UPerfTest *__hidden this)
		public ?usage@UPerfTest@@UAEXXZ
?usage@UPerfTest@@UAEXXZ proc near	; DATA XREF: .rdata:const UPerfTest::`vftable'o

var_F0		= byte ptr -0F0h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_11		= byte ptr -11h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0F0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F0]
		mov	ecx, 3Ch ; '<'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		push	offset ?gUsageString@UPerfTest@@2QBDB ;	"Usage:	%s [OPTIONS] [FILES]\n\tReads th"...
		call	dword ptr ds:__imp__puts
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+0Ch], 0
		jz	short loc_2A0C
		mov	esi, esp
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		push	ecx		; Str
		call	dword ptr ds:__imp__puts
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_2A0C:				; CODE XREF: UPerfTest::usage(void)+41j
		mov	eax, [ebp+var_8]
		mov	cl, [eax+40h]
		mov	[ebp+var_11], cl
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+40h], 1
		mov	esi, esp
		push	offset ??_C@_0N@DEFLPKOO@Test?5names?3?6?$AA@ ;	"Test names:\n"
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 20h ; ' '
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		push	offset ??_C@_0N@NAAKPPPI@?9?9?9?9?9?9?9?9?9?9?9?6?$AA@ ; "-----------\n"
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 20h ; ' '
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_20], 0
		mov	[ebp+var_2C], 0

loc_2A7E:				; CODE XREF: UPerfTest::usage(void)+13Dj
		mov	esi, esp
		push	0
		lea	eax, [ebp+var_2C]
		push	eax
		push	0
		mov	ecx, [ebp+var_20]
		push	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx]
		mov	ecx, [ebp+var_8]
		mov	edx, [eax+8]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	[ebp+var_2C], 0
		jnz	short loc_2AA8
		jmp	short loc_2AEF
; ---------------------------------------------------------------------------

loc_2AA8:				; CODE XREF: UPerfTest::usage(void)+F4j
		mov	esi, esp
		mov	eax, [ebp+var_2C]
		push	eax
		push	offset ??_C@_03OFAPEBGM@?$CFs?6?$AA@ ; "%s\n"
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 20h ; ' '
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_20]
		add	eax, 1
		mov	[ebp+var_20], eax
		cmp	[ebp+var_2C], 0
		jz	short loc_2AEF
		mov	eax, [ebp+var_2C]
		movsx	ecx, byte ptr [eax]
		test	ecx, ecx
		jnz	short loc_2A7E

loc_2AEF:				; CODE XREF: UPerfTest::usage(void)+F6j
					; UPerfTest::usage(void)+133j
		mov	eax, [ebp+var_8]
		mov	cl, [ebp+var_11]
		mov	[eax+40h], cl
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN11_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?usage@UPerfTest@@UAEXXZ endp

; ---------------------------------------------------------------------------
		align 10h
$LN11_0		dd 1			; DATA XREF: UPerfTest::usage(void)+14Co
		dd offset $LN10_0
$LN10_0		dd 0FFFFFFD4h, 4	; DATA XREF: .text:00002B24o
		dd offset $LN9_0	; "name"
$LN9_0		db 'name',0             ; DATA XREF: .text:00002B30o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2B3Ch
		public ??_C@_03OFAPEBGM@?$CFs?6?$AA@
; char `string'[4]
??_C@_03OFAPEBGM@?$CFs?6?$AA@ db '%s',0Ah,0 ; DATA XREF: UPerfTest::usage(void)+FEo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2B40h
		public ??_C@_0N@NAAKPPPI@?9?9?9?9?9?9?9?9?9?9?9?6?$AA@
; char `string'[]
??_C@_0N@NAAKPPPI@?9?9?9?9?9?9?9?9?9?9?9?6?$AA@	db '-----------',0Ah,0
					; DATA XREF: UPerfTest::usage(void)+98o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2B50h
		public ??_C@_0N@DEFLPKOO@Test?5names?3?6?$AA@
; char `string'[]
??_C@_0N@DEFLPKOO@Test?5names?3?6?$AA@ db 'Test names:',0Ah,0
					; DATA XREF: UPerfTest::usage(void)+6Eo
		align 10h
_rdata		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2B60h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall UPerfTest::setCaller(UPerfTest *this,	struct UPerfTest *)
		public ?setCaller@UPerfTest@@QAEXPAV1@@Z
?setCaller@UPerfTest@@QAEXPAV1@@Z proc near
					; CODE XREF: UPerfTest::callTest(UPerfTest &,char *)+37p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+54h], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+54h], 0
		jz	short loc_2BA4
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+54h]
		mov	edx, [ebp+var_8]
		mov	al, [ecx+40h]
		mov	[edx+40h], al

loc_2BA4:				; CODE XREF: UPerfTest::setCaller(UPerfTest *)+33j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?setCaller@UPerfTest@@QAEXPAV1@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2BB0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall UPerfTest::callTest(UPerfTest *this,	struct UPerfTest *, char *)
		public ?callTest@UPerfTest@@MAECAAV1@PAD@Z
?callTest@UPerfTest@@MAECAAV1@PAD@Z proc near ;	DATA XREF: .rdata:00000E14o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, ds:_execCount
		sub	eax, 1
		mov	ds:_execCount, eax
		mov	eax, [ebp+var_8]
		push	eax		; struct UPerfTest *
		mov	ecx, [ebp+arg_0] ; this
		call	?setCaller@UPerfTest@@QAEXPAV1@@Z ; UPerfTest::setCaller(UPerfTest *)
		mov	eax, [ebp+arg_4]
		push	eax		; char *
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+58h]
		push	edx		; Str1
		mov	ecx, [ebp+arg_0] ; this
		call	?runTest@UPerfTest@@QAECPAD0@Z ; UPerfTest::runTest(char *,char	*)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?callTest@UPerfTest@@MAECAAV1@PAD@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2C18h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall UPerfTest::~UPerfTest(UPerfTest *__hidden this)
		public ??1UPerfTest@@UAE@XZ
??1UPerfTest@@UAE@XZ proc near		; CODE XREF: UPerfTest::`scalar	deleting destructor'(uint)+26p
					; UPerfTest::`vector deleting destructor'(uint)+64p
					; DATA XREF: ...

var_D8		= byte ptr -0D8h
var_D4		= dword	ptr -0D4h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UPerfTest@@6B@ ; const UPerfTest::`vftable'
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+2Ch], 0
		jz	short loc_2C68
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+2Ch]
		mov	[ebp+var_D4], ecx
		mov	edx, [ebp+var_D4]
		push	edx		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_2C68:				; CODE XREF: UPerfTest::~UPerfTest(void)+33j
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+38h], 0
		jz	short loc_2C80
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+38h]
		push	ecx
		call	_uprv_free_56
		add	esp, 4

loc_2C80:				; CODE XREF: UPerfTest::~UPerfTest(void)+57j
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+10h], 0
		jz	short loc_2C98
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		push	ecx
		call	_uprv_free_56
		add	esp, 4

loc_2C98:				; CODE XREF: UPerfTest::~UPerfTest(void)+6Fj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+14h]
		push	ecx
		call	_ucbuf_close
		add	esp, 4
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1UPerfTest@@UAE@XZ endp

_text		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn __RTC_Shutdown:near ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
		extrn __RTC_InitBase:near ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
		extrn ___security_cookie:near
					; DATA XREF: UPerfFunction::time(int,UErrorCode	*)+20r
		extrn __fltused:near
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near
					; CODE XREF: UPerfFunction::time(int,UErrorCode	*)+B9p
; __fastcall _RTC_CheckStackVars(x, x)
		extrn @_RTC_CheckStackVars@8:near
					; CODE XREF: UPerfFunction::time(int,UErrorCode	*)+AAp
					; UPerfTest::init(UOption * const,int,UErrorCode &)+32Ap ...
		extrn __RTC_CheckEsp:near
					; CODE XREF: UPerfFunction::time(int,UErrorCode	*)+7Dp
					; UPerfFunction::time(int,UErrorCode *)+C6p ...
; BOOL __stdcall QueryPerformanceFrequency(LARGE_INTEGER *lpFrequency)
		extrn __imp__QueryPerformanceFrequency@4:near
					; CODE XREF: uprv_initFrequency(UTimer *)+27p
					; DATA XREF: uprv_initFrequency(UTimer *)+27r
; BOOL __stdcall QueryPerformanceCounter(LARGE_INTEGER *lpPerformanceCount)
		extrn __imp__QueryPerformanceCounter@4:near
					; CODE XREF: uprv_start(UTimer *)+24p
					; DATA XREF: uprv_start(UTimer *)+24r
; const	type_info::`vftable'
		extrn ??_7type_info@@6B@:near
					; DATA XREF: .data:UPerfFunction `RTTI Type Descriptor'o
					; .data:UPerfTest `RTTI	Type Descriptor'o
		extrn __purecall:near	; DATA XREF: .rdata:00000AE8o
					; .rdata:00000AECo
; void __cdecl operator	delete(void *)
		extrn ??3@YAXPAX@Z:near	; CODE XREF: UPerfFunction::`scalar deleting destructor'(uint)+37p
					; UPerfFunction::`vector deleting destructor'(uint)+51p ...
; void __stdcall `eh vector destructor iterator'(void *, unsigned int, int, void (__thiscall *)(void *))
		extrn ??_M@YGXPAXIHP6EX0@Z@Z:near
					; CODE XREF: UPerfFunction::`vector deleting destructor'(uint)+3Dp
					; UPerfTest::`vector deleting destructor'(uint)+3Dp
; int _printf(const char *Format, ...)
		extrn __imp__printf:near
					; CODE XREF: UPerfTest::init(UOption * const,int,UErrorCode &)+310p
					; UPerfTest::runTestLoop(char *,char *)+2EDp ...
		extrn _u_errorName_56:near
					; CODE XREF: UPerfTest::init(UOption * const,int,UErrorCode &)+2F9p
					; UPerfTest::runTestLoop(char *,char *)+2DDp ...
		extrn _ucbuf_open:near	; CODE XREF: UPerfTest::init(UOption * const,int,UErrorCode &)+2D0p
		extrn _uprv_malloc_56:near
					; CODE XREF: UPerfTest::init(UOption * const,int,UErrorCode &)+25Fp
					; UPerfTest::getBuffer(int &,UErrorCode	&)+5Ap
		extrn _ucbuf_resolveFileName:near
					; CODE XREF: UPerfTest::init(UOption * const,int,UErrorCode &)+253p
					; UPerfTest::init(UOption * const,int,UErrorCode &)+2B2p
; int __cdecl _atoi(const char *Str)
		extrn __imp__atoi:near	; CODE XREF: UPerfTest::init(UOption * const,int,UErrorCode &)+14Fp
					; UPerfTest::init(UOption * const,int,UErrorCode &)+178p ...
		extrn _u_parseArgs:near	; CODE XREF: UPerfTest::init(UOption * const,int,UErrorCode &)+7Ap
; void *__cdecl	memcpy(void *Dst, const	void *Src, size_t Size)
		extrn _memcpy:near	; CODE XREF: UPerfTest::init(UOption * const,int,UErrorCode &)+52p
					; UPerfTest::init(UOption * const,int,UErrorCode &)+9Ep ...
; int _fprintf(FILE *File, const char *Format, ...)
		extrn __imp__fprintf:near
					; CODE XREF: UPerfTest::getLines(UErrorCode &)+1B9p
					; UPerfTest::run(void)+FBp ...
; FILE *__cdecl	___iob_func()
		extrn __imp____iob_func:near
					; CODE XREF: UPerfTest::getLines(UErrorCode &)+1A8p
					; UPerfTest::run(void)+EAp ...
		extrn _ucbuf_readline:near
					; CODE XREF: UPerfTest::getLines(UErrorCode &)+A0p
; void *__cdecl	operator new(unsigned int)
		extrn ??2@YAPAXI@Z:near	; CODE XREF: UPerfTest::getLines(UErrorCode &)+58p
					; UPerfTest::getLines(UErrorCode &)+DFp ...
		extrn _u_strncpy_56:near
					; CODE XREF: UPerfTest::getBuffer(int &,UErrorCode &)+90p
		extrn _ucbuf_getBuffer:near
					; CODE XREF: UPerfTest::getBuffer(int &,UErrorCode &)+80p
		extrn _ucbuf_size:near	; CODE XREF: UPerfTest::getBuffer(int &,UErrorCode &)+43p
; char *__cdecl	_strchr(const char *Str, int Val)
		extrn __imp__strchr:near ; CODE	XREF: strchr(char *,int)+28p
					; DATA XREF: strchr(char *,int)+28r
; int __cdecl strcmp(const char	*Str1, const char *Str2)
		extrn _strcmp:near	; CODE XREF: UPerfTest::runTest(char *,char *)+7Ep
					; UPerfTest::runTest(char *,char *)+B2p ...
		extrn __ftol2_sse:near	; CODE XREF: UPerfTest::runTestLoop(char *,char	*)+204p
					; UPerfTest::runTestLoop(char *,char *)+260p
; int __cdecl _puts(const char *Str)
		extrn __imp__puts:near	; CODE XREF: UPerfTest::usage(void)+2Ap
					; UPerfTest::usage(void)+4Cp
					; DATA XREF: ...
		extrn _ucbuf_close:near	; CODE XREF: UPerfTest::~UPerfTest(void)+87p
		extrn _uprv_free_56:near ; CODE	XREF: UPerfTest::~UPerfTest(void)+60p
					; UPerfTest::~UPerfTest(void)+78p


		end
