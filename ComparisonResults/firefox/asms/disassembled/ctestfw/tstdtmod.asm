;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	156C5B2FA75C343659888DEEEA34044E
; Input	CRC32 :	AD651A0D

; File Name   :	D:\compspace\objfiles\firefox\ctestfw\tstdtmod.obj
; Format      :	COFF (X386MAGIC)
; includelib "msvcprtd"
; includelib "MSVCRTD"
;
; Exported entry
;

		include	uni.inc	; see unicode subdir of	ida for	info on	unicode

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall DataMap::DataMap(DataMap *this, const struct DataMap *)
		public ??0DataMap@@QAE@ABV0@@Z
??0DataMap@@QAE@ABV0@@Z	proc near	; CODE XREF: RBDataMap::RBDataMap(RBDataMap const &)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7DataMap@@6B@ ; const DataMap::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??0DataMap@@QAE@ABV0@@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 38h
		dd offset ??_R4DataMap@@6B@ ; const DataMap::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7DataMap@@6B@
; const	DataMap::`vftable'
??_7DataMap@@6B@ dd offset ??_EDataMap@@UAEPAXI@Z
					; DATA XREF: DataMap::DataMap(DataMap const &)+26o
					; DataMap::`vector deleting destructor'(uint)
off_40		dd offset __purecall	; DATA XREF: .rdata$r:000000C0o
					; .rdata$r:000002D0o ...
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$TMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$TMZ
		;org 60h
__RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
_rtc$TMZ	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$IMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$IMZ
		;org 64h
__RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
_rtc$IMZ	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 68h
		public ??_R4DataMap@@6B@
; const	DataMap::`RTTI Complete	Object Locator'
??_R4DataMap@@6B@ dd 3 dup(0)		; DATA XREF: .rdata:00000038o
		dd offset ??_R0?AVDataMap@@@8 ;	DataMap	`RTTI Type Descriptor'
		dd offset ??_R3DataMap@@8 ; DataMap::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 7Ch
		public ??_R0?AVDataMap@@@8
; class	DataMap	`RTTI Type Descriptor'
??_R0?AVDataMap@@@8 dd offset ??_7type_info@@6B@ ; DATA	XREF: .rdata$r:00000074o
					; .rdata$r:DataMap::`RTTI Base Class Descriptor	at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avdatamap@@	db '.?AVDataMap@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 94h
		public ??_R3DataMap@@8
; DataMap::`RTTI Class Hierarchy Descriptor'
??_R3DataMap@@8	dd 2 dup(0)		; DATA XREF: .rdata$r:00000078o
					; .rdata$r:000000C4o
		dd 1
		dd offset ??_R2DataMap@@8 ; DataMap::`RTTI Base	Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0A4h
		public ??_R2DataMap@@8
; DataMap::`RTTI Base Class Array'
??_R2DataMap@@8	dd offset ??_R1A@?0A@EA@DataMap@@8 ; DATA XREF:	.rdata$r:000000A0o
					; DataMap::`RTTI Base Class Descriptor at (0,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0ACh
		public ??_R1A@?0A@EA@DataMap@@8
; DataMap::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@DataMap@@8 dd offset ??_R0?AVDataMap@@@8
					; DATA XREF: .rdata$r:DataMap::`RTTI Base Class	Array'o
					; .rdata$r:000002B4o
					; DataMap `RTTI	Type Descriptor'
		dd 2 dup(0)
		dd 0FFFFFFFFh, 0
		dd offset off_40
		dd offset ??_R3DataMap@@8 ; DataMap::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	DataMap	& __thiscall DataMap::operator=(class DataMap const &)
		public ??4DataMap@@QAEAAV0@ABV0@@Z
??4DataMap@@QAEAAV0@ABV0@@Z proc near	; CODE XREF: RBDataMap::operator=(RBDataMap const &)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4DataMap@@QAEAAV0@ABV0@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall DataMap::`scalar deleting destructor'(unsigned int)
		public ??_GDataMap@@UAEPAXI@Z
??_GDataMap@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1DataMap@@UAE@XZ ; DataMap::~DataMap(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_137
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_137:				; CODE XREF: DataMap::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GDataMap@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 150h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall DataMap::`vector deleting destructor'(unsigned int)
		public ??_EDataMap@@UAEPAXI@Z
??_EDataMap@@UAEPAXI@Z proc near	; DATA XREF: .rdata:const DataMap::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_1B1
		push	offset ??1DataMap@@UAE@XZ ; DataMap::~DataMap(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	4
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_1A9
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_V@YAXPAX@Z	; operator delete[](void *)
		add	esp, 4

loc_1A9:				; CODE XREF: DataMap::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_1D0
; ---------------------------------------------------------------------------

loc_1B1:				; CODE XREF: DataMap::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1DataMap@@UAE@XZ ; DataMap::~DataMap(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_1CD
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_1CD:				; CODE XREF: DataMap::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_1D0:				; CODE XREF: DataMap::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EDataMap@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1E8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	RBDataMap::RBDataMap(struct DataMap *)
		public ??0RBDataMap@@QAE@ABV0@@Z
??0RBDataMap@@QAE@ABV0@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct DataMap *
		mov	ecx, [ebp+var_8] ; this
		call	??0DataMap@@QAE@ABV0@@Z	; DataMap::DataMap(DataMap const &)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7RBDataMap@@6B@ ; const RBDataMap::`vftable'
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	[eax+4], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0RBDataMap@@QAE@ABV0@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 248h
		dd offset ??_R4RBDataMap@@6B@ ;	const RBDataMap::`RTTI Complete	Object Locator'
;
; Exported entry
;
		public ??_7RBDataMap@@6B@
; const	RBDataMap::`vftable'
??_7RBDataMap@@6B@ dd offset ??_ERBDataMap@@UAEPAXI@Z
					; DATA XREF: RBDataMap::RBDataMap(RBDataMap const &)+32o
					; RBDataMap::`vector deleting destructor'(uint)
		dd offset ?getString@RBDataMap@@UBE?BVUnicodeString@icu_56@@PBDAAW4UErrorCode@@@Z ; RBDataMap::getString(char const *,UErrorCode &)
		dd offset ?getInt@RBDataMap@@UBEHPBDAAW4UErrorCode@@@Z ; RBDataMap::getInt(char	const *,UErrorCode &)
		dd offset ?getInt28@RBDataMap@@UBEHPBDAAW4UErrorCode@@@Z ; RBDataMap::getInt28(char const *,UErrorCode &)
		dd offset ?getUInt28@RBDataMap@@UBEIPBDAAW4UErrorCode@@@Z ; RBDataMap::getUInt28(char const *,UErrorCode &)
		dd offset ?getIntVector@RBDataMap@@UBEPBHAAHPBDAAW4UErrorCode@@@Z ; RBDataMap::getIntVector(int	&,char const *,UErrorCode &)
		dd offset ?getBinary@RBDataMap@@UBEPBEAAHPBDAAW4UErrorCode@@@Z ; RBDataMap::getBinary(int &,char const *,UErrorCode &)
		dd offset ?getStringArray@RBDataMap@@UBEPBVUnicodeString@icu_56@@AAHPBDAAW4UErrorCode@@@Z ; RBDataMap::getStringArray(int &,char const *,UErrorCode &)
		dd offset ?getIntArray@RBDataMap@@UBEPBHAAHPBDAAW4UErrorCode@@@Z ; RBDataMap::getIntArray(int &,char const *,UErrorCode	&)
		dd offset ?getItem@RBDataMap@@UBEPBVResourceBundle@icu_56@@PBDAAW4UErrorCode@@@Z ; RBDataMap::getItem(char const *,UErrorCode &)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 274h
		public ??_R4RBDataMap@@6B@
; const	RBDataMap::`RTTI Complete Object Locator'
??_R4RBDataMap@@6B@ dd 3 dup(0)		; DATA XREF: .rdata:00000248o
		dd offset ??_R0?AVRBDataMap@@@8	; RBDataMap `RTTI Type Descriptor'
		dd offset ??_R3RBDataMap@@8 ; RBDataMap::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 288h
		public ??_R0?AVRBDataMap@@@8
; class	RBDataMap `RTTI	Type Descriptor'
??_R0?AVRBDataMap@@@8 dd offset	??_7type_info@@6B@ ; DATA XREF:	.rdata$r:00000280o
					; .rdata$r:RBDataMap::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 10h
a_?avrbdatamap@	db '.?AVRBDataMap@@',0
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 2A0h
		public ??_R3RBDataMap@@8
; RBDataMap::`RTTI Class Hierarchy Descriptor'
??_R3RBDataMap@@8 dd 2 dup(0)		; DATA XREF: .rdata$r:00000284o
					; .rdata$r:000002D4o
		dd 2
		dd offset ??_R2RBDataMap@@8 ; RBDataMap::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 2B0h
		public ??_R2RBDataMap@@8
; RBDataMap::`RTTI Base	Class Array'
??_R2RBDataMap@@8 dd offset ??_R1A@?0A@EA@RBDataMap@@8 ; DATA XREF: .rdata$r:000002ACo
					; RBDataMap::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@DataMap@@8 ; DataMap::`RTTI Base Class Descriptor at (0,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 2BCh
		public ??_R1A@?0A@EA@RBDataMap@@8
; RBDataMap::`RTTI Base	Class Descriptor at (0,	-1, 0, 64)'
??_R1A@?0A@EA@RBDataMap@@8 dd offset ??_R0?AVRBDataMap@@@8
					; DATA XREF: .rdata$r:RBDataMap::`RTTI Base Class Array'o
					; RBDataMap `RTTI Type Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset off_40
		dd offset ??_R3RBDataMap@@8 ; RBDataMap::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2D8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	RBDataMap & __thiscall RBDataMap::operator=(class RBDataMap const &)
		public ??4RBDataMap@@QAEAAV0@ABV0@@Z
??4RBDataMap@@QAEAAV0@ABV0@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??4DataMap@@QAEAAV0@ABV0@@Z ; DataMap::operator=(DataMap const &)
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	[eax+4], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4RBDataMap@@QAEAAV0@ABV0@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 32Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall RBDataMap::`scalar deleting	destructor'(unsigned int)
		public ??_GRBDataMap@@UAEPAXI@Z
??_GRBDataMap@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1RBDataMap@@UAE@XZ ; RBDataMap::~RBDataMap(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_36B
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_36B:				; CODE XREF: RBDataMap::`scalar	deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GRBDataMap@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 384h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall RBDataMap::`vector deleting	destructor'(unsigned int)
		public ??_ERBDataMap@@UAEPAXI@Z
??_ERBDataMap@@UAEPAXI@Z proc near	; DATA XREF: .rdata:const RBDataMap::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_3E5
		push	offset ??1RBDataMap@@UAE@XZ ; RBDataMap::~RBDataMap(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	8
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_3DD
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_V@YAXPAX@Z	; operator delete[](void *)
		add	esp, 4

loc_3DD:				; CODE XREF: RBDataMap::`vector	deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_404
; ---------------------------------------------------------------------------

loc_3E5:				; CODE XREF: RBDataMap::`vector	deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1RBDataMap@@UAE@XZ ; RBDataMap::~RBDataMap(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_401
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_401:				; CODE XREF: RBDataMap::`vector	deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_404:				; CODE XREF: RBDataMap::`vector	deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_ERBDataMap@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 41Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall TestData::TestData(TestData	*this, const struct TestData *)
		public ??0TestData@@QAE@ABV0@@Z
??0TestData@@QAE@ABV0@@Z proc near	; CODE XREF: RBTestData::RBTestData(RBTestData const &)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7TestData@@6B@ ; const TestData::`vftable'
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	[eax+4], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+8]
		mov	[eax+8], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+0Ch]
		mov	[eax+0Ch], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+10h]
		mov	[eax+10h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+14h]
		mov	[eax+14h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+18h]
		mov	[eax+18h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+1Ch]
		mov	[eax+1Ch], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+20h]
		mov	[eax+20h], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??0TestData@@QAE@ABV0@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4B4h
		dd offset ??_R4TestData@@6B@ ; const TestData::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7TestData@@6B@
; const	TestData::`vftable'
??_7TestData@@6B@ dd offset ??_ETestData@@UAEPAXI@Z
					; DATA XREF: TestData::TestData(TestData const &)+26o
					; TestData::`vector deleting destructor'(uint)
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 4C8h
		public ??_R4TestData@@6B@
; const	TestData::`RTTI	Complete Object	Locator'
??_R4TestData@@6B@ dd 3	dup(0)		; DATA XREF: .rdata:000004B4o
		dd offset ??_R0?AVTestData@@@8 ; TestData `RTTI	Type Descriptor'
		dd offset ??_R3TestData@@8 ; TestData::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 4DCh
		public ??_R0?AVTestData@@@8
; class	TestData `RTTI Type Descriptor'
??_R0?AVTestData@@@8 dd	offset ??_7type_info@@6B@ ; DATA XREF: .rdata$r:000004D4o
					; .rdata$r:TestData::`RTTI Base	Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avtestdata@@	db '.?AVTestData@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 4F4h
		public ??_R3TestData@@8
; TestData::`RTTI Class	Hierarchy Descriptor'
??_R3TestData@@8 dd 2 dup(0)		; DATA XREF: .rdata$r:000004D8o
					; .rdata$r:00000524o
		dd 1
		dd offset ??_R2TestData@@8 ; TestData::`RTTI Base Class	Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 504h
		public ??_R2TestData@@8
; TestData::`RTTI Base Class Array'
??_R2TestData@@8 dd offset ??_R1A@?0A@EA@TestData@@8 ; DATA XREF: .rdata$r:00000500o
					; TestData::`RTTI Base Class Descriptor	at (0,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 50Ch
		public ??_R1A@?0A@EA@TestData@@8
; TestData::`RTTI Base Class Descriptor	at (0, -1, 0, 64)'
??_R1A@?0A@EA@TestData@@8 dd offset ??_R0?AVTestData@@@8
					; DATA XREF: .rdata$r:TestData::`RTTI Base Class Array'o
					; .rdata$r:00000784o
					; TestData `RTTI Type Descriptor'
		dd 2 dup(0)
		dd 0FFFFFFFFh, 0
		dd offset off_40
		dd offset ??_R3TestData@@8 ; TestData::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 528h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	TestData & __thiscall TestData::operator=(class	TestData const &)
		public ??4TestData@@QAEAAV0@ABV0@@Z
??4TestData@@QAEAAV0@ABV0@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	[eax+4], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+8]
		mov	[eax+8], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+0Ch]
		mov	[eax+0Ch], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+10h]
		mov	[eax+10h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+14h]
		mov	[eax+14h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+18h]
		mov	[eax+18h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+1Ch]
		mov	[eax+1Ch], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+20h]
		mov	[eax+20h], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4TestData@@QAEAAV0@ABV0@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5B8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall TestData::`scalar deleting destructor'(unsigned int)
		public ??_GTestData@@UAEPAXI@Z
??_GTestData@@UAEPAXI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1TestData@@UAE@XZ ; TestData::~TestData(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_5F7
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_5F7:				; CODE XREF: TestData::`scalar deleting	destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GTestData@@UAEPAXI@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 610h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall TestData::`vector deleting destructor'(unsigned int)
		public ??_ETestData@@UAEPAXI@Z
??_ETestData@@UAEPAXI@Z	proc near	; DATA XREF: .rdata:const TestData::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_671
		push	offset ??1TestData@@UAE@XZ ; TestData::~TestData(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	24h ; '$'
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_669
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_V@YAXPAX@Z	; operator delete[](void *)
		add	esp, 4

loc_669:				; CODE XREF: TestData::`vector deleting	destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_690
; ---------------------------------------------------------------------------

loc_671:				; CODE XREF: TestData::`vector deleting	destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1TestData@@UAE@XZ ; TestData::~TestData(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_68D
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_68D:				; CODE XREF: TestData::`vector deleting	destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_690:				; CODE XREF: TestData::`vector deleting	destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_ETestData@@UAEPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6A8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	RBTestData::RBTestData(struct TestData *)
		public ??0RBTestData@@QAE@ABV0@@Z
??0RBTestData@@QAE@ABV0@@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct TestData *
		mov	ecx, [ebp+var_8] ; this
		call	??0TestData@@QAE@ABV0@@Z ; TestData::TestData(TestData const &)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7RBTestData@@6B@ ; const RBTestData::`vftable'
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+24h]
		mov	[eax+24h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+28h]
		mov	[eax+28h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+2Ch]
		mov	[eax+2Ch], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+30h]
		mov	[eax+30h], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0RBTestData@@QAE@ABV0@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 72Ch
		dd offset ??_R4RBTestData@@6B@ ; const RBTestData::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7RBTestData@@6B@
; const	RBTestData::`vftable'
??_7RBTestData@@6B@ dd offset ??_ERBTestData@@UAEPAXI@Z
					; DATA XREF: RBTestData::RBTestData(RBTestData const &)+32o
					; RBTestData::`vector deleting destructor'(uint)
		dd offset ?getInfo@RBTestData@@UBECAAPBVDataMap@@AAW4UErrorCode@@@Z ; RBTestData::getInfo(DataMap const	* &,UErrorCode &)
		dd offset ?nextSettings@RBTestData@@UAECAAPBVDataMap@@AAW4UErrorCode@@@Z ; RBTestData::nextSettings(DataMap const * &,UErrorCode &)
		dd offset ?nextCase@RBTestData@@UAECAAPBVDataMap@@AAW4UErrorCode@@@Z ; RBTestData::nextCase(DataMap const * &,UErrorCode &)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 740h
		public ??_R4RBTestData@@6B@
; const	RBTestData::`RTTI Complete Object Locator'
??_R4RBTestData@@6B@ dd	3 dup(0)	; DATA XREF: .rdata:0000072Co
		dd offset ??_R0?AVRBTestData@@@8 ; RBTestData `RTTI Type Descriptor'
		dd offset ??_R3RBTestData@@8 ; RBTestData::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 754h
		public ??_R0?AVRBTestData@@@8
; class	RBTestData `RTTI Type Descriptor'
??_R0?AVRBTestData@@@8 dd offset ??_7type_info@@6B@ ; DATA XREF: .rdata$r:0000074Co
					; .rdata$r:RBTestData::`RTTI Base Class	Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avrbtestdata	db '.?AVRBTestData@@',0
		align 10h
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 770h
		public ??_R3RBTestData@@8
; RBTestData::`RTTI Class Hierarchy Descriptor'
??_R3RBTestData@@8 dd 2	dup(0)		; DATA XREF: .rdata$r:00000750o
					; .rdata$r:000007A4o
		dd 2
		dd offset ??_R2RBTestData@@8 ; RBTestData::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 780h
		public ??_R2RBTestData@@8
; RBTestData::`RTTI Base Class Array'
??_R2RBTestData@@8 dd offset ??_R1A@?0A@EA@RBTestData@@8 ; DATA	XREF: .rdata$r:0000077Co
					; RBTestData::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@TestData@@8 ; TestData::`RTTI Base Class Descriptor at (0,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 78Ch
		public ??_R1A@?0A@EA@RBTestData@@8
; RBTestData::`RTTI Base Class Descriptor at (0, -1, 0,	64)'
??_R1A@?0A@EA@RBTestData@@8 dd offset ??_R0?AVRBTestData@@@8
					; DATA XREF: .rdata$r:RBTestData::`RTTI	Base Class Array'o
					; RBTestData `RTTI Type	Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset off_40
		dd offset ??_R3RBTestData@@8 ; RBTestData::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7A8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall RBTestData::`scalar	deleting destructor'(unsigned int)
		public ??_GRBTestData@@UAEPAXI@Z
??_GRBTestData@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1RBTestData@@UAE@XZ ;	RBTestData::~RBTestData(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_7E7
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_7E7:				; CODE XREF: RBTestData::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GRBTestData@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 800h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall RBTestData::`vector	deleting destructor'(unsigned int)
		public ??_ERBTestData@@UAEPAXI@Z
??_ERBTestData@@UAEPAXI@Z proc near	; DATA XREF: .rdata:const RBTestData::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_861
		push	offset ??1RBTestData@@UAE@XZ ; RBTestData::~RBTestData(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	34h ; '4'
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_859
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_V@YAXPAX@Z	; operator delete[](void *)
		add	esp, 4

loc_859:				; CODE XREF: RBTestData::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_880
; ---------------------------------------------------------------------------

loc_861:				; CODE XREF: RBTestData::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1RBTestData@@UAE@XZ ;	RBTestData::~RBTestData(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_87D
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_87D:				; CODE XREF: RBTestData::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_880:				; CODE XREF: RBTestData::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_ERBTestData@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 898h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall TestLog::TestLog(TestLog *__hidden this)
		public ??0TestLog@@QAE@XZ
??0TestLog@@QAE@XZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7TestLog@@6B@ ; const TestLog::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0TestLog@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8D0h
		dd offset ??_R4TestLog@@6B@ ; const TestLog::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7TestLog@@6B@
; const	TestLog::`vftable'
??_7TestLog@@6B@ dd offset ??_ETestLog@@UAEPAXI@Z ; DATA XREF: TestLog::TestLog(void)+26o
					; TestLog::TestLog(TestLog const &)+26o ...
					; TestLog::`vector deleting destructor'(uint)
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 8E8h
		public ??_R4TestLog@@6B@
; const	TestLog::`RTTI Complete	Object Locator'
??_R4TestLog@@6B@ dd 3 dup(0)		; DATA XREF: .rdata:000008D0o
		dd offset ??_R0?AVTestLog@@@8 ;	TestLog	`RTTI Type Descriptor'
		dd offset ??_R3TestLog@@8 ; TestLog::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 8FCh
		public ??_R0?AVTestLog@@@8
; class	TestLog	`RTTI Type Descriptor'
??_R0?AVTestLog@@@8 dd offset ??_7type_info@@6B@ ; DATA	XREF: .rdata$r:000008F4o
					; .rdata$r:TestLog::`RTTI Base Class Descriptor	at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avtestlog@@	db '.?AVTestLog@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 914h
		public ??_R3TestLog@@8
; TestLog::`RTTI Class Hierarchy Descriptor'
??_R3TestLog@@8	dd 2 dup(0)		; DATA XREF: .rdata$r:000008F8o
					; .rdata$r:00000944o
		dd 1
		dd offset ??_R2TestLog@@8 ; TestLog::`RTTI Base	Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 924h
		public ??_R2TestLog@@8
; TestLog::`RTTI Base Class Array'
??_R2TestLog@@8	dd offset ??_R1A@?0A@EA@TestLog@@8 ; DATA XREF:	.rdata$r:00000920o
					; TestLog::`RTTI Base Class Descriptor at (0,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 92Ch
		public ??_R1A@?0A@EA@TestLog@@8
; TestLog::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@TestLog@@8 dd offset ??_R0?AVTestLog@@@8
					; DATA XREF: .rdata$r:TestLog::`RTTI Base Class	Array'o
					; TestLog `RTTI	Type Descriptor'
		dd 2 dup(0)
		dd 0FFFFFFFFh, 0
		dd offset off_40
		dd offset ??_R3TestLog@@8 ; TestLog::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 948h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall TestLog::TestLog(class TestLog const &)
		public ??0TestLog@@QAE@ABV0@@Z
??0TestLog@@QAE@ABV0@@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7TestLog@@6B@ ; const TestLog::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??0TestLog@@QAE@ABV0@@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 980h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	TestLog	& __thiscall TestLog::operator=(class TestLog const &)
		public ??4TestLog@@QAEAAV0@ABV0@@Z
??4TestLog@@QAEAAV0@ABV0@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4TestLog@@QAEAAV0@ABV0@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9B0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall TestLog::`scalar deleting destructor'(unsigned int)
		public ??_GTestLog@@UAEPAXI@Z
??_GTestLog@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1TestLog@@UAE@XZ ; TestLog::~TestLog(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_9EF
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_9EF:				; CODE XREF: TestLog::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GTestLog@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A08h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall TestLog::`vector deleting destructor'(unsigned int)
		public ??_ETestLog@@UAEPAXI@Z
??_ETestLog@@UAEPAXI@Z proc near	; DATA XREF: .rdata:const TestLog::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_A69
		push	offset ??1TestLog@@UAE@XZ ; TestLog::~TestLog(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	4
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_A61
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_V@YAXPAX@Z	; operator delete[](void *)
		add	esp, 4

loc_A61:				; CODE XREF: TestLog::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_A88
; ---------------------------------------------------------------------------

loc_A69:				; CODE XREF: TestLog::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1TestLog@@UAE@XZ ; TestLog::~TestLog(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_A85
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_A85:				; CODE XREF: TestLog::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_A88:				; CODE XREF: TestLog::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_ETestLog@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0AA0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall IcuTestErrorCode::IcuTestErrorCode(IcuTestErrorCode	*this, struct TestLog *, const char *)
		public ??0IcuTestErrorCode@@QAE@AAVTestLog@@PBD@Z
??0IcuTestErrorCode@@QAE@AAVTestLog@@PBD@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??0ErrorCode@icu_56@@QAE@XZ ; icu_56::ErrorCode::ErrorCode(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7IcuTestErrorCode@@6B@ ; const IcuTestErrorCode::`vftable'
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		mov	[eax+0Ch], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??0IcuTestErrorCode@@QAE@AAVTestLog@@PBD@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B0Ch
		dd offset ??_R4IcuTestErrorCode@@6B@ ; const IcuTestErrorCode::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7IcuTestErrorCode@@6B@
; const	IcuTestErrorCode::`vftable'
??_7IcuTestErrorCode@@6B@ dd offset ??_EIcuTestErrorCode@@UAEPAXI@Z
					; DATA XREF: IcuTestErrorCode::IcuTestErrorCode(TestLog	&,char const *)+38o
					; IcuTestErrorCode::IcuTestErrorCode(IcuTestErrorCode const &)+3Co ...
					; IcuTestErrorCode::`vector deleting destructor'(uint)
		dd offset ?handleFailure@IcuTestErrorCode@@MBEXXZ ; IcuTestErrorCode::handleFailure(void)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0B18h
		public ??_R4IcuTestErrorCode@@6B@
; const	IcuTestErrorCode::`RTTI	Complete Object	Locator'
??_R4IcuTestErrorCode@@6B@ dd 3	dup(0)	; DATA XREF: .rdata:00000B0Co
		dd offset ??_R0?AVIcuTestErrorCode@@@8 ; IcuTestErrorCode `RTTI	Type Descriptor'
		dd offset ??_R3IcuTestErrorCode@@8 ; IcuTestErrorCode::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 0B2Ch
		public ??_R0?AVIcuTestErrorCode@@@8
; class	IcuTestErrorCode `RTTI Type Descriptor'
??_R0?AVIcuTestErrorCode@@@8 dd	offset ??_7type_info@@6B@ ; DATA XREF: .rdata$r:00000B24o
					; .rdata$r:IcuTestErrorCode::`RTTI Base	Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avicutesterr	db '.?AVIcuTestErrorCode@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0B4Ch
		public ??_R3IcuTestErrorCode@@8
; IcuTestErrorCode::`RTTI Class	Hierarchy Descriptor'
??_R3IcuTestErrorCode@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:00000B28o
					; .rdata$r:00000B84o
		dd 3
		dd offset ??_R2IcuTestErrorCode@@8 ; IcuTestErrorCode::`RTTI Base Class	Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0B5Ch
		public ??_R2IcuTestErrorCode@@8
; IcuTestErrorCode::`RTTI Base Class Array'
??_R2IcuTestErrorCode@@8 dd offset ??_R1A@?0A@EA@IcuTestErrorCode@@8
					; DATA XREF: .rdata$r:00000B58o
					; IcuTestErrorCode::`RTTI Base Class Descriptor	at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@ErrorCode@icu_56@@8 ; icu_56::ErrorCode::`RTTI Base Class Descriptor at	(0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0B6Ch
		public ??_R1A@?0A@EA@IcuTestErrorCode@@8
; IcuTestErrorCode::`RTTI Base Class Descriptor	at (0, -1, 0, 64)'
??_R1A@?0A@EA@IcuTestErrorCode@@8 dd offset ??_R0?AVIcuTestErrorCode@@@8
					; DATA XREF: .rdata$r:IcuTestErrorCode::`RTTI Base Class Array'o
					; IcuTestErrorCode `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset off_40
		dd offset ??_R3IcuTestErrorCode@@8 ; IcuTestErrorCode::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0B88h
		public ??_R1A@?0A@EA@ErrorCode@icu_56@@8
; icu_56::ErrorCode::`RTTI Base	Class Descriptor at (0,	-1, 0, 64)'
??_R1A@?0A@EA@ErrorCode@icu_56@@8 dd offset ??_R0?AVErrorCode@icu_56@@@8
					; DATA XREF: .rdata$r:00000B60o
					; .rdata$r:icu_56::ErrorCode::`RTTI Base Class Array'o
					; icu_56::ErrorCode `RTTI Type Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset off_40
		dd offset ??_R3ErrorCode@icu_56@@8 ; icu_56::ErrorCode::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 0BA4h
		public ??_R0?AVErrorCode@icu_56@@@8
; class	icu_56::ErrorCode `RTTI	Type Descriptor'
??_R0?AVErrorCode@icu_56@@@8 dd	offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::ErrorCode::`RTTI Base Class Descriptor at	(0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?averrorcode@	db '.?AVErrorCode@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0BC4h
		public ??_R3ErrorCode@icu_56@@8
; icu_56::ErrorCode::`RTTI Class Hierarchy Descriptor'
??_R3ErrorCode@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:00000BA0o
		dd 2
		dd offset ??_R2ErrorCode@icu_56@@8 ; icu_56::ErrorCode::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0BD4h
		public ??_R2ErrorCode@icu_56@@8
; icu_56::ErrorCode::`RTTI Base	Class Array'
??_R2ErrorCode@icu_56@@8 dd offset ??_R1A@?0A@EA@ErrorCode@icu_56@@8
					; DATA XREF: .rdata$r:00000BD0o
					; icu_56::ErrorCode::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0BE0h
		public ??_R13?0A@EA@UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Descriptor at (4, -1, 0, 64)'
??_R13?0A@EA@UMemory@icu_56@@8 dd offset ??_R0?AVUMemory@icu_56@@@8
					; DATA XREF: .rdata$r:00000B64o
					; .rdata$r:00000BD8o
					; icu_56::UMemory `RTTI	Type Descriptor'
		align 8
		dd 4, 0FFFFFFFFh, 0
		dd offset off_40
		dd offset ??_R3UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 0BFCh
		public ??_R0?AVUMemory@icu_56@@@8
; class	icu_56::UMemory	`RTTI Type Descriptor'
??_R0?AVUMemory@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::UMemory::`RTTI Base Class	Descriptor at (4,-1,0,64)'o
					; .rdata$r:icu_56::UMemory::`RTTI Base Class Descriptor	at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avumemory@ic	db '.?AVUMemory@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0C1Ch
		public ??_R3UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Class Hierarchy Descriptor'
??_R3UMemory@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:00000BF8o
					; .rdata$r:00000C4Co
		dd 1
		dd offset ??_R2UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0C2Ch
		public ??_R2UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Array'
??_R2UMemory@icu_56@@8 dd offset ??_R1A@?0A@EA@UMemory@icu_56@@8
					; DATA XREF: .rdata$r:00000C28o
					; icu_56::UMemory::`RTTI Base Class Descriptor at (0,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0C34h
		public ??_R1A@?0A@EA@UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UMemory@icu_56@@8	dd offset ??_R0?AVUMemory@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UMemory::`RTTI Base Class	Array'o
					; icu_56::UMemory `RTTI	Type Descriptor'
		align 10h
		dd 0FFFFFFFFh, 0
		dd offset off_40
		dd offset ??_R3UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C50h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	IcuTestErrorCode::IcuTestErrorCode(struct icu_56::ErrorCode *)
		public ??0IcuTestErrorCode@@QAE@ABV0@@Z
??0IcuTestErrorCode@@QAE@ABV0@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::ErrorCode *
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??0ErrorCode@icu_56@@QAE@ABV01@@Z ; icu_56::ErrorCode::ErrorCode(icu_56::ErrorCode const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7IcuTestErrorCode@@6B@ ; const IcuTestErrorCode::`vftable'
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+8]
		mov	[eax+8], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+0Ch]
		mov	[eax+0Ch], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0IcuTestErrorCode@@QAE@ABV0@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0CC4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall IcuTestErrorCode::`scalar deleting destructor'(unsigned int)
		public ??_GIcuTestErrorCode@@UAEPAXI@Z
??_GIcuTestErrorCode@@UAEPAXI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1IcuTestErrorCode@@UAE@XZ ; IcuTestErrorCode::~IcuTestErrorCode(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_D0D
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_D0D:				; CODE XREF: IcuTestErrorCode::`scalar deleting	destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GIcuTestErrorCode@@UAEPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D28h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall IcuTestErrorCode::`vector deleting destructor'(unsigned int)
		public ??_EIcuTestErrorCode@@UAEPAXI@Z
??_EIcuTestErrorCode@@UAEPAXI@Z	proc near
					; DATA XREF: .rdata:const IcuTestErrorCode::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_D93
		push	offset ??1IcuTestErrorCode@@UAE@XZ ; IcuTestErrorCode::~IcuTestErrorCode(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	10h
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_D8B
		mov	eax, [ebp+var_8]
		sub	eax, 4
		mov	esi, esp
		push	eax		; void *
		call	dword ptr ds:__imp_??_VUMemory@icu_56@@SAXPAX@Z	; icu_56::UMemory::operator delete[](void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_D8B:				; CODE XREF: IcuTestErrorCode::`vector deleting	destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_DBC
; ---------------------------------------------------------------------------

loc_D93:				; CODE XREF: IcuTestErrorCode::`vector deleting	destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1IcuTestErrorCode@@UAE@XZ ; IcuTestErrorCode::~IcuTestErrorCode(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_DB9
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_DB9:				; CODE XREF: IcuTestErrorCode::`vector deleting	destructor'(uint)+79j
		mov	eax, [ebp+var_8]

loc_DBC:				; CODE XREF: IcuTestErrorCode::`vector deleting	destructor'(uint)+69j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EIcuTestErrorCode@@UAEPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0DD4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall TestDataModule::TestDataModule(TestDataModule *this, const struct TestDataModule *)
		public ??0TestDataModule@@QAE@ABV0@@Z
??0TestDataModule@@QAE@ABV0@@Z proc near
					; CODE XREF: RBTestDataModule::RBTestDataModule(RBTestDataModule const &)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7TestDataModule@@6B@	; const	TestDataModule::`vftable'
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	[eax+4], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+8]
		mov	[eax+8], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+0Ch]
		mov	[eax+0Ch], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??0TestDataModule@@QAE@ABV0@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E30h
		dd offset ??_R4TestDataModule@@6B@ ; const TestDataModule::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7TestDataModule@@6B@
; const	TestDataModule::`vftable'
??_7TestDataModule@@6B@	dd offset ??_ETestDataModule@@UAEPAXI@Z
					; DATA XREF: TestDataModule::TestDataModule(TestDataModule const &)+26o
					; TestDataModule::TestDataModule(char const *,TestLog &,UErrorCode &)+26o ...
					; TestDataModule::`vector deleting destructor'(uint)
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0E44h
		public ??_R4TestDataModule@@6B@
; const	TestDataModule::`RTTI Complete Object Locator'
??_R4TestDataModule@@6B@ dd 3 dup(0)	; DATA XREF: .rdata:00000E30o
		dd offset ??_R0?AVTestDataModule@@@8 ; TestDataModule `RTTI Type Descriptor'
		dd offset ??_R3TestDataModule@@8 ; TestDataModule::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 0E58h
		public ??_R0?AVTestDataModule@@@8
; class	TestDataModule `RTTI Type Descriptor'
??_R0?AVTestDataModule@@@8 dd offset ??_7type_info@@6B@	; DATA XREF: .rdata$r:00000E50o
					; .rdata$r:TestDataModule::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 10h
a_?avtestdatamo	db '.?AVTestDataModule@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0E78h
		public ??_R3TestDataModule@@8
; TestDataModule::`RTTI	Class Hierarchy	Descriptor'
??_R3TestDataModule@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:00000E54o
					; .rdata$r:00000EA8o
		dd 1
		dd offset ??_R2TestDataModule@@8 ; TestDataModule::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0E88h
		public ??_R2TestDataModule@@8
; TestDataModule::`RTTI	Base Class Array'
??_R2TestDataModule@@8 dd offset ??_R1A@?0A@EA@TestDataModule@@8
					; DATA XREF: .rdata$r:00000E84o
					; TestDataModule::`RTTI	Base Class Descriptor at (0,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0E90h
		public ??_R1A@?0A@EA@TestDataModule@@8
; TestDataModule::`RTTI	Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@TestDataModule@@8	dd offset ??_R0?AVTestDataModule@@@8
					; DATA XREF: .rdata$r:TestDataModule::`RTTI Base Class Array'o
					; .rdata$r:00001094o
					; TestDataModule `RTTI Type Descriptor'
		dd 2 dup(0)
		dd 0FFFFFFFFh, 0
		dd offset off_40
		dd offset ??_R3TestDataModule@@8 ; TestDataModule::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0EACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall TestDataModule::`scalar deleting destructor'(unsigned int)
		public ??_GTestDataModule@@UAEPAXI@Z
??_GTestDataModule@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1TestDataModule@@UAE@XZ ; TestDataModule::~TestDataModule(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_EEB
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_EEB:				; CODE XREF: TestDataModule::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GTestDataModule@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0F04h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall TestDataModule::`vector deleting destructor'(unsigned int)
		public ??_ETestDataModule@@UAEPAXI@Z
??_ETestDataModule@@UAEPAXI@Z proc near	; DATA XREF: .rdata:const TestDataModule::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_F65
		push	offset ??1TestDataModule@@UAE@XZ ; TestDataModule::~TestDataModule(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	10h
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_F5D
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_V@YAXPAX@Z	; operator delete[](void *)
		add	esp, 4

loc_F5D:				; CODE XREF: TestDataModule::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_F84
; ---------------------------------------------------------------------------

loc_F65:				; CODE XREF: TestDataModule::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1TestDataModule@@UAE@XZ ; TestDataModule::~TestDataModule(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_F81
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_F81:				; CODE XREF: TestDataModule::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_F84:				; CODE XREF: TestDataModule::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_ETestDataModule@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0F9Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	RBTestDataModule::RBTestDataModule(struct TestDataModule *)
		public ??0RBTestDataModule@@QAE@ABV0@@Z
??0RBTestDataModule@@QAE@ABV0@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct TestDataModule	*
		mov	ecx, [ebp+var_8] ; this
		call	??0TestDataModule@@QAE@ABV0@@Z ; TestDataModule::TestDataModule(TestDataModule const &)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7RBTestDataModule@@6B@ ; const RBTestDataModule::`vftable'
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+10h]
		mov	[eax+10h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+14h]
		mov	[eax+14h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+18h]
		mov	[eax+18h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	dl, [ecx+1Ch]
		mov	[eax+1Ch], dl
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+20h]
		mov	[eax+20h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+24h]
		mov	[eax+24h], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0RBTestDataModule@@QAE@ABV0@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1038h
		dd offset ??_R4RBTestDataModule@@6B@ ; const RBTestDataModule::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7RBTestDataModule@@6B@
; const	RBTestDataModule::`vftable'
??_7RBTestDataModule@@6B@ dd offset ??_ERBTestDataModule@@UAEPAXI@Z
					; DATA XREF: RBTestDataModule::RBTestDataModule(RBTestDataModule const &)+32o
					; RBTestDataModule::~RBTestDataModule(void)+26o ...
					; RBTestDataModule::`vector deleting destructor'(uint)
		dd offset ?getInfo@RBTestDataModule@@UBECAAPBVDataMap@@AAW4UErrorCode@@@Z ; RBTestDataModule::getInfo(DataMap const * &,UErrorCode &)
		dd offset ?createTestData@RBTestDataModule@@UBEPAVTestData@@PBDAAW4UErrorCode@@@Z ; RBTestDataModule::createTestData(char const	*,UErrorCode &)
		dd offset ?createTestData@RBTestDataModule@@UBEPAVTestData@@HAAW4UErrorCode@@@Z	; RBTestDataModule::createTestData(int,UErrorCode &)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 104Ch
		public ??_R4RBTestDataModule@@6B@
; const	RBTestDataModule::`RTTI	Complete Object	Locator'
??_R4RBTestDataModule@@6B@ dd 3	dup(0)	; DATA XREF: .rdata:00001038o
		dd offset ??_R0?AVRBTestDataModule@@@8 ; RBTestDataModule `RTTI	Type Descriptor'
		dd offset ??_R3RBTestDataModule@@8 ; RBTestDataModule::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 1060h
		public ??_R0?AVRBTestDataModule@@@8
; class	RBTestDataModule `RTTI Type Descriptor'
??_R0?AVRBTestDataModule@@@8 dd	offset ??_7type_info@@6B@ ; DATA XREF: .rdata$r:00001058o
					; .rdata$r:RBTestDataModule::`RTTI Base	Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 8
a_?avrbtestda_0	db '.?AVRBTestDataModule@@',0
		align 10h
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1080h
		public ??_R3RBTestDataModule@@8
; RBTestDataModule::`RTTI Class	Hierarchy Descriptor'
??_R3RBTestDataModule@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:0000105Co
					; .rdata$r:000010B4o
		dd 2
		dd offset ??_R2RBTestDataModule@@8 ; RBTestDataModule::`RTTI Base Class	Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1090h
		public ??_R2RBTestDataModule@@8
; RBTestDataModule::`RTTI Base Class Array'
??_R2RBTestDataModule@@8 dd offset ??_R1A@?0A@EA@RBTestDataModule@@8
					; DATA XREF: .rdata$r:0000108Co
					; RBTestDataModule::`RTTI Base Class Descriptor	at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@TestDataModule@@8 ; TestDataModule::`RTTI Base Class Descriptor	at (0,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 109Ch
		public ??_R1A@?0A@EA@RBTestDataModule@@8
; RBTestDataModule::`RTTI Base Class Descriptor	at (0, -1, 0, 64)'
??_R1A@?0A@EA@RBTestDataModule@@8 dd offset ??_R0?AVRBTestDataModule@@@8
					; DATA XREF: .rdata$r:RBTestDataModule::`RTTI Base Class Array'o
					; RBTestDataModule `RTTI Type Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset off_40
		dd offset ??_R3RBTestDataModule@@8 ; RBTestDataModule::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 10B8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall RBTestDataModule::`scalar deleting destructor'(unsigned int)
		public ??_GRBTestDataModule@@UAEPAXI@Z
??_GRBTestDataModule@@UAEPAXI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1RBTestDataModule@@UAE@XZ ; RBTestDataModule::~RBTestDataModule(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_10F7
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_10F7:				; CODE XREF: RBTestDataModule::`scalar deleting	destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GRBTestDataModule@@UAEPAXI@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1110h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall RBTestDataModule::`vector deleting destructor'(unsigned int)
		public ??_ERBTestDataModule@@UAEPAXI@Z
??_ERBTestDataModule@@UAEPAXI@Z	proc near
					; DATA XREF: .rdata:const RBTestDataModule::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_1171
		push	offset ??1RBTestDataModule@@UAE@XZ ; RBTestDataModule::~RBTestDataModule(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	28h ; '('
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_1169
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_V@YAXPAX@Z	; operator delete[](void *)
		add	esp, 4

loc_1169:				; CODE XREF: RBTestDataModule::`vector deleting	destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_1190
; ---------------------------------------------------------------------------

loc_1171:				; CODE XREF: RBTestDataModule::`vector deleting	destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1RBTestDataModule@@UAE@XZ ; RBTestDataModule::~RBTestDataModule(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_118D
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_118D:				; CODE XREF: RBTestDataModule::`vector deleting	destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_1190:				; CODE XREF: RBTestDataModule::`vector deleting	destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_ERBTestDataModule@@UAEPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 11A8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall TestLog::~TestLog(TestLog *__hidden	this)
		public ??1TestLog@@UAE@XZ
??1TestLog@@UAE@XZ proc	near		; CODE XREF: TestLog::`scalar deleting destructor'(uint)+26p
					; TestLog::`vector deleting destructor'(uint)+64p
					; DATA XREF: ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7TestLog@@6B@ ; const TestLog::`vftable'
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??1TestLog@@UAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 11DCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall IcuTestErrorCode::~IcuTestErrorCode(IcuTestErrorCode *__hidden this)
		public ??1IcuTestErrorCode@@UAE@XZ
??1IcuTestErrorCode@@UAE@XZ proc near	; CODE XREF: IcuTestErrorCode::`scalar deleting	destructor'(uint)+26p
					; IcuTestErrorCode::`vector deleting destructor'(uint)+6Ep
					; DATA XREF: ...

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??1IcuTestErrorCode@@UAE@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7IcuTestErrorCode@@6B@ ; const IcuTestErrorCode::`vftable'
		mov	[ebp+var_4], 0
		mov	esi, esp
		mov	ecx, [ebp+var_14] ; this
		call	dword ptr ds:__imp_?isFailure@ErrorCode@icu_56@@QBECXZ ; icu_56::ErrorCode::isFailure(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	eax, al
		test	eax, eax
		jz	short loc_124F
		mov	ecx, [ebp+var_14] ; this
		call	?handleFailure@IcuTestErrorCode@@MBEXXZ	; IcuTestErrorCode::handleFailure(void)

loc_124F:				; CODE XREF: IcuTestErrorCode::~IcuTestErrorCode(void)+69j
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		mov	ecx, [ebp+var_14] ; this
		call	dword ptr ds:__imp_??1ErrorCode@icu_56@@UAE@XZ ; icu_56::ErrorCode::~ErrorCode(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1IcuTestErrorCode@@UAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 1288h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1IcuTestErrorCode@@UAE@XZ$0 proc near	; DATA XREF: .xdata$x:000012BCo
		mov	esi, esp
		mov	ecx, [ebp-14h]	; this
		call	dword ptr ds:__imp_??1ErrorCode@icu_56@@UAE@XZ ; icu_56::ErrorCode::~ErrorCode(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??1IcuTestErrorCode@@UAE@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??1IcuTestErrorCode@@UAE@XZ	proc near
					; DATA XREF: IcuTestErrorCode::~IcuTestErrorCode(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??1IcuTestErrorCode@@UAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??1IcuTestErrorCode@@UAE@XZ	endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 12B8h
__unwindtable$??1IcuTestErrorCode@@UAE@XZ dd 0FFFFFFFFh	; DATA XREF: .xdata$x:000012C8o
		dd offset __unwindfunclet$??1IcuTestErrorCode@@UAE@XZ$0
__ehfuncinfo$??1IcuTestErrorCode@@UAE@XZ dd 19930522h, 1
					; DATA XREF: __ehhandler$??1IcuTestErrorCode@@UAE@XZ+14o
		dd offset __unwindtable$??1IcuTestErrorCode@@UAE@XZ
		align 20h
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 12E4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	IcuTestErrorCode::logIfFailureAndReset(IcuTestErrorCode	*this, const char *Format, ...)
		public ?logIfFailureAndReset@IcuTestErrorCode@@QAACPBDZZ
?logIfFailureAndReset@IcuTestErrorCode@@QAACPBDZZ proc near

var_1208	= dword	ptr -1208h
var_1204	= dword	ptr -1204h
var_1200	= dword	ptr -1200h
var_11FC	= dword	ptr -11FCh
var_11F1	= byte ptr -11F1h
var_11E8	= byte ptr -11E8h
var_11A0	= byte ptr -11A0h
var_1158	= byte ptr -1158h
var_1110	= byte ptr -1110h
var_1008	= byte ptr -1008h
Args		= dword	ptr -0FC0h
Dest		= byte ptr -0FB4h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
this		= dword	ptr  8
Format		= dword	ptr  0Ch
arg_8		= byte ptr  10h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?logIfFailureAndReset@IcuTestErrorCode@@QAACPBDZZ
		mov	eax, large fs:0
		push	eax
		mov	eax, 11FCh
		call	__chkstk
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_1208]
		mov	ecx, 47Fh
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax		; struct icu_56::UnicodeString *
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	esi, esp
		mov	ecx, [ebp+this]	; this
		call	dword ptr ds:__imp_?isFailure@ErrorCode@icu_56@@QBECXZ ; icu_56::ErrorCode::isFailure(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	eax, al
		test	eax, eax
		jz	loc_15B1
		lea	eax, [ebp+arg_8]
		mov	[ebp+Args], eax
		mov	esi, esp
		mov	eax, [ebp+Args]
		push	eax		; Args
		mov	ecx, [ebp+Format]
		push	ecx		; Format
		lea	edx, [ebp+Dest]
		push	edx		; Dest
		call	dword ptr ds:__imp__vsprintf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+Args], 0
		mov	esi, esp
		push	0
		push	0FFFFFFFFh	; struct icu_56::UnicodeString *
		mov	eax, [ebp+this]
		mov	ecx, [eax+0Ch]
		push	ecx		; struct icu_56::UnicodeString *
		lea	ecx, [ebp+var_1008]
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@PBDHW4EInvariant@01@@Z ; icu_56::UnicodeString::UnicodeString(char const *,int,icu_56::UnicodeString::EInvariant)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		mov	esi, esp
		push	0
		push	0FFFFFFFFh
		mov	edi, esp
		mov	ecx, [ebp+this]	; this
		call	dword ptr ds:__imp_?errorName@ErrorCode@icu_56@@QBEPBDXZ ; icu_56::ErrorCode::errorName(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		push	eax
		lea	ecx, [ebp+var_11A0]
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@PBDHW4EInvariant@01@@Z ; icu_56::UnicodeString::UnicodeString(char const *,int,icu_56::UnicodeString::EInvariant)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_11FC],	eax
		mov	eax, [ebp+var_11FC]
		mov	[ebp+var_1200],	eax
		mov	byte ptr [ebp+var_4], 1
		mov	esi, esp
		mov	ecx, [ebp+var_1200]
		push	ecx
		mov	edi, esp
		push	0FFFFFFFFh	; int
		push	offset ??_C@_1BG@ONGINEJD@?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAu?$AAr?$AAe?$AA?3?$AA?5?$AA?$AA@ ; " failure: "
		push	1		; signed __int8
		lea	ecx, [ebp+var_11E8] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@CPB_WH@Z ; icu_56::UnicodeString::UnicodeString(signed char,wchar_t const *,int)
		cmp	edi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_1204],	eax
		mov	edx, [ebp+var_1204]
		mov	[ebp+var_1208],	edx
		mov	byte ptr [ebp+var_4], 2
		mov	edi, esp
		mov	eax, [ebp+var_1208]
		push	eax		; struct icu_56::UnicodeString *
		lea	ecx, [ebp+var_1008] ; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z ; icu_56::UnicodeString::append(icu_56::UnicodeString const &)
		cmp	edi, esp
		call	__RTC_CheckEsp
		mov	ecx, eax	; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z ; icu_56::UnicodeString::append(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 1
		mov	esi, esp
		lea	ecx, [ebp+var_11E8] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_11A0] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		push	0
		push	0FFFFFFFFh
		lea	eax, [ebp+Dest]
		push	eax
		lea	ecx, [ebp+var_1110]
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@PBDHW4EInvariant@01@@Z ; icu_56::UnicodeString::UnicodeString(char const *,int,icu_56::UnicodeString::EInvariant)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_11FC],	eax
		mov	ecx, [ebp+var_11FC]
		mov	[ebp+var_1200],	ecx
		mov	byte ptr [ebp+var_4], 3
		mov	esi, esp
		mov	edx, [ebp+var_1200]
		push	edx
		mov	edi, esp
		push	0FFFFFFFFh	; int
		push	offset ??_C@_17HIKLPLBG@?$AA?5?$AA?9?$AA?5?$AA?$AA@ ; "	- "
		push	1		; signed __int8
		lea	ecx, [ebp+var_1158] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@CPB_WH@Z ; icu_56::UnicodeString::UnicodeString(signed char,wchar_t const *,int)
		cmp	edi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_1204],	eax
		mov	eax, [ebp+var_1204]
		mov	[ebp+var_1208],	eax
		mov	byte ptr [ebp+var_4], 4
		mov	edi, esp
		mov	ecx, [ebp+var_1208]
		push	ecx		; struct icu_56::UnicodeString *
		lea	ecx, [ebp+var_1008] ; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z ; icu_56::UnicodeString::append(icu_56::UnicodeString const &)
		cmp	edi, esp
		call	__RTC_CheckEsp
		mov	ecx, eax	; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z ; icu_56::UnicodeString::append(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 3
		mov	esi, esp
		lea	ecx, [ebp+var_1158] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_1110] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		lea	eax, [ebp+var_1008]
		push	eax
		mov	ecx, [ebp+this]
		mov	edx, [ecx+8]
		mov	eax, [ebp+this]
		mov	ecx, [eax+8]
		mov	edx, [edx]
		mov	eax, [edx+4]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		mov	ecx, [ebp+this]
		call	dword ptr ds:__imp_?reset@ErrorCode@icu_56@@QAE?AW4UErrorCode@@XZ ; icu_56::ErrorCode::reset(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_11F1],	1
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_1008] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	al, [ebp+var_11F1]
		jmp	short loc_15C5
; ---------------------------------------------------------------------------
		jmp	short loc_15C5
; ---------------------------------------------------------------------------

loc_15B1:				; CODE XREF: IcuTestErrorCode::logIfFailureAndReset(char const *,...)+5Bj
		mov	esi, esp
		mov	ecx, [ebp+this]
		call	dword ptr ds:__imp_?reset@ErrorCode@icu_56@@QAE?AW4UErrorCode@@XZ ; icu_56::ErrorCode::reset(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		xor	al, al

loc_15C5:				; CODE XREF: IcuTestErrorCode::logIfFailureAndReset(char const *,...)+2C9j
					; IcuTestErrorCode::logIfFailureAndReset(char const *,...)+2CBj
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN14
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 1208h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?logIfFailureAndReset@IcuTestErrorCode@@QAACPBDZZ endp

; ---------------------------------------------------------------------------
		align 10h
$LN14		dd 2			; DATA XREF: IcuTestErrorCode::logIfFailureAndReset(char const *,...)+2E5o
		dd offset $LN13
$LN13		dd 0FFFFF04Ch, 0FA0h	; DATA XREF: .text:00001604o
		dd offset $LN10		; "buffer"
		dd 0FFFFEFF8h, 40h
		dd offset $LN11
$LN11		dd 67736Dh		; DATA XREF: .text:0000161Co
$LN10		db 'buffer',0           ; DATA XREF: .text:00001610o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 162Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?logIfFailureAndReset@IcuTestErrorCode@@QAACPBDZZ$0 proc near
					; DATA XREF: .xdata$x:00001708o
		mov	esi, esp
		lea	ecx, [ebp-1008h] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?logIfFailureAndReset@IcuTestErrorCode@@QAACPBDZZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?logIfFailureAndReset@IcuTestErrorCode@@QAACPBDZZ$1 proc near
					; DATA XREF: .xdata$x:00001710o
		mov	esi, esp
		lea	ecx, [ebp-11A0h] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?logIfFailureAndReset@IcuTestErrorCode@@QAACPBDZZ$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?logIfFailureAndReset@IcuTestErrorCode@@QAACPBDZZ$2 proc near
					; DATA XREF: .xdata$x:00001718o
		mov	esi, esp
		lea	ecx, [ebp-11E8h] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?logIfFailureAndReset@IcuTestErrorCode@@QAACPBDZZ$2 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?logIfFailureAndReset@IcuTestErrorCode@@QAACPBDZZ$3 proc near
					; DATA XREF: .xdata$x:00001720o
		mov	esi, esp
		lea	ecx, [ebp-1110h] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?logIfFailureAndReset@IcuTestErrorCode@@QAACPBDZZ$3 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?logIfFailureAndReset@IcuTestErrorCode@@QAACPBDZZ$4 proc near
					; DATA XREF: .xdata$x:00001728o
		mov	esi, esp
		lea	ecx, [ebp-1158h] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?logIfFailureAndReset@IcuTestErrorCode@@QAACPBDZZ$4 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?logIfFailureAndReset@IcuTestErrorCode@@QAACPBDZZ proc near
					; DATA XREF: IcuTestErrorCode::logIfFailureAndReset(char const *,...)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-120Ch]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?logIfFailureAndReset@IcuTestErrorCode@@QAACPBDZZ
		jmp	___CxxFrameHandler3
__ehhandler$?logIfFailureAndReset@IcuTestErrorCode@@QAACPBDZZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 16C0h
		public ??_C@_17HIKLPLBG@?$AA?5?$AA?9?$AA?5?$AA?$AA@
; wchar_t `string'
??_C@_17HIKLPLBG@?$AA?5?$AA?9?$AA?5?$AA?$AA@:
					; DATA XREF: IcuTestErrorCode::logIfFailureAndReset(char const *,...)+1DEo
					; IcuTestErrorCode::logDataIfFailureAndReset(char const	*,...)+1DEo
		unicode	0, < - >,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 16C8h
		public ??_C@_1BG@ONGINEJD@?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAu?$AAr?$AAe?$AA?3?$AA?5?$AA?$AA@
; wchar_t `string'
??_C@_1BG@ONGINEJD@?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAu?$AAr?$AAe?$AA?3?$AA?5?$AA?$AA@:
					; DATA XREF: IcuTestErrorCode::logIfFailureAndReset(char const *,...)+10Eo
					; IcuTestErrorCode::logDataIfFailureAndReset(char const	*,...)+10Eo ...
		unicode	0, < failure: >,0
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 16E0h
__ehfuncinfo$?logIfFailureAndReset@IcuTestErrorCode@@QAACPBDZZ dd 19930522h, 5
					; DATA XREF: __ehhandler$?logIfFailureAndReset@IcuTestErrorCode@@QAACPBDZZ+1Eo
		dd offset __unwindtable$?logIfFailureAndReset@IcuTestErrorCode@@QAACPBDZZ
		align 20h
		dd 1
__unwindtable$?logIfFailureAndReset@IcuTestErrorCode@@QAACPBDZZ	dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000016E8o
		dd offset __unwindfunclet$?logIfFailureAndReset@IcuTestErrorCode@@QAACPBDZZ$0
		align 10h
		dd offset __unwindfunclet$?logIfFailureAndReset@IcuTestErrorCode@@QAACPBDZZ$1
		dd 1
		dd offset __unwindfunclet$?logIfFailureAndReset@IcuTestErrorCode@@QAACPBDZZ$2
		align 10h
		dd offset __unwindfunclet$?logIfFailureAndReset@IcuTestErrorCode@@QAACPBDZZ$3
		dd 3
		dd offset __unwindfunclet$?logIfFailureAndReset@IcuTestErrorCode@@QAACPBDZZ$4
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 172Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	IcuTestErrorCode::logDataIfFailureAndReset(IcuTestErrorCode *this, const char *Format, ...)
		public ?logDataIfFailureAndReset@IcuTestErrorCode@@QAACPBDZZ
?logDataIfFailureAndReset@IcuTestErrorCode@@QAACPBDZZ proc near

var_1208	= dword	ptr -1208h
var_1204	= dword	ptr -1204h
var_1200	= dword	ptr -1200h
var_11FC	= dword	ptr -11FCh
var_11F1	= byte ptr -11F1h
var_11E8	= byte ptr -11E8h
var_11A0	= byte ptr -11A0h
var_1158	= byte ptr -1158h
var_1110	= byte ptr -1110h
var_1008	= byte ptr -1008h
Args		= dword	ptr -0FC0h
Dest		= byte ptr -0FB4h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
this		= dword	ptr  8
Format		= dword	ptr  0Ch
arg_8		= byte ptr  10h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?logDataIfFailureAndReset@IcuTestErrorCode@@QAACPBDZZ
		mov	eax, large fs:0
		push	eax
		mov	eax, 11FCh
		call	__chkstk
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_1208]
		mov	ecx, 47Fh
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax		; struct icu_56::UnicodeString *
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	esi, esp
		mov	ecx, [ebp+this]	; this
		call	dword ptr ds:__imp_?isFailure@ErrorCode@icu_56@@QBECXZ ; icu_56::ErrorCode::isFailure(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	eax, al
		test	eax, eax
		jz	loc_19F9
		lea	eax, [ebp+arg_8]
		mov	[ebp+Args], eax
		mov	esi, esp
		mov	eax, [ebp+Args]
		push	eax		; Args
		mov	ecx, [ebp+Format]
		push	ecx		; Format
		lea	edx, [ebp+Dest]
		push	edx		; Dest
		call	dword ptr ds:__imp__vsprintf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+Args], 0
		mov	esi, esp
		push	0
		push	0FFFFFFFFh	; struct icu_56::UnicodeString *
		mov	eax, [ebp+this]
		mov	ecx, [eax+0Ch]
		push	ecx		; struct icu_56::UnicodeString *
		lea	ecx, [ebp+var_1008]
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@PBDHW4EInvariant@01@@Z ; icu_56::UnicodeString::UnicodeString(char const *,int,icu_56::UnicodeString::EInvariant)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		mov	esi, esp
		push	0
		push	0FFFFFFFFh
		mov	edi, esp
		mov	ecx, [ebp+this]	; this
		call	dword ptr ds:__imp_?errorName@ErrorCode@icu_56@@QBEPBDXZ ; icu_56::ErrorCode::errorName(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		push	eax
		lea	ecx, [ebp+var_11A0]
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@PBDHW4EInvariant@01@@Z ; icu_56::UnicodeString::UnicodeString(char const *,int,icu_56::UnicodeString::EInvariant)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_11FC],	eax
		mov	eax, [ebp+var_11FC]
		mov	[ebp+var_1200],	eax
		mov	byte ptr [ebp+var_4], 1
		mov	esi, esp
		mov	ecx, [ebp+var_1200]
		push	ecx
		mov	edi, esp
		push	0FFFFFFFFh	; int
		push	offset ??_C@_1BG@ONGINEJD@?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAu?$AAr?$AAe?$AA?3?$AA?5?$AA?$AA@ ; " failure: "
		push	1		; signed __int8
		lea	ecx, [ebp+var_11E8] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@CPB_WH@Z ; icu_56::UnicodeString::UnicodeString(signed char,wchar_t const *,int)
		cmp	edi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_1204],	eax
		mov	edx, [ebp+var_1204]
		mov	[ebp+var_1208],	edx
		mov	byte ptr [ebp+var_4], 2
		mov	edi, esp
		mov	eax, [ebp+var_1208]
		push	eax		; struct icu_56::UnicodeString *
		lea	ecx, [ebp+var_1008] ; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z ; icu_56::UnicodeString::append(icu_56::UnicodeString const &)
		cmp	edi, esp
		call	__RTC_CheckEsp
		mov	ecx, eax	; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z ; icu_56::UnicodeString::append(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 1
		mov	esi, esp
		lea	ecx, [ebp+var_11E8] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_11A0] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		push	0
		push	0FFFFFFFFh
		lea	eax, [ebp+Dest]
		push	eax
		lea	ecx, [ebp+var_1110]
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@PBDHW4EInvariant@01@@Z ; icu_56::UnicodeString::UnicodeString(char const *,int,icu_56::UnicodeString::EInvariant)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_11FC],	eax
		mov	ecx, [ebp+var_11FC]
		mov	[ebp+var_1200],	ecx
		mov	byte ptr [ebp+var_4], 3
		mov	esi, esp
		mov	edx, [ebp+var_1200]
		push	edx
		mov	edi, esp
		push	0FFFFFFFFh	; int
		push	offset ??_C@_17HIKLPLBG@?$AA?5?$AA?9?$AA?5?$AA?$AA@ ; "	- "
		push	1		; signed __int8
		lea	ecx, [ebp+var_1158] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@CPB_WH@Z ; icu_56::UnicodeString::UnicodeString(signed char,wchar_t const *,int)
		cmp	edi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_1204],	eax
		mov	eax, [ebp+var_1204]
		mov	[ebp+var_1208],	eax
		mov	byte ptr [ebp+var_4], 4
		mov	edi, esp
		mov	ecx, [ebp+var_1208]
		push	ecx		; struct icu_56::UnicodeString *
		lea	ecx, [ebp+var_1008] ; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z ; icu_56::UnicodeString::append(icu_56::UnicodeString const &)
		cmp	edi, esp
		call	__RTC_CheckEsp
		mov	ecx, eax	; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z ; icu_56::UnicodeString::append(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 3
		mov	esi, esp
		lea	ecx, [ebp+var_1158] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_1110] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		lea	eax, [ebp+var_1008]
		push	eax
		mov	ecx, [ebp+this]
		mov	edx, [ecx+8]
		mov	eax, [ebp+this]
		mov	ecx, [eax+8]
		mov	edx, [edx]
		mov	eax, [edx+0Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		mov	ecx, [ebp+this]
		call	dword ptr ds:__imp_?reset@ErrorCode@icu_56@@QAE?AW4UErrorCode@@XZ ; icu_56::ErrorCode::reset(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_11F1],	1
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_1008] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	al, [ebp+var_11F1]
		jmp	short loc_1A0D
; ---------------------------------------------------------------------------
		jmp	short loc_1A0D
; ---------------------------------------------------------------------------

loc_19F9:				; CODE XREF: IcuTestErrorCode::logDataIfFailureAndReset(char const *,...)+5Bj
		mov	esi, esp
		mov	ecx, [ebp+this]
		call	dword ptr ds:__imp_?reset@ErrorCode@icu_56@@QAE?AW4UErrorCode@@XZ ; icu_56::ErrorCode::reset(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		xor	al, al

loc_1A0D:				; CODE XREF: IcuTestErrorCode::logDataIfFailureAndReset(char const *,...)+2C9j
					; IcuTestErrorCode::logDataIfFailureAndReset(char const	*,...)+2CBj
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN14_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 1208h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?logDataIfFailureAndReset@IcuTestErrorCode@@QAACPBDZZ endp

; ---------------------------------------------------------------------------
		align 4
$LN14_0		dd 2			; DATA XREF: IcuTestErrorCode::logDataIfFailureAndReset(char const *,...)+2E5o
		dd offset $LN13_0
$LN13_0		dd 0FFFFF04Ch, 0FA0h	; DATA XREF: .text:00001A4Co
		dd offset $LN10_0	; "buffer"
		dd 0FFFFEFF8h, 40h
		dd offset $LN11_0
$LN11_0		dd 67736Dh		; DATA XREF: .text:00001A64o
$LN10_0		db 'buffer',0           ; DATA XREF: .text:00001A58o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 1A74h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?logDataIfFailureAndReset@IcuTestErrorCode@@QAACPBDZZ$0	proc near
					; DATA XREF: .xdata$x:00001B30o
		mov	esi, esp
		lea	ecx, [ebp-1008h] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?logDataIfFailureAndReset@IcuTestErrorCode@@QAACPBDZZ$0	endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?logDataIfFailureAndReset@IcuTestErrorCode@@QAACPBDZZ$1	proc near
					; DATA XREF: .xdata$x:00001B38o
		mov	esi, esp
		lea	ecx, [ebp-11A0h] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?logDataIfFailureAndReset@IcuTestErrorCode@@QAACPBDZZ$1	endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?logDataIfFailureAndReset@IcuTestErrorCode@@QAACPBDZZ$2	proc near
					; DATA XREF: .xdata$x:00001B40o
		mov	esi, esp
		lea	ecx, [ebp-11E8h] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?logDataIfFailureAndReset@IcuTestErrorCode@@QAACPBDZZ$2	endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?logDataIfFailureAndReset@IcuTestErrorCode@@QAACPBDZZ$3	proc near
					; DATA XREF: .xdata$x:00001B48o
		mov	esi, esp
		lea	ecx, [ebp-1110h] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?logDataIfFailureAndReset@IcuTestErrorCode@@QAACPBDZZ$3	endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?logDataIfFailureAndReset@IcuTestErrorCode@@QAACPBDZZ$4	proc near
					; DATA XREF: .xdata$x:00001B50o
		mov	esi, esp
		lea	ecx, [ebp-1158h] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?logDataIfFailureAndReset@IcuTestErrorCode@@QAACPBDZZ$4	endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?logDataIfFailureAndReset@IcuTestErrorCode@@QAACPBDZZ proc near
					; DATA XREF: IcuTestErrorCode::logDataIfFailureAndReset(char const *,...)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-120Ch]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?logDataIfFailureAndReset@IcuTestErrorCode@@QAACPBDZZ
		jmp	___CxxFrameHandler3
__ehhandler$?logDataIfFailureAndReset@IcuTestErrorCode@@QAACPBDZZ endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 1B08h
__ehfuncinfo$?logDataIfFailureAndReset@IcuTestErrorCode@@QAACPBDZZ dd 19930522h, 5
					; DATA XREF: __ehhandler$?logDataIfFailureAndReset@IcuTestErrorCode@@QAACPBDZZ+1Eo
		dd offset __unwindtable$?logDataIfFailureAndReset@IcuTestErrorCode@@QAACPBDZZ
		dd 5 dup(0)
		dd 1
__unwindtable$?logDataIfFailureAndReset@IcuTestErrorCode@@QAACPBDZZ dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00001B10o
		dd offset __unwindfunclet$?logDataIfFailureAndReset@IcuTestErrorCode@@QAACPBDZZ$0
		align 8
		dd offset __unwindfunclet$?logDataIfFailureAndReset@IcuTestErrorCode@@QAACPBDZZ$1
		dd 1
		dd offset __unwindfunclet$?logDataIfFailureAndReset@IcuTestErrorCode@@QAACPBDZZ$2
		align 8
		dd offset __unwindfunclet$?logDataIfFailureAndReset@IcuTestErrorCode@@QAACPBDZZ$3
		dd 3
		dd offset __unwindfunclet$?logDataIfFailureAndReset@IcuTestErrorCode@@QAACPBDZZ$4
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1B54h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall IcuTestErrorCode::handleFailure(IcuTestErrorCode *__hidden this)
		public ?handleFailure@IcuTestErrorCode@@MBEXXZ
?handleFailure@IcuTestErrorCode@@MBEXXZ	proc near
					; CODE XREF: IcuTestErrorCode::~IcuTestErrorCode(void)+6Ep
					; DATA XREF: .rdata:00000B14o

var_1C4		= dword	ptr -1C4h
var_1C0		= dword	ptr -1C0h
var_1BC		= dword	ptr -1BCh
var_1B8		= dword	ptr -1B8h
var_1B0		= byte ptr -1B0h
var_168		= byte ptr -168h
var_60		= byte ptr -60h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?handleFailure@IcuTestErrorCode@@MBEXXZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 1B8h
		push	ebx
		push	esi
		push	edi		; struct icu_56::UnicodeString *
		push	ecx
		lea	edi, [ebp+var_1C4]
		mov	ecx, 6Eh ; 'n'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax		; struct icu_56::UnicodeString *
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		mov	esi, esp
		push	0
		push	0FFFFFFFFh
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+0Ch]
		push	ecx
		lea	ecx, [ebp+var_60]
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@PBDHW4EInvariant@01@@Z ; icu_56::UnicodeString::UnicodeString(char const *,int,icu_56::UnicodeString::EInvariant)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		mov	esi, esp
		push	0
		push	0FFFFFFFFh
		mov	edi, esp
		mov	ecx, [ebp+var_18] ; this
		call	dword ptr ds:__imp_?errorName@ErrorCode@icu_56@@QBEPBDXZ ; icu_56::ErrorCode::errorName(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		push	eax
		lea	ecx, [ebp+var_168]
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@PBDHW4EInvariant@01@@Z ; icu_56::UnicodeString::UnicodeString(char const *,int,icu_56::UnicodeString::EInvariant)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_1B8], eax
		mov	eax, [ebp+var_1B8]
		mov	[ebp+var_1BC], eax
		mov	byte ptr [ebp+var_4], 1
		mov	esi, esp
		mov	ecx, [ebp+var_1BC]
		push	ecx
		mov	edi, esp
		push	0FFFFFFFFh	; int
		push	offset ??_C@_1BG@ONGINEJD@?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAu?$AAr?$AAe?$AA?3?$AA?5?$AA?$AA@ ; " failure: "
		push	1		; signed __int8
		lea	ecx, [ebp+var_1B0] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@CPB_WH@Z ; icu_56::UnicodeString::UnicodeString(signed char,wchar_t const *,int)
		cmp	edi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_1C0], eax
		mov	edx, [ebp+var_1C0]
		mov	[ebp+var_1C4], edx
		mov	byte ptr [ebp+var_4], 2
		mov	edi, esp
		mov	eax, [ebp+var_1C4]
		push	eax		; struct icu_56::UnicodeString *
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z ; icu_56::UnicodeString::append(icu_56::UnicodeString const &)
		cmp	edi, esp
		call	__RTC_CheckEsp
		mov	ecx, eax	; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z ; icu_56::UnicodeString::append(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 1
		mov	esi, esp
		lea	ecx, [ebp+var_1B0] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_168] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		mov	ecx, [ebp+var_18]
		call	dword ptr ds:__imp_?get@ErrorCode@icu_56@@QBE?AW4UErrorCode@@XZ	; icu_56::ErrorCode::get(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	eax, 2
		jz	short loc_1CC4
		mov	esi, esp
		mov	ecx, [ebp+var_18]
		call	dword ptr ds:__imp_?get@ErrorCode@icu_56@@QBE?AW4UErrorCode@@XZ	; icu_56::ErrorCode::get(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	eax, 4
		jnz	short loc_1CE6

loc_1CC4:				; CODE XREF: IcuTestErrorCode::handleFailure(void)+157j
		mov	esi, esp
		lea	eax, [ebp+var_60]
		push	eax
		mov	ecx, [ebp+var_18]
		mov	edx, [ecx+8]
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+8]
		mov	edx, [edx]
		mov	eax, [edx+0Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_1D06
; ---------------------------------------------------------------------------

loc_1CE6:				; CODE XREF: IcuTestErrorCode::handleFailure(void)+16Ej
		mov	esi, esp
		lea	eax, [ebp+var_60]
		push	eax
		mov	ecx, [ebp+var_18]
		mov	edx, [ecx+8]
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+8]
		mov	edx, [edx]
		mov	eax, [edx+4]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_1D06:				; CODE XREF: IcuTestErrorCode::handleFailure(void)+190j
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN12
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 1C4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?handleFailure@IcuTestErrorCode@@MBEXXZ	endp

; ---------------------------------------------------------------------------
		align 4
$LN12		dd 1			; DATA XREF: IcuTestErrorCode::handleFailure(void)+1CFo
		dd offset $LN11_1
$LN11_1		dd 0FFFFFFA0h, 40h	; DATA XREF: .text:00001D60o
		dd offset $LN9
$LN9		dd 67736Dh		; DATA XREF: .text:00001D6Co
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 1D74h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?handleFailure@IcuTestErrorCode@@MBEXXZ$0 proc near
					; DATA XREF: .xdata$x:00001DDCo
		mov	esi, esp
		lea	ecx, [ebp-60h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?handleFailure@IcuTestErrorCode@@MBEXXZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?handleFailure@IcuTestErrorCode@@MBEXXZ$1 proc near
					; DATA XREF: .xdata$x:00001DE4o
		mov	esi, esp
		lea	ecx, [ebp-168h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?handleFailure@IcuTestErrorCode@@MBEXXZ$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?handleFailure@IcuTestErrorCode@@MBEXXZ$2 proc near
					; DATA XREF: .xdata$x:00001DECo
		mov	esi, esp
		lea	ecx, [ebp-1B0h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?handleFailure@IcuTestErrorCode@@MBEXXZ$2 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?handleFailure@IcuTestErrorCode@@MBEXXZ proc near
					; DATA XREF: IcuTestErrorCode::handleFailure(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-1C8h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?handleFailure@IcuTestErrorCode@@MBEXXZ
		jmp	___CxxFrameHandler3
__ehhandler$?handleFailure@IcuTestErrorCode@@MBEXXZ endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 1DD8h
__unwindtable$?handleFailure@IcuTestErrorCode@@MBEXXZ dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00001DF8o
		dd offset __unwindfunclet$?handleFailure@IcuTestErrorCode@@MBEXXZ$0
		dd 0
		dd offset __unwindfunclet$?handleFailure@IcuTestErrorCode@@MBEXXZ$1
		dd 1
		dd offset __unwindfunclet$?handleFailure@IcuTestErrorCode@@MBEXXZ$2
__ehfuncinfo$?handleFailure@IcuTestErrorCode@@MBEXXZ dd	19930522h, 3
					; DATA XREF: __ehhandler$?handleFailure@IcuTestErrorCode@@MBEXXZ+1Eo
		dd offset __unwindtable$?handleFailure@IcuTestErrorCode@@MBEXXZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1E14h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct TestDataModule	*__cdecl TestDataModule::getTestDataModule(const char *, struct	TestLog	*, enum	UErrorCode *)
		public ?getTestDataModule@TestDataModule@@SAPAV1@PBDAAVTestLog@@AAW4UErrorCode@@@Z
?getTestDataModule@TestDataModule@@SAPAV1@PBDAAVTestLog@@AAW4UErrorCode@@@Z proc near

var_10C		= dword	ptr -10Ch
var_104		= dword	ptr -104h
var_F8		= dword	ptr -0F8h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?getTestDataModule@TestDataModule@@SAPAV1@PBDAAVTestLog@@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 100h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_10C]
		mov	ecx, 40h ; '@'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_1E6D
		xor	eax, eax
		jmp	loc_1F44
; ---------------------------------------------------------------------------

loc_1E6D:				; CODE XREF: TestDataModule::getTestDataModule(char const *,TestLog &,UErrorCode &)+50j
		mov	[ebp+var_14], 0
		push	28h ; '('       ; unsigned int
		call	??2@YAPAXI@Z	; operator new(uint)
		add	esp, 4
		mov	[ebp+var_F8], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_F8], 0
		jz	short loc_1EB3
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; char *
		mov	ecx, [ebp+var_F8]
		call	??0RBTestDataModule@@QAE@PBDAAVTestLog@@AAW4UErrorCode@@@Z ; RBTestDataModule::RBTestDataModule(char const *,TestLog &,UErrorCode &)
		mov	[ebp+var_10C], eax
		jmp	short loc_1EBD
; ---------------------------------------------------------------------------

loc_1EB3:				; CODE XREF: TestDataModule::getTestDataModule(char const *,TestLog &,UErrorCode &)+7Ej
		mov	[ebp+var_10C], 0

loc_1EBD:				; CODE XREF: TestDataModule::getTestDataModule(char const *,TestLog &,UErrorCode &)+9Dj
		mov	eax, [ebp+var_10C]
		mov	[ebp+var_104], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_104]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_1EF5
		mov	eax, [ebp+var_14]
		jmp	short loc_1F44
; ---------------------------------------------------------------------------
		jmp	short loc_1F44
; ---------------------------------------------------------------------------

loc_1EF5:				; CODE XREF: TestDataModule::getTestDataModule(char const *,TestLog &,UErrorCode &)+D8j
		mov	eax, [ebp+var_14]
		mov	[ebp+var_E0], eax
		mov	ecx, [ebp+var_E0]
		mov	[ebp+var_EC], ecx
		cmp	[ebp+var_EC], 0
		jz	short loc_1F38
		mov	esi, esp
		push	1
		mov	edx, [ebp+var_EC]
		mov	eax, [edx]
		mov	ecx, [ebp+var_EC]
		mov	edx, [eax]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_10C], eax
		jmp	short loc_1F42
; ---------------------------------------------------------------------------

loc_1F38:				; CODE XREF: TestDataModule::getTestDataModule(char const *,TestLog &,UErrorCode &)+FDj
		mov	[ebp+var_10C], 0

loc_1F42:				; CODE XREF: TestDataModule::getTestDataModule(char const *,TestLog &,UErrorCode &)+122j
		xor	eax, eax

loc_1F44:				; CODE XREF: TestDataModule::getTestDataModule(char const *,TestLog &,UErrorCode &)+54j
					; TestDataModule::getTestDataModule(char const *,TestLog &,UErrorCode &)+DDj ...
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 10Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getTestDataModule@TestDataModule@@SAPAV1@PBDAAVTestLog@@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 1F64h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getTestDataModule@TestDataModule@@SAPAV1@PBDAAVTestLog@@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:00001F94o
		mov	eax, [ebp-0F8h]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		pop	ecx
		retn
__unwindfunclet$?getTestDataModule@TestDataModule@@SAPAV1@PBDAAVTestLog@@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?getTestDataModule@TestDataModule@@SAPAV1@PBDAAVTestLog@@AAW4UErrorCode@@@Z	proc near
					; DATA XREF: TestDataModule::getTestDataModule(char const *,TestLog &,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-110h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?getTestDataModule@TestDataModule@@SAPAV1@PBDAAVTestLog@@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?getTestDataModule@TestDataModule@@SAPAV1@PBDAAVTestLog@@AAW4UErrorCode@@@Z	endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 1F90h
__unwindtable$?getTestDataModule@TestDataModule@@SAPAV1@PBDAAVTestLog@@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00001FA0o
		dd offset __unwindfunclet$?getTestDataModule@TestDataModule@@SAPAV1@PBDAAVTestLog@@AAW4UErrorCode@@@Z$0
__ehfuncinfo$?getTestDataModule@TestDataModule@@SAPAV1@PBDAAVTestLog@@AAW4UErrorCode@@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$?getTestDataModule@TestDataModule@@SAPAV1@PBDAAVTestLog@@AAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$?getTestDataModule@TestDataModule@@SAPAV1@PBDAAVTestLog@@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1FBCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl U_SUCCESS(enum  UErrorCode)
?U_SUCCESS@@YACW4UErrorCode@@@Z	proc near
					; CODE XREF: TestDataModule::getTestDataModule(char const *,TestLog &,UErrorCode &)+CBp
					; RBTestDataModule::createTestData(int,UErrorCode &)+9Fp ...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		setle	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?U_SUCCESS@@YACW4UErrorCode@@@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1FE8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl U_FAILURE(enum  UErrorCode)
?U_FAILURE@@YACW4UErrorCode@@@Z	proc near
					; CODE XREF: TestDataModule::getTestDataModule(char const *,TestLog &,UErrorCode &)+43p

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		setnle	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?U_FAILURE@@YACW4UErrorCode@@@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2014h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; protected: __thiscall	TestDataModule::TestDataModule(char const *, class TestLog &, enum  UErrorCode &)
		public ??0TestDataModule@@IAE@PBDAAVTestLog@@AAW4UErrorCode@@@Z
??0TestDataModule@@IAE@PBDAAVTestLog@@AAW4UErrorCode@@@Z proc near
					; CODE XREF: RBTestDataModule::RBTestDataModule(char const *,TestLog &,UErrorCode &)+54p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7TestDataModule@@6B@	; const	TestDataModule::`vftable'
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+4], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+8], 0
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		mov	[eax+0Ch], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	0Ch
??0TestDataModule@@IAE@PBDAAVTestLog@@AAW4UErrorCode@@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2068h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall TestDataModule::~TestDataModule(TestDataModule *__hidden this)
		public ??1TestDataModule@@UAE@XZ
??1TestDataModule@@UAE@XZ proc near	; CODE XREF: TestDataModule::`scalar deleting destructor'(uint)+26p
					; TestDataModule::`vector deleting destructor'(uint)+64p ...

var_E8		= dword	ptr -0E8h
var_E0		= dword	ptr -0E0h
var_D4		= dword	ptr -0D4h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E8]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7TestDataModule@@6B@	; const	TestDataModule::`vftable'
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+8], 0
		jz	short loc_20ED
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		mov	[ebp+var_D4], ecx
		mov	edx, [ebp+var_D4]
		mov	[ebp+var_E0], edx
		cmp	[ebp+var_E0], 0
		jz	short loc_20E3
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_E0]
		mov	edx, [eax]
		mov	ecx, [ebp+var_E0]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_E8], eax
		jmp	short loc_20ED
; ---------------------------------------------------------------------------

loc_20E3:				; CODE XREF: TestDataModule::~TestDataModule(void)+54j
		mov	[ebp+var_E8], 0

loc_20ED:				; CODE XREF: TestDataModule::~TestDataModule(void)+33j
					; TestDataModule::~TestDataModule(void)+79j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1TestDataModule@@UAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2104h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	char *__thiscall TestDataModule::getName(TestDataModule	*__hidden this)
		public ?getName@TestDataModule@@QBEPBDXZ
?getName@TestDataModule@@QBEPBDXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getName@TestDataModule@@QBEPBDXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2134h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall RBTestDataModule::~RBTestDataModule(RBTestDataModule *__hidden this)
		public ??1RBTestDataModule@@UAE@XZ
??1RBTestDataModule@@UAE@XZ proc near	; CODE XREF: RBTestDataModule::`scalar deleting	destructor'(uint)+26p
					; RBTestDataModule::`vector deleting destructor'(uint)+64p
					; DATA XREF: ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7RBTestDataModule@@6B@ ; const RBTestDataModule::`vftable'
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+14h]
		push	ecx
		call	_ures_close_56
		add	esp, 4
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		push	ecx
		call	_ures_close_56
		add	esp, 4
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+18h]
		push	ecx
		call	_ures_close_56
		add	esp, 4
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+20h]
		push	ecx
		call	_uprv_free_56
		add	esp, 4
		mov	ecx, [ebp+var_8] ; this
		call	??1TestDataModule@@UAE@XZ ; TestDataModule::~TestDataModule(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1RBTestDataModule@@UAE@XZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 21B8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	RBTestDataModule::RBTestDataModule(char	*, int,	enum UErrorCode	*)
		public ??0RBTestDataModule@@QAE@PBDAAVTestLog@@AAW4UErrorCode@@@Z
??0RBTestDataModule@@QAE@PBDAAVTestLog@@AAW4UErrorCode@@@Z proc	near
					; CODE XREF: TestDataModule::getTestDataModule(char const *,TestLog &,UErrorCode &)+92p

var_144		= dword	ptr -144h
var_140		= dword	ptr -140h
var_138		= dword	ptr -138h
var_12C		= dword	ptr -12Ch
var_120		= byte ptr -120h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0RBTestDataModule@@QAE@PBDAAVTestLog@@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 138h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_144]
		mov	ecx, 4Eh ; 'N'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		mov	ecx, [ebp+var_18]
		call	??0TestDataModule@@IAE@PBDAAVTestLog@@AAW4UErrorCode@@@Z ; TestDataModule::TestDataModule(char const *,TestLog &,UErrorCode &)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_18]
		mov	dword ptr [eax], offset	??_7RBTestDataModule@@6B@ ; const RBTestDataModule::`vftable'
		mov	eax, [ebp+var_18]
		mov	dword ptr [eax+10h], 0
		mov	eax, [ebp+var_18]
		mov	dword ptr [eax+14h], 0
		mov	eax, [ebp+var_18]
		mov	dword ptr [eax+18h], 0
		mov	eax, [ebp+var_18]
		mov	dword ptr [eax+20h], 0
		mov	eax, [ebp+var_18]
		mov	dword ptr [eax+24h], 0
		mov	eax, [ebp+var_18]
		mov	byte ptr [eax+1Ch], 1
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; char *
		mov	ecx, [ebp+var_18] ; this
		call	?getTestBundle@RBTestDataModule@@AAEPAUUResourceBundle@@PBDAAW4UErrorCode@@@Z ;	RBTestDataModule::getTestBundle(char const *,UErrorCode	&)
		mov	edx, [ebp+var_18]
		mov	[edx+10h], eax
		mov	eax, [ebp+var_18]
		movsx	ecx, byte ptr [eax+1Ch]
		test	ecx, ecx
		jz	loc_23B0
		mov	eax, [ebp+arg_8]
		push	eax
		push	0
		push	offset ??_C@_08OCIHCEBA@TestData?$AA@ ;	"TestData"
		mov	ecx, [ebp+var_18]
		mov	edx, [ecx+10h]
		push	edx
		call	_ures_getByKey_56
		add	esp, 10h
		mov	ecx, [ebp+var_18]
		mov	[ecx+14h], eax
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+14h]
		push	ecx
		call	_ures_getSize_56
		add	esp, 4
		mov	edx, [ebp+var_18]
		mov	[edx+24h], eax
		mov	eax, [ebp+arg_8]
		push	eax
		push	0
		push	offset ??_C@_04BJPIHCBA@Info?$AA@ ; "Info"
		mov	ecx, [ebp+var_18]
		mov	edx, [ecx+10h]
		push	edx
		call	_ures_getByKey_56
		add	esp, 10h
		mov	ecx, [ebp+var_18]
		mov	[ecx+18h], eax
		mov	eax, [ebp+arg_8]
		cmp	dword ptr [eax], 0
		jz	short loc_234F
		mov	esi, esp
		push	0FFFFFFFFh	; int
		push	offset ??_C@_1JC@NJKEKHLM@?$AAU?$AAn?$AAa?$AAb?$AAl?$AAe?$AA?5?$AAt?$AAo?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAa?$AAl?$AAi?$AAz?$AAe?$AA?5?$AAt?$AAe?$AAs?$AAt?$AA?5?$AAd?$AAa?$AAt?$AAa?$AA?5?$AA?9?$AA?5@ ; "Unable to	initalize test data - missing"...
		push	1		; signed __int8
		lea	ecx, [ebp+var_120] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@CPB_WH@Z ; icu_56::UnicodeString::UnicodeString(signed char,wchar_t const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_140], eax
		mov	eax, [ebp+var_140]
		mov	[ebp+var_144], eax
		mov	byte ptr [ebp+var_4], 1
		mov	esi, esp
		mov	ecx, [ebp+var_144]
		push	ecx
		mov	edx, [ebp+arg_4]
		mov	eax, [edx]
		mov	ecx, [ebp+arg_4]
		mov	edx, [eax+4]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_120] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_18]
		mov	byte ptr [eax+1Ch], 0
		jmp	short loc_23B0
; ---------------------------------------------------------------------------

loc_234F:				; CODE XREF: RBTestDataModule::RBTestDataModule(char const *,TestLog &,UErrorCode &)+122j
		push	8		; unsigned int
		call	??2@YAPAXI@Z	; operator new(uint)
		add	esp, 4
		mov	[ebp+var_12C], eax
		mov	byte ptr [ebp+var_4], 2
		cmp	[ebp+var_12C], 0
		jz	short loc_238A
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+var_18]
		mov	edx, [ecx+18h]
		push	edx
		mov	ecx, [ebp+var_12C]
		call	??0RBDataMap@@QAE@PAUUResourceBundle@@AAW4UErrorCode@@@Z ; RBDataMap::RBDataMap(UResourceBundle	*,UErrorCode &)
		mov	[ebp+var_140], eax
		jmp	short loc_2394
; ---------------------------------------------------------------------------

loc_238A:				; CODE XREF: RBTestDataModule::RBTestDataModule(char const *,TestLog &,UErrorCode &)+1B2j
		mov	[ebp+var_140], 0

loc_2394:				; CODE XREF: RBTestDataModule::RBTestDataModule(char const *,TestLog &,UErrorCode &)+1D0j
		mov	eax, [ebp+var_140]
		mov	[ebp+var_138], eax
		mov	byte ptr [ebp+var_4], 0
		mov	ecx, [ebp+var_18]
		mov	edx, [ebp+var_138]
		mov	[ecx+8], edx

loc_23B0:				; CODE XREF: RBTestDataModule::RBTestDataModule(char const *,TestLog &,UErrorCode &)+C1j
					; RBTestDataModule::RBTestDataModule(char const	*,TestLog &,UErrorCode &)+195j
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_18]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 144h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
??0RBTestDataModule@@QAE@PBDAAVTestLog@@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 23E8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0RBTestDataModule@@QAE@PBDAAVTestLog@@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:000024E8o
		mov	ecx, [ebp-18h]	; this
		jmp	??1TestDataModule@@UAE@XZ ; TestDataModule::~TestDataModule(void)
__unwindfunclet$??0RBTestDataModule@@QAE@PBDAAVTestLog@@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0RBTestDataModule@@QAE@PBDAAVTestLog@@AAW4UErrorCode@@@Z$1 proc near
					; DATA XREF: .xdata$x:000024F0o
		mov	esi, esp
		lea	ecx, [ebp-120h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0RBTestDataModule@@QAE@PBDAAVTestLog@@AAW4UErrorCode@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0RBTestDataModule@@QAE@PBDAAVTestLog@@AAW4UErrorCode@@@Z$2 proc near
					; DATA XREF: .xdata$x:000024F8o
		mov	eax, [ebp-12Ch]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		pop	ecx
		retn
__unwindfunclet$??0RBTestDataModule@@QAE@PBDAAVTestLog@@AAW4UErrorCode@@@Z$2 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0RBTestDataModule@@QAE@PBDAAVTestLog@@AAW4UErrorCode@@@Z proc near
					; DATA XREF: RBTestDataModule::RBTestDataModule(char const *,TestLog &,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-148h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0RBTestDataModule@@QAE@PBDAAVTestLog@@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0RBTestDataModule@@QAE@PBDAAVTestLog@@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 243Ch
		public ??_C@_1JC@NJKEKHLM@?$AAU?$AAn?$AAa?$AAb?$AAl?$AAe?$AA?5?$AAt?$AAo?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAa?$AAl?$AAi?$AAz?$AAe?$AA?5?$AAt?$AAe?$AAs?$AAt?$AA?5?$AAd?$AAa?$AAt?$AAa?$AA?5?$AA?9?$AA?5@
; wchar_t `string'
??_C@_1JC@NJKEKHLM@?$AAU?$AAn?$AAa?$AAb?$AAl?$AAe?$AA?5?$AAt?$AAo?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAa?$AAl?$AAi?$AAz?$AAe?$AA?5?$AAt?$AAe?$AAs?$AAt?$AA?5?$AAd?$AAa?$AAt?$AAa?$AA?5?$AA?9?$AA?5@:
					; DATA XREF: RBTestDataModule::RBTestDataModule(char const *,TestLog &,UErrorCode &)+128o
		unicode	0, <Unable to initalize	test data - missing mandatory descrip>
		unicode	0, <tion resources!>,0
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 24D0h
		public ??_C@_04BJPIHCBA@Info?$AA@
; `string'
??_C@_04BJPIHCBA@Info?$AA@ db 'Info',0  ; DATA XREF: RBTestDataModule::RBTestDataModule(char const *,TestLog &,UErrorCode &)+102o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 24D8h
		public ??_C@_08OCIHCEBA@TestData?$AA@
; `string'
??_C@_08OCIHCEBA@TestData?$AA@ db 'TestData',0
					; DATA XREF: RBTestDataModule::RBTestDataModule(char const *,TestLog &,UErrorCode &)+CDo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 24E4h
__unwindtable$??0RBTestDataModule@@QAE@PBDAAVTestLog@@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00002504o
		dd offset __unwindfunclet$??0RBTestDataModule@@QAE@PBDAAVTestLog@@AAW4UErrorCode@@@Z$0
		align 10h
		dd offset __unwindfunclet$??0RBTestDataModule@@QAE@PBDAAVTestLog@@AAW4UErrorCode@@@Z$1
		align 8
		dd offset __unwindfunclet$??0RBTestDataModule@@QAE@PBDAAVTestLog@@AAW4UErrorCode@@@Z$2
__ehfuncinfo$??0RBTestDataModule@@QAE@PBDAAVTestLog@@AAW4UErrorCode@@@Z	dd 19930522h, 3
					; DATA XREF: __ehhandler$??0RBTestDataModule@@QAE@PBDAAVTestLog@@AAW4UErrorCode@@@Z+1Eo
		dd offset __unwindtable$??0RBTestDataModule@@QAE@PBDAAVTestLog@@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2520h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall RBTestDataModule::getInfo(RBTestDataModule *this, const struct DataMap **, enum UErrorCode *)
		public ?getInfo@RBTestDataModule@@UBECAAPBVDataMap@@AAW4UErrorCode@@@Z
?getInfo@RBTestDataModule@@UBECAAPBVDataMap@@AAW4UErrorCode@@@Z	proc near
					; DATA XREF: .rdata:00001040o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+8]
		mov	[eax], edx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+8], 0
		jz	short loc_255D
		mov	al, 1
		jmp	short loc_255F
; ---------------------------------------------------------------------------
		jmp	short loc_255F
; ---------------------------------------------------------------------------

loc_255D:				; CODE XREF: RBTestDataModule::getInfo(DataMap const * &,UErrorCode &)+35j
		xor	al, al

loc_255F:				; CODE XREF: RBTestDataModule::getInfo(DataMap const * &,UErrorCode &)+39j
					; RBTestDataModule::getInfo(DataMap const * &,UErrorCode &)+3Bj
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	8
?getInfo@RBTestDataModule@@UBECAAPBVDataMap@@AAW4UErrorCode@@@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2568h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct TestData *__thiscall RBTestDataModule::createTestData(RBTestDataModule	*this, int, enum UErrorCode *)
		public ?createTestData@RBTestDataModule@@UBEPAVTestData@@HAAW4UErrorCode@@@Z
?createTestData@RBTestDataModule@@UBEPAVTestData@@HAAW4UErrorCode@@@Z proc near
					; DATA XREF: .rdata:00001048o

var_13C		= dword	ptr -13Ch
var_134		= dword	ptr -134h
var_128		= dword	ptr -128h
var_11C		= dword	ptr -11Ch
var_110		= dword	ptr -110h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?createTestData@RBTestDataModule@@UBEPAVTestData@@HAAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 130h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_13C]
		mov	ecx, 4Ch ; 'L'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	[ebp+var_20], 0
		mov	[ebp+var_2C], 0
		mov	eax, [ebp+var_14]
		movsx	ecx, byte ptr [eax+1Ch]
		cmp	ecx, 1
		jnz	loc_2704
		mov	eax, [ebp+arg_4]
		push	eax
		push	0
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	edx, [ebp+var_14]
		mov	eax, [edx+14h]
		push	eax
		call	_ures_getByIndex_56
		add	esp, 10h
		mov	[ebp+var_38], eax
		lea	eax, [ebp+var_2C]
		push	eax
		push	0
		push	offset ??_C@_07EJKOAGME@Headers?$AA@ ; "Headers"
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+18h]
		push	edx
		call	_ures_getByKey_56
		add	esp, 10h
		mov	[ebp+var_44], eax
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	loc_26EA
		push	34h ; '4'       ; unsigned int
		call	??2@YAPAXI@Z	; operator new(uint)
		add	esp, 4
		mov	[ebp+var_128], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_128], 0
		jz	short loc_2659
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_44]
		push	ecx
		mov	edx, [ebp+var_38]
		push	edx
		mov	ecx, [ebp+var_128]
		call	??0RBTestData@@QAE@PAUUResourceBundle@@0AAW4UErrorCode@@@Z ; RBTestData::RBTestData(UResourceBundle *,UResourceBundle *,UErrorCode &)
		mov	[ebp+var_13C], eax
		jmp	short loc_2663
; ---------------------------------------------------------------------------

loc_2659:				; CODE XREF: RBTestDataModule::createTestData(int,UErrorCode &)+D0j
		mov	[ebp+var_13C], 0

loc_2663:				; CODE XREF: RBTestDataModule::createTestData(int,UErrorCode &)+EFj
		mov	eax, [ebp+var_13C]
		mov	[ebp+var_134], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_134]
		mov	[ebp+var_20], ecx
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_269B
		mov	eax, [ebp+var_20]
		jmp	short loc_270F
; ---------------------------------------------------------------------------
		jmp	short loc_26E8
; ---------------------------------------------------------------------------

loc_269B:				; CODE XREF: RBTestDataModule::createTestData(int,UErrorCode &)+12Aj
		mov	eax, [ebp+var_20]
		mov	[ebp+var_110], eax
		mov	ecx, [ebp+var_110]
		mov	[ebp+var_11C], ecx
		cmp	[ebp+var_11C], 0
		jz	short loc_26DE
		mov	esi, esp
		push	1
		mov	edx, [ebp+var_11C]
		mov	eax, [edx]
		mov	ecx, [ebp+var_11C]
		mov	edx, [eax]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_13C], eax
		jmp	short loc_26E8
; ---------------------------------------------------------------------------

loc_26DE:				; CODE XREF: RBTestDataModule::createTestData(int,UErrorCode &)+14Fj
		mov	[ebp+var_13C], 0

loc_26E8:				; CODE XREF: RBTestDataModule::createTestData(int,UErrorCode &)+131j
					; RBTestDataModule::createTestData(int,UErrorCode &)+174j
		jmp	short loc_2702
; ---------------------------------------------------------------------------

loc_26EA:				; CODE XREF: RBTestDataModule::createTestData(int,UErrorCode &)+ACj
		mov	eax, [ebp+var_38]
		push	eax
		call	_ures_close_56
		add	esp, 4
		mov	eax, [ebp+var_44]
		push	eax
		call	_ures_close_56
		add	esp, 4

loc_2702:				; CODE XREF: RBTestDataModule::createTestData(int,UErrorCode &):loc_26E8j
		jmp	short loc_270D
; ---------------------------------------------------------------------------

loc_2704:				; CODE XREF: RBTestDataModule::createTestData(int,UErrorCode &)+5Aj
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 2

loc_270D:				; CODE XREF: RBTestDataModule::createTestData(int,UErrorCode &):loc_2702j
		xor	eax, eax

loc_270F:				; CODE XREF: RBTestDataModule::createTestData(int,UErrorCode &)+12Fj
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN17
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 13Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?createTestData@RBTestDataModule@@UBEPAVTestData@@HAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN17		dd 1			; DATA XREF: RBTestDataModule::createTestData(int,UErrorCode &)+1ABo
		dd offset $LN16
$LN16		dd 0FFFFFFD4h, 4	; DATA XREF: .text:00002748o
		dd offset $LN14_1	; "intStatus"
$LN14_1		db 'intStatus',0        ; DATA XREF: .text:00002754o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 2764h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?createTestData@RBTestDataModule@@UBEPAVTestData@@HAAW4UErrorCode@@@Z$0	proc near
					; DATA XREF: .xdata$x:0000279Co
		mov	eax, [ebp-128h]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		pop	ecx
		retn
__unwindfunclet$?createTestData@RBTestDataModule@@UBEPAVTestData@@HAAW4UErrorCode@@@Z$0	endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?createTestData@RBTestDataModule@@UBEPAVTestData@@HAAW4UErrorCode@@@Z proc near
					; DATA XREF: RBTestDataModule::createTestData(int,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-140h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?createTestData@RBTestDataModule@@UBEPAVTestData@@HAAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?createTestData@RBTestDataModule@@UBEPAVTestData@@HAAW4UErrorCode@@@Z endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2790h
		public ??_C@_07EJKOAGME@Headers?$AA@
; `string'
??_C@_07EJKOAGME@Headers?$AA@ db 'Headers',0
					; DATA XREF: RBTestDataModule::createTestData(int,UErrorCode &)+82o
					; RBTestDataModule::createTestData(char	const *,UErrorCode &)+82o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 2798h
__unwindtable$?createTestData@RBTestDataModule@@UBEPAVTestData@@HAAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000027A8o
		dd offset __unwindfunclet$?createTestData@RBTestDataModule@@UBEPAVTestData@@HAAW4UErrorCode@@@Z$0
__ehfuncinfo$?createTestData@RBTestDataModule@@UBEPAVTestData@@HAAW4UErrorCode@@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$?createTestData@RBTestDataModule@@UBEPAVTestData@@HAAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$?createTestData@RBTestDataModule@@UBEPAVTestData@@HAAW4UErrorCode@@@Z
		align 20h
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 27C4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct TestData *__thiscall RBTestDataModule::createTestData(RBTestDataModule	*this, const char *, enum UErrorCode *)
		public ?createTestData@RBTestDataModule@@UBEPAVTestData@@PBDAAW4UErrorCode@@@Z
?createTestData@RBTestDataModule@@UBEPAVTestData@@PBDAAW4UErrorCode@@@Z	proc near
					; DATA XREF: .rdata:00001044o

var_13C		= dword	ptr -13Ch
var_134		= dword	ptr -134h
var_128		= dword	ptr -128h
var_11C		= dword	ptr -11Ch
var_110		= dword	ptr -110h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?createTestData@RBTestDataModule@@UBEPAVTestData@@PBDAAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 130h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_13C]
		mov	ecx, 4Ch ; 'L'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	[ebp+var_20], 0
		mov	[ebp+var_2C], 0
		mov	eax, [ebp+var_14]
		movsx	ecx, byte ptr [eax+1Ch]
		cmp	ecx, 1
		jnz	loc_2960
		mov	eax, [ebp+arg_4]
		push	eax
		push	0
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	edx, [ebp+var_14]
		mov	eax, [edx+14h]
		push	eax
		call	_ures_getByKey_56
		add	esp, 10h
		mov	[ebp+var_38], eax
		lea	eax, [ebp+var_2C]
		push	eax
		push	0
		push	offset ??_C@_07EJKOAGME@Headers?$AA@ ; "Headers"
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+18h]
		push	edx
		call	_ures_getByKey_56
		add	esp, 10h
		mov	[ebp+var_44], eax
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	loc_2946
		push	34h ; '4'       ; unsigned int
		call	??2@YAPAXI@Z	; operator new(uint)
		add	esp, 4
		mov	[ebp+var_128], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_128], 0
		jz	short loc_28B5
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_44]
		push	ecx
		mov	edx, [ebp+var_38]
		push	edx
		mov	ecx, [ebp+var_128]
		call	??0RBTestData@@QAE@PAUUResourceBundle@@0AAW4UErrorCode@@@Z ; RBTestData::RBTestData(UResourceBundle *,UResourceBundle *,UErrorCode &)
		mov	[ebp+var_13C], eax
		jmp	short loc_28BF
; ---------------------------------------------------------------------------

loc_28B5:				; CODE XREF: RBTestDataModule::createTestData(char const *,UErrorCode &)+D0j
		mov	[ebp+var_13C], 0

loc_28BF:				; CODE XREF: RBTestDataModule::createTestData(char const *,UErrorCode &)+EFj
		mov	eax, [ebp+var_13C]
		mov	[ebp+var_134], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_134]
		mov	[ebp+var_20], ecx
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_28F7
		mov	eax, [ebp+var_20]
		jmp	short loc_296B
; ---------------------------------------------------------------------------
		jmp	short loc_2944
; ---------------------------------------------------------------------------

loc_28F7:				; CODE XREF: RBTestDataModule::createTestData(char const *,UErrorCode &)+12Aj
		mov	eax, [ebp+var_20]
		mov	[ebp+var_110], eax
		mov	ecx, [ebp+var_110]
		mov	[ebp+var_11C], ecx
		cmp	[ebp+var_11C], 0
		jz	short loc_293A
		mov	esi, esp
		push	1
		mov	edx, [ebp+var_11C]
		mov	eax, [edx]
		mov	ecx, [ebp+var_11C]
		mov	edx, [eax]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_13C], eax
		jmp	short loc_2944
; ---------------------------------------------------------------------------

loc_293A:				; CODE XREF: RBTestDataModule::createTestData(char const *,UErrorCode &)+14Fj
		mov	[ebp+var_13C], 0

loc_2944:				; CODE XREF: RBTestDataModule::createTestData(char const *,UErrorCode &)+131j
					; RBTestDataModule::createTestData(char	const *,UErrorCode &)+174j
		jmp	short loc_295E
; ---------------------------------------------------------------------------

loc_2946:				; CODE XREF: RBTestDataModule::createTestData(char const *,UErrorCode &)+ACj
		mov	eax, [ebp+var_38]
		push	eax
		call	_ures_close_56
		add	esp, 4
		mov	eax, [ebp+var_44]
		push	eax
		call	_ures_close_56
		add	esp, 4

loc_295E:				; CODE XREF: RBTestDataModule::createTestData(char const *,UErrorCode &):loc_2944j
		jmp	short loc_2969
; ---------------------------------------------------------------------------

loc_2960:				; CODE XREF: RBTestDataModule::createTestData(char const *,UErrorCode &)+5Aj
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 2

loc_2969:				; CODE XREF: RBTestDataModule::createTestData(char const *,UErrorCode &):loc_295Ej
		xor	eax, eax

loc_296B:				; CODE XREF: RBTestDataModule::createTestData(char const *,UErrorCode &)+12Fj
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN17_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 13Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?createTestData@RBTestDataModule@@UBEPAVTestData@@PBDAAW4UErrorCode@@@Z	endp

; ---------------------------------------------------------------------------
		align 10h
$LN17_0		dd 1			; DATA XREF: RBTestDataModule::createTestData(char const *,UErrorCode &)+1ABo
		dd offset $LN16_0
$LN16_0		dd 0FFFFFFD4h, 4	; DATA XREF: .text:000029A4o
		dd offset $LN14_2	; "intStatus"
$LN14_2		db 'intStatus',0        ; DATA XREF: .text:000029B0o
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 29C0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?createTestData@RBTestDataModule@@UBEPAVTestData@@PBDAAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:000029F0o
		mov	eax, [ebp-128h]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		pop	ecx
		retn
__unwindfunclet$?createTestData@RBTestDataModule@@UBEPAVTestData@@PBDAAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?createTestData@RBTestDataModule@@UBEPAVTestData@@PBDAAW4UErrorCode@@@Z proc near
					; DATA XREF: RBTestDataModule::createTestData(char const *,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-140h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?createTestData@RBTestDataModule@@UBEPAVTestData@@PBDAAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?createTestData@RBTestDataModule@@UBEPAVTestData@@PBDAAW4UErrorCode@@@Z endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 29ECh
__unwindtable$?createTestData@RBTestDataModule@@UBEPAVTestData@@PBDAAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000029FCo
		dd offset __unwindfunclet$?createTestData@RBTestDataModule@@UBEPAVTestData@@PBDAAW4UErrorCode@@@Z$0
__ehfuncinfo$?createTestData@RBTestDataModule@@UBEPAVTestData@@PBDAAW4UErrorCode@@@Z dd	19930522h, 1
					; DATA XREF: __ehhandler$?createTestData@RBTestDataModule@@UBEPAVTestData@@PBDAAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$?createTestData@RBTestDataModule@@UBEPAVTestData@@PBDAAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2A18h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct UResourceBundle *__thiscall RBTestDataModule::getTestBundle(RBTestDataModule *this, const char	*, enum	UErrorCode *)
		public ?getTestBundle@RBTestDataModule@@AAEPAUUResourceBundle@@PBDAAW4UErrorCode@@@Z
?getTestBundle@RBTestDataModule@@AAEPAUUResourceBundle@@PBDAAW4UErrorCode@@@Z proc near
					; CODE XREF: RBTestDataModule::RBTestDataModule(char const *,TestLog &,UErrorCode &)+ADp

var_1E4		= dword	ptr -1E4h
var_1E0		= dword	ptr -1E0h
var_1DC		= dword	ptr -1DCh
var_1D8		= dword	ptr -1D8h
var_1D4		= dword	ptr -1D4h
var_1D0		= dword	ptr -1D0h
var_1C8		= byte ptr -1C8h
var_180		= byte ptr -180h
var_138		= byte ptr -138h
var_30		= dword	ptr -30h
var_24		= dword	ptr -24h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?getTestBundle@RBTestDataModule@@AAEPAUUResourceBundle@@PBDAAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 1D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_1E4]
		mov	ecx, 76h ; 'v'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	loc_2BF3
		mov	[ebp+var_24], 0
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_18]
		mov	edx, [ecx+0Ch]
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+0Ch]
		mov	edx, [edx]
		mov	eax, [edx+10h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_30], eax
		cmp	[ebp+var_24], 0
		jnz	loc_2BEC
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	edx, [ebp+var_30]
		push	edx
		call	_ures_openDirect_56
		add	esp, 0Ch
		mov	[ebp+var_24], eax
		mov	eax, [ebp+arg_4]
		cmp	dword ptr [eax], 0
		jz	loc_2BEC
		mov	esi, esp
		push	0
		push	0FFFFFFFFh
		mov	eax, [ebp+arg_0]
		push	eax
		lea	ecx, [ebp+var_180]
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@PBDHW4EInvariant@01@@Z ; icu_56::UnicodeString::UnicodeString(char const *,int,icu_56::UnicodeString::EInvariant)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_1D0], eax
		mov	ecx, [ebp+var_1D0]
		mov	[ebp+var_1D4], ecx
		mov	[ebp+var_4], 0
		mov	esi, esp
		mov	edx, [ebp+var_1D4]
		push	edx
		mov	edi, esp
		push	0FFFFFFFFh	; int
		push	offset ??_C@_1FO@PHABEGHA@?$AAC?$AAo?$AAu?$AAl?$AAd?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAl?$AAo?$AAa?$AAd?$AA?5?$AAt?$AAe?$AAs?$AAt?$AA?5?$AAd?$AAa?$AAt?$AAa?$AA?5?$AAf?$AAr?$AAo?$AAm?$AA?5?$AAr?$AAe@ ; "Could not load test data from resourceb"...
		push	1		; signed __int8
		lea	ecx, [ebp+var_1C8] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@CPB_WH@Z ; icu_56::UnicodeString::UnicodeString(signed char,wchar_t const *,int)
		cmp	edi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_1D8], eax
		mov	eax, [ebp+var_1D8]
		mov	[ebp+var_1DC], eax
		mov	byte ptr [ebp+var_4], 1
		mov	ecx, [ebp+var_1DC]
		push	ecx
		lea	edx, [ebp+var_138]
		push	edx
		call	dword ptr ds:__imp_??Hicu_56@@YA?AVUnicodeString@0@ABV10@0@Z ; icu_56::operator+(icu_56::UnicodeString const &,icu_56::UnicodeString const &)
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_1E0], eax
		mov	eax, [ebp+var_1E0]
		mov	[ebp+var_1E4], eax
		mov	byte ptr [ebp+var_4], 2
		mov	esi, esp
		mov	ecx, [ebp+var_1E4]
		push	ecx
		mov	edx, [ebp+var_18]
		mov	eax, [edx+0Ch]
		mov	ecx, [ebp+var_18]
		mov	ecx, [ecx+0Ch]
		mov	edx, [eax]
		mov	eax, [edx+0Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 1
		mov	esi, esp
		lea	ecx, [ebp+var_138] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_1C8] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_180] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_18]
		mov	byte ptr [eax+1Ch], 0

loc_2BEC:				; CODE XREF: RBTestDataModule::getTestBundle(char const	*,UErrorCode &)+8Cj
					; RBTestDataModule::getTestBundle(char const *,UErrorCode &)+AFj
		mov	eax, [ebp+var_24]
		jmp	short loc_2BF5
; ---------------------------------------------------------------------------
		jmp	short loc_2BF5
; ---------------------------------------------------------------------------

loc_2BF3:				; CODE XREF: RBTestDataModule::getTestBundle(char const	*,UErrorCode &)+58j
		xor	eax, eax

loc_2BF5:				; CODE XREF: RBTestDataModule::getTestBundle(char const	*,UErrorCode &)+1D7j
					; RBTestDataModule::getTestBundle(char const *,UErrorCode &)+1D9j
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 1E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?getTestBundle@RBTestDataModule@@AAEPAUUResourceBundle@@PBDAAW4UErrorCode@@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 2C20h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getTestBundle@RBTestDataModule@@AAEPAUUResourceBundle@@PBDAAW4UErrorCode@@@Z$0	proc near
					; DATA XREF: .xdata$x:00002CECo
		mov	esi, esp
		lea	ecx, [ebp-180h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?getTestBundle@RBTestDataModule@@AAEPAUUResourceBundle@@PBDAAW4UErrorCode@@@Z$0	endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getTestBundle@RBTestDataModule@@AAEPAUUResourceBundle@@PBDAAW4UErrorCode@@@Z$1	proc near
					; DATA XREF: .xdata$x:00002CF4o
		mov	esi, esp
		lea	ecx, [ebp-1C8h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?getTestBundle@RBTestDataModule@@AAEPAUUResourceBundle@@PBDAAW4UErrorCode@@@Z$1	endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getTestBundle@RBTestDataModule@@AAEPAUUResourceBundle@@PBDAAW4UErrorCode@@@Z$2	proc near
					; DATA XREF: .xdata$x:00002CFCo
		mov	esi, esp
		lea	ecx, [ebp-138h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?getTestBundle@RBTestDataModule@@AAEPAUUResourceBundle@@PBDAAW4UErrorCode@@@Z$2	endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?getTestBundle@RBTestDataModule@@AAEPAUUResourceBundle@@PBDAAW4UErrorCode@@@Z proc near
					; DATA XREF: RBTestDataModule::getTestBundle(char const	*,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-1E8h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?getTestBundle@RBTestDataModule@@AAEPAUUResourceBundle@@PBDAAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?getTestBundle@RBTestDataModule@@AAEPAUUResourceBundle@@PBDAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 2C88h
		public ??_C@_1FO@PHABEGHA@?$AAC?$AAo?$AAu?$AAl?$AAd?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAl?$AAo?$AAa?$AAd?$AA?5?$AAt?$AAe?$AAs?$AAt?$AA?5?$AAd?$AAa?$AAt?$AAa?$AA?5?$AAf?$AAr?$AAo?$AAm?$AA?5?$AAr?$AAe@
; wchar_t `string'
??_C@_1FO@PHABEGHA@?$AAC?$AAo?$AAu?$AAl?$AAd?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAl?$AAo?$AAa?$AAd?$AA?5?$AAt?$AAe?$AAs?$AAt?$AA?5?$AAd?$AAa?$AAt?$AAa?$AA?5?$AAf?$AAr?$AAo?$AAm?$AA?5?$AAr?$AAe@:
					; DATA XREF: RBTestDataModule::getTestBundle(char const	*,UErrorCode &)+F8o
		unicode	0, <Could not load test	data from resourcebundle: >,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 2CE8h
__unwindtable$?getTestBundle@RBTestDataModule@@AAEPAUUResourceBundle@@PBDAAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00002D08o
		dd offset __unwindfunclet$?getTestBundle@RBTestDataModule@@AAEPAUUResourceBundle@@PBDAAW4UErrorCode@@@Z$0
		dd 0
		dd offset __unwindfunclet$?getTestBundle@RBTestDataModule@@AAEPAUUResourceBundle@@PBDAAW4UErrorCode@@@Z$1
		dd 1
		dd offset __unwindfunclet$?getTestBundle@RBTestDataModule@@AAEPAUUResourceBundle@@PBDAAW4UErrorCode@@@Z$2
__ehfuncinfo$?getTestBundle@RBTestDataModule@@AAEPAUUResourceBundle@@PBDAAW4UErrorCode@@@Z dd 19930522h, 3
					; DATA XREF: __ehhandler$?getTestBundle@RBTestDataModule@@AAEPAUUResourceBundle@@PBDAAW4UErrorCode@@@Z+1Eo
		dd offset __unwindtable$?getTestBundle@RBTestDataModule@@AAEPAUUResourceBundle@@PBDAAW4UErrorCode@@@Z
		align 20h
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn __RTC_Shutdown:near ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
		extrn __RTC_InitBase:near ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
; const	type_info::`vftable'
		extrn ??_7type_info@@6B@:near
					; DATA XREF: .data:DataMap `RTTI Type Descriptor'o
					; .data:RBDataMap `RTTI	Type Descriptor'o ...
		extrn __purecall:near	; DATA XREF: .rdata:off_40o
					; .rdata:00000044o ...
; void __cdecl operator	delete(void *)
		extrn ??3@YAXPAX@Z:near	; CODE XREF: DataMap::`scalar deleting destructor'(uint)+37p
					; DataMap::`vector deleting destructor'(uint)+75p ...
; _DWORD __thiscall DataMap::~DataMap(DataMap *__hidden	this)
		extrn ??1DataMap@@UAE@XZ:near
					; CODE XREF: DataMap::`scalar deleting destructor'(uint)+26p
					; DataMap::`vector deleting destructor'(uint)+64p
					; DATA XREF: ...
		extrn __RTC_CheckEsp:near
					; CODE XREF: DataMap::`scalar deleting destructor'(uint)+4Dp
					; DataMap::`vector deleting destructor'(uint)+8Bp ...
; void __cdecl operator	delete[](void *)
		extrn ??_V@YAXPAX@Z:near
					; CODE XREF: DataMap::`vector deleting destructor'(uint)+51p
					; RBDataMap::`vector deleting destructor'(uint)+51p ...
; void __stdcall `eh vector destructor iterator'(void *, unsigned int, int, void (__thiscall *)(void *))
		extrn ??_M@YGXPAXIHP6EX0@Z@Z:near
					; CODE XREF: DataMap::`vector deleting destructor'(uint)+3Dp
					; RBDataMap::`vector deleting destructor'(uint)+3Dp ...
; public: virtual class	icu_56::UnicodeString const __thiscall RBDataMap::getString(char const *, enum	UErrorCode &)const
		extrn ?getString@RBDataMap@@UBE?BVUnicodeString@icu_56@@PBDAAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:00000250o
; public: virtual int __thiscall RBDataMap::getInt(char	const *, enum  UErrorCode &)const
		extrn ?getInt@RBDataMap@@UBEHPBDAAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:00000254o
; public: virtual int __thiscall RBDataMap::getInt28(char const	*, enum	 UErrorCode &)const
		extrn ?getInt28@RBDataMap@@UBEHPBDAAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:00000258o
; public: virtual unsigned int __thiscall RBDataMap::getUInt28(char const *, enum  UErrorCode &)const
		extrn ?getUInt28@RBDataMap@@UBEIPBDAAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:0000025Co
; public: virtual int const * __thiscall RBDataMap::getIntVector(int &,	char const *, enum  UErrorCode &)const
		extrn ?getIntVector@RBDataMap@@UBEPBHAAHPBDAAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:00000260o
; public: virtual unsigned char	const *	__thiscall RBDataMap::getBinary(int &, char const *, enum  UErrorCode &)const
		extrn ?getBinary@RBDataMap@@UBEPBEAAHPBDAAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:00000264o
; public: virtual class	icu_56::UnicodeString const * __thiscall RBDataMap::getStringArray(int &, char const *,	enum  UErrorCode &)const
		extrn ?getStringArray@RBDataMap@@UBEPBVUnicodeString@icu_56@@AAHPBDAAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:00000268o
; public: virtual int const * __thiscall RBDataMap::getIntArray(int &, char const *, enum  UErrorCode &)const
		extrn ?getIntArray@RBDataMap@@UBEPBHAAHPBDAAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:0000026Co
; public: virtual class	icu_56::ResourceBundle const * __thiscall RBDataMap::getItem(char const	*, enum	 UErrorCode &)const
		extrn ?getItem@RBDataMap@@UBEPBVResourceBundle@icu_56@@PBDAAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:00000270o
; _DWORD __thiscall RBDataMap::~RBDataMap(RBDataMap *__hidden this)
		extrn ??1RBDataMap@@UAE@XZ:near
					; CODE XREF: RBDataMap::`scalar	deleting destructor'(uint)+26p
					; RBDataMap::`vector deleting destructor'(uint)+64p
					; DATA XREF: ...
; _DWORD __thiscall TestData::~TestData(TestData *__hidden this)
		extrn ??1TestData@@UAE@XZ:near
					; CODE XREF: TestData::`scalar deleting	destructor'(uint)+26p
					; TestData::`vector deleting destructor'(uint)+64p
					; DATA XREF: ...
; public: virtual signed char __thiscall RBTestData::getInfo(class DataMap const * &, enum  UErrorCode &)const
		extrn ?getInfo@RBTestData@@UBECAAPBVDataMap@@AAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:00000734o
; public: virtual signed char __thiscall RBTestData::nextSettings(class	DataMap	const *	&, enum	 UErrorCode &)
		extrn ?nextSettings@RBTestData@@UAECAAPBVDataMap@@AAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:00000738o
; public: virtual signed char __thiscall RBTestData::nextCase(class DataMap const * &, enum  UErrorCode	&)
		extrn ?nextCase@RBTestData@@UAECAAPBVDataMap@@AAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:0000073Co
; _DWORD __thiscall RBTestData::~RBTestData(RBTestData *__hidden this)
		extrn ??1RBTestData@@UAE@XZ:near
					; CODE XREF: RBTestData::`scalar deleting destructor'(uint)+26p
					; RBTestData::`vector deleting destructor'(uint)+64p
					; DATA XREF: ...
; _DWORD __thiscall icu_56::ErrorCode::ErrorCode(icu_56::ErrorCode *__hidden this)
		extrn __imp_??0ErrorCode@icu_56@@QAE@XZ:near
					; CODE XREF: IcuTestErrorCode::IcuTestErrorCode(TestLog	&,char const *)+28p
					; DATA XREF: IcuTestErrorCode::IcuTestErrorCode(TestLog	&,char const *)+28r
; _DWORD __thiscall icu_56::ErrorCode::ErrorCode(icu_56::ErrorCode *__hidden this, const struct	icu_56::ErrorCode *)
		extrn __imp_??0ErrorCode@icu_56@@QAE@ABV01@@Z:near
					; CODE XREF: IcuTestErrorCode::IcuTestErrorCode(IcuTestErrorCode const &)+2Cp
					; DATA XREF: IcuTestErrorCode::IcuTestErrorCode(IcuTestErrorCode const &)+2Cr
; void __cdecl icu_56::UMemory::operator delete(void *)
		extrn __imp_??3UMemory@icu_56@@SAXPAX@Z:near
					; CODE XREF: IcuTestErrorCode::`scalar deleting	destructor'(uint)+39p
					; IcuTestErrorCode::`vector deleting destructor'(uint)+81p
					; DATA XREF: ...
; void __cdecl icu_56::UMemory::operator delete[](void *)
		extrn __imp_??_VUMemory@icu_56@@SAXPAX@Z:near
					; CODE XREF: IcuTestErrorCode::`vector deleting	destructor'(uint)+53p
					; DATA XREF: IcuTestErrorCode::`vector deleting	destructor'(uint)+53r
; _DWORD __thiscall icu_56::ErrorCode::~ErrorCode(icu_56::ErrorCode *__hidden this)
		extrn __imp_??1ErrorCode@icu_56@@UAE@XZ:near
					; CODE XREF: IcuTestErrorCode::~IcuTestErrorCode(void)+7Fp
					; __unwindfunclet$??1IcuTestErrorCode@@UAE@XZ$0+5p
					; DATA XREF: ...
; signed __int8	__thiscall icu_56::ErrorCode::isFailure(icu_56::ErrorCode *__hidden this)
		extrn __imp_?isFailure@ErrorCode@icu_56@@QBECXZ:near
					; CODE XREF: IcuTestErrorCode::~IcuTestErrorCode(void)+57p
					; IcuTestErrorCode::logIfFailureAndReset(char const *,...)+49p	...
		extrn ___security_cookie:near
					; DATA XREF: IcuTestErrorCode::~IcuTestErrorCode(void)+2Er
					; IcuTestErrorCode::logIfFailureAndReset(char const *,...)+30r	...
		extrn ___CxxFrameHandler3:near
					; CODE XREF: __ehhandler$??1IcuTestErrorCode@@UAE@XZ+19j
					; __ehhandler$?logIfFailureAndReset@IcuTestErrorCode@@QAACPBDZZ+23j ...
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near
					; CODE XREF: __ehhandler$??1IcuTestErrorCode@@UAE@XZ+Fp
					; IcuTestErrorCode::logIfFailureAndReset(char const *,...)+305p ...
; enum UErrorCode __thiscall __high icu_56::ErrorCode::reset()
		extrn __imp_?reset@ErrorCode@icu_56@@QAE?AW4UErrorCode@@XZ:near
					; CODE XREF: IcuTestErrorCode::logIfFailureAndReset(char const *,...)+293p
					; IcuTestErrorCode::logIfFailureAndReset(char const *,...)+2D2p ...
; _DWORD __thiscall icu_56::UnicodeString::~UnicodeString(icu_56::UnicodeString	*__hidden this)
		extrn __imp_??1UnicodeString@icu_56@@UAE@XZ:near
					; CODE XREF: IcuTestErrorCode::logIfFailureAndReset(char const *,...)+175p
					; IcuTestErrorCode::logIfFailureAndReset(char const *,...)+18Ep ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *__hidden this, const struct icu_56::UnicodeString *)
		extrn __imp_?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z:near
					; CODE XREF: IcuTestErrorCode::logIfFailureAndReset(char const *,...)+14Dp
					; IcuTestErrorCode::logIfFailureAndReset(char const *,...)+15Cp ...
; _DWORD __thiscall icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString *__hidden this, signed __int8, const wchar_t *, int)
		extrn __imp_??0UnicodeString@icu_56@@QAE@CPB_WH@Z:near
					; CODE XREF: IcuTestErrorCode::logIfFailureAndReset(char const *,...)+11Bp
					; IcuTestErrorCode::logIfFailureAndReset(char const *,...)+1EBp ...
; const	char *__thiscall icu_56::ErrorCode::errorName(icu_56::ErrorCode	*__hidden this)
		extrn __imp_?errorName@ErrorCode@icu_56@@QBEPBDXZ:near
					; CODE XREF: IcuTestErrorCode::logIfFailureAndReset(char const *,...)+CAp
					; IcuTestErrorCode::logDataIfFailureAndReset(char const	*,...)+CAp ...
; _DWORD __thiscall __high icu_56::UnicodeString::UnicodeString(const char *, int, enum	icu_56::UnicodeString::EInvariant)
		extrn __imp_??0UnicodeString@icu_56@@QAE@PBDHW4EInvariant@01@@Z:near
					; CODE XREF: IcuTestErrorCode::logIfFailureAndReset(char const *,...)+ABp
					; IcuTestErrorCode::logIfFailureAndReset(char const *,...)+DEp	...
; int __cdecl _vsprintf(char *Dest, const char *Format,	va_list	Args)
		extrn __imp__vsprintf:near
					; CODE XREF: IcuTestErrorCode::logIfFailureAndReset(char const *,...)+7Ep
					; IcuTestErrorCode::logDataIfFailureAndReset(char const	*,...)+7Ep
					; DATA XREF: ...
; __fastcall _RTC_CheckStackVars(x, x)
		extrn @_RTC_CheckStackVars@8:near
					; CODE XREF: IcuTestErrorCode::logIfFailureAndReset(char const *,...)+2EBp
					; IcuTestErrorCode::logDataIfFailureAndReset(char const	*,...)+2EBp ...
		extrn __chkstk:near	; CODE XREF: IcuTestErrorCode::logIfFailureAndReset(char const *,...)+16p
					; IcuTestErrorCode::logDataIfFailureAndReset(char const	*,...)+16p
; enum UErrorCode __thiscall __high icu_56::ErrorCode::get()
		extrn __imp_?get@ErrorCode@icu_56@@QBE?AW4UErrorCode@@XZ:near
					; CODE XREF: IcuTestErrorCode::handleFailure(void)+147p
					; IcuTestErrorCode::handleFailure(void)+15Ep
					; DATA XREF: ...
; void *__cdecl	operator new(unsigned int)
		extrn ??2@YAPAXI@Z:near	; CODE XREF: TestDataModule::getTestDataModule(char const *,TestLog &,UErrorCode &)+62p
					; RBTestDataModule::RBTestDataModule(char const	*,TestLog &,UErrorCode &)+199p	...
		extrn _uprv_free_56:near
					; CODE XREF: RBTestDataModule::~RBTestDataModule(void)+60p
		extrn _ures_close_56:near
					; CODE XREF: RBTestDataModule::~RBTestDataModule(void)+33p
					; RBTestDataModule::~RBTestDataModule(void)+42p ...
; public: __thiscall RBDataMap::RBDataMap(struct UResourceBundle *, enum  UErrorCode &)
		extrn ??0RBDataMap@@QAE@PAUUResourceBundle@@AAW4UErrorCode@@@Z:near
					; CODE XREF: RBTestDataModule::RBTestDataModule(char const *,TestLog &,UErrorCode &)+1C5p
		extrn _ures_getSize_56:near
					; CODE XREF: RBTestDataModule::RBTestDataModule(char const *,TestLog &,UErrorCode &)+EEp
		extrn _ures_getByKey_56:near
					; CODE XREF: RBTestDataModule::RBTestDataModule(char const *,TestLog &,UErrorCode &)+D9p
					; RBTestDataModule::RBTestDataModule(char const	*,TestLog &,UErrorCode &)+10Ep	...
; public: __thiscall RBTestData::RBTestData(struct UResourceBundle *, struct UResourceBundle *,	enum  UErrorCode &)
		extrn ??0RBTestData@@QAE@PAUUResourceBundle@@0AAW4UErrorCode@@@Z:near
					; CODE XREF: RBTestDataModule::createTestData(int,UErrorCode &)+E4p
					; RBTestDataModule::createTestData(char	const *,UErrorCode &)+E4p
		extrn _ures_getByIndex_56:near
					; CODE XREF: RBTestDataModule::createTestData(int,UErrorCode &)+71p
; __declspec(dllimport)	class icu_56::UnicodeString __cdecl icu_56::operator+(class icu_56::UnicodeString const	&, class icu_56::UnicodeString const &)
		extrn __imp_??Hicu_56@@YA?AVUnicodeString@0@ABV10@0@Z:near
					; CODE XREF: RBTestDataModule::getTestBundle(char const	*,UErrorCode &)+136p
					; DATA XREF: RBTestDataModule::getTestBundle(char const	*,UErrorCode &)+136r
		extrn _ures_openDirect_56:near
					; CODE XREF: RBTestDataModule::getTestBundle(char const	*,UErrorCode &)+9Ep


		end
