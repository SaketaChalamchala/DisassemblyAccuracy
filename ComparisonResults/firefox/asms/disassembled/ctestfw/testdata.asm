;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	94A19A4CD3A0950E6D35D3D14221D9E3
; Input	CRC32 :	686B6A9C

; File Name   :	D:\compspace\objfiles\firefox\ctestfw\testdata.obj
; Format      :	COFF (X386MAGIC)
; includelib "msvcprtd"
; includelib "MSVCRTD"
;
; Exported entry
;

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall DataMap::DataMap(DataMap *this, const struct DataMap *)
		public ??0DataMap@@QAE@ABV0@@Z
??0DataMap@@QAE@ABV0@@Z	proc near	; CODE XREF: RBDataMap::RBDataMap(RBDataMap const &)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7DataMap@@6B@ ; const DataMap::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??0DataMap@@QAE@ABV0@@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 38h
		dd offset ??_R4DataMap@@6B@ ; const DataMap::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7DataMap@@6B@
; const	DataMap::`vftable'
??_7DataMap@@6B@ dd offset ??_EDataMap@@UAEPAXI@Z
					; DATA XREF: DataMap::DataMap(DataMap const &)+26o
					; DataMap::`vector deleting destructor'(uint)
off_40		dd offset __purecall	; DATA XREF: .rdata$r:000000C0o
					; .rdata$r:000002D0o ...
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$TMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$TMZ
		;org 60h
__RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
_rtc$TMZ	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$IMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$IMZ
		;org 64h
__RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
_rtc$IMZ	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 68h
		public ??_R4DataMap@@6B@
; const	DataMap::`RTTI Complete	Object Locator'
??_R4DataMap@@6B@ dd 3 dup(0)		; DATA XREF: .rdata:00000038o
		dd offset ??_R0?AVDataMap@@@8 ;	DataMap	`RTTI Type Descriptor'
		dd offset ??_R3DataMap@@8 ; DataMap::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 7Ch
		public ??_R0?AVDataMap@@@8
; class	DataMap	`RTTI Type Descriptor'
??_R0?AVDataMap@@@8 dd offset ??_7type_info@@6B@ ; DATA	XREF: .rdata$r:00000074o
					; .rdata$r:DataMap::`RTTI Base Class Descriptor	at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avdatamap@@	db '.?AVDataMap@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 94h
		public ??_R3DataMap@@8
; DataMap::`RTTI Class Hierarchy Descriptor'
??_R3DataMap@@8	dd 2 dup(0)		; DATA XREF: .rdata$r:00000078o
					; .rdata$r:000000C4o
		dd 1
		dd offset ??_R2DataMap@@8 ; DataMap::`RTTI Base	Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0A4h
		public ??_R2DataMap@@8
; DataMap::`RTTI Base Class Array'
??_R2DataMap@@8	dd offset ??_R1A@?0A@EA@DataMap@@8 ; DATA XREF:	.rdata$r:000000A0o
					; DataMap::`RTTI Base Class Descriptor at (0,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0ACh
		public ??_R1A@?0A@EA@DataMap@@8
; DataMap::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@DataMap@@8 dd offset ??_R0?AVDataMap@@@8
					; DATA XREF: .rdata$r:DataMap::`RTTI Base Class	Array'o
					; .rdata$r:000002B4o
					; DataMap `RTTI	Type Descriptor'
		dd 2 dup(0)
		dd 0FFFFFFFFh, 0
		dd offset off_40
		dd offset ??_R3DataMap@@8 ; DataMap::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	DataMap	& __thiscall DataMap::operator=(class DataMap const &)
		public ??4DataMap@@QAEAAV0@ABV0@@Z
??4DataMap@@QAEAAV0@ABV0@@Z proc near	; CODE XREF: RBDataMap::operator=(RBDataMap const &)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4DataMap@@QAEAAV0@ABV0@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall DataMap::`scalar deleting destructor'(unsigned int)
		public ??_GDataMap@@UAEPAXI@Z
??_GDataMap@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1DataMap@@UAE@XZ ; DataMap::~DataMap(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_137
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_137:				; CODE XREF: DataMap::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GDataMap@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 150h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall DataMap::`vector deleting destructor'(unsigned int)
		public ??_EDataMap@@UAEPAXI@Z
??_EDataMap@@UAEPAXI@Z proc near	; DATA XREF: .rdata:const DataMap::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_1B1
		push	offset ??1DataMap@@UAE@XZ ; DataMap::~DataMap(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	4
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_1A9
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_V@YAXPAX@Z	; operator delete[](void *)
		add	esp, 4

loc_1A9:				; CODE XREF: DataMap::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_1D0
; ---------------------------------------------------------------------------

loc_1B1:				; CODE XREF: DataMap::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1DataMap@@UAE@XZ ; DataMap::~DataMap(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_1CD
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_1CD:				; CODE XREF: DataMap::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_1D0:				; CODE XREF: DataMap::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EDataMap@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1E8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	RBDataMap::RBDataMap(struct DataMap *)
		public ??0RBDataMap@@QAE@ABV0@@Z
??0RBDataMap@@QAE@ABV0@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct DataMap *
		mov	ecx, [ebp+var_8] ; this
		call	??0DataMap@@QAE@ABV0@@Z	; DataMap::DataMap(DataMap const &)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7RBDataMap@@6B@ ; const RBDataMap::`vftable'
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	[eax+4], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0RBDataMap@@QAE@ABV0@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 248h
		dd offset ??_R4RBDataMap@@6B@ ;	const RBDataMap::`RTTI Complete	Object Locator'
;
; Exported entry
;
		public ??_7RBDataMap@@6B@
; const	RBDataMap::`vftable'
??_7RBDataMap@@6B@ dd offset ??_ERBDataMap@@UAEPAXI@Z
					; DATA XREF: RBDataMap::RBDataMap(RBDataMap const &)+32o
					; RBDataMap::`vector deleting destructor'(uint)
		dd offset ?getString@RBDataMap@@UBE?BVUnicodeString@icu_56@@PBDAAW4UErrorCode@@@Z ; RBDataMap::getString(char const *,UErrorCode &)
		dd offset ?getInt@RBDataMap@@UBEHPBDAAW4UErrorCode@@@Z ; RBDataMap::getInt(char	const *,UErrorCode &)
		dd offset ?getInt28@RBDataMap@@UBEHPBDAAW4UErrorCode@@@Z ; RBDataMap::getInt28(char const *,UErrorCode &)
		dd offset ?getUInt28@RBDataMap@@UBEIPBDAAW4UErrorCode@@@Z ; RBDataMap::getUInt28(char const *,UErrorCode &)
		dd offset ?getIntVector@RBDataMap@@UBEPBHAAHPBDAAW4UErrorCode@@@Z ; RBDataMap::getIntVector(int	&,char const *,UErrorCode &)
		dd offset ?getBinary@RBDataMap@@UBEPBEAAHPBDAAW4UErrorCode@@@Z ; RBDataMap::getBinary(int &,char const *,UErrorCode &)
		dd offset ?getStringArray@RBDataMap@@UBEPBVUnicodeString@icu_56@@AAHPBDAAW4UErrorCode@@@Z ; RBDataMap::getStringArray(int &,char const *,UErrorCode &)
		dd offset ?getIntArray@RBDataMap@@UBEPBHAAHPBDAAW4UErrorCode@@@Z ; RBDataMap::getIntArray(int &,char const *,UErrorCode	&)
		dd offset ?getItem@RBDataMap@@UBEPBVResourceBundle@icu_56@@PBDAAW4UErrorCode@@@Z ; RBDataMap::getItem(char const *,UErrorCode &)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 274h
		public ??_R4RBDataMap@@6B@
; const	RBDataMap::`RTTI Complete Object Locator'
??_R4RBDataMap@@6B@ dd 3 dup(0)		; DATA XREF: .rdata:00000248o
		dd offset ??_R0?AVRBDataMap@@@8	; RBDataMap `RTTI Type Descriptor'
		dd offset ??_R3RBDataMap@@8 ; RBDataMap::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 288h
		public ??_R0?AVRBDataMap@@@8
; class	RBDataMap `RTTI	Type Descriptor'
??_R0?AVRBDataMap@@@8 dd offset	??_7type_info@@6B@ ; DATA XREF:	.rdata$r:00000280o
					; .rdata$r:RBDataMap::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 10h
a_?avrbdatamap@	db '.?AVRBDataMap@@',0
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 2A0h
		public ??_R3RBDataMap@@8
; RBDataMap::`RTTI Class Hierarchy Descriptor'
??_R3RBDataMap@@8 dd 2 dup(0)		; DATA XREF: .rdata$r:00000284o
					; .rdata$r:000002D4o
		dd 2
		dd offset ??_R2RBDataMap@@8 ; RBDataMap::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 2B0h
		public ??_R2RBDataMap@@8
; RBDataMap::`RTTI Base	Class Array'
??_R2RBDataMap@@8 dd offset ??_R1A@?0A@EA@RBDataMap@@8 ; DATA XREF: .rdata$r:000002ACo
					; RBDataMap::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@DataMap@@8 ; DataMap::`RTTI Base Class Descriptor at (0,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 2BCh
		public ??_R1A@?0A@EA@RBDataMap@@8
; RBDataMap::`RTTI Base	Class Descriptor at (0,	-1, 0, 64)'
??_R1A@?0A@EA@RBDataMap@@8 dd offset ??_R0?AVRBDataMap@@@8
					; DATA XREF: .rdata$r:RBDataMap::`RTTI Base Class Array'o
					; RBDataMap `RTTI Type Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset off_40
		dd offset ??_R3RBDataMap@@8 ; RBDataMap::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2D8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	RBDataMap & __thiscall RBDataMap::operator=(class RBDataMap const &)
		public ??4RBDataMap@@QAEAAV0@ABV0@@Z
??4RBDataMap@@QAEAAV0@ABV0@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??4DataMap@@QAEAAV0@ABV0@@Z ; DataMap::operator=(DataMap const &)
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	[eax+4], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4RBDataMap@@QAEAAV0@ABV0@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 32Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall RBDataMap::`scalar deleting	destructor'(unsigned int)
		public ??_GRBDataMap@@UAEPAXI@Z
??_GRBDataMap@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1RBDataMap@@UAE@XZ ; RBDataMap::~RBDataMap(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_36B
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_36B:				; CODE XREF: RBDataMap::`scalar	deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GRBDataMap@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 384h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall RBDataMap::`vector deleting	destructor'(unsigned int)
		public ??_ERBDataMap@@UAEPAXI@Z
??_ERBDataMap@@UAEPAXI@Z proc near	; DATA XREF: .rdata:const RBDataMap::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_3E5
		push	offset ??1RBDataMap@@UAE@XZ ; RBDataMap::~RBDataMap(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	8
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_3DD
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_V@YAXPAX@Z	; operator delete[](void *)
		add	esp, 4

loc_3DD:				; CODE XREF: RBDataMap::`vector	deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_404
; ---------------------------------------------------------------------------

loc_3E5:				; CODE XREF: RBDataMap::`vector	deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1RBDataMap@@UAE@XZ ; RBDataMap::~RBDataMap(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_401
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_401:				; CODE XREF: RBDataMap::`vector	deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_404:				; CODE XREF: RBDataMap::`vector	deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_ERBDataMap@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 41Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall TestLog::TestLog(TestLog *__hidden this)
		public ??0TestLog@@QAE@XZ
??0TestLog@@QAE@XZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7TestLog@@6B@ ; const TestLog::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0TestLog@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 454h
		dd offset ??_R4TestLog@@6B@ ; const TestLog::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7TestLog@@6B@
; const	TestLog::`vftable'
??_7TestLog@@6B@ dd offset ??_ETestLog@@UAEPAXI@Z ; DATA XREF: TestLog::TestLog(void)+26o
					; TestLog::TestLog(TestLog const &)+26o
					; TestLog::`vector deleting destructor'(uint)
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 46Ch
		public ??_R4TestLog@@6B@
; const	TestLog::`RTTI Complete	Object Locator'
??_R4TestLog@@6B@ dd 3 dup(0)		; DATA XREF: .rdata:00000454o
		dd offset ??_R0?AVTestLog@@@8 ;	TestLog	`RTTI Type Descriptor'
		dd offset ??_R3TestLog@@8 ; TestLog::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 480h
		public ??_R0?AVTestLog@@@8
; class	TestLog	`RTTI Type Descriptor'
??_R0?AVTestLog@@@8 dd offset ??_7type_info@@6B@ ; DATA	XREF: .rdata$r:00000478o
					; .rdata$r:TestLog::`RTTI Base Class Descriptor	at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 8
a_?avtestlog@@	db '.?AVTestLog@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 498h
		public ??_R3TestLog@@8
; TestLog::`RTTI Class Hierarchy Descriptor'
??_R3TestLog@@8	dd 2 dup(0)		; DATA XREF: .rdata$r:0000047Co
					; .rdata$r:000004C8o
		dd 1
		dd offset ??_R2TestLog@@8 ; TestLog::`RTTI Base	Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 4A8h
		public ??_R2TestLog@@8
; TestLog::`RTTI Base Class Array'
??_R2TestLog@@8	dd offset ??_R1A@?0A@EA@TestLog@@8 ; DATA XREF:	.rdata$r:000004A4o
					; TestLog::`RTTI Base Class Descriptor at (0,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 4B0h
		public ??_R1A@?0A@EA@TestLog@@8
; TestLog::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@TestLog@@8 dd offset ??_R0?AVTestLog@@@8
					; DATA XREF: .rdata$r:TestLog::`RTTI Base Class	Array'o
					; TestLog `RTTI	Type Descriptor'
		dd 2 dup(0)
		dd 0FFFFFFFFh, 0
		dd offset off_40
		dd offset ??_R3TestLog@@8 ; TestLog::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4CCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall TestLog::TestLog(class TestLog const &)
		public ??0TestLog@@QAE@ABV0@@Z
??0TestLog@@QAE@ABV0@@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7TestLog@@6B@ ; const TestLog::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??0TestLog@@QAE@ABV0@@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 504h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	TestLog	& __thiscall TestLog::operator=(class TestLog const &)
		public ??4TestLog@@QAEAAV0@ABV0@@Z
??4TestLog@@QAEAAV0@ABV0@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4TestLog@@QAEAAV0@ABV0@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 534h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall TestLog::`scalar deleting destructor'(unsigned int)
		public ??_GTestLog@@UAEPAXI@Z
??_GTestLog@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1TestLog@@UAE@XZ ; TestLog::~TestLog(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_573
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_573:				; CODE XREF: TestLog::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GTestLog@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 58Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall TestLog::`vector deleting destructor'(unsigned int)
		public ??_ETestLog@@UAEPAXI@Z
??_ETestLog@@UAEPAXI@Z proc near	; DATA XREF: .rdata:const TestLog::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_5ED
		push	offset ??1TestLog@@UAE@XZ ; TestLog::~TestLog(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	4
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_5E5
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_V@YAXPAX@Z	; operator delete[](void *)
		add	esp, 4

loc_5E5:				; CODE XREF: TestLog::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_60C
; ---------------------------------------------------------------------------

loc_5ED:				; CODE XREF: TestLog::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1TestLog@@UAE@XZ ; TestLog::~TestLog(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_609
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_609:				; CODE XREF: TestLog::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_60C:				; CODE XREF: TestLog::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_ETestLog@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 624h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall IcuTestErrorCode::IcuTestErrorCode(class TestLog &, char const *)
		public ??0IcuTestErrorCode@@QAE@AAVTestLog@@PBD@Z
??0IcuTestErrorCode@@QAE@AAVTestLog@@PBD@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??0ErrorCode@icu_56@@QAE@XZ ; icu_56::ErrorCode::ErrorCode(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7IcuTestErrorCode@@6B@ ; const IcuTestErrorCode::`vftable'
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		mov	[eax+0Ch], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??0IcuTestErrorCode@@QAE@AAVTestLog@@PBD@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 690h
		dd offset ??_R4IcuTestErrorCode@@6B@ ; const IcuTestErrorCode::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7IcuTestErrorCode@@6B@
; const	IcuTestErrorCode::`vftable'
??_7IcuTestErrorCode@@6B@ dd offset ??_EIcuTestErrorCode@@UAEPAXI@Z
					; DATA XREF: IcuTestErrorCode::IcuTestErrorCode(TestLog	&,char const *)+38o
					; IcuTestErrorCode::IcuTestErrorCode(IcuTestErrorCode const &)+3Co
					; IcuTestErrorCode::`vector deleting destructor'(uint)
		dd offset ?handleFailure@IcuTestErrorCode@@MBEXXZ ; IcuTestErrorCode::handleFailure(void)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 69Ch
		public ??_R4IcuTestErrorCode@@6B@
; const	IcuTestErrorCode::`RTTI	Complete Object	Locator'
??_R4IcuTestErrorCode@@6B@ dd 3	dup(0)	; DATA XREF: .rdata:00000690o
		dd offset ??_R0?AVIcuTestErrorCode@@@8 ; IcuTestErrorCode `RTTI	Type Descriptor'
		dd offset ??_R3IcuTestErrorCode@@8 ; IcuTestErrorCode::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 6B0h
		public ??_R0?AVIcuTestErrorCode@@@8
; class	IcuTestErrorCode `RTTI Type Descriptor'
??_R0?AVIcuTestErrorCode@@@8 dd	offset ??_7type_info@@6B@ ; DATA XREF: .rdata$r:000006A8o
					; .rdata$r:IcuTestErrorCode::`RTTI Base	Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 8
a_?avicutesterr	db '.?AVIcuTestErrorCode@@',0
		align 10h
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 6D0h
		public ??_R3IcuTestErrorCode@@8
; IcuTestErrorCode::`RTTI Class	Hierarchy Descriptor'
??_R3IcuTestErrorCode@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:000006ACo
					; .rdata$r:00000708o
		dd 3
		dd offset ??_R2IcuTestErrorCode@@8 ; IcuTestErrorCode::`RTTI Base Class	Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 6E0h
		public ??_R2IcuTestErrorCode@@8
; IcuTestErrorCode::`RTTI Base Class Array'
??_R2IcuTestErrorCode@@8 dd offset ??_R1A@?0A@EA@IcuTestErrorCode@@8
					; DATA XREF: .rdata$r:000006DCo
					; IcuTestErrorCode::`RTTI Base Class Descriptor	at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@ErrorCode@icu_56@@8 ; icu_56::ErrorCode::`RTTI Base Class Descriptor at	(0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 6F0h
		public ??_R1A@?0A@EA@IcuTestErrorCode@@8
; IcuTestErrorCode::`RTTI Base Class Descriptor	at (0, -1, 0, 64)'
??_R1A@?0A@EA@IcuTestErrorCode@@8 dd offset ??_R0?AVIcuTestErrorCode@@@8
					; DATA XREF: .rdata$r:IcuTestErrorCode::`RTTI Base Class Array'o
					; IcuTestErrorCode `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset off_40
		dd offset ??_R3IcuTestErrorCode@@8 ; IcuTestErrorCode::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 70Ch
		public ??_R1A@?0A@EA@ErrorCode@icu_56@@8
; icu_56::ErrorCode::`RTTI Base	Class Descriptor at (0,	-1, 0, 64)'
??_R1A@?0A@EA@ErrorCode@icu_56@@8 dd offset ??_R0?AVErrorCode@icu_56@@@8
					; DATA XREF: .rdata$r:000006E4o
					; .rdata$r:icu_56::ErrorCode::`RTTI Base Class Array'o
					; icu_56::ErrorCode `RTTI Type Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset off_40
		dd offset ??_R3ErrorCode@icu_56@@8 ; icu_56::ErrorCode::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 728h
		public ??_R0?AVErrorCode@icu_56@@@8
; class	icu_56::ErrorCode `RTTI	Type Descriptor'
??_R0?AVErrorCode@icu_56@@@8 dd	offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::ErrorCode::`RTTI Base Class Descriptor at	(0,-1,0,64)'o
					; const	type_info::`vftable'
		align 10h
a_?averrorcode@	db '.?AVErrorCode@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 748h
		public ??_R3ErrorCode@icu_56@@8
; icu_56::ErrorCode::`RTTI Class Hierarchy Descriptor'
??_R3ErrorCode@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:00000724o
		dd 2
		dd offset ??_R2ErrorCode@icu_56@@8 ; icu_56::ErrorCode::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 758h
		public ??_R2ErrorCode@icu_56@@8
; icu_56::ErrorCode::`RTTI Base	Class Array'
??_R2ErrorCode@icu_56@@8 dd offset ??_R1A@?0A@EA@ErrorCode@icu_56@@8
					; DATA XREF: .rdata$r:00000754o
					; icu_56::ErrorCode::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 764h
		public ??_R13?0A@EA@UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Descriptor at (4, -1, 0, 64)'
??_R13?0A@EA@UMemory@icu_56@@8 dd offset ??_R0?AVUMemory@icu_56@@@8
					; DATA XREF: .rdata$r:000006E8o
					; .rdata$r:0000075Co
					; icu_56::UMemory `RTTI	Type Descriptor'
		dd 0
		dd 4, 0FFFFFFFFh, 0
		dd offset off_40
		dd offset ??_R3UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 780h
		public ??_R0?AVUMemory@icu_56@@@8
; class	icu_56::UMemory	`RTTI Type Descriptor'
??_R0?AVUMemory@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::UMemory::`RTTI Base Class	Descriptor at (4,-1,0,64)'o
					; .rdata$r:icu_56::UMemory::`RTTI Base Class Descriptor	at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 8
a_?avumemory@ic	db '.?AVUMemory@icu_56@@',0
		align 10h
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 7A0h
		public ??_R3UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Class Hierarchy Descriptor'
??_R3UMemory@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:0000077Co
					; .rdata$r:000007D0o
		dd 1
		dd offset ??_R2UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 7B0h
		public ??_R2UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Array'
??_R2UMemory@icu_56@@8 dd offset ??_R1A@?0A@EA@UMemory@icu_56@@8
					; DATA XREF: .rdata$r:000007ACo
					; icu_56::UMemory::`RTTI Base Class Descriptor at (0,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 7B8h
		public ??_R1A@?0A@EA@UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UMemory@icu_56@@8	dd offset ??_R0?AVUMemory@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UMemory::`RTTI Base Class	Array'o
					; icu_56::UMemory `RTTI	Type Descriptor'
		dd 2 dup(0)
		dd 0FFFFFFFFh, 0
		dd offset off_40
		dd offset ??_R3UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7D4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	IcuTestErrorCode::IcuTestErrorCode(struct icu_56::ErrorCode *)
		public ??0IcuTestErrorCode@@QAE@ABV0@@Z
??0IcuTestErrorCode@@QAE@ABV0@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::ErrorCode *
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??0ErrorCode@icu_56@@QAE@ABV01@@Z ; icu_56::ErrorCode::ErrorCode(icu_56::ErrorCode const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7IcuTestErrorCode@@6B@ ; const IcuTestErrorCode::`vftable'
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+8]
		mov	[eax+8], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+0Ch]
		mov	[eax+0Ch], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0IcuTestErrorCode@@QAE@ABV0@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 848h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall IcuTestErrorCode::`scalar deleting destructor'(unsigned int)
		public ??_GIcuTestErrorCode@@UAEPAXI@Z
??_GIcuTestErrorCode@@UAEPAXI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1IcuTestErrorCode@@UAE@XZ ; IcuTestErrorCode::~IcuTestErrorCode(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_891
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_891:				; CODE XREF: IcuTestErrorCode::`scalar deleting	destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GIcuTestErrorCode@@UAEPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8ACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall IcuTestErrorCode::`vector deleting destructor'(unsigned int)
		public ??_EIcuTestErrorCode@@UAEPAXI@Z
??_EIcuTestErrorCode@@UAEPAXI@Z	proc near
					; DATA XREF: .rdata:const IcuTestErrorCode::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_917
		push	offset ??1IcuTestErrorCode@@UAE@XZ ; IcuTestErrorCode::~IcuTestErrorCode(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	10h
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_90F
		mov	eax, [ebp+var_8]
		sub	eax, 4
		mov	esi, esp
		push	eax		; void *
		call	dword ptr ds:__imp_??_VUMemory@icu_56@@SAXPAX@Z	; icu_56::UMemory::operator delete[](void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_90F:				; CODE XREF: IcuTestErrorCode::`vector deleting	destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_940
; ---------------------------------------------------------------------------

loc_917:				; CODE XREF: IcuTestErrorCode::`vector deleting	destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1IcuTestErrorCode@@UAE@XZ ; IcuTestErrorCode::~IcuTestErrorCode(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_93D
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_93D:				; CODE XREF: IcuTestErrorCode::`vector deleting	destructor'(uint)+79j
		mov	eax, [ebp+var_8]

loc_940:				; CODE XREF: IcuTestErrorCode::`vector deleting	destructor'(uint)+69j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EIcuTestErrorCode@@UAEPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 958h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall TestDataModule::TestDataModule(TestDataModule *this, const struct TestDataModule *)
		public ??0TestDataModule@@QAE@ABV0@@Z
??0TestDataModule@@QAE@ABV0@@Z proc near
					; CODE XREF: RBTestDataModule::RBTestDataModule(RBTestDataModule const &)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7TestDataModule@@6B@	; const	TestDataModule::`vftable'
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	[eax+4], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+8]
		mov	[eax+8], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+0Ch]
		mov	[eax+0Ch], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??0TestDataModule@@QAE@ABV0@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 9B4h
		dd offset ??_R4TestDataModule@@6B@ ; const TestDataModule::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7TestDataModule@@6B@
; const	TestDataModule::`vftable'
??_7TestDataModule@@6B@	dd offset ??_ETestDataModule@@UAEPAXI@Z
					; DATA XREF: TestDataModule::TestDataModule(TestDataModule const &)+26o
					; TestDataModule::`vector deleting destructor'(uint)
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9C8h
		public ??_R4TestDataModule@@6B@
; const	TestDataModule::`RTTI Complete Object Locator'
??_R4TestDataModule@@6B@ dd 3 dup(0)	; DATA XREF: .rdata:000009B4o
		dd offset ??_R0?AVTestDataModule@@@8 ; TestDataModule `RTTI Type Descriptor'
		dd offset ??_R3TestDataModule@@8 ; TestDataModule::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 9DCh
		public ??_R0?AVTestDataModule@@@8
; class	TestDataModule `RTTI Type Descriptor'
??_R0?AVTestDataModule@@@8 dd offset ??_7type_info@@6B@	; DATA XREF: .rdata$r:000009D4o
					; .rdata$r:TestDataModule::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avtestdatamo	db '.?AVTestDataModule@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9FCh
		public ??_R3TestDataModule@@8
; TestDataModule::`RTTI	Class Hierarchy	Descriptor'
??_R3TestDataModule@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:000009D8o
					; .rdata$r:00000A2Co
		dd 1
		dd offset ??_R2TestDataModule@@8 ; TestDataModule::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0A0Ch
		public ??_R2TestDataModule@@8
; TestDataModule::`RTTI	Base Class Array'
??_R2TestDataModule@@8 dd offset ??_R1A@?0A@EA@TestDataModule@@8
					; DATA XREF: .rdata$r:00000A08o
					; TestDataModule::`RTTI	Base Class Descriptor at (0,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0A14h
		public ??_R1A@?0A@EA@TestDataModule@@8
; TestDataModule::`RTTI	Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@TestDataModule@@8	dd offset ??_R0?AVTestDataModule@@@8
					; DATA XREF: .rdata$r:TestDataModule::`RTTI Base Class Array'o
					; .rdata$r:00000C18o
					; TestDataModule `RTTI Type Descriptor'
		align 10h
		dd 0FFFFFFFFh, 0
		dd offset off_40
		dd offset ??_R3TestDataModule@@8 ; TestDataModule::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A30h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall TestDataModule::`scalar deleting destructor'(unsigned int)
		public ??_GTestDataModule@@UAEPAXI@Z
??_GTestDataModule@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1TestDataModule@@UAE@XZ ; TestDataModule::~TestDataModule(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_A6F
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_A6F:				; CODE XREF: TestDataModule::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GTestDataModule@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A88h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall TestDataModule::`vector deleting destructor'(unsigned int)
		public ??_ETestDataModule@@UAEPAXI@Z
??_ETestDataModule@@UAEPAXI@Z proc near	; DATA XREF: .rdata:const TestDataModule::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_AE9
		push	offset ??1TestDataModule@@UAE@XZ ; TestDataModule::~TestDataModule(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	10h
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_AE1
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_V@YAXPAX@Z	; operator delete[](void *)
		add	esp, 4

loc_AE1:				; CODE XREF: TestDataModule::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_B08
; ---------------------------------------------------------------------------

loc_AE9:				; CODE XREF: TestDataModule::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1TestDataModule@@UAE@XZ ; TestDataModule::~TestDataModule(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_B05
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_B05:				; CODE XREF: TestDataModule::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_B08:				; CODE XREF: TestDataModule::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_ETestDataModule@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B20h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	RBTestDataModule::RBTestDataModule(struct TestDataModule *)
		public ??0RBTestDataModule@@QAE@ABV0@@Z
??0RBTestDataModule@@QAE@ABV0@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct TestDataModule	*
		mov	ecx, [ebp+var_8] ; this
		call	??0TestDataModule@@QAE@ABV0@@Z ; TestDataModule::TestDataModule(TestDataModule const &)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7RBTestDataModule@@6B@ ; const RBTestDataModule::`vftable'
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+10h]
		mov	[eax+10h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+14h]
		mov	[eax+14h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+18h]
		mov	[eax+18h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	dl, [ecx+1Ch]
		mov	[eax+1Ch], dl
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+20h]
		mov	[eax+20h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+24h]
		mov	[eax+24h], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0RBTestDataModule@@QAE@ABV0@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0BBCh
		dd offset ??_R4RBTestDataModule@@6B@ ; const RBTestDataModule::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7RBTestDataModule@@6B@
; const	RBTestDataModule::`vftable'
??_7RBTestDataModule@@6B@ dd offset ??_ERBTestDataModule@@UAEPAXI@Z
					; DATA XREF: RBTestDataModule::RBTestDataModule(RBTestDataModule const &)+32o
					; RBTestDataModule::`vector deleting destructor'(uint)
		dd offset ?getInfo@RBTestDataModule@@UBECAAPBVDataMap@@AAW4UErrorCode@@@Z ; RBTestDataModule::getInfo(DataMap const * &,UErrorCode &)
		dd offset ?createTestData@RBTestDataModule@@UBEPAVTestData@@PBDAAW4UErrorCode@@@Z ; RBTestDataModule::createTestData(char const	*,UErrorCode &)
		dd offset ?createTestData@RBTestDataModule@@UBEPAVTestData@@HAAW4UErrorCode@@@Z	; RBTestDataModule::createTestData(int,UErrorCode &)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0BD0h
		public ??_R4RBTestDataModule@@6B@
; const	RBTestDataModule::`RTTI	Complete Object	Locator'
??_R4RBTestDataModule@@6B@ dd 3	dup(0)	; DATA XREF: .rdata:00000BBCo
		dd offset ??_R0?AVRBTestDataModule@@@8 ; RBTestDataModule `RTTI	Type Descriptor'
		dd offset ??_R3RBTestDataModule@@8 ; RBTestDataModule::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 0BE4h
		public ??_R0?AVRBTestDataModule@@@8
; class	RBTestDataModule `RTTI Type Descriptor'
??_R0?AVRBTestDataModule@@@8 dd	offset ??_7type_info@@6B@ ; DATA XREF: .rdata$r:00000BDCo
					; .rdata$r:RBTestDataModule::`RTTI Base	Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avrbtestdata	db '.?AVRBTestDataModule@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0C04h
		public ??_R3RBTestDataModule@@8
; RBTestDataModule::`RTTI Class	Hierarchy Descriptor'
??_R3RBTestDataModule@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:00000BE0o
					; .rdata$r:00000C38o
		dd 2
		dd offset ??_R2RBTestDataModule@@8 ; RBTestDataModule::`RTTI Base Class	Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0C14h
		public ??_R2RBTestDataModule@@8
; RBTestDataModule::`RTTI Base Class Array'
??_R2RBTestDataModule@@8 dd offset ??_R1A@?0A@EA@RBTestDataModule@@8
					; DATA XREF: .rdata$r:00000C10o
					; RBTestDataModule::`RTTI Base Class Descriptor	at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@TestDataModule@@8 ; TestDataModule::`RTTI Base Class Descriptor	at (0,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0C20h
		public ??_R1A@?0A@EA@RBTestDataModule@@8
; RBTestDataModule::`RTTI Base Class Descriptor	at (0, -1, 0, 64)'
??_R1A@?0A@EA@RBTestDataModule@@8 dd offset ??_R0?AVRBTestDataModule@@@8
					; DATA XREF: .rdata$r:RBTestDataModule::`RTTI Base Class Array'o
					; RBTestDataModule `RTTI Type Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset off_40
		dd offset ??_R3RBTestDataModule@@8 ; RBTestDataModule::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C3Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall RBTestDataModule::`scalar deleting destructor'(unsigned int)
		public ??_GRBTestDataModule@@UAEPAXI@Z
??_GRBTestDataModule@@UAEPAXI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1RBTestDataModule@@UAE@XZ ; RBTestDataModule::~RBTestDataModule(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_C7B
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_C7B:				; CODE XREF: RBTestDataModule::`scalar deleting	destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GRBTestDataModule@@UAEPAXI@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C94h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall RBTestDataModule::`vector deleting destructor'(unsigned int)
		public ??_ERBTestDataModule@@UAEPAXI@Z
??_ERBTestDataModule@@UAEPAXI@Z	proc near
					; DATA XREF: .rdata:const RBTestDataModule::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_CF5
		push	offset ??1RBTestDataModule@@UAE@XZ ; RBTestDataModule::~RBTestDataModule(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	28h ; '('
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_CED
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_V@YAXPAX@Z	; operator delete[](void *)
		add	esp, 4

loc_CED:				; CODE XREF: RBTestDataModule::`vector deleting	destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_D14
; ---------------------------------------------------------------------------

loc_CF5:				; CODE XREF: RBTestDataModule::`vector deleting	destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1RBTestDataModule@@UAE@XZ ; RBTestDataModule::~RBTestDataModule(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_D11
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_D11:				; CODE XREF: RBTestDataModule::`vector deleting	destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_D14:				; CODE XREF: RBTestDataModule::`vector deleting	destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_ERBTestDataModule@@UAEPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D2Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall TestData::TestData(TestData	*this, const struct TestData *)
		public ??0TestData@@QAE@ABV0@@Z
??0TestData@@QAE@ABV0@@Z proc near	; CODE XREF: RBTestData::RBTestData(RBTestData const &)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7TestData@@6B@ ; const TestData::`vftable'
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	[eax+4], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+8]
		mov	[eax+8], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+0Ch]
		mov	[eax+0Ch], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+10h]
		mov	[eax+10h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+14h]
		mov	[eax+14h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+18h]
		mov	[eax+18h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+1Ch]
		mov	[eax+1Ch], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+20h]
		mov	[eax+20h], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??0TestData@@QAE@ABV0@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0DC4h
		dd offset ??_R4TestData@@6B@ ; const TestData::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7TestData@@6B@
; const	TestData::`vftable'
??_7TestData@@6B@ dd offset ??_ETestData@@UAEPAXI@Z
					; DATA XREF: TestData::TestData(TestData const &)+26o
					; TestData::TestData(char const	*)+26o	...
					; TestData::`vector deleting destructor'(uint)
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0DD8h
		public ??_R4TestData@@6B@
; const	TestData::`RTTI	Complete Object	Locator'
??_R4TestData@@6B@ dd 3	dup(0)		; DATA XREF: .rdata:00000DC4o
		dd offset ??_R0?AVTestData@@@8 ; TestData `RTTI	Type Descriptor'
		dd offset ??_R3TestData@@8 ; TestData::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 0DECh
		public ??_R0?AVTestData@@@8
; class	TestData `RTTI Type Descriptor'
??_R0?AVTestData@@@8 dd	offset ??_7type_info@@6B@ ; DATA XREF: .rdata$r:00000DE4o
					; .rdata$r:TestData::`RTTI Base	Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avtestdata@@	db '.?AVTestData@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0E04h
		public ??_R3TestData@@8
; TestData::`RTTI Class	Hierarchy Descriptor'
??_R3TestData@@8 dd 2 dup(0)		; DATA XREF: .rdata$r:00000DE8o
					; .rdata$r:00000E34o
		dd 1
		dd offset ??_R2TestData@@8 ; TestData::`RTTI Base Class	Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0E14h
		public ??_R2TestData@@8
; TestData::`RTTI Base Class Array'
??_R2TestData@@8 dd offset ??_R1A@?0A@EA@TestData@@8 ; DATA XREF: .rdata$r:00000E10o
					; TestData::`RTTI Base Class Descriptor	at (0,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0E1Ch
		public ??_R1A@?0A@EA@TestData@@8
; TestData::`RTTI Base Class Descriptor	at (0, -1, 0, 64)'
??_R1A@?0A@EA@TestData@@8 dd offset ??_R0?AVTestData@@@8
					; DATA XREF: .rdata$r:TestData::`RTTI Base Class Array'o
					; .rdata$r:00001094o
					; TestData `RTTI Type Descriptor'
		dd 2 dup(0)
		dd 0FFFFFFFFh, 0
		dd offset off_40
		dd offset ??_R3TestData@@8 ; TestData::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0E38h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	TestData & __thiscall TestData::operator=(class	TestData const &)
		public ??4TestData@@QAEAAV0@ABV0@@Z
??4TestData@@QAEAAV0@ABV0@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	[eax+4], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+8]
		mov	[eax+8], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+0Ch]
		mov	[eax+0Ch], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+10h]
		mov	[eax+10h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+14h]
		mov	[eax+14h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+18h]
		mov	[eax+18h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+1Ch]
		mov	[eax+1Ch], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+20h]
		mov	[eax+20h], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4TestData@@QAEAAV0@ABV0@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0EC8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall TestData::`scalar deleting destructor'(unsigned int)
		public ??_GTestData@@UAEPAXI@Z
??_GTestData@@UAEPAXI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1TestData@@UAE@XZ ; TestData::~TestData(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_F07
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_F07:				; CODE XREF: TestData::`scalar deleting	destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GTestData@@UAEPAXI@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0F20h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall TestData::`vector deleting destructor'(unsigned int)
		public ??_ETestData@@UAEPAXI@Z
??_ETestData@@UAEPAXI@Z	proc near	; DATA XREF: .rdata:const TestData::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_F81
		push	offset ??1TestData@@UAE@XZ ; TestData::~TestData(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	24h ; '$'
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_F79
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_V@YAXPAX@Z	; operator delete[](void *)
		add	esp, 4

loc_F79:				; CODE XREF: TestData::`vector deleting	destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_FA0
; ---------------------------------------------------------------------------

loc_F81:				; CODE XREF: TestData::`vector deleting	destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1TestData@@UAE@XZ ; TestData::~TestData(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_F9D
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_F9D:				; CODE XREF: TestData::`vector deleting	destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_FA0:				; CODE XREF: TestData::`vector deleting	destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_ETestData@@UAEPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0FB8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	RBTestData::RBTestData(struct TestData *)
		public ??0RBTestData@@QAE@ABV0@@Z
??0RBTestData@@QAE@ABV0@@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct TestData *
		mov	ecx, [ebp+var_8] ; this
		call	??0TestData@@QAE@ABV0@@Z ; TestData::TestData(TestData const &)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7RBTestData@@6B@ ; const RBTestData::`vftable'
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+24h]
		mov	[eax+24h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+28h]
		mov	[eax+28h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+2Ch]
		mov	[eax+2Ch], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+30h]
		mov	[eax+30h], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0RBTestData@@QAE@ABV0@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 103Ch
		dd offset ??_R4RBTestData@@6B@ ; const RBTestData::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7RBTestData@@6B@
; const	RBTestData::`vftable'
??_7RBTestData@@6B@ dd offset ??_ERBTestData@@UAEPAXI@Z
					; DATA XREF: RBTestData::RBTestData(RBTestData const &)+32o
					; RBTestData::RBTestData(char const *)+32o ...
					; RBTestData::`vector deleting destructor'(uint)
		dd offset ?getInfo@RBTestData@@UBECAAPBVDataMap@@AAW4UErrorCode@@@Z ; RBTestData::getInfo(DataMap const	* &,UErrorCode &)
		dd offset ?nextSettings@RBTestData@@UAECAAPBVDataMap@@AAW4UErrorCode@@@Z ; RBTestData::nextSettings(DataMap const * &,UErrorCode &)
		dd offset ?nextCase@RBTestData@@UAECAAPBVDataMap@@AAW4UErrorCode@@@Z ; RBTestData::nextCase(DataMap const * &,UErrorCode &)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1050h
		public ??_R4RBTestData@@6B@
; const	RBTestData::`RTTI Complete Object Locator'
??_R4RBTestData@@6B@ dd	3 dup(0)	; DATA XREF: .rdata:0000103Co
		dd offset ??_R0?AVRBTestData@@@8 ; RBTestData `RTTI Type Descriptor'
		dd offset ??_R3RBTestData@@8 ; RBTestData::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 1064h
		public ??_R0?AVRBTestData@@@8
; class	RBTestData `RTTI Type Descriptor'
??_R0?AVRBTestData@@@8 dd offset ??_7type_info@@6B@ ; DATA XREF: .rdata$r:0000105Co
					; .rdata$r:RBTestData::`RTTI Base Class	Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avrbtestda_0	db '.?AVRBTestData@@',0
		align 10h
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1080h
		public ??_R3RBTestData@@8
; RBTestData::`RTTI Class Hierarchy Descriptor'
??_R3RBTestData@@8 dd 2	dup(0)		; DATA XREF: .rdata$r:00001060o
					; .rdata$r:000010B4o
		dd 2
		dd offset ??_R2RBTestData@@8 ; RBTestData::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1090h
		public ??_R2RBTestData@@8
; RBTestData::`RTTI Base Class Array'
??_R2RBTestData@@8 dd offset ??_R1A@?0A@EA@RBTestData@@8 ; DATA	XREF: .rdata$r:0000108Co
					; RBTestData::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@TestData@@8 ; TestData::`RTTI Base Class Descriptor at (0,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 109Ch
		public ??_R1A@?0A@EA@RBTestData@@8
; RBTestData::`RTTI Base Class Descriptor at (0, -1, 0,	64)'
??_R1A@?0A@EA@RBTestData@@8 dd offset ??_R0?AVRBTestData@@@8
					; DATA XREF: .rdata$r:RBTestData::`RTTI	Base Class Array'o
					; RBTestData `RTTI Type	Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset off_40
		dd offset ??_R3RBTestData@@8 ; RBTestData::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 10B8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall RBTestData::`scalar	deleting destructor'(unsigned int)
		public ??_GRBTestData@@UAEPAXI@Z
??_GRBTestData@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1RBTestData@@UAE@XZ ;	RBTestData::~RBTestData(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_10F7
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_10F7:				; CODE XREF: RBTestData::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GRBTestData@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1110h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall RBTestData::`vector	deleting destructor'(unsigned int)
		public ??_ERBTestData@@UAEPAXI@Z
??_ERBTestData@@UAEPAXI@Z proc near	; DATA XREF: .rdata:const RBTestData::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_1171
		push	offset ??1RBTestData@@UAE@XZ ; RBTestData::~RBTestData(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	34h ; '4'
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_1169
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_V@YAXPAX@Z	; operator delete[](void *)
		add	esp, 4

loc_1169:				; CODE XREF: RBTestData::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_1190
; ---------------------------------------------------------------------------

loc_1171:				; CODE XREF: RBTestData::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1RBTestData@@UAE@XZ ;	RBTestData::~RBTestData(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_118D
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_118D:				; CODE XREF: RBTestData::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_1190:				; CODE XREF: RBTestData::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_ERBTestData@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 11A8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; protected: __thiscall	TestData::TestData(char	const *)
		public ??0TestData@@IAE@PBD@Z
??0TestData@@IAE@PBD@Z proc near	; CODE XREF: RBTestData::RBTestData(char const *)+2Ap
					; RBTestData::RBTestData(UResourceBundle *,UResourceBundle *,UErrorCode	&)+52p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7TestData@@6B@ ; const TestData::`vftable'
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+4], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+8], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+0Ch], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+10h], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+14h], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+18h], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+1Ch], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+20h], 0
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??0TestData@@IAE@PBD@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1230h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall TestData::~TestData(TestData *__hidden this)
		public ??1TestData@@UAE@XZ
??1TestData@@UAE@XZ proc near		; CODE XREF: TestData::`scalar deleting	destructor'(uint)+26p
					; TestData::`vector deleting destructor'(uint)+64p ...

var_118		= dword	ptr -118h
var_110		= dword	ptr -110h
var_104		= dword	ptr -104h
var_F8		= dword	ptr -0F8h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_D4		= dword	ptr -0D4h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 118h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_118]
		mov	ecx, 46h ; 'F'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7TestData@@6B@ ; const TestData::`vftable'
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+8], 0
		jz	short loc_12B5
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		mov	[ebp+var_104], ecx
		mov	edx, [ebp+var_104]
		mov	[ebp+var_110], edx
		cmp	[ebp+var_110], 0
		jz	short loc_12AB
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_110]
		mov	edx, [eax]
		mov	ecx, [ebp+var_110]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_118], eax
		jmp	short loc_12B5
; ---------------------------------------------------------------------------

loc_12AB:				; CODE XREF: TestData::~TestData(void)+54j
		mov	[ebp+var_118], 0

loc_12B5:				; CODE XREF: TestData::~TestData(void)+33j
					; TestData::~TestData(void)+79j
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+0Ch], 0
		jz	short loc_130E
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		mov	[ebp+var_EC], ecx
		mov	edx, [ebp+var_EC]
		mov	[ebp+var_F8], edx
		cmp	[ebp+var_F8], 0
		jz	short loc_1304
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_F8]
		mov	edx, [eax]
		mov	ecx, [ebp+var_F8]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_118], eax
		jmp	short loc_130E
; ---------------------------------------------------------------------------

loc_1304:				; CODE XREF: TestData::~TestData(void)+ADj
		mov	[ebp+var_118], 0

loc_130E:				; CODE XREF: TestData::~TestData(void)+8Cj
					; TestData::~TestData(void)+D2j
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+10h], 0
		jz	short loc_1367
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	[ebp+var_D4], ecx
		mov	edx, [ebp+var_D4]
		mov	[ebp+var_E0], edx
		cmp	[ebp+var_E0], 0
		jz	short loc_135D
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_E0]
		mov	edx, [eax]
		mov	ecx, [ebp+var_E0]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_118], eax
		jmp	short loc_1367
; ---------------------------------------------------------------------------

loc_135D:				; CODE XREF: TestData::~TestData(void)+106j
		mov	[ebp+var_118], 0

loc_1367:				; CODE XREF: TestData::~TestData(void)+E5j
					; TestData::~TestData(void)+12Bj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 118h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1TestData@@UAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 137Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	char *__thiscall TestData::getName(TestData *__hidden this)
		public ?getName@TestData@@QBEPBDXZ
?getName@TestData@@QBEPBDXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getName@TestData@@QBEPBDXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 13ACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RBTestData::RBTestData(char const *)
		public ??0RBTestData@@QAE@PBD@Z
??0RBTestData@@QAE@PBD@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??0TestData@@IAE@PBD@Z ; TestData::TestData(char const *)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7RBTestData@@6B@ ; const RBTestData::`vftable'
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+24h], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+28h], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+2Ch], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+30h], 0
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0RBTestData@@QAE@PBD@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1428h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RBTestData::RBTestData(struct UResourceBundle *, struct UResourceBundle *,	enum  UErrorCode &)
		public ??0RBTestData@@QAE@PAUUResourceBundle@@0AAW4UErrorCode@@@Z
??0RBTestData@@QAE@PAUUResourceBundle@@0AAW4UErrorCode@@@Z proc	near

var_118		= dword	ptr -118h
var_110		= dword	ptr -110h
var_104		= dword	ptr -104h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0RBTestData@@QAE@PAUUResourceBundle@@0AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 10Ch
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_118]
		mov	ecx, 43h ; 'C'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		call	_ures_getKey_56
		add	esp, 4
		push	eax
		mov	ecx, [ebp+var_14]
		call	??0TestData@@IAE@PBD@Z ; TestData::TestData(char const *)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7RBTestData@@6B@ ; const RBTestData::`vftable'
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	[eax+24h], ecx
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_4]
		mov	[eax+28h], ecx
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+2Ch], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+30h], 0
		mov	[ebp+var_20], 0
		lea	eax, [ebp+var_20]
		push	eax
		push	0
		push	offset ??_C@_07EJKOAGME@Headers?$AA@ ; "Headers"
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	_ures_getByKey_56
		add	esp, 10h
		mov	[ebp+var_2C], eax
		cmp	[ebp+var_20], 0
		jnz	short loc_14F6
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+28h]
		push	ecx
		call	_ures_close_56
		add	esp, 4
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_2C]
		mov	[eax+28h], ecx
		jmp	short loc_14FD
; ---------------------------------------------------------------------------

loc_14F6:				; CODE XREF: RBTestData::RBTestData(UResourceBundle *,UResourceBundle *,UErrorCode &)+B2j
		mov	[ebp+var_20], 0

loc_14FD:				; CODE XREF: RBTestData::RBTestData(UResourceBundle *,UResourceBundle *,UErrorCode &)+CCj
		lea	eax, [ebp+var_20]
		push	eax
		push	0
		push	offset ??_C@_08EEOHOBEO@Settings?$AA@ ;	"Settings"
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	_ures_getByKey_56
		add	esp, 10h
		mov	edx, [ebp+var_14]
		mov	[edx+2Ch], eax
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+2Ch]
		push	ecx
		call	_ures_getSize_56
		add	esp, 4
		mov	edx, [ebp+var_14]
		mov	[edx+14h], eax
		lea	eax, [ebp+var_20]
		push	eax
		push	0
		push	offset ??_C@_04BJPIHCBA@Info?$AA@ ; "Info"
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	_ures_getByKey_56
		add	esp, 10h
		mov	[ebp+var_38], eax
		mov	eax, [ebp+var_20]
		push	eax
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_15BC
		push	8		; unsigned int
		call	??2@YAPAXI@Z	; operator new(uint)
		add	esp, 4
		mov	[ebp+var_104], eax
		mov	byte ptr [ebp+var_4], 1
		cmp	[ebp+var_104], 0
		jz	short loc_1594
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+var_38]
		push	ecx
		mov	ecx, [ebp+var_104]
		call	??0RBDataMap@@QAE@PAUUResourceBundle@@AAW4UErrorCode@@@Z ; RBDataMap::RBDataMap(UResourceBundle	*,UErrorCode &)
		mov	[ebp+var_118], eax
		jmp	short loc_159E
; ---------------------------------------------------------------------------

loc_1594:				; CODE XREF: RBTestData::RBTestData(UResourceBundle *,UResourceBundle *,UErrorCode &)+14Fj
		mov	[ebp+var_118], 0

loc_159E:				; CODE XREF: RBTestData::RBTestData(UResourceBundle *,UResourceBundle *,UErrorCode &)+16Aj
		mov	edx, [ebp+var_118]
		mov	[ebp+var_110], edx
		mov	byte ptr [ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_110]
		mov	[eax+8], ecx
		jmp	short loc_15C3
; ---------------------------------------------------------------------------

loc_15BC:				; CODE XREF: RBTestData::RBTestData(UResourceBundle *,UResourceBundle *,UErrorCode &)+132j
		mov	[ebp+var_20], 0

loc_15C3:				; CODE XREF: RBTestData::RBTestData(UResourceBundle *,UResourceBundle *,UErrorCode &)+192j
		mov	eax, [ebp+arg_8]
		push	eax
		push	0
		push	offset ??_C@_05FACHFEOP@Cases?$AA@ ; "Cases"
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	_ures_getByKey_56
		add	esp, 10h
		mov	edx, [ebp+var_14]
		mov	[edx+30h], eax
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+30h]
		push	ecx
		call	_ures_getSize_56
		add	esp, 4
		mov	edx, [ebp+var_14]
		mov	[edx+18h], eax
		mov	eax, [ebp+var_38]
		push	eax
		call	_ures_close_56
		add	esp, 4
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN14
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 118h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
??0RBTestData@@QAE@PAUUResourceBundle@@0AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
$LN14		dd 1			; DATA XREF: RBTestData::RBTestData(UResourceBundle *,UResourceBundle *,UErrorCode &)+1E7o
		dd offset $LN13
$LN13		dd 0FFFFFFE0h, 4	; DATA XREF: .text:00001644o
		dd offset $LN11		; "intStatus"
$LN11		db 'intStatus',0        ; DATA XREF: .text:00001650o
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 1660h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0RBTestData@@QAE@PAUUResourceBundle@@0AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:000016BCo
		mov	ecx, [ebp-14h]	; this
		jmp	??1TestData@@UAE@XZ ; TestData::~TestData(void)
__unwindfunclet$??0RBTestData@@QAE@PAUUResourceBundle@@0AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0RBTestData@@QAE@PAUUResourceBundle@@0AAW4UErrorCode@@@Z$1 proc near
					; DATA XREF: .xdata$x:000016C4o
		mov	eax, [ebp-104h]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		pop	ecx
		retn
__unwindfunclet$??0RBTestData@@QAE@PAUUResourceBundle@@0AAW4UErrorCode@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0RBTestData@@QAE@PAUUResourceBundle@@0AAW4UErrorCode@@@Z proc near
					; DATA XREF: RBTestData::RBTestData(UResourceBundle *,UResourceBundle *,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-11Ch]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0RBTestData@@QAE@PAUUResourceBundle@@0AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0RBTestData@@QAE@PAUUResourceBundle@@0AAW4UErrorCode@@@Z endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1694h
		public ??_C@_05FACHFEOP@Cases?$AA@
; `string'
??_C@_05FACHFEOP@Cases?$AA@ db 'Cases',0
					; DATA XREF: RBTestData::RBTestData(UResourceBundle *,UResourceBundle *,UErrorCode &)+1A1o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 169Ch
		public ??_C@_04BJPIHCBA@Info?$AA@
; `string'
??_C@_04BJPIHCBA@Info?$AA@ db 'Info',0  ; DATA XREF: RBTestData::RBTestData(UResourceBundle *,UResourceBundle *,UErrorCode &)+10Do
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 16A4h
		public ??_C@_08EEOHOBEO@Settings?$AA@
; `string'
??_C@_08EEOHOBEO@Settings?$AA@ db 'Settings',0
					; DATA XREF: RBTestData::RBTestData(UResourceBundle *,UResourceBundle *,UErrorCode &)+DBo
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 16B0h
		public ??_C@_07EJKOAGME@Headers?$AA@
; `string'
??_C@_07EJKOAGME@Headers?$AA@ db 'Headers',0
					; DATA XREF: RBTestData::RBTestData(UResourceBundle *,UResourceBundle *,UErrorCode &)+9Ao
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 16B8h
__unwindtable$??0RBTestData@@QAE@PAUUResourceBundle@@0AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000016D0o
		dd offset __unwindfunclet$??0RBTestData@@QAE@PAUUResourceBundle@@0AAW4UErrorCode@@@Z$0
		dd 0
		dd offset __unwindfunclet$??0RBTestData@@QAE@PAUUResourceBundle@@0AAW4UErrorCode@@@Z$1
__ehfuncinfo$??0RBTestData@@QAE@PAUUResourceBundle@@0AAW4UErrorCode@@@Z	dd 19930522h, 2
					; DATA XREF: __ehhandler$??0RBTestData@@QAE@PAUUResourceBundle@@0AAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$??0RBTestData@@QAE@PAUUResourceBundle@@0AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 16ECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl U_SUCCESS(enum  UErrorCode)
?U_SUCCESS@@YACW4UErrorCode@@@Z	proc near
					; CODE XREF: RBTestData::RBTestData(UResourceBundle *,UResourceBundle *,UErrorCode &)+125p
					; RBTestData::nextSettings(DataMap const * &,UErrorCode	&)+87p	...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		setle	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?U_SUCCESS@@YACW4UErrorCode@@@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1718h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall RBTestData::~RBTestData(RBTestData *__hidden this)
		public ??1RBTestData@@UAE@XZ
??1RBTestData@@UAE@XZ proc near		; CODE XREF: RBTestData::`scalar deleting destructor'(uint)+26p
					; RBTestData::`vector deleting destructor'(uint)+64p
					; DATA XREF: ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7RBTestData@@6B@ ; const RBTestData::`vftable'
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+24h]
		push	ecx
		call	_ures_close_56
		add	esp, 4
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+28h]
		push	ecx
		call	_ures_close_56
		add	esp, 4
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+2Ch]
		push	ecx
		call	_ures_close_56
		add	esp, 4
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+30h]
		push	ecx
		call	_ures_close_56
		add	esp, 4
		mov	ecx, [ebp+var_8] ; this
		call	??1TestData@@UAE@XZ ; TestData::~TestData(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1RBTestData@@UAE@XZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 179Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall RBTestData::getInfo(RBTestData *this, const struct DataMap **, enum UErrorCode *)
		public ?getInfo@RBTestData@@UBECAAPBVDataMap@@AAW4UErrorCode@@@Z
?getInfo@RBTestData@@UBECAAPBVDataMap@@AAW4UErrorCode@@@Z proc near
					; DATA XREF: .rdata:00001044o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+8], 0
		jz	short loc_17D9
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+8]
		mov	[eax], edx
		mov	al, 1
		jmp	short loc_17E4
; ---------------------------------------------------------------------------
		jmp	short loc_17E4
; ---------------------------------------------------------------------------

loc_17D9:				; CODE XREF: RBTestData::getInfo(DataMap const * &,UErrorCode &)+2Aj
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 0
		xor	al, al

loc_17E4:				; CODE XREF: RBTestData::getInfo(DataMap const * &,UErrorCode &)+39j
					; RBTestData::getInfo(DataMap const * &,UErrorCode &)+3Bj
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	8
?getInfo@RBTestData@@UBECAAPBVDataMap@@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 17F0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall RBTestData::nextSettings(RBTestData *this, const struct DataMap **, enum UErrorCode *)
		public ?nextSettings@RBTestData@@UAECAAPBVDataMap@@AAW4UErrorCode@@@Z
?nextSettings@RBTestData@@UAECAAPBVDataMap@@AAW4UErrorCode@@@Z proc near
					; DATA XREF: .rdata:00001048o

var_10C		= dword	ptr -10Ch
var_104		= dword	ptr -104h
var_F8		= dword	ptr -0F8h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?nextSettings@RBTestData@@UAECAAPBVDataMap@@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 100h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_10C]
		mov	ecx, 40h ; '@'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	[ebp+var_20], 0
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+1Ch]
		mov	[ebp+var_10C], ecx
		mov	edx, [ebp+var_14]
		mov	eax, [edx+1Ch]
		add	eax, 1
		mov	ecx, [ebp+var_14]
		mov	[ecx+1Ch], eax
		lea	edx, [ebp+var_20]
		push	edx
		push	0
		mov	eax, [ebp+var_10C]
		push	eax
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+2Ch]
		push	edx
		call	_ures_getByIndex_56
		add	esp, 10h
		mov	[ebp+var_2C], eax
		mov	eax, [ebp+var_20]
		push	eax
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	loc_1933
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+20h], 0
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+0Ch], 0
		jnz	short loc_1903
		push	8		; unsigned int
		call	??2@YAPAXI@Z	; operator new(uint)
		add	esp, 4
		mov	[ebp+var_F8], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_F8], 0
		jz	short loc_18D8
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_2C]
		push	ecx
		mov	ecx, [ebp+var_F8]
		call	??0RBDataMap@@QAE@PAUUResourceBundle@@AAW4UErrorCode@@@Z ; RBDataMap::RBDataMap(UResourceBundle	*,UErrorCode &)
		mov	[ebp+var_10C], eax
		jmp	short loc_18E2
; ---------------------------------------------------------------------------

loc_18D8:				; CODE XREF: RBTestData::nextSettings(DataMap const * &,UErrorCode &)+CBj
		mov	[ebp+var_10C], 0

loc_18E2:				; CODE XREF: RBTestData::nextSettings(DataMap const * &,UErrorCode &)+E6j
		mov	edx, [ebp+var_10C]
		mov	[ebp+var_104], edx
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_104]
		mov	[eax+0Ch], ecx
		jmp	short loc_1916
; ---------------------------------------------------------------------------

loc_1903:				; CODE XREF: RBTestData::nextSettings(DataMap const * &,UErrorCode &)+ABj
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_2C]
		push	ecx		; struct UResourceBundle *
		mov	edx, [ebp+var_14]
		mov	ecx, [edx+0Ch]	; this
		call	?init@RBDataMap@@QAEXPAUUResourceBundle@@AAW4UErrorCode@@@Z ; RBDataMap::init(UResourceBundle *,UErrorCode &)

loc_1916:				; CODE XREF: RBTestData::nextSettings(DataMap const * &,UErrorCode &)+111j
		mov	eax, [ebp+var_2C]
		push	eax
		call	_ures_close_56
		add	esp, 4
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+0Ch]
		mov	[eax], edx
		mov	al, 1
		jmp	short loc_193E
; ---------------------------------------------------------------------------
		jmp	short loc_193E
; ---------------------------------------------------------------------------

loc_1933:				; CODE XREF: RBTestData::nextSettings(DataMap const * &,UErrorCode &)+94j
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 0
		xor	al, al

loc_193E:				; CODE XREF: RBTestData::nextSettings(DataMap const * &,UErrorCode &)+13Fj
					; RBTestData::nextSettings(DataMap const * &,UErrorCode	&)+141j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN13_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 10Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?nextSettings@RBTestData@@UAECAAPBVDataMap@@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
$LN13_0		dd 1			; DATA XREF: RBTestData::nextSettings(DataMap const * &,UErrorCode &)+152o
		dd offset $LN12
$LN12		dd 0FFFFFFE0h, 4	; DATA XREF: .text:00001974o
		dd offset $LN10		; "intStatus"
$LN10		db 'intStatus',0        ; DATA XREF: .text:00001980o
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 1990h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?nextSettings@RBTestData@@UAECAAPBVDataMap@@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:000019C0o
		mov	eax, [ebp-0F8h]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		pop	ecx
		retn
__unwindfunclet$?nextSettings@RBTestData@@UAECAAPBVDataMap@@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?nextSettings@RBTestData@@UAECAAPBVDataMap@@AAW4UErrorCode@@@Z proc	near
					; DATA XREF: RBTestData::nextSettings(DataMap const * &,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-110h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?nextSettings@RBTestData@@UAECAAPBVDataMap@@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?nextSettings@RBTestData@@UAECAAPBVDataMap@@AAW4UErrorCode@@@Z endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 19BCh
__unwindtable$?nextSettings@RBTestData@@UAECAAPBVDataMap@@AAW4UErrorCode@@@Z dd	0FFFFFFFFh
					; DATA XREF: .xdata$x:000019CCo
		dd offset __unwindfunclet$?nextSettings@RBTestData@@UAECAAPBVDataMap@@AAW4UErrorCode@@@Z$0
__ehfuncinfo$?nextSettings@RBTestData@@UAECAAPBVDataMap@@AAW4UErrorCode@@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$?nextSettings@RBTestData@@UAECAAPBVDataMap@@AAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$?nextSettings@RBTestData@@UAECAAPBVDataMap@@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 19E8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall RBTestData::nextCase(RBTestData *this, const	struct DataMap **, enum	UErrorCode *)
		public ?nextCase@RBTestData@@UAECAAPBVDataMap@@AAW4UErrorCode@@@Z
?nextCase@RBTestData@@UAECAAPBVDataMap@@AAW4UErrorCode@@@Z proc	near
					; DATA XREF: .rdata:0000104Co

var_10C		= dword	ptr -10Ch
var_104		= dword	ptr -104h
var_F8		= dword	ptr -0F8h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?nextCase@RBTestData@@UAECAAPBVDataMap@@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 100h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_10C]
		mov	ecx, 40h ; '@'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	[ebp+var_20], 0
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+20h]
		mov	[ebp+var_10C], ecx
		mov	edx, [ebp+var_14]
		mov	eax, [edx+20h]
		add	eax, 1
		mov	ecx, [ebp+var_14]
		mov	[ecx+20h], eax
		lea	edx, [ebp+var_20]
		push	edx
		push	0
		mov	eax, [ebp+var_10C]
		push	eax
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+30h]
		push	edx
		call	_ures_getByIndex_56
		add	esp, 10h
		mov	[ebp+var_2C], eax
		mov	eax, [ebp+var_20]
		push	eax
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	loc_1B2F
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+10h], 0
		jnz	short loc_1AF8
		push	8		; unsigned int
		call	??2@YAPAXI@Z	; operator new(uint)
		add	esp, 4
		mov	[ebp+var_F8], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_F8], 0
		jz	short loc_1ACD
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_2C]
		push	ecx
		mov	edx, [ebp+var_14]
		mov	eax, [edx+28h]
		push	eax
		mov	ecx, [ebp+var_F8]
		call	??0RBDataMap@@QAE@PAUUResourceBundle@@0AAW4UErrorCode@@@Z ; RBDataMap::RBDataMap(UResourceBundle *,UResourceBundle *,UErrorCode	&)
		mov	[ebp+var_10C], eax
		jmp	short loc_1AD7
; ---------------------------------------------------------------------------

loc_1ACD:				; CODE XREF: RBTestData::nextCase(DataMap const	* &,UErrorCode &)+C1j
		mov	[ebp+var_10C], 0

loc_1AD7:				; CODE XREF: RBTestData::nextCase(DataMap const	* &,UErrorCode &)+E3j
		mov	ecx, [ebp+var_10C]
		mov	[ebp+var_104], ecx
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	edx, [ebp+var_14]
		mov	eax, [ebp+var_104]
		mov	[edx+10h], eax
		jmp	short loc_1B12
; ---------------------------------------------------------------------------

loc_1AF8:				; CODE XREF: RBTestData::nextCase(DataMap const	* &,UErrorCode &)+A1j
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_2C]
		push	ecx		; struct UResourceBundle *
		mov	edx, [ebp+var_14]
		mov	eax, [edx+28h]
		push	eax		; struct UResourceBundle *
		mov	ecx, [ebp+var_14]
		mov	ecx, [ecx+10h]	; this
		call	?init@RBDataMap@@QAEXPAUUResourceBundle@@0AAW4UErrorCode@@@Z ; RBDataMap::init(UResourceBundle *,UResourceBundle *,UErrorCode &)

loc_1B12:				; CODE XREF: RBTestData::nextCase(DataMap const	* &,UErrorCode &)+10Ej
		mov	eax, [ebp+var_2C]
		push	eax
		call	_ures_close_56
		add	esp, 4
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+10h]
		mov	[eax], edx
		mov	al, 1
		jmp	short loc_1B3A
; ---------------------------------------------------------------------------
		jmp	short loc_1B3A
; ---------------------------------------------------------------------------

loc_1B2F:				; CODE XREF: RBTestData::nextCase(DataMap const	* &,UErrorCode &)+94j
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 0
		xor	al, al

loc_1B3A:				; CODE XREF: RBTestData::nextCase(DataMap const	* &,UErrorCode &)+143j
					; RBTestData::nextCase(DataMap const * &,UErrorCode &)+145j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN13_1
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 10Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?nextCase@RBTestData@@UAECAAPBVDataMap@@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
$LN13_1		dd 1			; DATA XREF: RBTestData::nextCase(DataMap const	* &,UErrorCode &)+156o
		dd offset $LN12_0
$LN12_0		dd 0FFFFFFE0h, 4	; DATA XREF: .text:00001B70o
		dd offset $LN10_0	; "intStatus"
$LN10_0		db 'intStatus',0        ; DATA XREF: .text:00001B7Co
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 1B8Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?nextCase@RBTestData@@UAECAAPBVDataMap@@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:00001BBCo
		mov	eax, [ebp-0F8h]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		pop	ecx
		retn
__unwindfunclet$?nextCase@RBTestData@@UAECAAPBVDataMap@@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?nextCase@RBTestData@@UAECAAPBVDataMap@@AAW4UErrorCode@@@Z proc near
					; DATA XREF: RBTestData::nextCase(DataMap const	* &,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-110h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?nextCase@RBTestData@@UAECAAPBVDataMap@@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?nextCase@RBTestData@@UAECAAPBVDataMap@@AAW4UErrorCode@@@Z endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 1BB8h
__unwindtable$?nextCase@RBTestData@@UAECAAPBVDataMap@@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00001BC8o
		dd offset __unwindfunclet$?nextCase@RBTestData@@UAECAAPBVDataMap@@AAW4UErrorCode@@@Z$0
__ehfuncinfo$?nextCase@RBTestData@@UAECAAPBVDataMap@@AAW4UErrorCode@@@Z	dd 19930522h, 1
					; DATA XREF: __ehhandler$?nextCase@RBTestData@@UAECAAPBVDataMap@@AAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$?nextCase@RBTestData@@UAECAAPBVDataMap@@AAW4UErrorCode@@@Z
		align 20h
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn __RTC_Shutdown:near ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
		extrn __RTC_InitBase:near ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
; const	type_info::`vftable'
		extrn ??_7type_info@@6B@:near
					; DATA XREF: .data:DataMap `RTTI Type Descriptor'o
					; .data:RBDataMap `RTTI	Type Descriptor'o ...
		extrn __purecall:near	; DATA XREF: .rdata:off_40o
					; .rdata:00000044o ...
; void __cdecl operator	delete(void *)
		extrn ??3@YAXPAX@Z:near	; CODE XREF: DataMap::`scalar deleting destructor'(uint)+37p
					; DataMap::`vector deleting destructor'(uint)+75p ...
; _DWORD __thiscall DataMap::~DataMap(DataMap *__hidden	this)
		extrn ??1DataMap@@UAE@XZ:near
					; CODE XREF: DataMap::`scalar deleting destructor'(uint)+26p
					; DataMap::`vector deleting destructor'(uint)+64p
					; DATA XREF: ...
		extrn __RTC_CheckEsp:near
					; CODE XREF: DataMap::`scalar deleting destructor'(uint)+4Dp
					; DataMap::`vector deleting destructor'(uint)+8Bp ...
; void __cdecl operator	delete[](void *)
		extrn ??_V@YAXPAX@Z:near
					; CODE XREF: DataMap::`vector deleting destructor'(uint)+51p
					; RBDataMap::`vector deleting destructor'(uint)+51p ...
; void __stdcall `eh vector destructor iterator'(void *, unsigned int, int, void (__thiscall *)(void *))
		extrn ??_M@YGXPAXIHP6EX0@Z@Z:near
					; CODE XREF: DataMap::`vector deleting destructor'(uint)+3Dp
					; RBDataMap::`vector deleting destructor'(uint)+3Dp ...
; public: virtual class	icu_56::UnicodeString const __thiscall RBDataMap::getString(char const *, enum	UErrorCode &)const
		extrn ?getString@RBDataMap@@UBE?BVUnicodeString@icu_56@@PBDAAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:00000250o
; public: virtual int __thiscall RBDataMap::getInt(char	const *, enum  UErrorCode &)const
		extrn ?getInt@RBDataMap@@UBEHPBDAAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:00000254o
; public: virtual int __thiscall RBDataMap::getInt28(char const	*, enum	 UErrorCode &)const
		extrn ?getInt28@RBDataMap@@UBEHPBDAAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:00000258o
; public: virtual unsigned int __thiscall RBDataMap::getUInt28(char const *, enum  UErrorCode &)const
		extrn ?getUInt28@RBDataMap@@UBEIPBDAAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:0000025Co
; public: virtual int const * __thiscall RBDataMap::getIntVector(int &,	char const *, enum  UErrorCode &)const
		extrn ?getIntVector@RBDataMap@@UBEPBHAAHPBDAAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:00000260o
; public: virtual unsigned char	const *	__thiscall RBDataMap::getBinary(int &, char const *, enum  UErrorCode &)const
		extrn ?getBinary@RBDataMap@@UBEPBEAAHPBDAAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:00000264o
; public: virtual class	icu_56::UnicodeString const * __thiscall RBDataMap::getStringArray(int &, char const *,	enum  UErrorCode &)const
		extrn ?getStringArray@RBDataMap@@UBEPBVUnicodeString@icu_56@@AAHPBDAAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:00000268o
; public: virtual int const * __thiscall RBDataMap::getIntArray(int &, char const *, enum  UErrorCode &)const
		extrn ?getIntArray@RBDataMap@@UBEPBHAAHPBDAAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:0000026Co
; public: virtual class	icu_56::ResourceBundle const * __thiscall RBDataMap::getItem(char const	*, enum	 UErrorCode &)const
		extrn ?getItem@RBDataMap@@UBEPBVResourceBundle@icu_56@@PBDAAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:00000270o
; _DWORD __thiscall RBDataMap::~RBDataMap(RBDataMap *__hidden this)
		extrn ??1RBDataMap@@UAE@XZ:near
					; CODE XREF: RBDataMap::`scalar	deleting destructor'(uint)+26p
					; RBDataMap::`vector deleting destructor'(uint)+64p
					; DATA XREF: ...
; _DWORD __thiscall TestLog::~TestLog(TestLog *__hidden	this)
		extrn ??1TestLog@@UAE@XZ:near
					; CODE XREF: TestLog::`scalar deleting destructor'(uint)+26p
					; TestLog::`vector deleting destructor'(uint)+64p
					; DATA XREF: ...
; _DWORD __thiscall icu_56::ErrorCode::ErrorCode(icu_56::ErrorCode *__hidden this)
		extrn __imp_??0ErrorCode@icu_56@@QAE@XZ:near
					; CODE XREF: IcuTestErrorCode::IcuTestErrorCode(TestLog	&,char const *)+28p
					; DATA XREF: IcuTestErrorCode::IcuTestErrorCode(TestLog	&,char const *)+28r
; protected: virtual void __thiscall IcuTestErrorCode::handleFailure(void)const
		extrn ?handleFailure@IcuTestErrorCode@@MBEXXZ:near
					; DATA XREF: .rdata:00000698o
; _DWORD __thiscall icu_56::ErrorCode::ErrorCode(icu_56::ErrorCode *__hidden this, const struct	icu_56::ErrorCode *)
		extrn __imp_??0ErrorCode@icu_56@@QAE@ABV01@@Z:near
					; CODE XREF: IcuTestErrorCode::IcuTestErrorCode(IcuTestErrorCode const &)+2Cp
					; DATA XREF: IcuTestErrorCode::IcuTestErrorCode(IcuTestErrorCode const &)+2Cr
; void __cdecl icu_56::UMemory::operator delete(void *)
		extrn __imp_??3UMemory@icu_56@@SAXPAX@Z:near
					; CODE XREF: IcuTestErrorCode::`scalar deleting	destructor'(uint)+39p
					; IcuTestErrorCode::`vector deleting destructor'(uint)+81p
					; DATA XREF: ...
; _DWORD __thiscall IcuTestErrorCode::~IcuTestErrorCode(IcuTestErrorCode *__hidden this)
		extrn ??1IcuTestErrorCode@@UAE@XZ:near
					; CODE XREF: IcuTestErrorCode::`scalar deleting	destructor'(uint)+26p
					; IcuTestErrorCode::`vector deleting destructor'(uint)+6Ep
					; DATA XREF: ...
; void __cdecl icu_56::UMemory::operator delete[](void *)
		extrn __imp_??_VUMemory@icu_56@@SAXPAX@Z:near
					; CODE XREF: IcuTestErrorCode::`vector deleting	destructor'(uint)+53p
					; DATA XREF: IcuTestErrorCode::`vector deleting	destructor'(uint)+53r
; _DWORD __thiscall TestDataModule::~TestDataModule(TestDataModule *__hidden this)
		extrn ??1TestDataModule@@UAE@XZ:near
					; CODE XREF: TestDataModule::`scalar deleting destructor'(uint)+26p
					; TestDataModule::`vector deleting destructor'(uint)+64p
					; DATA XREF: ...
; public: virtual signed char __thiscall RBTestDataModule::getInfo(class DataMap const * &, enum  UErrorCode &)const
		extrn ?getInfo@RBTestDataModule@@UBECAAPBVDataMap@@AAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:00000BC4o
; public: virtual class	TestData * __thiscall RBTestDataModule::createTestData(char const *, enum  UErrorCode &)const
		extrn ?createTestData@RBTestDataModule@@UBEPAVTestData@@PBDAAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:00000BC8o
; public: virtual class	TestData * __thiscall RBTestDataModule::createTestData(int, enum  UErrorCode &)const
		extrn ?createTestData@RBTestDataModule@@UBEPAVTestData@@HAAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:00000BCCo
; _DWORD __thiscall RBTestDataModule::~RBTestDataModule(RBTestDataModule *__hidden this)
		extrn ??1RBTestDataModule@@UAE@XZ:near
					; CODE XREF: RBTestDataModule::`scalar deleting	destructor'(uint)+26p
					; RBTestDataModule::`vector deleting destructor'(uint)+64p
					; DATA XREF: ...
; public: __thiscall RBDataMap::RBDataMap(struct UResourceBundle *, enum  UErrorCode &)
		extrn ??0RBDataMap@@QAE@PAUUResourceBundle@@AAW4UErrorCode@@@Z:near
					; CODE XREF: RBTestData::RBTestData(UResourceBundle *,UResourceBundle *,UErrorCode &)+15Fp
					; RBTestData::nextSettings(DataMap const * &,UErrorCode	&)+DBp
; void *__cdecl	operator new(unsigned int)
		extrn ??2@YAPAXI@Z:near	; CODE XREF: RBTestData::RBTestData(UResourceBundle *,UResourceBundle *,UErrorCode &)+136p
					; RBTestData::nextSettings(DataMap const * &,UErrorCode	&)+AFp	...
		extrn _ures_getSize_56:near
					; CODE XREF: RBTestData::RBTestData(UResourceBundle *,UResourceBundle *,UErrorCode &)+F9p
					; RBTestData::RBTestData(UResourceBundle *,UResourceBundle *,UErrorCode	&)+1BFp
		extrn _ures_close_56:near
					; CODE XREF: RBTestData::RBTestData(UResourceBundle *,UResourceBundle *,UErrorCode &)+BBp
					; RBTestData::RBTestData(UResourceBundle *,UResourceBundle *,UErrorCode	&)+1D1p ...
		extrn _ures_getByKey_56:near
					; CODE XREF: RBTestData::RBTestData(UResourceBundle *,UResourceBundle *,UErrorCode &)+A3p
					; RBTestData::RBTestData(UResourceBundle *,UResourceBundle *,UErrorCode	&)+E4p	...
		extrn _ures_getKey_56:near
					; CODE XREF: RBTestData::RBTestData(UResourceBundle *,UResourceBundle *,UErrorCode &)+46p
		extrn ___security_cookie:near
					; DATA XREF: RBTestData::RBTestData(UResourceBundle *,UResourceBundle *,UErrorCode &)+2Er
					; RBTestData::nextSettings(DataMap const * &,UErrorCode	&)+2Er	...
		extrn ___CxxFrameHandler3:near
					; CODE XREF: __ehhandler$??0RBTestData@@QAE@PAUUResourceBundle@@0AAW4UErrorCode@@@Z+19j
					; __ehhandler$?nextSettings@RBTestData@@UAECAAPBVDataMap@@AAW4UErrorCode@@@Z+19j ...
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near
					; CODE XREF: __ehhandler$??0RBTestData@@QAE@PAUUResourceBundle@@0AAW4UErrorCode@@@Z+Fp
					; __ehhandler$?nextSettings@RBTestData@@UAECAAPBVDataMap@@AAW4UErrorCode@@@Z+Fp ...
; __fastcall _RTC_CheckStackVars(x, x)
		extrn @_RTC_CheckStackVars@8:near
					; CODE XREF: RBTestData::RBTestData(UResourceBundle *,UResourceBundle *,UErrorCode &)+1EDp
					; RBTestData::nextSettings(DataMap const * &,UErrorCode	&)+158p ...
; void __thiscall RBDataMap::init(RBDataMap *__hidden this, struct UResourceBundle *, enum UErrorCode *)
		extrn ?init@RBDataMap@@QAEXPAUUResourceBundle@@AAW4UErrorCode@@@Z:near
					; CODE XREF: RBTestData::nextSettings(DataMap const * &,UErrorCode &)+121p
		extrn _ures_getByIndex_56:near
					; CODE XREF: RBTestData::nextSettings(DataMap const * &,UErrorCode &)+78p
					; RBTestData::nextCase(DataMap const * &,UErrorCode &)+78p
; void __thiscall RBDataMap::init(RBDataMap *__hidden this, struct UResourceBundle *, struct UResourceBundle *,	enum UErrorCode	*)
		extrn ?init@RBDataMap@@QAEXPAUUResourceBundle@@0AAW4UErrorCode@@@Z:near
					; CODE XREF: RBTestData::nextCase(DataMap const	* &,UErrorCode &)+125p
; public: __thiscall RBDataMap::RBDataMap(struct UResourceBundle *, struct UResourceBundle *, enum  UErrorCode &)
		extrn ??0RBDataMap@@QAE@PAUUResourceBundle@@0AAW4UErrorCode@@@Z:near
					; CODE XREF: RBTestData::nextCase(DataMap const	* &,UErrorCode &)+D8p


		end
